\t4 public void <identifier> ( final string message ) { \n \t5 <identifier> <identifiersep> logger . error ( message ) ; } \n \t3 } ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 result = command . execute ( <identifier> ) \n \t3 } catch ( command <identifiersep> exception e ) { \n \t4 io . <identifier> . <identifier> ( <identifier> ( ) . a ( <identifier> . attribute . <identifier> <identifiersep> <identifier> ) . <identifier> ( <identifier> . <identifier> . <identifier> ) . a ( e . message ) . <identifier> ( ) ) } \n <ect>
\t3 s <identifiersep> logger . error ( ex ) ; } \n \t2 return return <identifiersep> values ; } \n \t1 private static string execute <identifiersep> <identifier> ( string server , string <identifier> , string password ) throws http <identifiersep> exception , io <identifiersep> exception { \n \t2 string url = server + <string_literal> + s <identifiersep> user <identifiersep> id . get ( ) . to <identifiersep> string ( ) ; \n <ect>
\t2 break ; } \n \t1 } while ( <identifier> <identifiersep> count ++ < <identifier> <identifiersep> max <identifiersep> <identifier> ) ; \n \t1 <comment> \n \t1 if ( <identifier> <identifiersep> count >= <identifier> <identifiersep> max <identifiersep> <identifier> && ! <identifier> <identifiersep> service . target <identifiersep> has <identifiersep> <identifier> ( volume <identifiersep> id , <identifier> , <identifier> , timeout ) ) { \n <ect>
\t4 if ( client <identifiersep> socket <identifiersep> channel == null ) { \n \t5 <identifier> <identifiersep> log . info ( <string_literal> ) ; \n \t5 break ; } \n \t4 if ( client <identifiersep> socket <identifiersep> channel . socket ( ) == null ) { \n <ect>
\t1 try { \n \t1 return <identifier> . get <identifiersep> method ( method <identifiersep> name , <identifier> <identifiersep> type ) . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t1 } catch ( exception e ) { \n \t1 <comment> \n <ect>
\t1 try { \n \t2 get <identifiersep> <identifier> ( ) . create <identifiersep> pool ( request . get <identifiersep> pool ( ) ) ; \n \t2 return new <identifier> <identifiersep> create <identifiersep> pool <identifiersep> response ( ) ; \n \t1 } catch ( meta <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . send <identifiersep> message ( <string_literal> + s ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 logger . error ( <string_literal> , s , e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( not <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( node ) . close ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove ( node ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( node ) . close ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove ( node ) ; \n <ect>
\t5 <identifier> <identifiersep> cache <identifiersep> entry <identifiersep> <identifier> , null , false , <identifier> <identifiersep> <identifier> , has <identifiersep> <identifier> , null , null , null ) ; \n \t4 log . debug ( <string_literal> + entry + <string_literal> + <identifier> . node <identifiersep> id ( ) + ' ] ' ) ; } \n <ect>
\t3 int <identifier> <identifiersep> code = result <identifiersep> handler . get <identifiersep> <identifier> <identifiersep> value ( ) ; \n \t3 <identifier> = string <identifiersep> utils . <identifier> ( <identifier> . to <identifiersep> string ( ) ) ; \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> code , <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t4 for ( int i = 0 ; i < <identifier> . length ( ) ; i ++ ) { \n \t5 string <identifier> <identifiersep> name = <identifier> . get <identifiersep> json <identifiersep> object ( i ) . get <identifiersep> json <identifiersep> object ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) ; \n \t5 string <identifier> <identifiersep> value = <identifier> . get <identifiersep> json <identifiersep> object ( i ) . get <identifiersep> json <identifiersep> object ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) ; \n \t5 if ( <identifier> . contains <identifiersep> key ( <identifier> <identifiersep> name ) ) { \n <ect>
\t1 @ synchronized \n \t1 public void <identifier> ( ) { \n \t2 logger . debug ( <string_literal> , this . token <identifiersep> <identifier> , <identifier> <identifiersep> date <identifiersep> time . <identifier> ( ) ) ; \n \t2 token <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t4 logger . error ( <string_literal> , message ) ; } } } \n \t1 public void send <identifiersep> <identifier> <identifiersep> message ( message message ) { \n \t2 if ( message != null && is <identifiersep> <identifier> ( ) ) { \n \t3 try { \n <ect>
<comment> \n private map < string , string > read <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> lock lock , string lock <identifiersep> name ) { \n <ect>
\t3 <comment> \n \t3 for ( int i = 0 ; i < node . get <identifiersep> <identifier> <identifiersep> count ( ) ; i ++ ) { \n \t4 add <identifiersep> node ( new <identifiersep> node , ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> node ) node . get <identifiersep> <identifier> <identifiersep> <identifier> ( i ) ) ; } \n \t2 } catch ( illegal <identifiersep> user <identifiersep> action <identifiersep> exception <identifier> ) { \n <ect>
\t3 result . <identifier> = ( org . apache . <identifier> . <identifier> . client . <identifier> . thrift . thrift <identifiersep> security <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> is <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t2 try { \n \t3 class <identifier> <identifiersep> class = <identifier> <identifiersep> application . get <identifiersep> config ( ) . get <identifiersep> property ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> filter <identifiersep> class , class . class , default <identifiersep> stack <identifiersep> trace <identifiersep> <identifier> . class ) ; \n \t3 stack <identifiersep> <identifier> = bean <identifiersep> utils . <identifier> <identifiersep> class ( <identifier> <identifiersep> class , stack <identifiersep> trace <identifiersep> <identifier> . class ) ; } \n \t2 catch ( throwable t ) { \n <ect>
\t1 public <identifier> <identifiersep> <identifier> <identifiersep> error <identifiersep> handler ( log logger ) { \n \t2 this . logger = logger ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> <identifiersep> parse <identifiersep> exception ex ) throws <identifier> <identifiersep> exception { \n <ect>
\t3 <identifier> = new byte [ in . <identifier> ( ) ] ; \n \t3 in . read ( <identifier> ) ; } \n \t2 catch ( io <identifiersep> exception e ) \n \t2 { \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t4 logger . debug ( <string_literal> + <identifier> . get <identifiersep> table <identifiersep> name ( ) ) ; \n \t4 return null ; } \n \t4 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> date ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> name ) ) { \n <ect>
\t1 logger . debug ( <string_literal> ) \n else : \n \t1 <identifier> <identifiersep> policy <identifiersep> info = <identifier> <identifiersep> policy <identifiersep> info ( <identifier> <identifiersep> java <identifiersep> <identifier> ) \n \t1 if <identifier> <identifiersep> policy <identifiersep> info . is <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> policy ( ) : \n <ect>
\t4 try { \n \t5 <comment> \n \t5 if ( host . state == host . state . <identifier> ) \n \t6 return ; \n <ect>
\t2 long timeout = ( long ) ( <identifier> . max ( <identifier> . <identifier> <identifiersep> timeout , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> collection <identifiersep> timeout ) * 1 . <number_literal> ) ; \n \t2 <identifier> . get <identifiersep> <identifier> <identifiersep> handler ( ) . wait <identifiersep> <identifier> <identifiersep> <identifier> ( timeout ) ; } \n \t1 public void <identifier> ( address <identifier> ) { \n \t2 if ( <identifier> . equals ( <identifier> . local <identifiersep> <identifier> ) ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> map < string , string > <identifier> <identifiersep> object = next <identifiersep> object ; \n \t1 try { \n \t1 next <identifiersep> object = read <identifiersep> next <identifiersep> object ( this . <identifier> ) ; \n \t1 } catch ( end <identifiersep> of <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . set <identifiersep> max <identifiersep> <identifier> ( this . <identifier> ) ; \n \t3 try { \n \t4 this . <identifier> <identifiersep> cache = utils . get <identifiersep> <identifier> ( cache <identifiersep> manager . class ) . create <identifiersep> new <identifiersep> local <identifiersep> cache ( configuration ) ; \n \t3 } catch ( cache <identifiersep> exception e ) { \n <ect>
\t3 success = <identifier> . <identifier> ( class <identifiersep> name , class <identifiersep> <identifier> <identifiersep> string ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n \t3 string msg = <string_literal> ; \n \t3 msg += ex . to <identifiersep> string ( ) ; \n <ect>
\t1 try { \n \t2 p = new <identifier> <identifiersep> <identifier> <identifiersep> path ( <identifier> <identifiersep> name , conf ) ; \n \t1 } catch ( exception e ) { \n \t2 log . error ( e . get <identifiersep> message ( ) ) ; \n <ect>
\t3 <comment> \n \t3 set <identifiersep> <identifier> <identifiersep> <identifier> ( null ) ; \n \t3 <comment> \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> != null ) \n \t5 <identifier> <identifiersep> <identifier> . add ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t4 break ; \n \t3 default : \n <ect>
\t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 assert <identifiersep> that ( <identifier> . <identifier> ( cluster <identifiersep> state , <string_literal> ) . routing <identifiersep> table ( ) , <identifier> <identifiersep> instance ( cluster <identifiersep> state . routing <identifiersep> table ( ) ) ) ; \n <ect>
\t3 log . debug ( <string_literal> , i , message . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 string <identifier> = message . get <identifiersep> string <identifiersep> property ( <string_literal> ) ; \n \t3 string <identifier> = message . get <identifiersep> string <identifiersep> property ( <string_literal> ) ; \n \t3 log . debug ( <string_literal> , <identifier> ) ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t5 <identifier> += <identifier> <identifiersep> <identifier> ; \n \t5 if ( <identifier> >= current <identifiersep> <identifier> <identifiersep> max <identifiersep> <identifier> ) { \n \t6 <identifier> ++ ; \n \t6 <identifier> = 0 ; \n <ect>
\t1 public boolean add <identifiersep> <identifier> ( string <identifier> <identifiersep> name , <identifier> <identifiersep> client <identifier> , <identifier> <identifiersep> client <identifier> , <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , level level , <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) throws io <identifiersep> exception , <identifier> <identifiersep> security <identifiersep> exception { \n \t2 if ( <identifier> ) \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( message <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> message ( <string_literal> ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 result . add ( \n \t2 new <identifier> <identifiersep> input <identifiersep> <identifier> ( new null <identifiersep> <identifier> <identifiersep> input <identifiersep> format . <identifier> <identifiersep> input <identifiersep> <identifier> ( <identifier> [ 0 ] ) , <identifier> <identifiersep> <identifier> <identifiersep> input <identifiersep> format . class . get <identifiersep> name ( ) ) ) ; } \n <ect>
\t2 { \n \t3 log . info ( <string_literal> + list . size ( ) + <string_literal> ) ; } \n \t2 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : list ) \n \t2 { \n <ect>
\t2 <identifier> . <identifier> ( new <identifier> <identifiersep> status <identifiersep> <identifier> ( ) , 0 , time <identifiersep> unit . <identifier> ) ; \n \t2 long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 while ( true ) { \n <ect>
\t4 while ( class <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t5 url url = class <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . next <identifiersep> element ( ) ; \n \t5 <identifier> . add ( url ) ; } \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> item ( item item , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config config , event <identifiersep> <identifier> <identifier> , int state , string <identifier> ) { \n <ect>
\t6 for ( map . entry < object , object > entry : properties . entry <identifiersep> set ( ) ) { \n \t7 <identifier> <identifiersep> map . put ( ( string ) entry . get <identifiersep> key ( ) , ( string ) entry . get <identifiersep> value ( ) ) ; } \n \t6 log . info ( <string_literal> , <identifier> <identifiersep> map ) ; } } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 conn . close ( ) ; \n \t2 } catch ( exception <identifier> ) { \n \t2 log . error ( <string_literal> + handle <identifiersep> id , <identifier> ) ; } } \n \t1 } else { \n <ect>
public void <identifier> <identifiersep> <identifier> ( ) { \n \t1 try { \n \t1 <identifier> <identifiersep> utils . <identifier> <identifiersep> table ( get <identifiersep> table <identifiersep> name ( ) , get <identifiersep> manager ( ) ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t5 + result . get <identifiersep> <identifier> <identifiersep> id ( ) + <string_literal> \n \t5 + ( result . get <identifiersep> <identifier> ( ) != null ? result . get <identifiersep> <identifier> ( ) . get <identifiersep> id ( ) : <string_literal> ) ) ; } } \n \t2 { \n <ect>
\t8 <identifier> = self . <identifier> . id , \n \t8 <identifier> = <identifier> , \n \t8 <identifier> = <identifier> . id \n \t8 ) \n <ect>
\t1 final string resource <identifiersep> uri = resource == null ? <string_literal> : resource . get <identifiersep> uri ( ) ; \n \t1 try { \n \t1 <identifier> . write ( process ( resource <identifiersep> uri , content ) ) ; \n \t1 } catch ( final exception e ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t5 ( byte ) <identifier> . get <identifiersep> id ( ) , \n \t5 <identifier> , \n \t5 byte <identifiersep> <identifier> . <identifier> ( <identifier> ) ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( this . attribute <identifiersep> <identifier> == null ) { \n \t4 final application <identifiersep> context context = application <identifiersep> context <identifiersep> provider . get <identifiersep> application <identifiersep> context ( ) ; \n \t4 if ( context != null ) { \n \t5 return context . get <identifiersep> bean ( <string_literal> , i <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao . class ) ; } \n <ect>
\t4 <comment> \n \t4 try { \n \t5 super . <identifier> ( key , resource ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t6 continue ; } \n \t5 <comment> \n \t5 update <identifiersep> file <identifiersep> <identifier> <identifier> = new update <identifiersep> file <identifiersep> <identifier> ( content ) ; \n \t5 <identifier> . parse ( ) ; \n <ect>
\t6 result = ( ( <identifier> <identifiersep> list < <identifier> <identifiersep> model <identifiersep> <identifier> > ) service <identifiersep> action <identifiersep> <identifier> . execute ( current <identifiersep> context , \n \t8 get <identifiersep> <identifier> <identifiersep> action ) ) . get <identifiersep> first ( ) ; } \n \t5 catch ( exception e ) \n \t5 { \n <ect>
\t1 if ( cmd <identifiersep> line . has <identifiersep> <identifier> ( remove <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t2 remove <identifiersep> <identifier> = true ; } \n \t1 run <identifiersep> job ( input <identifiersep> path , output <identifiersep> path , <identifier> <identifiersep> file , cmd <identifiersep> line . has <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) , all , remove <identifiersep> <identifier> ) ; \n \t1 } catch ( <identifier> <identifiersep> exception | interrupted <identifiersep> exception | class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t1 <identifier> <identifiersep> host <identifiersep> <identifier> . set <identifiersep> max <identifiersep> wait <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> ( integer . parse <identifiersep> int ( ( string ) max <identifiersep> wait <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> content ( ) ) ) ; \n \t1 if ( max <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> as <identifiersep> <identifier> != null ) { \n \t2 <identifier> <identifiersep> host <identifiersep> <identifier> . set <identifiersep> max <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> as <identifiersep> <identifier> ( integer . parse <identifiersep> int ( ( string ) max <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> as <identifiersep> <identifier> . get <identifiersep> content ( ) ) ) ; } \n <ect>
\t1 final public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n \t1 { \n \t2 lock <identifiersep> state state = get <identifiersep> lock <identifiersep> state ( ) ; \n <ect>
\t3 { \n \t4 logger . warn ( <string_literal> ) ; \n \t4 logger . warn ( <string_literal> ) ; \n \t4 logger . warn ( <string_literal> ) ; \n <ect>
\t3 catch ( exception e ) \n \t3 { \n \t4 { \n <ect>
\t1 boolean <identifier> = false ; \n \t1 try { \n \t1 <identifier> = m <identifiersep> <identifier> . try <identifiersep> <identifier> ( m <identifiersep> timeout , time <identifiersep> unit . <identifier> ) ; \n \t1 } catch ( interrupted <identifiersep> exception interrupted <identifiersep> exception ) { \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> vm . set <identifiersep> public <identifiersep> ip <identifiersep> address ( <identifier> . get <identifiersep> address ( ) . <identifier> ( ) ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> storage <identifiersep> vm <identifiersep> dao . update ( <identifier> <identifiersep> vm . get <identifiersep> id ( ) , <identifier> <identifiersep> vm ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 logger . info ( <string_literal> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 log . error ( <string_literal> , e ) ; \n \t3 } finally { \n \t4 <identifier> . set ( false ) ; } \n \t2 } else { \n <ect>
\t3 device <identifiersep> <identifier> <identifier> = m <identifiersep> <identifier> . get ( <identifier> ) ; \n \t3 if ( <identifier> == null ) { \n \t4 logger . error ( <string_literal> , <identifier> , <identifier> ) ; \n \t3 } else { \n <ect>
\t5 <identifier> . check <identifiersep> not <identifiersep> null ( o ) ; \n \t5 log . debug ( <string_literal> , <identifier> , o ) ; \n \t5 load <identifiersep> count ++ ; \n \t4 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> , <identifier> ) ; \n \t5 try { \n \t6 <identifier> = <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t7 <string_literal> , field . name ( ) , <string_literal> , field . <identifier> ( ) , <string_literal> , \n \t7 field . <identifier> ( ) , <string_literal> , field . is <identifiersep> <identifier> ( ) , <string_literal> , \n \t7 field , <string_literal> \n \t5 ) ) ; } } \n <ect>
\t3 } catch ( io <identifiersep> exception ex ) { \n \t4 if ( ! uri . to <identifiersep> <identifier> <identifiersep> case ( ) . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t5 log . info ( <string_literal> , file , uri ) ; } } \n \t2 } else { \n <ect>
\t3 for ( string query : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t4 log . info ( <string_literal> + query ) ; \n \t4 query <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> query <identifiersep> <identifier> ( query ) ; \n \t4 log . info ( <string_literal> + <identifier> . get <identifiersep> cache <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> public <identifiersep> <identifier> != null ) { \n \t3 info = <identifier> <identifiersep> utils . get <identifiersep> network <identifiersep> <identifier> ( <identifier> <identifiersep> public <identifiersep> <identifier> ) ; \n \t3 if ( info != null ) { \n <ect>
\t2 return null ; } \n \t1 @ <identifier> \n \t1 public status is <identifiersep> <identifier> <identifiersep> <identifier> ( host <identifiersep> vo <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> index <identifiersep> x = - 1 ; } \n \t2 try { \n \t3 <identifier> <identifiersep> x = meta <identifiersep> <identifier> . parse ( <identifier> <identifiersep> x ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 url = <identifier> <identifiersep> server + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> vm <identifiersep> id . get ( ) + <string_literal> + <identifier> <identifiersep> api <identifiersep> key + <string_literal> + <identifier> <identifiersep> <identifier> ; \n \t2 client = new http <identifiersep> client ( ) ; \n \t2 method = new get <identifiersep> method ( url ) ; \n \t2 response <identifiersep> code = client . execute <identifiersep> method ( method ) ; \n <ect>
\t6 if ( delete <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> update ) { \n \t7 <identifier> <identifiersep> client . <identifier> ( ) . in <identifiersep> <identifier> ( <identifier> ) . with <identifiersep> <identifier> ( new <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) . delete ( ) ; \n \t7 log . info ( <string_literal> ) ; \n \t6 } else { \n <ect>
\t1 public static void <identifier> <identifiersep> <identifier> <identifiersep> context <identifiersep> for <identifiersep> current <identifiersep> thread ( <identifier> <identifiersep> <identifier> <identifiersep> context <identifier> ) { \n \t2 if ( <identifier> <identifiersep> <identifier> ( ) && <identifier> != null ) { \n \t3 list <identifier> = <identifier> . get ( ) ; \n \t3 <identifier> . add ( <identifier> ) ; \n <ect>
\t2 try { \n \t3 default <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 response <identifiersep> object = <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> response ( response <identifiersep> message ) ; \n \t2 } catch ( configuration <identifiersep> exception | factory <identifiersep> configuration <identifiersep> error | <identifier> <identifiersep> configuration <identifiersep> exception | <identifier> <identifiersep> exception | io <identifiersep> exception | <identifier> <identifiersep> exception e ) { \n <ect>
\t6 if ( msg == null ) { \n \t7 return ; } \n \t6 num <identifiersep> <identifier> ++ ; \n \t6 if ( num <identifiersep> <identifier> <identifier> <number_literal> == 0 ) { \n <ect>
\t2 c <identifiersep> <identifier> <identifiersep> header <identifier> <identifiersep> header \n \t3 = ( c <identifiersep> <identifier> <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> <identifier> <identifiersep> header . name ) ; \n \t2 if ( <identifier> <identifiersep> header == null ) \n \t2 { \n <ect>
\t2 logger . info ( <string_literal> + response <identifiersep> <identifier> ) ; \n \t2 assert . assert <identifiersep> equals ( <string_literal> , <number_literal> , response . get <identifiersep> status ( ) / <number_literal> ) ; \n \t2 string [ ] answer = response <identifiersep> <identifier> . <identifier> ( <string_literal> ) ; \n \t2 assert . assert <identifiersep> equals ( <string_literal> , <number_literal> , answer . length ) ; \n <ect>
\t2 if ( <identifier> ( ) ) \n \t2 { \n \t3 log . debug ( format ( <string_literal> , node . get <identifiersep> id ( ) , <identifier> ) ) ; \n \t3 log . debug ( format ( <string_literal> , this ) ) ; \n <ect>
\t2 return false ; } \n \t1 public boolean remove <identifiersep> snapshot ( string snapshot <identifiersep> name , boolean remove <identifiersep> <identifier> ) throws exception { \n \t2 <identifier> <identifiersep> object <identifiersep> <identifier> <identifier> <identifiersep> snapshot = get <identifiersep> snapshot <identifiersep> <identifier> ( snapshot <identifiersep> name ) ; \n \t2 if ( <identifier> <identifiersep> snapshot == null ) { \n <ect>
\t2 for ( node <identifiersep> pool pool : <identifier> ) { \n \t3 collection < node > <identifier> = pool . <identifier> <identifiersep> nodes ( nodes <identifiersep> <identifier> ) ; \n \t3 <identifier> . add <identifiersep> all ( <identifier> ) ; \n \t3 nodes <identifiersep> <identifier> -= <identifier> . size ( ) ; \n <ect>
\t3 { \n \t4 logger . warn ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> port = system . get <identifiersep> property ( <string_literal> ) ; \n \t4 if ( <identifier> <identifiersep> port == null ) \n <ect>
\t5 out <identifiersep> stream . write ( data <identifiersep> bytes ) ; \n \t4 out <identifiersep> stream . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 string <identifier> <identifiersep> dir = system . get <identifiersep> property ( <string_literal> ) ; \n <ect>
public string <identifier> ( ) { \n \t1 return ( string ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> ( string value ) { \n <ect>
\t1 if ( map <identifiersep> <identifier> == null ) { \n \t1 log . debug ( <string_literal> ) ; \n \t1 return ; \n \t1 } else if ( map <identifiersep> <identifier> . get <identifiersep> path <identifiersep> to <identifiersep> <identifier> ( ) == null ) { \n <ect>
\t5 error ++ ; } \n \t4 else if ( ( <identifier> == true ) && ( api . get <identifiersep> response <identifiersep> type ( ) == response <identifiersep> type . error || api . get <identifiersep> response <identifiersep> type ( ) == response <identifiersep> type . empty ) ) { \n \t5 s <identifiersep> logger . info ( <string_literal> + api . get <identifiersep> test <identifiersep> case <identifiersep> info ( ) + <string_literal> ) ; } \n \t4 else if ( ( api . get <identifiersep> response <identifiersep> type ( ) == response <identifiersep> type . error ) && ( api . get <identifiersep> response <identifiersep> code ( ) == <number_literal> ) ) { \n <ect>
\t3 boolean <identifier> <identifiersep> ticket <identifiersep> cache = <identifier> <identifiersep> configuration . get <identifiersep> boolean ( security <identifiersep> options . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 user <identifiersep> group <identifiersep> <identifier> <identifier> <identifiersep> user = user <identifiersep> group <identifiersep> <identifier> . get <identifiersep> current <identifiersep> user ( ) ; \n \t3 if ( <identifier> <identifiersep> user . get <identifiersep> authentication <identifiersep> method ( ) == user <identifiersep> group <identifiersep> <identifier> . authentication <identifiersep> method . <identifier> \n \t4 && <identifier> <identifiersep> ticket <identifiersep> cache && ! <identifier> <identifiersep> user . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 <identifier> = false ; \n \t2 <identifier> = new array <identifiersep> list < > ( ) ; \n \t2 <identifier> . add ( new <identifier> <identifiersep> <identifier> <identifiersep> level ( 0 ) ) ; <comment> \n \t1 public void set <identifiersep> start ( <identifier> <identifiersep> resource <identifier> ) { \n <ect>
\t2 private void <identifier> <identifiersep> <identifier> ( output <identifiersep> stream output <identifiersep> stream ) { \n \t3 try { \n \t4 output <identifiersep> stream . <identifier> ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 consumer . set <identifiersep> message <identifiersep> listener ( new message <identifiersep> listener ( ) { \n \t3 @ <identifier> \n \t3 public void on <identifiersep> message ( message message ) { \n \t4 try { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
<identifier> <identifier> ( self , <identifier> ) : \n \t1 config = <identifier> . get <identifiersep> config ( ) \n \t1 <identifier> <identifiersep> output = { } \n \t1 cmd = self . get <identifiersep> <identifier> <identifiersep> cmd ( ) \n <ect>
\t2 if ( <identifier> ) { \n \t3 <comment> \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 if ( port <identifiersep> group <identifiersep> policy != null ) \n \t2 { \n \t3 new <identifiersep> <identifier> <identifiersep> port <identifiersep> group <identifiersep> <identifier> . set <identifiersep> policy ( port <identifiersep> group <identifiersep> policy ) ; } \n \t2 if ( ! data <identifiersep> <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> <identifiersep> port <identifiersep> group ( network <identifiersep> name ) ) { \n <ect>
\t3 if ( ! this . <identifier> ) { \n \t4 this . do <identifiersep> start ( ) ; \n \t4 this . <identifier> = true ; \n <ect>
\t4 <identifier> . add ( id . get <identifiersep> value ( ) ) ; \n \t4 <identifier> ++ ; \n \t4 continue ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> listener <identifiersep> context context = new <identifier> <identifiersep> listener <identifiersep> context ( <identifier> ) ; \n \t2 <identifier> <identifiersep> result <identifier> = listener <identifiersep> client <identifiersep> data . client . create <identifiersep> <identifier> <identifiersep> result ( context , event . get <identifiersep> result ( ) ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get ( ) ; \n \t3 this . process <identifiersep> <identifier> ( <identifier> <identifiersep> version , <identifier> <identifiersep> <identifier> ) ; } \n \t2 else \n \t2 { \n <ect>
\t3 list < string > properties = <identifier> . list ( ( <identifier> < string > ) <identifier> <identifiersep> properties . property <identifiersep> <identifier> ( ) ) ; \n \t3 for ( string property : properties ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + property ) ; } } \n <ect>
\t5 <comment> \n \t5 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> info ( <identifier> <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t4 } else { \n <ect>
\t2 if ( ! is <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> user ( <identifier> <identifiersep> <identifier> , user <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 log . info ( <string_literal> , <identifier> <identifiersep> user , <identifier> <identifiersep> principal , \n \t5 user <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 return false ; } \n <ect>
\t1 public static void set <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( final int num <identifiersep> <identifier> ) \n \t1 { \n \t2 do <identifiersep> <identifier> = ( num <identifiersep> <identifier> == 1 ) ; \n \t2 if ( num <identifiersep> <identifier> > 1 ) \n <ect>
\t3 client <identifiersep> <identifier> . update ( result ) ; \n \t3 while ( ! stop <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> update update = <identifier> . <identifier> ( ) ; \n \t4 client <identifiersep> <identifier> . update ( update ) ; } \n <ect>
\t1 log <identifiersep> log . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) + <string_literal> ) ; } \n \t1 <identifier> <identifiersep> root <identifiersep> <identifier> ( properties , <identifier> ) ; \n \t1 <identifier> <identifiersep> logger <identifiersep> factory ( properties ) ; \n \t1 parse <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( properties , <identifier> ) ; \n <ect>
\t3 <identifier> <identifiersep> options <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> options ( ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> wait <identifiersep> <identifier> ( 1 ) ; \n \t3 for ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t4 client . get <identifiersep> client ( ) . <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> name ( ) , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 return <identifier> <identifiersep> factory . get <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } else if ( <identifier> . class . is <identifiersep> <identifier> <identifiersep> from ( test <identifiersep> bean <identifiersep> class ) ) { \n \t3 return <identifier> <identifiersep> factory . get <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } else { \n <ect>
\t2 case <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> : { \n \t3 string <identifier> <identifiersep> path = ( string ) <identifier> . <identifier> [ 0 ] ; \n \t3 string <identifier> <identifiersep> path = ( string ) <identifier> . <identifier> [ 1 ] ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> path ( <identifier> <identifiersep> path , <identifier> <identifiersep> path ) ; \n <ect>
\t4 <identifier> <identifiersep> new <identifiersep> version = new <identifiersep> version ; \n \t3 } else { \n \t4 update <identifiersep> status ( <string_literal> + <identifier> <identifiersep> t ( <string_literal> , <identifier> ( url ) ) + <string_literal> ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 logger . error ( <string_literal> , e . get <identifiersep> message ( ) . to <identifiersep> string ( ) ) ; \n \t3 response = null ; \n \t3 exception <identifiersep> <identifier> = true ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> socket <identifiersep> <identifier> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> socket <identifiersep> <identifier> ) s . get <identifiersep> handler ( ) ; \n \t2 if ( <identifier> . <identifier> != null && <identifier> . <identifier> . get <identifiersep> state ( ) == state . <identifier> ) { \n \t4 log . warn ( <string_literal> , as . s ) ; \n <ect>
\t4 to <identifiersep> <identifier> = <identifier> ; \n \t3 } else { \n \t4 logger . warn ( <string_literal> , <identifier> ) ; } \n \t2 } catch ( exception <identifier> <identifiersep> ex ) { \n <ect>
\t5 stop = true ; } } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> , e ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t3 logger . info ( <string_literal> , conf . <identifier> <identifiersep> access <identifiersep> mode , index <identifiersep> access <identifiersep> mode ) ; } \n \t2 else \n \t2 { \n \t3 index <identifiersep> access <identifiersep> mode = conf . <identifier> <identifiersep> access <identifiersep> mode ; \n <ect>
\t7 <string_literal> , \n \t7 from , to , network <identifiersep> id ) ) ; } \n \t2 if ( ! r . get <identifiersep> result ( ) ) { \n \t3 <identifier> . set <identifiersep> state ( <identifier> <identifiersep> <identifier> . state . failed . name ( ) ) ; \n <ect>
\t2 if ( service <identifiersep> <identifier> != null ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> ticket <identifiersep> id = handle <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> ticket <identifiersep> <identifier> ( service <identifiersep> ticket <identifiersep> id , service <identifiersep> <identifier> ) ; \n \t3 } catch ( final authentication <identifiersep> exception e ) { \n <ect>
\t3 context = create ( v <identifiersep> <identifier> <identifiersep> address , v <identifiersep> <identifier> <identifiersep> user <identifiersep> name , v <identifiersep> <identifier> <identifiersep> password ) ; \n \t2 } else { \n \t3 <comment> \n \t3 if ( ! context . <identifier> ( ) || ( context . get <identifiersep> <identifier> <identifiersep> client ( ) . get <identifiersep> <identifier> <identifiersep> session <identifiersep> timeout ( ) != s <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> session <identifiersep> timeout ( ) ) ) { \n <ect>
\t2 while ( ! <identifier> <identifiersep> <identifier> && <identifier> <identifiersep> count <identifiersep> on <identifiersep> lock <identifiersep> timeout > 0 ) { \n \t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> store . lock <identifiersep> <identifier> ( new <identifiersep> <identifier> <identifiersep> to <identifiersep> lock ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 r = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( new file <identifiersep> input <identifiersep> stream ( <identifier> ) ) ) ; \n \t1 for ( string <identifier> <identifiersep> line : <identifier> <identifiersep> <identifier> ) { \n \t2 assert <identifiersep> equals ( <identifier> <identifiersep> line , r . read <identifiersep> line ( ) ) ; } \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \t2 } catch ( runtime <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 <identifier> ( ) ; \n \t4 try { \n \t5 read ( this , <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 return false ; \n \t2 } else if ( <string_literal> . equals <identifiersep> ignore <identifiersep> case ( <identifier> ) ) { \n \t3 return true ; \n \t2 } else { \n <ect>
\t5 + <string_literal> , item . get <identifiersep> value ( ) ) ; \n \t4 if ( properties . get <identifiersep> <identifier> <identifiersep> mode ( ) == <identifier> <identifiersep> service <identifiersep> <identifier> <identifiersep> properties . <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) { \n \t5 service <identifiersep> <identifier> . <identifier> ( item . get <identifiersep> value ( ) ) ; } \n \t4 return item . get <identifiersep> value ( ) ; } \n <ect>
\t1 return create <identifiersep> new <identifiersep> key <identifiersep> <identifier> <identifiersep> in <identifiersep> org ( from . get <identifiersep> org ( ) , from . get <identifiersep> name ( ) ) ; } \n private key <identifiersep> <identifier> create <identifiersep> new <identifiersep> key <identifiersep> <identifier> <identifiersep> in <identifiersep> org ( uri org , string key <identifiersep> <identifier> <identifiersep> name ) { \n \t1 check <identifiersep> not <identifiersep> null ( org , <string_literal> ) ; \n \t1 check <identifiersep> not <identifiersep> null ( key <identifiersep> <identifier> <identifiersep> name , <string_literal> ) ; \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 db = new <identifier> <identifiersep> db ( get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , file ) ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 task <identifiersep> <identifier> <identifiersep> list . add ( <identifier> ) ; } } \n \t2 } else { <comment> \n \t3 set < resource <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t3 <identifier> <identifier> = <identifier> . on ( <string_literal> ) ; \n <ect>
\t5 int count = 0 ; \n \t5 while ( <identifier> <identifiersep> state == <identifier> <identifiersep> client . state . <identifier> ) { \n \t6 try { \n \t7 count ++ ; \n <ect>
\t3 <identifier> ( ( <identifier> <identifiersep> <identifier> <identifiersep> msg <identifiersep> id ) msg <identifiersep> id ) ; \n \t2 } else { \n \t3 log . warn ( <string_literal> + msg <identifiersep> id . get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + msg <identifiersep> id ) ; } } \n \t1 protected void handle <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> msg <identifiersep> id msg <identifiersep> id ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = task <identifiersep> info . is <identifiersep> <identifier> ; \n \t2 task <identifiersep> info . is <identifiersep> <identifier> = true ; } \n \t1 if ( <identifier> <identifiersep> <identifier> ) { \n \t2 <comment> \n <ect>
\t6 for ( <identifier> <identifiersep> address endpoint : handler . <identifier> ) \n \t7 storage <identifiersep> <identifier> . write <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> , endpoint ) ; } } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t4 } else { \n \t5 log . debug ( <string_literal> \n \t7 + <string_literal> , map <identifiersep> manager . size ( ) ) ; } } \n \t3 if ( transaction <identifiersep> template != null ) { \n <ect>
\t3 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = execute <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t5 transaction <identifiersep> id <identifiersep> store <identifiersep> <identifier> . get ( ) , <identifier> <identifiersep> uri , <identifier> , <identifier> <identifiersep> store <identifiersep> id , <identifier> <identifiersep> request ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t3 { \n <ect>
\t4 <comment> \n \t2 return <identifier> ; } \n \t1 private string <identifier> <identifiersep> url <identifiersep> from <identifiersep> <identifier> ( map < ? , ? > <identifier> ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t5 session <identifiersep> handler handler = session <identifiersep> cache . get <identifiersep> session <identifiersep> handler ( ) ; \n \t5 handler . <identifier> <identifiersep> event <identifiersep> <identifier> ( ) ; \n \t5 handler . remove <identifiersep> session ( session <identifiersep> id , true ) ; } \n \t3 } catch ( final exception ex ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + cmd . get <identifiersep> host ( ) + <string_literal> + cmd . get <identifiersep> port ( ) + <string_literal> + cmd . get <identifiersep> vm <identifiersep> id ( ) + <string_literal> + ticket <identifiersep> in <identifiersep> url ) ; } \n \t2 if ( ! cmd . is <identifiersep> <identifier> ( ) ) { \n \t3 string ticket = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> access <identifiersep> ticket ( cmd . get <identifiersep> host ( ) , cmd . get <identifiersep> port ( ) , cmd . get <identifiersep> <identifier> ( ) , cmd . get <identifiersep> vm <identifiersep> id ( ) ) ; \n <ect>
\t3 { \n \t4 int <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> in <identifiersep> <identifier> ( ) ; \n \t4 if ( should <identifiersep> <identifier> ( session , <identifier> ) ) \n \t4 { \n <ect>
private operation remove <identifiersep> operation ( operation <identifiersep> handle <identifier> <identifiersep> handle ) { \n \t1 operation operation = handle <identifiersep> to <identifiersep> operation . remove ( <identifier> <identifiersep> handle ) ; \n \t1 string query <identifiersep> id = get <identifiersep> query <identifiersep> id ( operation ) ; \n \t1 query <identifiersep> id <identifiersep> operation . remove ( query <identifiersep> id ) ; \n <ect>
\t5 } catch ( <identifier> <identifiersep> sql <identifiersep> exception e ) { \n \t6 if ( e . get <identifiersep> error <identifiersep> code ( ) == <number_literal> ) { \n \t7 logger . debug ( <string_literal> + name ) ; \n \t6 } else { \n <ect>
\t1 try { \n \t1 context . set <identifiersep> <identifier> <identifiersep> context ( <identifier> . execute ( <identifier> , <identifier> <identifiersep> manager ) ) ; \n \t1 } catch ( exception e ) { \n \t1 this . exception = e ; \n <ect>
\t3 try { \n \t4 logger . trace ( <string_literal> , <identifier> , cluster <identifiersep> <identifier> <identifiersep> event . state ( ) . version ( ) ) ; \n \t4 <identifier> . <identifier> <identifiersep> cluster <identifiersep> state ( cluster <identifiersep> <identifier> <identifiersep> event ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> request <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + command + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> resource . get <identifiersep> name ( ) , e ) ; \n \t3 return new <identifier> <identifiersep> answer ( command , e . get <identifiersep> message ( ) ) ; <comment> \n \t2 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> to ( <identifier> , <identifier> ) ; } \n \t1 public static < x > void <identifier> <identifiersep> to ( <identifier> < x > <identifier> <identifiersep> <identifier> , <identifier> < ? super x > <identifier> ) { \n \t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> success ( ) ) { \n \t3 if ( ! <identifier> . try <identifiersep> success ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 return ( string ) <identifier> <identifiersep> context ( ) . value <identifiersep> for <identifiersep> key ( <string_literal> ) ; } \n \t1 public string value <identifiersep> for <identifiersep> group ( ) { \n \t2 string result = <string_literal> ; \n \t2 string <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> key = ( string ) <identifier> <identifiersep> context ( ) . value <identifiersep> for <identifiersep> key ( <string_literal> ) ; \n <ect>
\t1 throw new lock <identifiersep> exception ( error <identifiersep> msg . <identifier> <identifiersep> <identifier> <identifiersep> failed . get <identifiersep> msg ( ) , \n \t2 e ) ; } \n \t1 finally { \n \t1 if ( <identifier> ) { \n <ect>
\t4 } else { \n \t5 <comment> \n \t5 handle = handle . as <identifiersep> <identifier> ( object [ ] . class , target <identifiersep> type . <identifier> <identifiersep> count ( ) - 1 ) ; } \n \t4 current <identifiersep> type = remove <identifiersep> <identifier> ( target <identifiersep> type ) ; \n <ect>
\t6 } catch ( io <identifiersep> exception e ) { \n \t7 log . warn ( <string_literal> + command , e ) ; } } \n \t5 return ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 file <identifiersep> utils . delete <identifiersep> <identifier> ( file ) ; } } } } \n \t2 private void remove <identifiersep> <identifier> <identifiersep> remote <identifiersep> <identifier> ( long success <identifiersep> <identifier> <identifiersep> id ) { \n \t3 long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 if ( last <identifiersep> success <identifiersep> <identifier> <identifiersep> id != - 1 && last <identifiersep> success <identifiersep> <identifier> <identifiersep> id != ( success <identifiersep> <identifier> <identifiersep> id - 1 ) ) { \n <ect>
\t2 <comment> \n \t2 i <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> . <identifier> <identifiersep> authentication ( ) && ! ( <identifier> instanceof i <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) \n \t2 { \n <ect>
\t1 <comment> \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null && ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider . load <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; } \n \t1 <identifier> <identifiersep> provider <identifier> <identifiersep> provider = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 logger . error ( <string_literal> , node <identifiersep> id ) ; \n \t3 <identifier> <identifiersep> message . set <identifiersep> transaction <identifiersep> <identifier> ( ) ; \n \t3 return false ; } \n \t2 if ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( 0 ) != <identifier> ) { \n <ect>
\t2 for ( string <identifier> <identifiersep> name : <identifier> <identifiersep> <identifier> ) { \n \t3 bean <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> bean <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t3 if ( class <identifiersep> name . equals ( <identifier> . get <identifiersep> bean <identifiersep> class <identifiersep> name ( ) ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> response <identifier> = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( this ) ; \n \t3 <identifier> . set <identifiersep> response <identifiersep> name ( get <identifiersep> command <identifiersep> name ( ) ) ; \n \t3 this . set <identifiersep> response <identifiersep> object ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> ( <string_literal> ) ; } } \n \t1 <comment> \n \t1 @ test \n \t1 public void test <identifiersep> remove <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> ) ; \n \t2 try { \n \t3 meta <identifiersep> state <identifiersep> handle . <identifier> <identifiersep> state ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 public synchronized boolean has <identifiersep> next ( ) { \n \t2 try { \n \t3 get <identifiersep> next <identifiersep> <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( request request , task task ) { \n \t2 logger . trace ( <string_literal> , request . get <identifiersep> url ( ) ) ; \n \t2 if ( should <identifiersep> <identifier> ( request ) || no <identifiersep> <identifier> <identifiersep> to <identifiersep> remove <identifiersep> <identifier> ( request ) || ! <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( request , task ) ) { \n <ect>
\t6 if ( command . get <identifiersep> command <identifiersep> switch ( ) . equals <identifiersep> ignore <identifiersep> case ( <identifier> <identifiersep> snapshot <identifiersep> command . create <identifiersep> snapshot ) ) { \n \t7 s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> + snapshot <identifiersep> name ) ; \n \t7 <identifier> . <identifier> <identifiersep> create ( snapshot <identifiersep> name ) ; \n \t6 } else { \n <ect>
\t1 try { \n \t1 return build <identifiersep> client ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider . <identifier> <identifiersep> user <identifiersep> <identifier> . instance , \n \t3 <identifier> <identifiersep> properties . <identifier> <identifiersep> client <identifiersep> config ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t3 state = new boolean [ <identifier> ] ; } \n \t2 @ <identifier> \n \t2 public void update ( <identifier> <identifiersep> <identifier> <identifier> , string <identifier> <identifiersep> name , int <identifier> ) { \n \t3 if ( ! <identifier> ( ) ) { \n <ect>
\t2 <identifier> < service , provider > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> manager <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> map ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> map <identifiersep> vo <identifier> <identifiersep> <identifier> <identifiersep> service : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 network . service service = network . service . get <identifiersep> service ( <identifier> <identifiersep> <identifier> <identifiersep> service . get <identifiersep> service ( ) ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( service ) ) { \n <ect>
\t5 } catch ( exception e ) { \n \t6 logger . error ( <string_literal> , e ) ; } } \n \t3 } ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n <comment> \n @ test \n public void <identifier> <identifiersep> volume <identifiersep> <identifier> <identifiersep> volume <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; <comment> \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 throw e ; \n \t1 } catch ( exception e ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t6 <identifier> . set <identifiersep> string ( 1 , <identifier> <identifiersep> network <identifiersep> <identifier> ) ; \n \t6 result <identifiersep> set <identifier> <identifiersep> <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t6 s <identifiersep> logger . debug ( <string_literal> ) ; \n <ect>
\t3 <identifier> . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n \t3 <comment> \n \t3 if ( last <identifiersep> <identifier> <identifiersep> message <identifiersep> <identifier> < <identifier> - <number_literal> ) \n \t3 { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . size ( ) == 1 \n \t2 && <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get ( 0 ) instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 try { \n \t3 <identifier> conn = <identifier> <identifiersep> connection . get <identifiersep> connection ( ) ; \n \t3 storage = conn . storage <identifiersep> pool <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> string ( <identifier> ) ; \n \t3 if ( storage . get <identifiersep> info ( ) . state != storage <identifiersep> pool <identifiersep> state . <identifier> <identifiersep> storage <identifiersep> pool <identifiersep> <identifier> ) { \n <ect>
\t3 <identifier> <identifier> = null ; \n \t3 try { \n \t4 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> factory . get <identifiersep> default <identifiersep> <identifier> ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 answer answer = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send ( <identifier> <identifiersep> <identifier> <identifiersep> host . get <identifiersep> id ( ) , cmd ) ; \n \t4 if ( answer == null || ! answer . get <identifiersep> result ( ) ) { \n \t5 s <identifiersep> logger . error ( <string_literal> ) ; \n \t4 } else { \n <ect>
\t3 result . success = o ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t5 <identifier> = <identifier> . root <identifiersep> <identifier> ; } \n \t4 add <identifiersep> <identifier> <identifiersep> handler ( <identifier> , new <identifiersep> class <identifiersep> instance ( <identifier> <identifiersep> handler . class , \n \t6 ( class < <identifier> <identifiersep> handler > ) io <identifiersep> utils . load <identifiersep> class ( get <identifiersep> class ( ) , s ) ) ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 unit <identifier> = <identifier> <identifiersep> it . next ( ) ; \n \t2 if ( ( ! c <identifiersep> or <identifiersep> t . get <identifiersep> <identifier> ( ) . contains ( <identifier> ) ) && \n \t3 ( ! <identifier> <identifiersep> return <identifiersep> or <identifiersep> throw ( <identifier> ) ) ) { \n \t3 if ( options . v ( ) . <identifier> ( ) ) \n <ect>
\t3 string current = <identifier> . get <identifiersep> <identifier> <identifiersep> handle ( ) ; \n \t3 for ( string handle : <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t4 if ( ! handle . equals ( <identifier> . get <identifiersep> <identifier> <identifiersep> handle ( ) ) ) { \n \t5 <identifier> . switch <identifiersep> to ( ) . <identifier> ( handle ) ; \n <ect>
\t7 log . debug ( <string_literal> , get <identifiersep> connection <identifiersep> address ( ) , <identifier> ) ; } \n \t6 <identifier> <identifiersep> timeout <identifiersep> <identifier> . <identifier> ( this , <identifier> , time <identifiersep> unit . <identifier> ) ; } \n \t4 } else { \n <ect>
\t1 return <identifier> . find ( <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t1 throw new no <identifiersep> such <identifiersep> entity <identifiersep> exception ( <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t5 new add <identifiersep> node <identifiersep> task ( ) . run ( ) ; <comment> \n \t4 } else { \n \t5 new remove <identifiersep> node <identifiersep> task ( ) . run ( ) ; } \n \t3 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . add <identifiersep> host <identifiersep> to <identifiersep> <identifier> ( host <identifiersep> request . get <identifiersep> <identifier> <identifiersep> name ( ) , host <identifiersep> name ) ; \n \t3 <identifier> <identifiersep> to <identifiersep> ignore . add ( host <identifiersep> name ) ; \n \t3 log . info ( <string_literal> , host <identifiersep> name ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t7 thread . <identifier> ( <number_literal> ) ; <comment> \n \t6 } catch ( interrupted <identifiersep> exception ex ) { \n \t7 <comment> \n \t4 <comment> \n <ect>
\t5 try { \n \t6 byte [ ] data = <identifier> <identifiersep> send <identifiersep> data ( e <identifiersep> <identifier> <identifiersep> provider , item <identifiersep> name , null ) ; \n \t6 if ( data != null && data . length > 0 ) { \n \t7 if ( <identifier> == null ) { \n <ect>
\t2 log . warn ( <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id + <string_literal> , <identifier> <identifiersep> ex ) ; \n \t2 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( \n \t3 <string_literal> + snapshot <identifiersep> id + <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id + <string_literal> , <identifier> <identifiersep> ex ) ; } \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 return answer . create <identifiersep> <identifier> <identifiersep> command <identifiersep> answer ( cmd ) ; } } \n \t1 protected <identifier> <identifiersep> local <identifiersep> network get <identifiersep> native <identifiersep> network <identifiersep> for <identifiersep> <identifier> ( connection conn , <identifier> <identifiersep> type type , string name ) throws <identifier> <identifiersep> api <identifiersep> exception , xml <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( name != null ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . <identifier> ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t4 to <identifiersep> <identifier> . set <identifiersep> attribute ( <string_literal> , <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ) ; \n \t3 } else { \n <ect>
\t4 get <identifiersep> context ( ) . job <identifiersep> queue ( ) . add <identifiersep> job ( <identifier> ) ; \n \t4 <identifier> += <number_literal> ; } } \n \t2 long <identifier> = get <identifiersep> next <identifiersep> run <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
<comment> \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) { \n \t2 <identifier> <identifiersep> <identifier> <identifier> ; \n \t2 try { \n <ect>
\t2 logger . warn ( <string_literal> , item <identifiersep> name ) ; \n \t2 <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> <identifiersep> item ( item <identifiersep> name ) ; } \n \t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> update ( string item <identifiersep> name , state new <identifiersep> state ) { \n <ect>
\t2 <identifier> . for <identifiersep> <identifier> ( file - > { \n \t3 try { \n \t4 file <identifiersep> utils . <identifier> <identifiersep> delete ( file ) ; \n \t3 } catch ( final exception e ) { \n <ect>
\t3 } catch ( channel <identifiersep> exception x ) { \n \t4 <comment> \n \t4 <comment> \n \t4 <comment> \n <ect>
\t3 protected sql get <identifiersep> <identifier> <identifiersep> sql ( ) { \n \t4 final connection <identifier> = session . connection ( ) \n \t4 <identifier> <identifier> = { object , method , <identifier> - > \n \t5 if ( method . name == <string_literal> ) { \n <ect>
<identifier> query <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> command , url , <identifier> <identifiersep> command , action ) : \n if <identifier> <identifiersep> <identifier> <identifiersep> command : \n \t1 run <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> command , <string_literal> ) \n try : \n <ect>
\t2 return <string_literal> ; } \n \t1 @ <identifier> \n \t1 public object <identifier> ( final action <identifiersep> context <identifier> , final object <identifier> , final object [ ] <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 if ( ! <identifier> . <identifier> <identifiersep> enabled . get <identifiersep> value ( ) ) { \n <ect>
\t1 if ( ! <identifier> ) { \n \t2 try { \n \t2 output <identifiersep> stream . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 try { \n \t7 <identifier> <identifiersep> destination <identifier> = new <identifier> <identifiersep> destination ( <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( network . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) ) , null , null , null ) ; \n \t7 <identifier> <identifiersep> network <identifiersep> <identifier> . <identifier> <identifiersep> network ( network . get <identifiersep> id ( ) , <identifier> , context ) ; \n \t6 } catch ( exception ex ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 return build <identifiersep> status <identifiersep> response ( response . status . <identifier> ) ; \n \t2 } else { \n \t2 return build <identifiersep> status <identifiersep> response ( response . status . not <identifiersep> <identifier> ) ; } \n \t1 } catch ( <identifier> <identifiersep> error e ) { \n <ect>
\t7 + ( <string_literal> . equals ( <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ) ? <string_literal> : <string_literal> + <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ) ) ; \n \t5 <identifier> . get ( ) . set <identifiersep> <identifier> <identifiersep> found ( request . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t3 } else { \n \t4 if ( user <identifiersep> <identifier> <identifiersep> string != null ) { \n <ect>
\t4 try { \n \t5 <identifier> . <identifier> <identifiersep> message <identifiersep> <identifier> ( message , abstract <identifiersep> <identifier> <identifiersep> channel . this , \n \t7 this . <identifier> . get <identifiersep> message <identifiersep> handler ( ) , ex ) ; } \n \t4 catch ( throwable <identifier> ) { <comment> \n <ect>
\t2 if ( <identifier> <identifiersep> config <identifiersep> <identifier> . class . is <identifiersep> <identifier> <identifiersep> from ( load <identifiersep> class ) ) { \n \t2 <comment> \n \t2 final class < ? extends <identifier> <identifiersep> config <identifiersep> <identifier> > <identifier> = \n \t3 load <identifiersep> class . as <identifiersep> <identifier> ( <identifier> <identifiersep> config <identifiersep> <identifier> . class ) ; \n <ect>
\t3 get <identifiersep> service <identifiersep> ticket <identifiersep> <identifier> ( ) . to ( <identifier> , service <identifiersep> ticket . class . <identifier> ( ticket ) ) ; \n \t2 } else if ( ticket instanceof <identifier> <identifiersep> ticket ) { \n \t3 get <identifiersep> <identifier> <identifiersep> ticket <identifiersep> <identifier> ( ) . to ( <identifier> , <identifier> <identifiersep> ticket . class . <identifier> ( ticket ) ) ; \n \t2 } else { \n <ect>
\t3 data . <identifier> <identifiersep> meta = ( <identifier> <identifiersep> metadata <identifiersep> <identifier> ) <identifier> . get <identifiersep> metadata ( <string_literal> ) ; \n \t3 data . <identifier> <identifiersep> meta = ( <identifier> <identifiersep> metadata <identifiersep> <identifier> ) <identifier> . get <identifiersep> metadata ( <string_literal> ) ; \n \t3 return data ; \n \t2 } catch ( throwable t ) { \n <ect>
<number_literal> 0 , \n <number_literal> <number_literal> * byte <identifiersep> utils . size <identifiersep> of <identifiersep> int ) , \n <number_literal> <identifier> <identifiersep> first <identifiersep> element ( current <identifiersep> element ) ) ) ; } } } \n \t3 count ++ ; } \n <ect>
\t4 <identifier> <identifiersep> <identifier> . <identifier> ( this ) ; \n \t3 } catch ( <identifier> <identifiersep> session <identifiersep> exception <identifier> ) { \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( num <identifiersep> <identifier> , num <identifiersep> <identifier> , true ) , num <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 return <identifier> . <identifier> ( ) ; } \n public void stop ( ) { \n \t1 long start <identifiersep> time = system . <identifier> <identifiersep> time ( ) ; \n <ect>
\t1 @ <identifier> <identifiersep> throws \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config ( ) { \n \t2 final string <identifier> <identifiersep> value = system . get <identifiersep> property ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> conf ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> value ) ) { \n <ect>
\t4 { \n \t5 <identifier> <identifiersep> start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t5 { \n <ect>
\t4 log . warn ( <string_literal> + <identifier> \n \t6 + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> manager . this . <identifier> <identifiersep> <identifier> \n \t6 + <string_literal> + e ) ; } \n \t3 this . <identifier> ( ) ; \n <ect>
\t4 logger . info ( <string_literal> ) ; \n \t4 <identifier> . <identifier> <identifiersep> handler ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this , client <identifiersep> <identifier> ) ) ; } \n \t3 else \n \t3 { \n <ect>
\t2 for ( int i = <number_literal> ; i < <number_literal> ; i ++ ) { \n \t3 index ( <string_literal> , <string_literal> , integer . to <identifiersep> string ( i ) , <string_literal> , <string_literal> + i ) ; \n \t3 index ( <string_literal> , <string_literal> , integer . to <identifiersep> string ( i ) , <string_literal> , <string_literal> + i ) ; \n \t3 index ( <string_literal> , <string_literal> , integer . to <identifiersep> string ( i ) , <string_literal> , <string_literal> + i ) ; } \n <ect>
\t2 <identifier> . assert <identifiersep> is <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . stop ( ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n <ect>
\t3 assert . <identifier> ( ) ; \n \t2 } finally { } \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 public void stream <identifiersep> data ( <identifier> <identifiersep> output <identifiersep> stream output <identifiersep> stream ) throws exception { \n <ect>
\t3 <identifier> . execute ( ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + <identifier> , e ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t6 log . debug ( x <identifiersep> log . <identifier> , <string_literal> , node <identifiersep> job . node <identifiersep> name ) ; } \n \t5 else { \n \t6 if ( context . status == status . <identifier> ) { \n \t7 status = status . <identifier> ; \n <ect>
\t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> command ( string item <identifiersep> name , command command ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config config = get <identifiersep> config <identifiersep> for <identifiersep> item <identifiersep> name ( item <identifiersep> name ) ; \n \t2 if ( config == null ) { \n <ect>
\t1 public void <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> long ( string id ) { \n \t2 for ( <identifier> <identifiersep> provider provider : <identifier> ) { \n \t3 for ( string item <identifiersep> name : provider . get <identifiersep> item <identifiersep> <identifier> ( ) ) { \n \t4 if ( provider . get <identifiersep> id ( item <identifiersep> name ) . equals ( id ) && provider . get <identifiersep> channel ( item <identifiersep> name ) . equals ( <string_literal> ) ) { \n <ect>
\t6 <identifier> . <identifier> ( <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> ) ; \n \t6 this . <identifier> . add ( <identifier> ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> . length == 0 ) { \n \t2 log . info ( <string_literal> ) ; \n \t2 <identifier> . delete ( output <identifiersep> path , true ) ; \n \t2 } else if ( <identifier> . length == 1 && <identifier> [ 0 ] . get <identifiersep> path ( ) . get <identifiersep> name ( ) . equals ( file <identifiersep> output <identifiersep> <identifier> . <identifier> <identifiersep> file <identifiersep> name ) ) { \n <ect>
\t1 try { \n \t2 <identifier> . start ( ) ; \n \t2 break ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 logger . <identifier> ( this , <string_literal> + <identifier> <identifiersep> key ) ; \n \t4 try { \n \t5 <identifier> <identifiersep> key . set <identifiersep> <identifier> <identifiersep> key ( <identifier> <identifiersep> key ) ; \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> < <identifier> < integer , string > > <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < > ( this . <identifier> <identifiersep> manager , this . io <identifiersep> manager , \n \t5 source , this . <identifier> <identifiersep> task , this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , \n \t5 ( double ) <number_literal> / <number_literal> , <number_literal> , 0 . <identifier> , true <comment> , false ) ; \n \t3 <comment> \n <ect>
<comment> \n \t1 private void test <identifiersep> <identifier> ( <identifier> <identifiersep> info <identifier> ) { \n \t2 <identifier> <identifiersep> info in <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t2 if ( in <identifiersep> <identifier> == null ) { \n <ect>
\t4 if ( ! <identifier> <identifiersep> attribute <identifiersep> <identifier> ( url , attribute <identifiersep> list ) ) { \n \t5 logger . error ( <string_literal> ) ; } \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 logger . warn ( <string_literal> ) ; } \n <ect>
\t2 for ( int i = 0 ; i < grid <identifiersep> count ( ) ; i ++ ) { \n \t3 grid <identifiersep> <identifier> grid = ( grid <identifiersep> <identifier> ) grid ( i ) ; \n \t3 grid <identifiersep> cache <identifiersep> <identifier> cache = grid . <identifier> <identifiersep> cache ( null ) ; \n \t3 grid <identifiersep> cache <identifiersep> map <identifiersep> entry entry = cache . map ( ) . get <identifiersep> entry ( key ) ; \n <ect>
\t4 <identifier> = argument <identifiersep> type . attribute ; \n \t3 else if ( is <identifiersep> instance <identifiersep> of <identifiersep> the <identifiersep> class ( node . as <identifiersep> resource ( ) , <identifier> ) ) \n \t4 <identifier> = argument <identifiersep> type . <identifier> ; \n \t2 } else { \n <ect>
\t1 <identifier> = load <identifiersep> <identifier> . get <identifiersep> <identifier> ( account <identifiersep> number , <identifier> <identifiersep> name ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception ex ) { \n \t1 return ; \n \t1 } catch ( exception ex ) { \n <ect>
\t1 conn = data <identifiersep> source . get <identifiersep> connection ( ) ; \n \t1 <identifier> = conn . <identifier> <identifiersep> <identifier> ( remove <identifiersep> <identifier> <identifiersep> sql ) ; \n \t1 set <identifiersep> long <identifiersep> <identifier> ( <identifier> , 1 , user <identifiersep> id ) ; \n \t1 set <identifiersep> long <identifiersep> <identifier> ( <identifier> , <number_literal> , item <identifiersep> id ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> array < <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> return <identifiersep> value > <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> array < <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> return <identifiersep> value > ( count ) ; \n \t2 for ( int i = 0 ; i < count ; ++ i ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> ) <identifier> . object <identifiersep> <identifier> <identifiersep> index ( i ) ; \n \t3 if ( ! <string_literal> . equals ( <identifier> <identifiersep> <identifier> <identifiersep> utils . method ( <identifier> ) ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> pool == null ) { \n \t3 try { \n \t4 api . create ( <identifier> <identifiersep> pool ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t4 long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t4 <identifier> <identifiersep> <identifier> ( new <identifier> <identifiersep> long ( message <identifiersep> count ) , target ) ; \n \t4 long end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t4 long <identifier> = ( end <identifiersep> time - start <identifiersep> time ) / <number_literal> ; \n <ect>
\t3 write <identifiersep> index <identifiersep> file ( result , config ) ; \n \t3 write <identifiersep> json <identifiersep> to <identifiersep> out <identifiersep> dir ( <identifier> . to <identifiersep> <identifier> <identifiersep> json ( config ) , <string_literal> ) ; \n \t2 } catch ( exception e ) { \n \t3 log . error ( e . get <identifiersep> message ( ) , e ) ; } \n <ect>
\t6 <identifier> <identifiersep> properties = new array <identifiersep> list < > ( ) ; } \n \t5 <identifier> <identifiersep> properties . add ( property ) ; } } \n \t3 if ( collection <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( <identifier> <identifiersep> properties ) ) { \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + vm . to <identifiersep> string ( ) + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> ( <identifier> <identifiersep> type , vm . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id <identifiersep> to <identifiersep> <identifier> <identifiersep> in ( ) , vm . get <identifiersep> <identifier> <identifiersep> id <identifiersep> to <identifiersep> <identifier> <identifiersep> in ( ) , <string_literal> + vm . get <identifiersep> host <identifiersep> name ( ) + <string_literal> + host <identifiersep> <identifier> , \n \t5 <string_literal> + vm . get <identifiersep> host <identifiersep> name ( ) + <string_literal> + vm <identifiersep> id + <string_literal> + host <identifiersep> <identifier> ) ; \n \t2 } catch ( final resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 private collection < <identifier> <identifiersep> type > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( final list < <identifier> <identifiersep> type > <identifier> <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> <identifier> && ! <identifier> <identifiersep> <identifier> . contains ( <identifier> <identifiersep> type . <identifier> ) ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t3 result . <identifier> = ( thrift <identifiersep> security <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> is <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t1 public void close ( ) { \n \t2 list < <identifier> > <identifier> ; \n \t2 synchronized ( this . <identifier> ) { \n \t3 <identifier> = new array <identifiersep> list < <identifier> > ( this . <identifier> ) ; } \n <ect>
\t3 s <identifiersep> logger . info ( <string_literal> + ( string ) key + <string_literal> + conf . get <identifiersep> property ( ( string ) key ) ) ; } \n \t2 string s = conf . get <identifiersep> property ( <string_literal> ) ; \n \t2 if ( s != null ) { \n \t3 http <identifiersep> <identifier> <identifiersep> port = integer . parse <identifiersep> int ( s ) ; \n <ect>
\t4 type = config . get <identifiersep> node <identifiersep> entity <identifiersep> class ( type <identifiersep> string ) ; \n \t4 if ( type != null ) { \n \t5 query . and <identifiersep> <identifier> ( type ) ; \n \t4 } else { \n <ect>
\t3 long <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> in <identifiersep> millis = system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> <identifiersep> create <identifiersep> time ; \n \t3 log . info ( <identifier> . get <identifiersep> <identifier> <identifiersep> number ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> key ( ) + <string_literal> + data + <string_literal> \n \t5 + <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> in <identifiersep> millis + <string_literal> ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 if ( <identifier> != null && <identifier> != null && <identifier> != null ) { \n \t5 log . info ( <string_literal> ) ; \n \t5 log . info ( <string_literal> + <identifier> ) ; \n \t5 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t5 <string_literal> + ( <identifier> <identifiersep> type <identifiersep> <identifier> == null ? 0 : <identifier> <identifiersep> type <identifiersep> <identifier> . size ( ) ) ) ; \n \t3 num <identifiersep> of <identifiersep> <identifier> *= ( <identifier> <identifiersep> type <identifiersep> <identifier> == null || <identifier> <identifiersep> type <identifiersep> <identifier> . is <identifiersep> empty ( ) ? 1 : <identifier> <identifiersep> type <identifiersep> <identifier> . size ( ) ) ; \n \t3 logger . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . size ( ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . update <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> type <identifiersep> <identifier> ) ; \n <ect>
\t3 log . info ( <string_literal> + get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t3 log . info ( <string_literal> + get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t3 log . info ( <string_literal> + get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> local . class ) ) ; \n \t3 log . info ( <string_literal> + get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> new <identifiersep> bean . class ) ) ; \n <ect>
\t5 command <identifiersep> as <identifiersep> string = value <identifiersep> <identifier> . name ( ) ; \n \t5 break ; } \n \t3 string response = <identifier> <identifiersep> device . request <identifiersep> response ( command <identifiersep> as <identifiersep> string ) ; \n \t3 if ( response . equals ( <string_literal> ) ) { \n <ect>
\t6 if ( ! <identifier> <identifiersep> <identifier> . stop <identifiersep> <identifier> ( <identifier> <identifiersep> context , <identifier> <identifiersep> name ) ) { \n \t7 <comment> \n \t5 } catch ( throwable e ) { \n \t6 <comment> \n <ect>
\t4 <identifier> = ( ( state <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) . get <identifiersep> <identifier> ( ) ; \n \t4 if ( from <identifiersep> conf ) { \n \t5 integer <identifier> <identifiersep> num = config <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> conf , <identifier> <identifiersep> name ) ; \n \t5 if ( <identifier> <identifiersep> num != null ) { \n <ect>
\t2 list < method <identifiersep> <identifier> > <identifier> = method <identifiersep> <identifier> . get ( method ) ; \n \t2 if ( <identifier> != null ) \n \t2 { \n <ect>
\t2 <comment> \n \t2 @ <identifier> public void on <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t3 assert ! job <identifiersep> <identifier> <identifiersep> <identifier> ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> device <identifiersep> type <identifier> <identifiersep> <identifier> <identifiersep> device <identifiersep> type = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config . get <identifiersep> device <identifiersep> type ( ) ; \n \t4 int <identifier> <identifiersep> id ; \n \t4 int <identifier> <identifiersep> id ; \n \t4 int cmd ; \n <ect>
\t4 if ( ! <identifier> <identifiersep> public <identifiersep> ip <identifiersep> address ( ip . get <identifiersep> id ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> user <identifiersep> id ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> account ( ) ) ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + ip . get <identifiersep> id ( ) ) ; \n \t5 success = false ; \n \t4 } else { \n <ect>
\t1 private <identifier> <identifiersep> system \t2 system ; \n \t1 @ <identifier> \n \t1 public void execute ( ) throws <identifier> <identifiersep> execution <identifiersep> exception , <identifier> <identifiersep> failure <identifiersep> exception { \n \t2 if ( <identifier> ) { \n <ect>
\t6 return url <identifiersep> <identifier> . <identifier> ( <identifier> [ <number_literal> ] , <string_literal> ) ; \n \t5 } else { \n \t6 log . warn ( <string_literal> + <identifier> <identifiersep> url ) ; } \n \t4 } else { \n <ect>
\t1 } catch ( <identifier> <identifiersep> key <identifiersep> exception e ) { \n \t1 log . error ( <string_literal> ) ; \n \t1 throw new runtime <identifiersep> exception ( e ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 catch ( interrupted <identifiersep> exception e ) { \n \t4 <comment> \n \t3 <identifier> . run ( ) ; } \n \t2 if ( this . file <identifiersep> <identifier> . size ( ) > 0 ) { \n <ect>
\t3 <comment> \n \t3 message msg = new message ( ) ; \n \t3 msg . set <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 msg . set <identifiersep> <identifier> ( msg <identifiersep> <identifier> ) ; \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t5 exchange . get <identifiersep> in ( ) . get <identifiersep> header ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> handle , string . class ) , <identifier> <identifiersep> <identifier> ) ; \n \t3 try { \n \t4 log . trace ( <string_literal> , this . <identifier> <identifiersep> <identifier> , this . exchange ) ; \n \t4 get <identifiersep> endpoint ( ) . get <identifiersep> client ( ) . <identifier> <identifiersep> message <identifiersep> <identifier> ( request ) ; \n <ect>
\t6 new string [ ] { <string_literal> } ) ; \n \t4 s <identifiersep> logger \n \t4 . info ( <string_literal> + success . get ( <string_literal> ) ) ; \n \t3 } else { \n <ect>
\t1 public void <identifier> <identifiersep> <identifier> ( public <identifiersep> key target , session <identifiersep> key key , <identifier> <identifiersep> set <identifiersep> handle <identifier> ) { \n \t2 <identifier> <identifiersep> session <identifier> = get <identifiersep> session ( target ) ; \n \t2 if ( <identifier> == null ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 list < message > <identifier> = consumer . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 for ( <identifier> < message > <identifier> = <identifier> . <identifier> ( ) ; <identifier> . has <identifiersep> next ( ) ; ) { \n \t3 object message = <identifier> . next ( ) ; \n <ect>
class system <identifiersep> property <identifiersep> host <identifiersep> location <identifiersep> <identifier> implements host <identifiersep> location <identifiersep> <identifier> { \n \t1 private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( <identifier> . class ) ; \n \t1 @ json <identifiersep> <identifier> \n \t1 public system <identifiersep> property <identifiersep> host <identifiersep> location <identifiersep> <identifier> ( ) { \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> ) ; \n \t2 final http <identifiersep> <identifier> <identifier> = new http <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> content <identifiersep> type ( <identifier> <identifiersep> type . text <identifiersep> <identifier> ) ; \n \t2 final response <identifiersep> entity < string > entity = new response <identifiersep> entity < > ( <identifier> , <identifier> , http <identifiersep> status . <identifier> ) ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t4 } else { \n \t5 result . set <identifiersep> failure <identifiersep> message ( <string_literal> + get <identifiersep> json <identifiersep> path ( ) ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t4 text <identifiersep> message <identifier> = ( text <identifiersep> message ) message ; \n \t4 try { \n \t5 log . info ( <string_literal> , <identifier> . get <identifiersep> text ( ) , count . get ( ) ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } else { \n \t3 <identifier> . end <identifiersep> <identifier> ( ) ; } } \n \t1 private void end <identifiersep> <identifier> ( ) { \n \t2 if ( current <identifiersep> <identifier> == no <identifiersep> line ) { \n <ect>
\t3 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> . class ) ; \n \t3 if ( <identifier> == null ) { \n \t4 if ( ! <identifier> . is <identifiersep> abstract ( <identifier> . get <identifiersep> <identifier> ( ) ) ) { \n \t5 <comment> \n <ect>
\t4 return result ; \n \t3 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t1 protected void assert <identifiersep> message <identifiersep> <identifier> ( int index , message message ) throws <identifier> <identifiersep> exception { \n \t2 text <identifiersep> message text <identifiersep> message = ( text <identifiersep> message ) message ; \n \t2 string text = text <identifiersep> message . get <identifiersep> text ( ) ; \n \t2 if ( <identifier> ) { \n <ect>
\t7 return false ; } \n \t6 query . set <identifiersep> <identifier> ( <string_literal> , string . value <identifiersep> of ( new <identifiersep> <identifier> ) ) ; \n \t6 <identifier> ++ ; } \n <ect>
\t3 <identifier> <identifiersep> index <identifiersep> <identifier> ( index <identifiersep> name , <identifier> <identifiersep> read <identifiersep> <identifier> ) ; \n \t3 assert <identifiersep> that ( client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> create <identifiersep> snapshot ( <identifier> <identifiersep> name , <string_literal> ) . set <identifiersep> <identifier> ( <identifier> <identifiersep> index <identifiersep> name <identifiersep> <identifier> ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( true ) . get ( ) . status ( ) , equal <identifiersep> to ( <identifier> <identifiersep> status . <identifier> ) ) ; \n \t2 } finally { \n \t3 <identifier> <identifiersep> index <identifiersep> <identifier> ( index <identifiersep> name , <identifier> <identifiersep> read <identifiersep> <identifier> ) ; } \n <ect>
\t3 <identifier> . <identifier> ( <identifier> . <identifier> <identifiersep> mode , key <identifiersep> <identifier> ) ; \n \t3 byte [ ] <identifier> <identifiersep> bytes = <identifier> . do <identifiersep> final ( text . get <identifiersep> bytes ( ) ) ; \n \t3 return <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( <identifier> <identifiersep> bytes ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
<comment> \n public static string <identifier> <identifiersep> <identifier> <identifiersep> item <identifiersep> <identifier> ( final string input <identifiersep> file <identifiersep> path , \n <number_literal> final string user <identifiersep> name ) { \n \t1 if ( string <identifiersep> <identifier> . is <identifiersep> empty ( input <identifiersep> file <identifiersep> path ) ) { \n <ect>
{ \n \t1 private final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( base <identifiersep> <identifier> <identifiersep> configuration . class ) ; \n \t1 public void set <identifiersep> root <identifiersep> logger <identifiersep> level ( level level ) \n \t1 { \n <ect>
\t1 private void <identifier> <identifiersep> access <identifiersep> token <identifiersep> response ( final http <identifiersep> <identifier> <identifiersep> request request , final http <identifiersep> <identifier> <identifiersep> response response , \n <number_literal> final access <identifiersep> token <identifiersep> request <identifiersep> data <identifiersep> <identifier> request <identifiersep> <identifier> , \n <number_literal> final <identifier> <identifiersep> context context , final access <identifiersep> token access <identifiersep> token , \n <number_literal> final <identifier> <identifiersep> token <identifier> <identifiersep> token ) { \n <ect>
\t4 string error = <string_literal> + vm . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) ; \n \t4 s <identifiersep> logger . error ( error ) ; \n \t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( error ) ; \n \t3 } else { \n <ect>
\t3 if ( listener <identifiersep> <identifier> instanceof <identifier> <identifiersep> bean ) { \n \t4 try { \n \t5 ( ( <identifier> <identifiersep> bean ) listener <identifiersep> <identifier> ) . <identifier> ( ) ; } \n \t4 catch ( exception ex ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 } else { \n \t3 try { \n \t4 api . update ( policy ) ; \n \t3 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t4 } else if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . equals ( <identifier> <identifiersep> entry . get <identifiersep> property <identifiersep> name ( ) ) ) { \n \t5 <identifier> <identifiersep> field = <string_literal> ; \n \t4 } else { \n \t5 if ( <identifier> <identifiersep> entry . get <identifiersep> property <identifiersep> name ( ) . index <identifiersep> of ( ' / ' ) >= 0 ) { \n <ect>
\t2 read <identifiersep> message ( data , <identifier> , <identifier> , type ) ; \n \t2 <identifier> += <identifier> ; \n \t2 <identifier> <identifiersep> has <identifiersep> <identifier> = true ; \n \t2 if ( <identifier> <identifiersep> test && <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t2 assert <identifiersep> true ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) . <identifier> ( ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> success ( ) ; \n \t2 log . debug ( <string_literal> ) ; \n <ect>
\t1 private logger log ; \n \t1 private array <identifiersep> list < object > event <identifiersep> list = new array <identifiersep> list < object > ( ) ; \n \t1 public void process ( @ <identifier> @ <identifier> <identifiersep> process string event ) { \n \t2 event <identifiersep> list . add ( event ) ; \n <ect>
\t3 principal <identifier> = <identifier> . get <identifiersep> property ( file . <identifier> ) ; \n \t3 <identifier> . success ( ) ; \n \t3 return <identifier> ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t5 logger . debug ( <string_literal> + this . target <identifiersep> session + <string_literal> ) ; } } \n \t3 else { \n <ect>
\t1 public void test <identifiersep> map <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 final <identifier> <identifiersep> source < <identifier> <identifiersep> <identifier> <identifiersep> type , <identifier> <identifiersep> <identifier> > <identifier> = test <identifiersep> <identifier> \n \t4 . get <identifiersep> <identifier> <identifiersep> source ( <string_literal> ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> ) ; \n <ect>
\t1 if ( client == null ) { \n \t2 try { \n \t2 <identifier> . put ( <identifier> , create <identifiersep> destination ( <identifier> ) ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 if ( log . should <identifiersep> log ( log . debug ) ) \n \t4 log . debug ( <string_literal> + time <identifiersep> from <identifiersep> <identifier> + <string_literal> + config , new exception ( <string_literal> ) ) ; \n \t3 return null ; } \n \t2 if ( log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 logger . debug ( <string_literal> , type ) ; \n \t3 return new <identifier> <identifiersep> password <identifiersep> <identifier> ( properties . get <identifiersep> type ( ) ) ; } \n \t2 if ( type . contains ( <string_literal> ) ) { \n \t3 try { \n <ect>
\t1 public string <identifier> <identifiersep> <identifier> <identifiersep> value ( final <identifier> <identifier> , final http <identifiersep> <identifier> <identifiersep> request request ) { \n \t2 final string <identifier> <identifiersep> value = this . <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> . get <identifiersep> value ( ) ) . to <identifiersep> string ( ) ; \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> value ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> <identifiersep> value ) ) { \n <ect>
\t1 protected s <identifier> ( ) { \n \t1 final string <identifier> = get <identifiersep> <identifier> <identifiersep> value ( ) ; \n \t1 s <identifier> <identifiersep> <identifier> = get <identifiersep> default <identifiersep> <identifier> ( ) ; \n \t1 if ( ! string <identifiersep> utils . is <identifiersep> empty ( <identifier> ) ) { \n <ect>
\t4 { \n \t5 message <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( default <identifiersep> <identifier> ) ; } \n \t4 catch ( throwable e ) \n \t4 { \n <ect>
\t2 string address = null ; \n \t2 try { \n \t3 address = <identifier> <identifiersep> <identifier> . get <identifiersep> service <identifiersep> url ( <identifier> , service <identifiersep> <identifier> . <identifier> , <identifier> , <string_literal> , true ) ; \n \t3 if ( <identifier> . is <identifiersep> null <identifiersep> or <identifiersep> blank ( address ) ) { \n <ect>
\t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> attributes ( ) ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ) ; \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> attribute <identifiersep> value ( <identifier> <identifiersep> value ) ) { \n \t5 log <identifiersep> <identifier> <identifiersep> attribute <identifiersep> entry ( attribute <identifiersep> name , <identifier> <identifiersep> value ) ; \n \t5 attributes <identifiersep> to <identifiersep> <identifier> . put ( attribute <identifiersep> name , <identifier> <identifiersep> value ) ; } } \n \t2 } ) ; \n <ect>
\t6 try { \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . wait ( <identifier> . <identifier> ( time <identifiersep> <identifier> , <identifier> ) ) ; \n \t6 } catch ( interrupted <identifiersep> exception <identifier> ) { \n \t7 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t1 protected boolean check <identifiersep> <identifier> ( ) { \n \t2 if ( get <identifiersep> <identifier> <identifiersep> entity ( ) == null ) { \n \t3 log <identifiersep> log . warn ( <string_literal> ) ; \n \t2 } else if ( ! <identifier> <identifiersep> to <identifiersep> create <identifiersep> <identifier> <identifiersep> context ( ) ) { \n <ect>
\t3 command . add ( <identifier> <identifiersep> file <identifiersep> name ) ; <comment> \n \t3 for ( string <identifier> <identifiersep> name : <identifier> ) { \n \t4 command . add ( <identifier> <identifiersep> name ) ; } \n \t3 command . execute ( ) ; \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 log . <identifier> ( <string_literal> ) ; \n \t2 log . <identifier> ( <string_literal> , new exception ( <string_literal> ) ) ; \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> instance ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n \t1 log . info ( <string_literal> + target <identifiersep> version ) ; \n \t1 <identifier> <identifiersep> <identifier> target <identifiersep> <identifier> <identifiersep> <identifier> = abstract <identifiersep> <identifier> <identifiersep> <identifier> \n \t2 . get <identifiersep> <identifier> <identifiersep> <identifier> ( target <identifiersep> version ) ; \n <ect>
\t4 <comment> \n \t4 string <identifier> <identifiersep> <identifier> <identifiersep> ticket = \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> access <identifiersep> ticket ( cmd . get <identifiersep> host ( ) , cmd . get <identifiersep> port ( ) , cmd . get <identifiersep> <identifier> ( ) , cmd . get <identifiersep> vm <identifiersep> id ( ) , new date ( <identifier> . get <identifiersep> time ( ) - <number_literal> * <number_literal> ) ) ; \n <ect>
\t3 response . read <identifiersep> entity ( string . class ) ; \n \t3 throw new exception ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> exception e = ( <identifier> <identifiersep> <identifier> <identifiersep> exception ) <identifier> . get <identifiersep> <identifier> ( ) ; \n <ect>
\t2 assert . assert <identifiersep> equals ( 1 , has <identifiersep> <identifier> . size ( ) ) ; \n \t2 assert . assert <identifiersep> equals ( <number_literal> , has <identifiersep> <identifier> . size ( ) ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t5 ( <identifier> <identifiersep> <identifier> instanceof <identifier> ) ) { \n \t4 try { \n \t5 ( ( <identifier> ) <identifier> <identifiersep> <identifier> ) . stop ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 <identifier> . <identifier> ( <string_literal> ) . <identifier> ( table <identifiersep> name ) . <identifier> ( <string_literal> ) ; } \n \t1 <identifier> . <identifier> ( <string_literal> + table <identifiersep> name + <string_literal> ) ; \n \t1 string table <identifiersep> <identifier> = get <identifiersep> conf ( ) . get ( sql <identifiersep> server <identifiersep> manager . table <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 if ( table <identifiersep> <identifier> != null ) { \n <ect>
\t2 <comment> \n \t2 string <identifier> = system . get <identifiersep> property ( <string_literal> ) ; \n \t2 boolean <identifier> = boolean . value <identifiersep> of ( <identifier> <identifiersep> config <identifiersep> dao . get <identifiersep> value ( <string_literal> ) ) ; \n \t2 if ( ! <identifier> . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) && ! <identifier> ) { \n <ect>
\t1 if ( <identifier> . wait <identifiersep> object <identifiersep> 0 != result and <identifier> . wait <identifiersep> timeout != result ) : \n \t1 <identifier> <identifier> <identifiersep> exception ( - 1 , <string_literal> + <identifier> ( result ) ) \n \t1 if ( <identifier> . wait <identifiersep> timeout == result ) : \n \t1 return - 1 \n <ect>
for <identifier> <identifiersep> name in <identifier> <identifiersep> <identifier> : \n \t1 if <identifier> <identifiersep> name in <identifier> : \n \t1 <identifier> = <identifier> . get ( <identifier> <identifiersep> name ) \n \t1 <identifier> ( <identifier> ) \n <ect>
\t5 for ( <identifier> <identifier> : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t6 if ( <identifier> . get <identifiersep> has <identifiersep> <identifier> ( ) ) { \n \t7 continue ; } \n \t6 <identifier> <identifiersep> file <identifier> <identifiersep> file = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( security <identifiersep> context , <identifier> ) ; \n <ect>
\t1 for ( <identifier> <identifiersep> group <identifiersep> <identifier> group : <identifier> ) { \n \t2 log . debug ( group . name ) ; \n \t2 int i = 0 ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifier> : group . <identifier> ) { \n <ect>
\t4 if ( <identifier> <identifiersep> state == state . <identifier> ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + vm + <string_literal> ) ; \n \t5 s <identifiersep> <identifier> . remove ( <identifier> <identifiersep> cluster , host <identifiersep> <identifier> , vm ) ; \n \t4 } else if ( <identifier> <identifiersep> state == state . <identifier> ) { \n <ect>
\t3 return null ; \n \t2 final <identifier> resource <identifiersep> <identifier> = resource <identifiersep> <identifier> . <identifier> ( data ) ; \n \t2 if ( ! resource <identifiersep> <identifier> . find ( ) ) \n \t2 { \n <ect>
\t3 { \n \t4 return false ; } } \n \t2 catch ( <identifier> <identifiersep> exception <identifier> <identifiersep> exception ) \n \t2 { \n <ect>
\t5 + e . get <identifiersep> <identifier> <identifiersep> message ( ) ) ; \n \t2 } else if ( e != null ) { \n \t3 log . error ( <string_literal> + e . get <identifiersep> <identifier> <identifiersep> message ( ) ) ; } \n \t2 if ( job <identifiersep> id == null || e == null ) { \n <ect>
\t2 <identifier> . stop <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> cache . <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> cache ( string <identifiersep> utils . <identifier> <identifiersep> <identifier> ( db <identifiersep> name ) , \n \t3 string <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name ) , <identifier> ) ; \n \t1 } catch ( meta <identifiersep> exception | no <identifiersep> such <identifiersep> object <identifiersep> exception e ) { \n <ect>
\t5 try { \n \t6 <identifier> <identifiersep> <identifier> . wait ( time <identifiersep> unit . <identifier> . to <identifiersep> millis ( <number_literal> ) ) ; \n \t5 } catch ( interrupted <identifiersep> exception <identifier> ) { } } \n \t4 if ( this . <identifier> . get ( ) > 0 ) { \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 <identifier> . <identifier> ( <string_literal> ) ; \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> ( ) ; \n <ect>
\t5 cmd <identifiersep> <identifier> . add ( <string_literal> ) ; \n \t5 try { \n \t6 <identifier> <identifiersep> process ( cmd <identifiersep> <identifier> , <identifier> ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> device . get <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> ( ) . add <identifiersep> all ( <identifier> . as <identifiersep> list ( load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . values ( ) ) ) ; \n \t3 <identifier> <identifiersep> device . set <identifiersep> <identifier> <identifiersep> config ( configuration ) ; \n \t3 <identifier> <identifiersep> config ( <identifier> <identifiersep> device , device <identifiersep> config ) ; \n \t2 } else if ( device <identifiersep> type . equals ( type <identifiersep> key . <identifier> <identifiersep> <identifier> . name ( ) ) ) { \n <ect>
\t4 this . <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> ( ) . next ( ) , <identifier> , false ) ; \n \t3 } else { \n \t4 <identifier> <identifiersep> a <identifiersep> <identifier> ( <identifier> , <identifier> ) ; } } } \n \t1 protected void <identifier> <identifiersep> a <identifiersep> <identifier> ( set < <identifier> > <identifier> , <identifier> <identifier> ) { \n <ect>
\t1 return <identifier> <identifiersep> status \n <identifier> <identifier> <identifiersep> client ( self , connection , method , service <identifiersep> url , body , <identifier> ) : \n \t1 service = <string_literal> <identifier> connection . host . <identifier> ( ) \n \t1 logger . debug ( <string_literal> , connection ) \n <ect>
\t4 r <identifier> <identifiersep> first <identifiersep> application = r ; \n \t4 try { \n \t5 <identifier> <identifiersep> first <identifiersep> application = execution <identifiersep> <identifier> . on <identifiersep> <identifier> ( <identifier> <identifiersep> cmd , r ) ; \n \t4 } catch ( throwable <identifier> <identifiersep> ex ) { \n <ect>
public <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> uri ) { \n \t1 super ( <identifier> <identifiersep> uri ) ; } \n @ <identifier> \n public response <identifier> <identifiersep> handle ( http <identifiersep> request request ) throws json <identifiersep> exception { \n <ect>
public boolean check ( @ <identifier> string key , string value ) { \n \t1 try { \n \t1 return key != null && <identifier> <identifiersep> <identifier> . parse ( key ) . <identifier> <identifiersep> to ( <identifier> <identifiersep> <identifier> . parse ( value ) ) < = 0 ; \n \t1 } catch ( parse <identifiersep> exception e ) { \n <ect>
\t1 if ( output . failed ( ) || string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( output . error ) ) { \n \t1 if ( output . return <identifiersep> value == resource <identifiersep> not <identifiersep> found && output . error . contains ( <string_literal> ) ) { \n \t2 log . debug ( <string_literal> + volume <identifiersep> id + <string_literal> ) ; \n \t2 throw new resource <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + <identifier> ) ; } \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , context ) ; \n \t2 get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> store ( ) . delete <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( index , context , true ) ; } \n \t1 public x <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ( final x <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , string <identifier> , x <identifiersep> <identifier> <identifiersep> context context ) throws x <identifiersep> <identifier> <identifiersep> exception \n \t1 { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 address <identifier> = msg . get <identifiersep> <identifier> ( ) ; \n \t3 address <identifier> = msg . get <identifiersep> <identifier> ( ) ; \n \t3 if ( ! is <identifiersep> local ( <identifier> ) ) { \n <ect>
\t1 } ; \n \t1 try { \n \t1 <identifier> . as <identifiersep> transaction ( <identifier> <identifiersep> <identifier> ) . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( final throwable <identifier> ) { \n <ect>
\t2 string <identifier> <identifiersep> string = null ; \n \t2 try { \n \t3 <identifier> <identifiersep> string = s <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> operation <identifiersep> not <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 action = <string_literal> ; \n \t5 <identifier> = <identifier> + <string_literal> ; \n \t5 update <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> = true ; \n \t4 } else { \n <ect>
\t3 wait <identifiersep> for <identifiersep> <identifier> ( total <identifiersep> num <identifiersep> <identifier> , <identifier> ) ; \n \t3 <identifier> . assert <identifiersep> no <identifiersep> <identifier> ( ) ; \n \t3 logger . info ( <string_literal> , total <identifiersep> num <identifiersep> <identifier> ) ; \n \t3 <comment> \n <ect>
<comment> \n \t1 public void write <identifiersep> string ( string msg ) { \n <ect>
\t2 < input type = <string_literal> <identifier> - model = <string_literal> / > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > log < / <identifier> > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > warn < / <identifier> > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > info < / <identifier> > \n <ect>
\t3 <identifier> . add ( new read <identifiersep> entity ( db . get <identifiersep> <identifier> ( db <identifiersep> name ) ) ) ; } } } \n \t1 set <identifiersep> <identifier> <identifiersep> task ( create <identifiersep> <identifier> <identifiersep> task ( <identifier> <identifiersep> <identifier> ) ) ; \n \t1 } catch ( exception e ) { \n \t1 <comment> \n <ect>
\t3 . get <identifiersep> client <identifiersep> transaction ( ) ; \n \t2 if ( client <identifiersep> transaction == null ) \n \t2 { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 boolean <identifier> = false ; \n \t2 if ( ( <identifier> <identifiersep> code == null ) || ( <identifier> <identifiersep> code . length ( ) != <number_literal> ) ) { \n \t3 logger . warn ( <string_literal> ) ; \n \t2 } else if ( ( <identifier> < 1 ) || ( <identifier> > <identifier> <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> the <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t3 try { \n \t4 <comment> \n \t4 if ( service == current <identifiersep> <identifier> <identifiersep> <identifier> && current <identifiersep> <identifier> <identifiersep> session <identifiersep> id . equals ( <identifier> <identifiersep> session <identifiersep> id ) ) { \n \t5 final string address = service . <identifier> . get <identifiersep> address ( ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> from <identifiersep> to ( list < element > <identifier> <identifiersep> from <identifiersep> <identifier> , list < element > <identifier> <identifiersep> to <identifiersep> <identifier> ) throws <identifier> <identifiersep> configuration <identifiersep> exception { \n <ect>
\t4 logger . debug ( <string_literal> + user <identifiersep> info ) ; \n \t4 logger . debug ( <string_literal> + current <identifiersep> <identifier> <identifiersep> status ) ; \n <ect>
\t3 boolean success = status >= <number_literal> && status < <number_literal> ; \n \t3 if ( ! success ) { \n \t4 logger . warn ( <string_literal> + url ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t1 <comment> \n \t1 string name = <identifier> . get <identifiersep> name ( ) ; \n \t1 <identifier> <identifiersep> bean <identifiersep> config config = <identifier> <identifiersep> config . find <identifiersep> <identifier> <identifiersep> bean <identifiersep> config ( name ) ; \n \t1 if ( config == null ) { \n <ect>
\t1 this . <identifier> = true ; \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t1 <identifier> <identifiersep> conf . <identifier> ( ) ; } \n \t1 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 return object <identifiersep> metadata <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> <identifiersep> <identifier> ( entity , last <identifiersep> <identifier> , <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 long <identifier> = <identifier> . get <identifiersep> value ( ) ; \n \t2 long read = data <identifiersep> <identifier> . from <identifiersep> long ( <identifier> , <identifier> . length - <number_literal> , <number_literal> ) ; \n \t2 if ( read != <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 logger . info ( <string_literal> , <identifier> <identifiersep> routing ) ; \n \t4 <identifier> <identifiersep> routing new <identifiersep> <identifier> = <identifier> <identifiersep> state . routing <identifiersep> table ( ) . index ( <identifier> <identifiersep> routing . index ( ) ) \n \t5 . <identifier> ( <identifier> <identifiersep> routing . id ( ) ) . <identifier> <identifiersep> <identifier> ( ) ; \n \t4 version new <identifiersep> <identifier> <identifiersep> version = get <identifiersep> node <identifiersep> version ( new <identifiersep> <identifier> , <identifier> <identifiersep> state ) ; \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t5 } else { \n \t6 vm . set <identifiersep> <identifier> ( key , <identifier> <identifiersep> <identifier> . get ( key ) ) ; } } \n \t4 vm . set <identifiersep> <identifier> ( <string_literal> , <string_literal> ) ; \n \t4 <identifier> <identifiersep> vm <identifiersep> dao . <identifier> <identifiersep> <identifier> ( vm ) ; \n <ect>
\t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( content <identifiersep> name name , <identifier> <identifiersep> handle handle ) throws io <identifiersep> exception { \n \t2 this ( handle ) ; \n \t2 if ( name != null ) { \n \t3 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> io , level . info ) ) \n <ect>
\t2 if ( this . channel != null ) { \n \t3 this . channel . key <identifiersep> for ( this . <identifier> . get <identifiersep> <identifier> ( ) ) . <identifier> ( ) ; \n \t3 this . <identifier> . get <identifiersep> <identifier> ( ) . <identifier> ( ) ; <comment> \n \t3 try { \n <ect>
\t3 success = true ; \n \t2 } catch ( lock <identifiersep> <identifier> <identifiersep> failed <identifiersep> exception ex ) { \n \t3 logger . debug ( ( ) - > new <identifier> <identifiersep> message ( <string_literal> , index ) , ex ) ; \n \t2 } catch ( exception ex ) { \n <ect>
public void set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> <identifier> value ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( value , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> <identifier> value ) { \n <ect>
\t1 list < task > <identifier> = task <identifiersep> service . create <identifiersep> task <identifiersep> query ( ) . process <identifiersep> instance <identifiersep> id ( <identifier> . get <identifiersep> id ( ) ) . list ( ) ; \n \t1 for ( task task : <identifier> ) { \n \t1 map < string , object > <identifier> = new <identifier> <identifiersep> map < string , object > ( ) ; \n \t1 <comment> \n <ect>
\t4 logger . info ( <string_literal> \n \t8 + <string_literal> ) ; } \n \t3 catch ( no <identifiersep> local <identifiersep> <identifier> <identifiersep> manager <identifiersep> exception e ) \n \t3 { \n <ect>
\t3 log . debug ( <string_literal> , \n \t5 root , <identifier> , <identifier> . to <identifiersep> string ( path ) , path <identifiersep> index , <identifier> , <identifier> ) ; } \n \t2 if ( thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ) { \n \t3 query <identifiersep> exception exception = new query <identifiersep> exception ( <string_literal> ) ; \n <ect>
\t2 public void run ( ) { \n \t3 try { \n \t4 <identifier> <identifiersep> lock lock = <identifier> <identifiersep> lock . get <identifiersep> <identifier> <identifiersep> lock ( <string_literal> ) ; \n \t4 if ( lock == null ) { \n <ect>
\t4 return ; } } \n \t2 boolean is <identifiersep> <identifier> = true ; \n \t2 boolean result = <identifier> . get <identifiersep> <identifier> <identifiersep> type <identifiersep> model <identifiersep> handler ( ) . read <identifiersep> model <identifiersep> from <identifiersep> file ( model <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) , is <identifiersep> <identifier> ) ; \n \t2 if ( ! result ) \n <ect>
\t1 public map < string , object > get <identifiersep> <identifier> <identifiersep> attributes <identifiersep> from ( final <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 try { \n \t3 final string result = this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> . get <identifiersep> attributes ( ) ) ; \n \t3 if ( string <identifiersep> utils . is <identifiersep> blank ( result ) ) { \n <ect>
\t8 + get <identifiersep> connection <identifiersep> id ( ) \n \t8 + <string_literal> \n \t8 + message ) ; } } \n \t4 catch ( exception <identifier> ) { \n <ect>
<comment> \n \t1 <identifier> ( string input ) { \n \t2 this . input = input ; \n <ect>
\t1 public boolean contains <identifiersep> <identifier> ( final string <identifier> ) { \n \t2 try { \n \t3 return parse <identifiersep> <identifier> ( null , null , <identifier> , false ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> = new properties <identifiersep> <identifier> ( ) ; } } \n \t2 else { \n \t3 <comment> \n <ect>
\t3 <comment> \n \t3 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) && boolean . true . equals ( <identifier> . <identifier> ( <identifier> <identifiersep> context , this , <string_literal> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) . <identifier> ( <string_literal> ) , <string_literal> ) ) ) { \n \t4 return false ; } \n \t2 } catch ( <identifier> <identifiersep> exception | <identifier> <identifiersep> exception ex ) { \n <ect>
\t1 public <identifier> <identifiersep> <identifier> ( transport local <identifiersep> <identifier> , transport remote <identifiersep> <identifier> ) { \n \t2 this . local <identifiersep> <identifier> = local <identifiersep> <identifier> ; \n \t2 this . remote <identifiersep> <identifier> = remote <identifiersep> <identifier> ; } \n \t1 public void start ( ) throws exception { \n <ect>
\t4 try { \n \t5 in . close ( ) ; \n \t4 } catch ( io <identifiersep> exception ex ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> response <identifier> <identifiersep> <identifier> <identifiersep> response ; \n \t1 try { \n \t2 if ( ! <identifier> <identifiersep> session <identifiersep> manager . is <identifiersep> registered ( <identifier> <identifiersep> session <identifiersep> id ) ) { \n \t2 <comment> \n <ect>
<comment> \n static void execute <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( string cmd , i <identifiersep> <identifier> <identifier> ) throws exception { \n <ect>
\t1 end \n \t1 <identifier> += 1 \n \t1 server <identifiersep> index = ( server <identifiersep> index + 1 ) <identifier> <identifier> . length \n \t1 end \n <ect>
\t2 if ( object instanceof string ) { \n \t2 try { \n \t3 <identifier> <identifiersep> id = integer . value <identifiersep> of ( ( string ) object ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 protected void run <identifiersep> in <identifiersep> context ( ) { \n \t5 try { \n \t6 class < ? > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . load <identifiersep> class ( <string_literal> ) ; \n \t6 try { \n <ect>
\t1 <identifier> = <identifier> \n \t1 <identifier> <identifiersep> <identifier> = [ ] \n \t1 <identifier> <identifiersep> <identifier> = false \n \t1 if <identifier> <identifiersep> config : \n <ect>
\t4 <identifier> <identifiersep> method method = <identifier> <identifiersep> new <identifiersep> method . <identifier> ( <string_literal> + type . get <identifiersep> name ( ) + <string_literal> , <identifier> <identifiersep> class ) ; \n \t4 <identifier> <identifiersep> class . add <identifiersep> method ( method ) ; \n \t4 return ( object <identifiersep> <identifier> < t > ) ( <identifier> <identifiersep> class . to <identifiersep> class ( type . get <identifiersep> class <identifiersep> <identifier> ( ) , type . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) . get <identifiersep> <identifier> ( ) . new <identifiersep> instance ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception | <identifier> <identifiersep> target <identifiersep> exception | <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 <comment> \n \t1 array <identifiersep> list < node > <identifier> <identifiersep> nodes = new array <identifiersep> list < node > ( ) ; \n \t1 <identifier> <identifiersep> nodes . add <identifiersep> all ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . values ( ) ) ; \n \t1 <identifier> . start <identifiersep> <identifier> ( <identifier> <identifiersep> nodes , null ) ; \n <ect>
\t3 log . info ( <string_literal> , address , <identifier> ) ; } } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> stop ( ) throws exception { \n \t2 if ( configuration . is <identifiersep> client <identifiersep> mode ( ) && configuration . get <identifiersep> <identifier> ( ) . equals ( <string_literal> ) ) { \n <ect>
\t6 <comment> \n \t6 logger . <identifier> ( <identifier> , <identifier> + <string_literal> + <identifier> + <string_literal> , e ) ; \n \t5 } catch ( throwable e ) { \n \t6 <comment> \n <ect>
\t3 <identifier> <identifiersep> cluster <identifiersep> state . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> base <identifiersep> path ) ; \n \t3 <identifier> <identifiersep> cluster <identifiersep> state . <identifier> ( cluster . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> path ( <identifier> <identifiersep> id ) ) ; \n \t3 <identifier> <identifiersep> cluster <identifiersep> state . <identifier> ( cluster . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> path ( <identifier> <identifiersep> id ) ) ; \n \t3 <comment> \n <ect>
\t1 try { \n \t1 client . delete ( ) . <identifier> ( ) . for <identifiersep> path ( local <identifiersep> node <identifiersep> path ) ; \n \t1 } catch ( <identifier> <identifiersep> exception . no <identifiersep> node <identifiersep> exception ignore ) { \n \t1 } catch ( exception e ) { \n <ect>
\t1 try { \n \t1 <identifier> <identifiersep> meta <identifiersep> data meta <identifiersep> data = connection <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> metadata ( connection ) ; \n \t1 <identifier> ( ) . <identifier> ( new result <identifiersep> <identifier> ( - 1 , meta <identifiersep> data ) , self ( ) ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t4 logger . info ( <string_literal> + <identifier> + <string_literal> + task <identifiersep> list + <string_literal> ) ; \n \t4 } else if ( <identifier> <identifiersep> <identifier> . is <identifiersep> lock <identifiersep> error ( e ) ) { \n \t4 logger . info ( <string_literal> + <identifier> + <string_literal> + task <identifiersep> list + <string_literal> ) ; \n \t4 } else { \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
protected void <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t1 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) || <identifier> <identifiersep> new <identifiersep> <identifier> ) { \n \t1 return ; } \n <ect>
\t3 execution <identifiersep> <identifier> . <identifier> <identifiersep> job <identifiersep> status <identifiersep> listener ( listener ) \n \t2 case <identifier> <identifiersep> <identifier> = > <comment> \n \t1 } catch { \n \t2 case t : throwable = > \n <ect>
\t2 try { \n \t3 send <identifiersep> response ( <identifier> , e , <string_literal> ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 <comment> \n \t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 <comment> \n \t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n <ect>
\t1 public void add <identifiersep> event <identifiersep> listener ( <identifier> <identifiersep> <identifier> <identifiersep> event <identifiersep> listener listener ) { \n \t2 logger . error ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void remove <identifiersep> event <identifiersep> listener ( <identifier> <identifiersep> <identifier> <identifiersep> event <identifiersep> listener listener ) { \n <ect>
\t2 return <identifier> ; } \n \t1 public void test <identifiersep> <identifier> ( ) { \n \t2 string conf <identifiersep> debug = <string_literal> ; \n \t2 if ( ! conf <identifiersep> debug . equals ( <string_literal> ) && ! conf <identifiersep> debug . equals ( <string_literal> ) ) { \n <ect>
\t2 log . warn ( <string_literal> + this . snapshot <identifiersep> id + <string_literal> , ex ) ; \n \t2 throw ex ; } \n \t1 <comment> \n \t1 if ( <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t4 send <identifiersep> update ( <identifier> <identifiersep> property . <identifier> <identifiersep> mode . get <identifiersep> code ( ) , new string <identifiersep> type ( value ) ) ; \n \t3 } else if ( command . equals ( <string_literal> ) ) { \n \t4 process <identifiersep> <identifier> <identifiersep> command ( command , value ) ; } \n \t2 } else { \n <ect>
\t2 <identifier> <identifiersep> group . <identifier> <identifiersep> and <identifiersep> get ( <string_literal> ) ; \n \t2 logger . error ( <string_literal> , ex ) ; \n \t1 } catch ( runtime <identifiersep> exception ex ) { \n \t2 <identifier> <identifiersep> group . <identifier> <identifiersep> and <identifiersep> get ( <string_literal> ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 <comment> \n \t2 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) \n \t2 { \n <ect>
\t3 <comment> \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> found . get ( ) ) { \n \t4 <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> class ( ) , <identifier> , handler ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 thread . <identifier> ( thread <identifiersep> local <identifiersep> <identifier> . current ( ) . next <identifiersep> int ( <number_literal> ) ) ; \n \t3 context . start ( ) ; \n \t3 context <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t4 log . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> key ( ) . get <identifiersep> id ( ) \n \t6 + <string_literal> ) ; \n \t4 continue ; } \n \t3 if ( <identifier> . is <identifiersep> <identifier> <identifiersep> operation ( ) ) { \n <ect>
\t2 for ( entry < key , value > entry : <identifier> <identifiersep> <identifier> ) { \n \t2 if ( ! entry . get <identifiersep> key ( ) . get <identifiersep> <identifier> ( ) . equals ( <identifier> ) ) \n \t3 break ; } \n \t1 } catch ( table <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t2 return new org . apache . thrift . <identifier> . <identifier> <identifiersep> method <identifiersep> <identifier> < void > ( ) { \n \t2 public void on <identifiersep> <identifier> ( void o ) { } \n \t2 public void on <identifiersep> error ( java . <identifier> . exception e ) { \n \t3 if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
public void set <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . <identifier> value ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( value , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . <identifier> value ) { \n <ect>
\t3 file <identifiersep> input <identifiersep> format . add <identifiersep> input <identifiersep> path ( job , input ) ; \n \t3 file <identifiersep> output <identifiersep> format . set <identifiersep> output <identifiersep> path ( job , output ) ; \n \t3 job . wait <identifiersep> for <identifiersep> <identifier> ( true ) ; } \n \t2 catch ( io <identifiersep> exception e ) { \n <ect>
\t5 ) ; \n \t5 <identifier> <identifiersep> server . start ( ) ; } \n \t4 catch ( io <identifiersep> exception e ) \n \t4 { \n <ect>
\t4 log . info ( <string_literal> ) ; \n \t2 server <identifiersep> session <identifiersep> pool = new server <identifiersep> session <identifiersep> pool <identifiersep> <identifier> ( this , endpoint <identifiersep> <identifier> <identifiersep> key . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> max <identifiersep> <identifier> <identifiersep> int <identifiersep> value ( ) ) ; \n \t2 <identifier> ( ) ; \n \t3 } else { \n <ect>
\t3 <comment> \n \t3 string <identifier> <identifiersep> name = get <identifiersep> <identifier> <identifiersep> context <identifiersep> attribute <identifiersep> name ( ) ; \n \t3 get <identifiersep> <identifier> <identifiersep> context ( ) . set <identifiersep> attribute ( <identifier> <identifiersep> name , <identifier> ) ; \n <ect>
\t1 public void create <identifiersep> <identifier> ( final <identifier> <identifier> <identifiersep> <identifier> ) throws exception { \n \t2 org . apache . <identifier> . <identifier> . <identifier> . <identifier> . source source = ( org . apache . <identifier> . <identifier> . <identifier> . <identifier> . source ) <identifier> <identifiersep> <identifier> . get <identifiersep> remote <identifiersep> source ( ) ; \n \t2 consumer <identifiersep> info consumer <identifiersep> info = new consumer <identifiersep> info ( get <identifiersep> next <identifiersep> consumer <identifiersep> id ( ) ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( this , <identifier> <identifiersep> <identifier> , consumer <identifiersep> info ) ; \n <ect>
\t1 assert <identifiersep> is <identifiersep> not <identifiersep> in <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> cache , key ) ; \n \t1 check <identifiersep> <identifier> check <identifiersep> <identifier> = new check <identifiersep> <identifier> ( ) ; \n \t1 state <identifiersep> <identifier> <identifiersep> lock lock = wait <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> lock ( <identifier> <identifiersep> <identifier> <identifiersep> cache , check <identifiersep> <identifier> ) ; \n \t1 try { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> event ( event <identifiersep> <identifier> . event <identifiersep> vm <identifiersep> snapshot <identifiersep> <identifier> <identifiersep> <identifier> , vm <identifiersep> snapshot , user <identifiersep> vm , <identifier> <identifiersep> <identifier> <identifiersep> size , <identifier> ) ; \n \t4 return true ; \n \t3 } else { \n \t4 string <identifier> <identifiersep> msg = ( answer == null ) ? null : answer . get <identifiersep> <identifier> ( ) ; \n <ect>
\t3 class <identifiersep> <identifier> class <identifiersep> <identifier> ) throws job <identifiersep> execution <identifiersep> exception { \n \t2 check <identifiersep> not <identifiersep> null ( job <identifiersep> manager <identifiersep> <identifier> , <string_literal> ) ; \n \t2 check <identifiersep> not <identifiersep> null ( job <identifiersep> <identifier> , <string_literal> ) ; \n \t2 check <identifiersep> not <identifiersep> null ( timeout , <string_literal> ) ; \n <ect>
\t3 db <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifier> = new db <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 <identifier> <identifiersep> db <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( service <identifiersep> instance . class , <identifier> <identifiersep> manager . get <identifiersep> <identifier> ( ) . get <identifiersep> service <identifiersep> <identifier> ( ) , <identifier> <identifiersep> list , <identifier> <identifiersep> <identifier> <identifiersep> mode , <identifier> ) ; \n \t3 in <identifiersep> <identifier> = <identifier> . create == 0 && <identifier> . delete == 0 ; \n \t2 } catch ( exception ex ) { \n <ect>
\t6 if ( <identifier> != null ) { \n \t7 <identifier> . execute ( <identifier> ) ; \n \t7 <identifier> . add ( <identifier> ) ; \n \t6 } else { \n <ect>
\t2 <identifier> exception as e : \n \t2 self . log . error ( <string_literal> + <identifier> . format <identifiersep> <identifier> ( ) ) \n \t2 <identifier> \n \t1 <identifier> message . name == <identifier> : \n <ect>
\t1 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t1 logger . info ( <string_literal> , user <identifiersep> name ) ; \n \t1 string user <identifiersep> <identifier> = <identifier> <identifiersep> configuration <identifiersep> service . check <identifiersep> user <identifiersep> attributes ( user <identifiersep> name , test <identifiersep> user <identifiersep> <identifier> , <identifier> <identifiersep> configuration ) ; \n \t1 <comment> \n <ect>
\t3 if ( ! filter . <identifier> ( table <identifiersep> name ) ) { \n \t4 log . info ( <string_literal> + table <identifiersep> name ) ; \n \t4 continue ; } \n \t3 table <identifiersep> <identifier> . add ( table <identifiersep> name ) ; } \n <ect>
\t2 return new <identifier> [ 0 ] ; } \n \t1 private static void log <identifiersep> <identifier> <identifiersep> <identifier> ( string type , <identifier> [ ] <identifier> ) { \n \t3 for ( <identifier> <identifier> : <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> query = query ; } \n \t1 try { \n \t2 query <identifiersep> object = <identifier> . from <identifiersep> xml ( <identifier> , <identifier> <identifiersep> query ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t6 <comment> true , \n \t6 <identifier> ) ; } \n \t3 catch ( <identifier> <identifiersep> failed <identifiersep> exception <identifier> ) \n \t3 { \n <ect>
\t2 if ( item . get <identifiersep> state ( ) instanceof <identifier> <identifiersep> <identifier> <identifiersep> type ) { \n \t3 return ; } \n \t2 <comment> \n \t2 if ( <identifier> == false ) { \n <ect>
\t2 response response = response <identifiersep> event . get <identifiersep> response ( ) ; \n \t2 c <identifiersep> <identifier> <identifiersep> header <identifier> = ( ( c <identifiersep> <identifier> <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> <identifier> <identifiersep> header . name ) ) ; \n \t2 if ( <identifier> == null ) \n \t2 { \n <ect>
\t7 key = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> bean . get <identifiersep> <identifier> <identifiersep> storage <identifiersep> key ( \n \t8 data . get <identifiersep> <identifier> <identifiersep> storage <identifiersep> <identifier> ( ) , \n \t8 <identifier> <identifiersep> type ) ; \n \t6 } catch ( exception e ) { \n <ect>
<comment> \n \t1 public void delete <identifiersep> group ( string group <identifiersep> id ) { \n \t2 try { \n <ect>
\t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; } } \n \t1 @ <identifier> \n \t1 public void set <identifiersep> properties ( properties p ) { \n <ect>
\t4 return ( <identifier> ) <identifier> . new <identifiersep> instance ( <identifier> <identifiersep> values ) ; \n \t3 } catch ( illegal <identifiersep> argument <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception | <identifier> <identifiersep> exception | <identifier> <identifiersep> target <identifiersep> exception | security <identifiersep> exception e ) { \n \t4 log . error ( this , <string_literal> + class <identifiersep> name + <string_literal> + e . get <identifiersep> message ( ) , e ) ; \n \t3 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception ex ) { \n <ect>
\t1 } else { \n \t1 log . warn ( <string_literal> + <identifier> . get <identifiersep> snapshot <identifiersep> id ( ) + <string_literal> + snapshot <identifiersep> id ) ; \n \t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> . get <identifiersep> snapshot <identifiersep> id ( ) + <string_literal> + snapshot <identifiersep> id ) ; } } \n private void <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( snapshot <identifiersep> info <identifier> , snapshot <identifiersep> info <identifier> <identifiersep> <identifier> ) throws exception { \n <ect>
\t1 log . info ( <string_literal> , <identifier> ) ; } \n \t1 try { \n \t1 log <identifiersep> thread . <identifier> ( <number_literal> ) ; \n \t1 } catch ( interrupted <identifiersep> exception <identifier> ) { \n <ect>
\t3 long value = data <identifiersep> <identifier> . from <identifiersep> long ( data , 0 , <number_literal> ) ; \n \t3 if ( <identifier> != null ) { \n \t4 <identifier> . <identifier> ( length , value ) ; \n \t3 } else { \n <ect>
\t2 <identifier> client <identifiersep> <identifier> = null ; \n \t2 boolean has <identifiersep> <identifier> <identifiersep> <identifier> = false ; \n \t2 for ( int i = <identifier> . length - 1 ; i >= 0 ; i -- ) { \n \t3 final <identifier> <identifier> = <identifier> [ i ] ; \n <ect>
\t4 if ( <identifier> <identifiersep> type . get <identifiersep> <identifier> ( ) . to <identifiersep> <identifier> <identifiersep> case ( ) . index <identifiersep> of ( <identifier> <identifiersep> type <identifiersep> name . to <identifiersep> <identifier> <identifiersep> case ( ) ) != - 1 ) \n \t5 return <identifier> <identifiersep> type . get <identifiersep> id ( ) ; } \n \t3 return null ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( set <identifiersep> <identifier> <identifiersep> attribute ( <identifier> ) ) \n \t4 <identifier> . add ( <identifier> ) ; \n \t3 else { \n <ect>
\t1 server <identifiersep> version = <identifier> . <identifier> <identifiersep> <identifier> ( <string_literal> ) . next ( ) ; \n \t1 <identifier> . close ( ) ; } \n private void get <identifiersep> <identifier> <identifiersep> action <identifiersep> <identifier> ( file <identifier> <identifiersep> action <identifiersep> <identifier> <identifiersep> root ) throws <identifier> <identifiersep> exception , <identifier> <identifiersep> exception { \n \t1 if ( <identifier> <identifiersep> action <identifiersep> <identifier> <identifiersep> root != null ) { \n <ect>
\t3 <comment> \n \t3 builder . set <identifiersep> command <identifiersep> factory ( new <identifier> <identifiersep> command <identifiersep> factory ( ) ) ; \n \t3 return builder . build ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 <comment> \n \t1 <identifier> <identifier> = function <identifiersep> <identifier> \n \t1 if ( <identifier> . is <identifiersep> <identifier> ) \n \t1 native <identifiersep> <identifier> += <string_literal> + <identifier> . get \n <ect>
\t3 final <identifier> <identifiersep> <identifier> <identifiersep> metadata <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> metadata <identifiersep> <identifier> ( ) ; \n \t3 final <identifier> metadata = <identifier> . <identifier> <identifiersep> metadata <identifiersep> <identifier> ( <identifier> <identifiersep> properties ) ; \n \t3 out . write ( <identifier> . node <identifiersep> to <identifiersep> string ( metadata ) ) ; \n \t2 } catch ( final exception ex ) { \n <ect>
\t1 <identifier> <identifier> <identifiersep> <identifier> = to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , host <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t1 <identifier> <identifier> <identifiersep> c = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ( <identifier> <identifiersep> a , <identifier> <identifiersep> <identifier> ) ) \n \t1 <identifier> <identifier> <identifiersep> c = from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> c ) \n \t1 <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> \n <ect>
<comment> \n \t2 @ <identifier> \n \t2 public void <identifier> <identifiersep> meta ( meta <identifiersep> class <identifiersep> <identifier> <identifier> ) { \n \t3 if ( <identifier> == null ) return ; \n <ect>
\t2 cluster <identifiersep> state = service . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , routing <identifiersep> nodes . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 return <identifier> <identifiersep> <identifier> <identifiersep> shards <identifiersep> <identifier> <identifiersep> no <identifiersep> <identifier> ( cluster <identifiersep> state , service ) ; } \n \t1 private cluster <identifiersep> state remove <identifiersep> nodes ( cluster <identifiersep> state cluster <identifiersep> state , <identifier> <identifiersep> service service , int num <identifiersep> nodes ) { \n <ect>
\t5 } else if ( <identifier> . is <identifiersep> success ( ) ) { \n \t6 if ( success ) { \n \t7 logger . debug ( <string_literal> , type ) ; \n \t6 } else { \n <ect>
\t1 check <identifiersep> argument ( ! file . is <identifiersep> directory ( ) ) ; \n \t1 check <identifiersep> argument ( file . length ( ) > 0 ) ; \n \t1 <identifier> <identifiersep> file = new <identifier> <identifiersep> file ( file ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t4 byte [ ] <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( this . <identifier> ( ) ) ; \n \t4 byte [ ] <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> content ( ) ) ; \n \t4 if ( log . is <identifiersep> <identifier> ( level . info ) ) { \n \t5 log . info ( <string_literal> + name + <string_literal> + <identifier> <identifiersep> info . get <identifiersep> <identifier> ( ) + <string_literal> + data <identifiersep> utils . <identifier> <identifiersep> bytes ( <identifier> ) + <string_literal> + data <identifiersep> utils . <identifier> <identifiersep> bytes ( <identifier> ) ) ; \n <ect>
\t3 return vm <identifiersep> <identifier> ; } \n \t2 try { \n \t3 <identifier> = conn . list <identifiersep> <identifier> ( ) ; \n \t2 } catch ( final <identifier> <identifiersep> exception e ) { \n <ect>
\t1 public string to <identifiersep> <identifier> <identifiersep> value ( type type , string <identifier> <identifiersep> id ) { \n \t2 <identifier> <identifier> ; \n \t2 int <identifier> <identifiersep> number = get <identifiersep> <identifier> <identifiersep> number ( <identifier> <identifiersep> id ) ; \n \t2 if ( <identifier> <identifiersep> number == - 1 ) { \n <ect>
\t1 @ <identifier> \n \t1 public string get <identifiersep> <identifier> <identifiersep> uri ( ) { \n \t2 string uri = ( string ) get <identifiersep> thread <identifiersep> local <identifiersep> request ( ) . get <identifiersep> session ( ) . get <identifiersep> attribute ( <string_literal> ) ; \n \t2 if ( uri != null ) { \n <ect>
\t1 private x <identifiersep> path <identifiersep> <identifier> ( ) { <comment> \n \t2 super ( ) ; } \n \t1 private static x <identifiersep> path <identifiersep> file <identifiersep> <identifier> <identifier> ( string file , string <identifier> <identifiersep> string ) { \n \t2 string <identifier> = thread . current <identifiersep> thread ( ) . get <identifiersep> name ( ) ; \n <ect>
\t5 try { \n \t6 <comment> \n \t6 log . debug ( <string_literal> + thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) ) ; \n \t6 thread . current <identifiersep> thread ( ) . set <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> <identifier> ( ) ) ; \n <ect>
\t4 pool <identifiersep> <identifier> . add ( host ) ; \n \t3 } catch ( exception e ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + host + <string_literal> + <identifier> <identifiersep> data <identifiersep> store <identifiersep> info , e ) ; } } \n \t2 if ( pool <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t5 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n \t5 for ( string <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t6 <identifier> <identifiersep> cluster <identifiersep> state . add <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> ) ; } } \n \t3 } else { \n <ect>
\t3 try { \n \t4 <identifier> . cluster <identifiersep> <identifier> ( event ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 file <identifier> = context . get <identifiersep> dir ( <string_literal> , context . mode <identifiersep> private ) ; \n \t1 queue <identifiersep> file queue <identifiersep> file = create <identifiersep> queue <identifiersep> file ( <identifier> , <identifier> ) ; \n \t1 <identifier> <identifiersep> queue = new <identifier> <identifiersep> queue . <identifier> <identifiersep> queue ( queue <identifiersep> file ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 <comment> \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> dao . <identifier> ( <identifier> . get <identifiersep> id ( ) ) ; \n \t5 <comment> \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> ( load <identifiersep> <identifier> <identifiersep> ip <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; \n <ect>
\t4 <identifier> . set <identifiersep> string ( 1 , db <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ) ; \n \t4 <identifier> . execute <identifiersep> update ( ) ; \n \t4 s <identifiersep> logger . info ( <string_literal> ) ; \n \t3 } catch ( sql <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void handle <identifiersep> application <identifiersep> command <identifiersep> request ( <identifier> <identifiersep> message <identifier> <identifiersep> message , int <identifier> , int endpoint ) { \n <ect>
\t4 <identifier> <identifiersep> check <identifiersep> <identifier> = integer . parse <identifiersep> int ( ( string ) config . get ( <string_literal> ) ) ; \n \t4 logger . info ( <string_literal> , <identifier> <identifiersep> check <identifiersep> <identifier> ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n \t4 <identifier> <identifiersep> check <identifiersep> <identifier> = null ; \n <ect>
<comment> \n \t1 public static void set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n <ect>
\t1 builder . user <identifiersep> metadata ( metadata ) ; \n \t1 try { \n \t2 return builder . build ( ) ; \n \t1 } catch ( null <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t2 logger . info ( <string_literal> + entry . get <identifiersep> key ( ) ) ; \n \t2 <identifier> . <identifier> ( entry . get <identifiersep> value ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 } else { \n \t4 <comment> \n \t4 return <identifier> <identifiersep> conn . get <identifiersep> pool ( ) + <identifier> <identifiersep> <identifier> <identifiersep> info . pool <identifiersep> <identifier> <identifiersep> <identifier> + <identifier> <identifiersep> name ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . delete <identifiersep> queue ( <identifier> . get <identifiersep> name ( ) ) ; \n \t2 <identifier> . <identifier> <identifiersep> queue ( <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) throws exception { \n <ect>
\t5 . execute ( ) ; \n \t2 } catch ( <identifier> <identifiersep> json <identifiersep> response <identifiersep> exception e ) { \n \t3 <comment> \n \t3 if ( <number_literal> == e . get <identifiersep> status <identifiersep> code ( ) ) { \n <ect>
\t2 log . info ( <string_literal> + \n \t3 <string_literal> + input . get <identifiersep> short <identifiersep> <identifier> ( ) ) ; \n \t2 not <identifiersep> <identifier> <identifiersep> list . add ( input ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t1 } else if ( <identifier> <identifiersep> <identifier> . size ( ) == 0 ) { \n \t2 return ; } \n \t1 final string instance <identifiersep> ip = <identifier> <identifiersep> <identifier> . get ( 0 ) ; \n \t1 if ( instance <identifiersep> ip == null || instance <identifiersep> ip . length ( ) < = 0 ) { \n <ect>
\t2 <identifier> = ( <identifier> <identifiersep> array < <identifier> . <identifier> . test . <identifier> . <identifier> <identifiersep> entity > ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> array <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> array ( <identifier> , <identifier> <identifiersep> <identifier> ) ; } } \n \t1 return <identifier> ; } \n public void add <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . test . <identifier> . <identifier> <identifiersep> entity object ) { \n <ect>
\t3 s <identifiersep> logger . info ( <string_literal> + cmd . get <identifiersep> <identifier> <identifiersep> num ( ) + <string_literal> ) ; \n \t3 update <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> = true ; \n \t3 action = <string_literal> ; \n \t3 <identifier> = <string_literal> ; } \n <ect>
\t5 file . delete <identifiersep> on <identifiersep> <identifier> ( ) ; \n \t5 file dir = new file ( directory <identifiersep> path ) ; \n \t5 dir . delete <identifiersep> on <identifiersep> <identifier> ( ) ; \n \t4 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t4 try { \n \t5 ( ( <identifier> ) <identifier> <identifiersep> manager ) . stop ( ) ; \n \t5 ( ( <identifier> ) <identifier> <identifiersep> manager ) . <identifier> ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> state ( <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> <identifier> . state . add ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . update ( <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t2 try { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . add ( url ) ; } } \n \t4 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> . length ; i ++ ) { \n \t5 if ( ! <identifier> <identifiersep> <identifier> [ i ] ) { \n <ect>
\t3 for ( string name : <identifier> ) { \n \t4 if ( name . <identifier> ( ) . length ( ) != 0 ) <identifier> <identifiersep> <identifier> . add ( name . <identifier> ( ) ) ; } \n \t3 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) return new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 if ( root <identifiersep> count > 0 && <identifier> <identifiersep> <identifier> ( ) ) \n \t5 log . debug ( <string_literal> ) ; \n \t4 if ( count + root <identifiersep> count == 0 && <identifier> <identifiersep> <identifier> ( ) ) { \n \t5 set < t <identifiersep> server <identifiersep> instance > current <identifiersep> <identifier> = <identifier> <identifiersep> set . get <identifiersep> current <identifiersep> <identifier> ( ) ; \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 set <identifiersep> response <identifiersep> object ( response ) ; \n \t3 } else { \n \t4 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . <identifier> <identifiersep> error , <string_literal> ) ; } \n \t2 } catch ( resource <identifiersep> in <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + provider . get <identifiersep> provider <identifiersep> name ( ) + <string_literal> + provider . get <identifiersep> id ( ) , e ) ; \n \t4 return false ; \n \t3 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t2 success = <identifier> . <identifier> ( path , <identifier> <identifiersep> path ) ; \n \t2 break ; } \n \t2 case <identifier> : { \n <ect>
\t2 try ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = response . get <identifiersep> <identifier> ( ) ) { \n \t3 response . set <identifiersep> status ( status ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( text ) ; \n \t2 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t1 client . <identifier> ( ) ; \n \t1 found = client . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> cluster <identifiersep> name ( ) != null ; \n \t1 client . close ( ) ; \n \t1 } catch ( <identifier> <identifiersep> transport <identifiersep> exception <identifier> ) { \n <ect>
\t5 thread . <identifier> ( <number_literal> ) ; } } \n \t3 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t4 log . warn ( <string_literal> , <identifier> . get <identifiersep> message ( ) , <identifier> ) ; } \n \t3 catch ( interrupted <identifiersep> exception ex ) { \n <ect>
\t4 string name = <identifier> . get <identifiersep> key ( ) ; \n \t4 string [ ] <identifier> <identifiersep> name = name . <identifier> ( <string_literal> ) ; \n \t4 string <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> name ) ; \n \t4 if ( ! <identifier> . get <identifiersep> value ( ) . contains <identifiersep> key ( <identifier> ) ) { \n <ect>
\t3 <identifier> <identifier> = <identifier> . <identifier> ( message ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; } \n \t2 catch ( throwable e ) \n \t2 { \n <ect>
\t2 for ( <identifier> <identifiersep> api <identifiersep> <identifier> <identifier> <identifiersep> manager : <identifier> ) { \n \t3 if ( <identifier> <identifiersep> manager != null && <identifier> <identifiersep> manager instanceof <identifier> <identifiersep> manager ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager = ( <identifier> <identifiersep> manager ) <identifier> <identifiersep> manager ; } } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager == null ) { \n <ect>
\t1 @ <identifier> \n \t1 void handle <identifiersep> event ( <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class <identifiersep> value <identifiersep> event event , item item , map < string , string > <identifier> ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> state <identifiersep> <identifier> < ? , ? > <identifier> = this . get <identifiersep> state <identifiersep> <identifier> ( item , event . get <identifiersep> value ( ) ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 channel <identifiersep> <identifier> . on <identifiersep> success ( c ) ; } \n \t1 else \n \t1 { \n \t2 throwable <identifier> = channel <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t2 while ( ! <identifier> . get ( ) ) { \n \t3 try { \n \t4 if ( <identifier> > 0 ) { \n \t5 time <identifiersep> unit unit = get <identifiersep> time <identifiersep> unit ( ) ; \n <ect>
\t2 object client <identifiersep> <identifier> <identifiersep> config <identifiersep> value = <identifier> <identifiersep> map <identifiersep> entry . get <identifiersep> value ( ) ; \n \t2 if ( <identifier> <identifiersep> client <identifiersep> property <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> config <identifiersep> key ( client <identifiersep> <identifier> <identifiersep> config <identifiersep> key ) ) \n \t2 { \n \t2 <identifier> <identifiersep> client <identifiersep> config <identifiersep> for <identifiersep> <identifier> <identifiersep> service . put ( client <identifiersep> <identifier> <identifiersep> config <identifiersep> key , client <identifiersep> <identifier> <identifiersep> config <identifiersep> value ) ; \n <ect>
\t5 data <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception : : class . java ) \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> exception != null ) { \n \t4 response . <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> message ( <identifier> <identifiersep> configuration . get <identifiersep> default <identifiersep> <identifier> ( ) , \n \t6 <identifier> <identifiersep> <identifier> . error <identifiersep> user <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message ) ) \n <ect>
\t4 if ( answer . <identifier> <identifiersep> <identifier> ( ) ) { \n \t5 throw new connection <identifiersep> exception ( false , <string_literal> ) ; } \n \t4 return ; \n \t3 } else { \n <ect>
\t4 <identifier> ++ ; \n \t4 if ( ! find <identifiersep> in <identifiersep> list ( entry . get <identifiersep> key ( ) , ( list < <identifier> <identifiersep> entity > ) list ) ) { \n \t5 <identifier> ( string . format ( <string_literal> , entry . get <identifiersep> key ( ) ) ) ; } } } \n \t2 assert <identifiersep> equals ( <identifier> , list . size ( ) ) ; \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> ) { \n \t2 <comment> \n \t2 connection . set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; } \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> no = integer . parse <identifiersep> int ( <identifier> <identifiersep> num ) ; \n \t5 set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 try { \n \t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> . port <identifiersep> <identifier> + <string_literal> + <identifier> . static <identifiersep> <identifier> + <string_literal> + ip <identifiersep> id + <string_literal> ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> and <identifiersep> static <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> ip ( ip <identifiersep> id , user <identifiersep> id , <identifier> ) ) { \n <ect>
\t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , true , false ) ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> ) ; \n \t4 success = false ; } \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 final network <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> model . get <identifiersep> network ( <identifier> . get <identifiersep> network <identifiersep> id ( ) ) ; \n \t3 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) == <identifier> <identifiersep> type . <identifier> ) { \n \t4 <identifier> <identifiersep> ip <identifiersep> address = <identifier> . get <identifiersep> i <identifiersep> <identifier> ( ) ; } } \n \t2 if ( <identifier> <identifiersep> ip <identifiersep> address == null ) { \n <ect>
\t5 . <identifier> <identifiersep> <identifier> ( <string_literal> ) . get ( ) ; \n \t3 assert . assert <identifiersep> equals ( <number_literal> , response . get <identifiersep> status ( ) ) ; \n \t3 string <identifier> = response . get <identifiersep> header <identifiersep> string ( http <identifiersep> header <identifiersep> <identifier> . <identifier> ) ; \n \t3 assert . assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n <ect>
\t2 <comment> \n \t2 final runtime runtime = runtime . get <identifiersep> runtime ( ) ; \n \t2 final long max \t2 = runtime . max <identifiersep> <identifier> ( ) / <number_literal> / <number_literal> / <number_literal> ; \n \t2 final int <identifier> = runtime . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public int get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cache <identifiersep> size ( ) { \n <ect>
\t3 return null ; } \n \t2 final map < string , <identifier> <identifiersep> authentication <identifiersep> provider > provider <identifiersep> map = \n \t4 <identifier> <identifiersep> authentication <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> authentication <identifiersep> <identifier> ( this . application <identifiersep> context ) ; \n \t2 if ( provider <identifiersep> map == null || provider <identifiersep> map . is <identifiersep> empty ( ) ) { \n <ect>
\t3 thread <identifiersep> pool . shutdown ( ) ; \n \t3 thread . <identifier> ( thread <identifiersep> target <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ) ; } \n \t2 <comment> \n \t2 thread <identifiersep> pool . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t3 if ( vm <identifiersep> instance . get <identifiersep> state ( ) == state . <identifier> ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + vm <identifiersep> instance + <string_literal> ) ; \n \t4 return true ; } \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( user <identifiersep> id , vm <identifiersep> id ) == null ) { \n <ect>
\t2 if ( m <identifiersep> id == null ) { \n \t2 o <identifiersep> <identifier> <identifiersep> server <identifiersep> log . warn ( this , node <identifiersep> name , null , <identifier> . <identifier> , <string_literal> , m <identifiersep> name ) ; \n \t2 continue ; \n \t2 } else if ( m <identifiersep> id < 0 ) { \n <ect>
\t4 this . logger . info ( <string_literal> , e ) ; } \n \t3 try { \n \t4 <identifier> . put ( <identifier> <identifiersep> <identifier> . <identifier> , <identifier> <identifiersep> message . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t3 catch ( exception e ) { \n <ect>
\t3 assert . assert <identifiersep> array <identifiersep> equals ( <identifier> . public <identifiersep> key ( ) . get <identifiersep> <identifier> ( ) , <identifier> . public <identifiersep> key ( ) . get <identifiersep> <identifier> ( ) ) ; \n \t2 } else { \n \t3 assert . assert <identifiersep> equals ( <identifier> . public <identifiersep> key ( ) , <identifier> . public <identifiersep> key ( ) ) ; } \n \t2 if ( null != <identifier> <identifiersep> key ) { \n <ect>
\t3 if ( <identifier> <identifiersep> set . contains ( query <identifiersep> name ) ) { \n \t4 continue ; } \n \t3 string sql = get <identifiersep> text <identifiersep> from <identifiersep> file ( sql <identifiersep> file ) ; \n \t3 <comment> \n <ect>
\t2 for ( index <identifiersep> event <identifiersep> listener listener : <identifier> ) { \n \t3 try { \n \t4 listener . <identifier> <identifiersep> index <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , index <identifiersep> <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
<number_literal> final http <identifiersep> <identifier> <identifiersep> request request ) throws exception { \n \t2 <comment> \n \t2 final string provider <identifiersep> id = <identifier> <identifiersep> utils . <identifier> <identifiersep> get <identifiersep> <identifier> ( request , <identifier> <identifiersep> id <identifiersep> p <identifiersep> <identifier> . provider <identifiersep> id ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( provider <identifiersep> id ) ) { \n <ect>
\t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t3 command . add ( <string_literal> + <identifier> ) ; \n \t3 command . add ( <string_literal> + password , <identifier> <identifiersep> type . password ) ; \n \t3 final string result = command . execute ( ) ; \n \t3 if ( result != null ) { \n <ect>
\t2 log . debug ( <string_literal> + import <identifiersep> <identifier> ) ; } \n \t2 <identifier> . add ( <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . execute ( ) ; \n <ect>
\t7 <string_literal> ) ; } } \n \t3 try { \n \t4 <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 file . <identifier> <identifiersep> system <identifiersep> properties <identifiersep> <identifier> ( ) ; \n \t3 file . set <identifiersep> property ( <identifier> <identifiersep> <identifier> . key ( file . class , <string_literal> ) , size ) ; \n \t2 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 throw new command <identifiersep> exception ( e ) ; } \n \t2 for ( int i = 0 ; i < <identifier> . size ( ) ; i ++ ) { \n \t3 if ( ! nodes <identifiersep> to <identifiersep> <identifier> . contains ( <identifier> . get ( i ) . get <identifiersep> name ( ) ) ) { \n \t4 store . delete <identifiersep> action ( <identifier> . get ( i ) . get <identifiersep> id ( ) ) ; \n <ect>
\t3 <comment> \n \t3 boolean <identifier> <identifiersep> <identifier> = false ; \n \t3 try { \n \t4 for ( string <identifier> : <identifier> . <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 public static class <identifier> <identifiersep> xml <identifiersep> <identifier> implements <identifier> { \n \t2 public void process ( exchange exchange ) { \n \t3 object input = exchange . get <identifiersep> in ( ) . get <identifiersep> body ( ) ; \n \t3 if ( input instanceof x <identifiersep> <identifier> <identifiersep> response ) { \n <ect>
\t4 } else { \n \t5 try { \n \t6 <identifier> . <identifier> <identifiersep> <identifier> ( new class [ ] { c } ) ; \n \t5 } catch ( throwable e ) { \n <ect>
\t5 string <identifier> <identifiersep> name = <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id + <string_literal> ; \n \t5 try { \n \t6 <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> . name ( ) ; \n \t5 } catch ( throwable t ) { \n <ect>
\t2 <comment> \n \t2 if ( <identifier> != null ) { \n \t3 <identifier> <identifiersep> location . <identifier> ( ' # ' ) . <identifier> ( <identifier> ) ; } \n \t2 final <identifiersep> location = response . <identifier> <identifiersep> <identifier> <identifiersep> url ( <identifier> <identifiersep> location . to <identifiersep> string ( ) ) ; \n <ect>
\t3 error <identifiersep> <identifier> error <identifiersep> <identifier> = new error <identifiersep> <identifier> ( ) ; \n \t3 if ( root <identifiersep> <identifier> == null ) \n \t3 { \n \t4 root <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> root <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> <identifiersep> root <identifiersep> <identifier> ( ) ) ; } \n <ect>
\t2 logger log = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) ; \n \t2 log . trace ( <string_literal> ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n <ect>
\t4 connection <identifier> <identifiersep> conn = null ; \n \t4 session <identifier> <identifiersep> session = null ; \n \t4 try { \n <ect>
\t8 <string_literal> \n \t10 + <string_literal> , \n \t8 <identifier> . get ( <string_literal> ) , <identifier> . get ( <string_literal> ) ) ; } } \n \t3 } else { \n <ect>
\t6 <identifier> <identifiersep> job <identifiersep> vo job = <identifier> <identifiersep> job <identifiersep> dao . find <identifiersep> by <identifiersep> id ( job <identifiersep> id ) ; \n \t6 if ( job != null && ( job . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) & <identifier> <identifiersep> job . <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) != 0 ) \n \t7 <identifier> <identifiersep> execution ( job , false ) ; } \n \t4 } catch ( throwable e ) { \n <ect>
\t2 if ( result . equals ( <string_literal> ) ) { \n \t3 <identifier> <identifiersep> context . wait <identifiersep> for <identifiersep> task <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> task ) ; \n \t3 return true ; \n \t2 } else { \n <ect>
\t1 } ; \n \t1 try { \n \t1 <identifier> . as <identifiersep> transaction ( vm <identifiersep> instance . class , <identifier> <identifiersep> name ) . <identifier> ( this . get <identifiersep> request ( ) . get <identifiersep> instance <identifiersep> id ( ) ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception <identifier> ) { \n <ect>
\t7 string <identifier> = line . <identifier> ( 0 , <identifier> ) ; \n \t7 <identifier> . put ( name , <identifier> ) ; } \n \t6 line = <identifier> . read <identifiersep> line ( ) ; } } } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 i <identifiersep> job job <identifiersep> from <identifiersep> query <identifiersep> data = \n \t6 job <identifiersep> config <identifiersep> manager . create <identifiersep> job <identifiersep> from <identifiersep> query <identifiersep> data ( job <identifiersep> id , job <identifiersep> config <identifiersep> manager . <identifier> <identifiersep> job <identifiersep> data ( job <identifiersep> id ) ) ; \n \t4 <identifier> . put ( job <identifiersep> id , job <identifiersep> from <identifiersep> query <identifiersep> data ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t4 continue ; } \n \t3 <identifier> <identifiersep> <identifier> . add ( new <identifier> <identifiersep> id <identifiersep> <identifier> ( <identifier> <identifiersep> id , <identifier> <identifiersep> id , <identifier> <identifiersep> id <identifiersep> <identifier> ) ) ; } \n \t2 return <identifier> <identifiersep> <identifier> ; } \n \t1 private static void <identifier> <identifiersep> <identifier> ( key <identifiersep> <identifier> local ) { \n <ect>
\t2 final map < string , object > principal <identifiersep> attributes = <identifier> <identifiersep> attributes <identifiersep> from <identifiersep> principal <identifiersep> attribute <identifiersep> <identifier> ( principal ) ; \n \t2 logger . debug ( <string_literal> , principal <identifiersep> attributes , principal . get <identifiersep> id ( ) ) ; \n \t2 logger . debug ( <string_literal> , get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , principal . get <identifiersep> id ( ) ) ; \n \t2 final map < string , object > policy <identifiersep> attributes = get <identifiersep> attributes <identifiersep> <identifier> ( principal , principal <identifiersep> attributes , registered <identifiersep> service ) ; \n <ect>
\t4 int <identifier> = - 1 ; \n \t4 try { \n \t5 <identifier> = integer . parse <identifiersep> int ( value <identifiersep> <identifier> ) ; \n \t4 } catch ( java . <identifier> . number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 log . debug ( config <identifiersep> info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> msg <identifiersep> <identifier> ) ) ; \n \t3 log . debug ( config <identifiersep> info ( <string_literal> , <identifier> <identifiersep> size <identifiersep> <identifier> ) ) ; \n \t3 log . debug ( config <identifiersep> info ( <string_literal> , conn <identifiersep> timeout ) ) ; \n \t3 log . debug ( config <identifiersep> info ( <string_literal> , max <identifiersep> conn <identifiersep> timeout ) ) ; \n <ect>
\t3 logger . debug ( <string_literal> , number <identifiersep> of <identifiersep> <identifier> ) ; \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> size ) ; \n \t3 byte <identifiersep> array <identifiersep> output <identifiersep> stream byte <identifiersep> stream = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; \n \t3 for ( int i = 0 ; i < number <identifiersep> of <identifiersep> <identifier> ; i ++ ) { \n <ect>
public void handle <identifiersep> error ( throwable ex ) { \n \t1 assert ex != null ; \n \t1 synchronized ( <identifier> <identifiersep> lock ) { \n \t1 current <identifiersep> exception = ex ; } \n <ect>
\t4 file <identifier> <identifiersep> <identifier> <identifiersep> dir = new file ( <identifier> , <identifier> <identifiersep> id ) ; \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> . delete <identifiersep> directory ( <identifier> <identifiersep> <identifier> <identifiersep> dir ) ; } \n \t4 catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( has <identifiersep> <identifier> ( ) ) { \n \t4 return get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( message ) ; } \n \t3 else { \n <ect>
\t4 object <identifiersep> files . put ( file <identifiersep> <identifier> , <identifier> <identifiersep> file ) ; } \n \t2 @ <identifier> \n \t2 public void <identifier> ( file <identifiersep> <identifier> file <identifiersep> <identifier> , node <identifiersep> table node <identifiersep> table ) { \n \t3 if ( <identifier> ) \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void set <identifiersep> max <identifiersep> connection <identifiersep> <identifier> ( long max <identifiersep> connection <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ) { \n <ect>
\t2 try { \n \t3 string snapshot <identifiersep> id = <identifier> . get <identifiersep> snapshot <identifiersep> id ( ) ; \n \t3 log . debug ( <string_literal> + snapshot <identifiersep> id + <string_literal> ) ; \n \t3 if ( <identifier> . get <identifiersep> is <identifiersep> <identifier> ( ) == null ) { <comment> \n <ect>
\t6 if ( msg == null ) { \n \t7 return ; } \n \t6 num <identifiersep> <identifier> ++ ; \n \t6 if ( num <identifiersep> <identifier> <identifier> <number_literal> == 0 ) { \n <ect>
\t7 write <identifiersep> <identifier> . state . get <identifiersep> channel ( ) . <identifier> ( write <identifiersep> <identifier> , <identifier> , write <identifiersep> <identifier> . state ) ; \n \t7 write <identifiersep> registered = true ; } \n \t5 } catch ( exception e ) { \n \t6 <comment> \n <ect>
\t3 } else { \n \t4 <identifier> . set <identifiersep> <identifier> ( <identifier> . <identifier> ) ; } \n \t3 <identifier> . <identifier> <identifiersep> line ( <identifier> <identifiersep> <identifier> , <identifier> - data , <identifier> <identifiersep> <identifier> , <identifier> - data - 1 ) ; \n <ect>
\t3 <comment> \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> list . size ( ) ; i ++ ) { \n \t4 if ( node >= 0 && get <identifiersep> node ( <identifier> <identifiersep> list . get ( i ) . <identifier> ) == node && ! <identifier> <identifiersep> list . get ( i ) . is <identifiersep> <identifier> ( ) ) { \n \t5 <comment> \n <ect>
\t2 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t1 method m = this . get <identifiersep> class ( ) . get <identifiersep> method ( <string_literal> + action <identifiersep> num ) ; \n \t1 return ( string ) m . <identifier> ( this ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t1 log . info ( <string_literal> , process <identifiersep> id . get <identifiersep> key ( ) ) ; \n \t1 if ( stop <identifiersep> count <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) == 0 && node <identifiersep> <identifier> . try <identifiersep> to <identifiersep> <identifier> <identifiersep> to ( node <identifiersep> <identifier> . state . <identifier> ) ) { \n \t1 if ( ! <identifier> <identifiersep> <identifier> . get ( ) && \n \t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> set ( true , false ) ) { \n <ect>
<comment> \n <comment> \n \t2 <comment> \n \t2 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> session ) { \n <ect>
\t3 string error <identifiersep> message ; \n \t3 try { \n \t4 error <identifiersep> message = response <identifiersep> to <identifiersep> error <identifiersep> message ( response ) ; \n \t3 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = null ; } \n \t1 data <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( remote <identifiersep> <identifier> <identifiersep> listener listener ) { \n \t2 this . listener = listener ; \n \t2 <identifier> <identifiersep> <identifier> = null ; \n <ect>
\t1 private static cache < string , map < long , long > > <identifier> <identifiersep> <identifier> <identifiersep> cache = cache <identifiersep> builder . new <identifiersep> builder ( ) \n \t3 . <identifier> <identifiersep> listener ( new <identifier> <identifiersep> listener < string , map < long , long > > ( ) { \n \t4 @ <identifier> \n \t4 public void on <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> < string , map < long , long > > <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> out <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t2 if ( ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) || ( <identifier> <identifiersep> out <identifiersep> <identifier> == null ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> port = integer . parse <identifiersep> int ( <identifier> [ 0 ] ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n \t4 <identifier> . log ( <string_literal> ) ; \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 string <identifier> , <identifier> , <identifier> = null ; \n \t2 if ( true ) { \n <ect>
\t1 public synchronized <identifiersep> <identifier> <identifiersep> connection ( remote <identifiersep> connection < t > <identifier> ) { \n \t2 this . <identifier> = <identifier> ; } \n \t1 public void <identifier> ( final t message ) { \n \t2 if ( ! ( message instanceof output <identifiersep> message ) ) { \n <ect>
\t1 ) { \n \t1 <identifier> <identifiersep> name <identifiersep> and <identifiersep> config <identifiersep> key <identifier> = parse <identifiersep> config <identifiersep> key ( key , config <identifiersep> <identifier> ) ; \n \t1 if ( <identifier> != null ) { \n \t2 string name = <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) . <identifier> ( ) ; \n <ect>
\t2 element <identifier> <identifiersep> file = <identifier> . get <identifiersep> <identifier> <identifiersep> or <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> file != null ) { \n \t3 <identifier> <identifiersep> id = <identifier> <identifiersep> file . get <identifiersep> attribute <identifiersep> value ( <string_literal> ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null && ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + account <identifiersep> id ) ; \n \t4 for ( <identifier> <identifiersep> resource <identifiersep> vo <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t5 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> . get <identifiersep> id ( ) ) ) { \n <ect>
\t3 logger . info ( <string_literal> + instance <identifiersep> location . get <identifiersep> url ( ) ) ; } \n \t2 logger . debug ( <string_literal> + <identifier> . get <identifiersep> user <identifiersep> location ( ) . get <identifiersep> url ( ) ) ; \n \t2 logger . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> location ( ) . get <identifiersep> url ( ) ) ; \n \t2 logger . debug ( <string_literal> + <identifier> . get <identifiersep> instance <identifiersep> location ( ) . get <identifiersep> url ( ) ) ; \n <ect>
\t2 if ( <identifier> ) { \n \t3 if ( <identifier> . get <identifiersep> <identifier> ( ) == null ) { \n \t3 <identifier> = <identifier> <identifiersep> file ( <identifier> , <identifier> , <identifier> , <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t3 if ( <identifier> . length ( ) < <identifier> . get <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 return ; } \n \t1 <identifier> [ <identifier> ] = value . get <identifiersep> string ( ) ; \n \t1 <identifier> <identifiersep> <identifier> [ <identifier> ] = value . get <identifiersep> <identifier> ( ) ; } \n \t1 if ( <identifier> <identifiersep> <identifier> [ 0 ] == - 1 ) { \n <ect>
\t2 log . info ( <string_literal> + <identifier> ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <identifier> . <identifier> <identifiersep> value + 1 , <identifier> ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = local <identifiersep> resource . <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> id ( <identifier> ) ; \n <ect>
\t6 } else { \n \t7 try { \n \t8 return <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> exception <identifiersep> class , <string_literal> , failure . get <identifiersep> message ( ) , failure ) ; \n \t7 } catch ( exception e ) { \n <ect>
\t5 } ; \n \t4 } ) ; \n \t3 } catch ( <identifier> <identifiersep> execution <identifiersep> exception ex ) { \n \t4 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> shutdown ( ) ) { \n <ect>
\t2 wait <identifiersep> for <identifiersep> <identifier> ( cluster <identifiersep> <identifier> <identifiersep> status . <identifier> ) ; \n \t2 cluster <identifiersep> state state = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> state ( ) . get ( ) . get <identifiersep> state ( ) ; \n \t2 for ( <identifier> <identifiersep> routing <identifier> : state . get <identifiersep> routing <identifiersep> table ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) ) { \n \t3 string node = state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <identifier> . current <identifiersep> node <identifiersep> id ( ) ) . node ( ) . get <identifiersep> name ( ) ; \n <ect>
\t4 ( <identifier> <identifiersep> <identifier> instanceof <identifier> ) ) { \n \t4 try { \n \t5 ( ( <identifier> ) <identifier> <identifiersep> <identifier> ) . stop ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 logger . error ( <string_literal> , e ) ; } \n \t3 try { \n \t4 remove <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> , <identifier> . key <identifiersep> set ( ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 protected object handle <identifiersep> get <identifiersep> object ( string key ) { \n \t2 try { \n \t3 return <identifier> . get <identifiersep> string ( key ) ; \n \t2 } catch ( <identifier> <identifiersep> resource <identifiersep> exception e ) { \n <ect>
\t6 . put ( <identifier> <identifiersep> <identifier> <identifiersep> index <identifiersep> store . index <identifiersep> check <identifiersep> index <identifiersep> on <identifiersep> close <identifiersep> <identifier> . get <identifiersep> key ( ) , false ) \n \t2 ) ) ; \n \t2 index <identifiersep> <identifier> <identifiersep> data ( index ) ; \n \t2 <identifier> <identifiersep> <identifier> ( index ) ; \n <ect>
\t5 } else if ( <identifier> instanceof query <identifiersep> <identifier> <identifiersep> interface ) { \n \t6 query <identifiersep> <identifier> <identifiersep> interface <identifier> = ( query <identifiersep> <identifier> <identifiersep> interface ) <identifier> ; \n \t6 <comment> \n \t5 } else { \n <ect>
\t2 security <identifiersep> context <identifiersep> <identifier> . get <identifiersep> context ( ) . set <identifiersep> authentication ( authentication ) ; \n \t2 request . get <identifiersep> session ( true ) . set <identifiersep> attribute ( <string_literal> , \n \t3 security <identifiersep> context <identifiersep> <identifier> . get <identifiersep> context ( ) ) ; \n \t2 request . set <identifiersep> attribute ( <string_literal> , true ) ; \n <ect>
\t3 try { \n \t3 if ( input . get <identifiersep> is <identifiersep> <identifier> ( ) != null && input . get <identifiersep> is <identifiersep> <identifier> ( ) ) { <comment> \n \t4 string <identifier> <identifiersep> <identifier> = null ; \n \t4 string connection <identifiersep> string = input . get <identifiersep> connection <identifiersep> string ( ) ; \n <ect>
\t4 new thread ( ( ) - > { \n \t5 try ( file <identifiersep> <identifier> <identifier> = new file <identifiersep> <identifier> ( new file ( file <identifiersep> utils . get <identifiersep> user <identifiersep> <identifier> ( ) , default <identifiersep> server <identifiersep> <identifier> . <identifier> <identifiersep> file ) , false ) ) { \n \t6 <identifier> . write ( <string_literal> + <identifier> <identifiersep> file <identifiersep> path ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t4 write <identifiersep> message ( <identifier> , <string_literal> , <identifier> . get <identifiersep> source <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) , \n \t5 <identifier> . get <identifiersep> message ( ) , <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t3 } catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t1 assert . assert <identifiersep> equals ( <string_literal> , <string_literal> , \n \t2 new string ( event . get <identifiersep> body ( ) ) ) ; \n \t1 transaction . <identifier> ( ) ; \n \t1 transaction . close ( ) ; \n <ect>
\t2 string <identifier> = system . get <identifiersep> property ( <string_literal> , null ) ; \n \t2 if ( <identifier> == null ) { \n \t3 debug <identifiersep> dir = null ; \n \t2 } else { \n <ect>
\t1 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> array ) ; } } \n public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n \t1 <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> list ( <identifier> <identifiersep> <identifier> ) ) ; } \n public void <identifier> <identifiersep> <identifier> ( collection < <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> <identifiersep> collection ) { \n <ect>
\t4 <identifier> <identifier> = new <identifier> ( <identifier> <identifiersep> context , this ) ; \n \t4 <identifier> . request <identifiersep> <identifier> ( ) ; \n \t4 return true ; \n \t3 } catch ( throwable t ) { \n <ect>
\t4 <identifier> < integer , integer > time <identifiersep> to <identifiersep> port = this . <identifier> <identifiersep> id <identifiersep> to <identifiersep> start <identifiersep> time <identifiersep> and <identifiersep> port . get ( <identifier> <identifiersep> id ) ; \n \t4 if ( time <identifiersep> to <identifiersep> port != null ) { \n \t5 local <identifiersep> <identifier> local <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get ( time <identifiersep> to <identifiersep> port . get <identifiersep> <identifier> ( ) ) ; \n \t5 if ( local <identifiersep> <identifier> == null ) { \n <ect>
\t1 if ( size <identifiersep> <identifier> < = 0 ) { \n \t2 all <identifiersep> file = false ; \n \t2 break ; } \n \t1 if ( <identifier> . is <identifiersep> dir ( ) ) { \n <ect>
\t3 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 } finally { \n \t4 try { socket . close ( ) ; } catch ( io <identifiersep> exception <identifier> ) { } } \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 m <identifiersep> <identifier> . set <identifiersep> value ( <identifier> <identifiersep> <identifier> . get <identifiersep> request <identifiersep> context ( ) . add <identifiersep> <identifier> <identifiersep> root ( start <identifiersep> <identifier> == null ? <string_literal> : start <identifiersep> <identifier> ) ) ; \n \t3 m <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> object ( <identifier> <identifiersep> <identifier> ) ; \n \t3 m <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> root <identifiersep> <identifier> ( true ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t7 if ( <string_literal> . equals <identifiersep> ignore <identifiersep> case ( <identifier> <identifiersep> <identifier> <identifiersep> string ) ) { \n \t8 try { \n \t9 <identifier> . <identifier> <identifiersep> size <identifiersep> <identifier> ( ( short ) current <identifiersep> <identifier> <identifiersep> number ) ; \n \t8 } catch ( exception ex ) { \n <ect>
\t1 <identifier> <identifiersep> store . set <identifiersep> conf ( conf ) ; \n \t1 configuration <identifier> <identifiersep> conf = this . conf ; \n \t1 this . conf = conf ; \n \t1 if ( <identifier> <identifiersep> <identifier> != null && conf != <identifier> <identifiersep> conf ) { \n <ect>
\t2 int current <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 int current <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 log . info ( <string_literal> + last <identifiersep> <identifier> ) ; \n \t2 log . info ( <string_literal> + last <identifiersep> <identifier> ) ; \n <ect>
\t2 boolean <identifier> <identifiersep> result = true ; \n \t2 try { \n \t3 <identifier> <identifiersep> result = shutdown <identifiersep> network <identifiersep> <identifier> ( network . get <identifiersep> id ( ) , context . get <identifiersep> account ( ) , context . get <identifiersep> <identifier> ( ) . get <identifiersep> id ( ) ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t2 logger . warn ( <string_literal> + <identifier> ) ; \n \t2 for ( int i = 0 ; i < <identifier> . <identifier> <identifiersep> map . size ( ) ; i ++ ) { \n \t3 int <identifier> = <identifier> . <identifier> <identifiersep> map . get ( i ) ; \n \t3 int <identifier> = <identifier> . <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> map . get ( i ) ; \n <ect>
\t2 try { \n \t3 for ( <identifier> < <identifier> > <identifier> <identifiersep> it = <identifier> . <identifier> ( ) ; <identifier> <identifiersep> it . has <identifiersep> next ( ) ; ) { \n \t4 count ++ ; \n \t4 <identifier> <identifier> = <identifier> <identifiersep> it . next ( ) ; \n <ect>
\t3 <identifier> <identifier> = new <identifier> ( ) ; \n \t3 <identifier> . set <identifiersep> content ( <identifier> <identifiersep> string . to <identifiersep> string ( ) ) ; \n \t3 <identifier> . set <identifiersep> type ( content <identifiersep> type . text ) ; \n \t3 entry . set <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t4 . set <identifiersep> type ( <string_literal> ) . set <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) . get ( ) ; \n \t2 assert <identifiersep> that ( put <identifiersep> <identifier> <identifiersep> response . is <identifiersep> <identifier> ( ) , equal <identifiersep> to ( true ) ) ; \n \t2 create <identifiersep> index ( <string_literal> , <string_literal> , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t1 public list < job <identifiersep> task <identifiersep> <identifier> <identifiersep> <identifier> > get <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> host ( host <identifiersep> state host , list < host <identifiersep> state > <identifier> ) { \n \t2 string host <identifiersep> id = host . get <identifiersep> host <identifiersep> <identifier> ( ) ; \n \t2 list < job <identifiersep> task <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> = new array <identifiersep> list < > ( ) ; \n \t2 if ( ( <identifier> == null ) || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t4 logger . info ( <string_literal> , job <identifiersep> id , job <identifiersep> name ) ; \n \t4 <identifier> <identifiersep> <identifier> ( ) ; } } } \n \t1 protected boolean should <identifiersep> <identifier> ( ) { \n \t2 if ( current <identifiersep> status . equals ( job <identifiersep> status . wait <identifiersep> <identifier> ) ) { \n <ect>
\t1 if ( event <identifiersep> <identifier> != null && event <identifiersep> <identifier> . length > 0 ) { \n \t1 <identifier> <identifier> = session . get <identifiersep> <identifier> ( ) ; \n \t1 <identifier> <identifiersep> manager manager = <identifier> . get <identifiersep> <identifier> <identifiersep> manager ( ) ; \n <ect>
\t5 try { \n \t6 <identifier> . <identifier> ( ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n \t6 <identifier> . <identifier> ( e ) ; } } \n <ect>
\t4 logger . debug ( <string_literal> , entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; } \n \t3 <identifier> <identifiersep> values ( all <identifiersep> data ) ; \n \t3 return true ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } ; } \n \t1 protected <identifier> <identifiersep> <identifier> check <identifiersep> state <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifiersep> http <identifiersep> <identifier> . <identifier> state <identifiersep> <identifier> = get <identifiersep> <identifier> ( <identifier> . get <identifiersep> state <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 if ( state <identifiersep> <identifier> == null ) { \n <ect>
\t1 protected void <identifier> <identifiersep> error <identifiersep> handler ( throwable ex ) { \n \t2 if ( this . error <identifiersep> handler != null ) { \n \t3 this . error <identifiersep> handler . handle <identifiersep> error ( ex ) ; } \n <ect>
\t4 for ( security <identifiersep> group <identifiersep> vo security <identifiersep> group : <identifier> <identifiersep> <identifier> ) { \n \t5 <comment> \n \t5 security <identifiersep> group <identifiersep> vo <identifier> <identifiersep> lock = <identifier> <identifiersep> security <identifiersep> group <identifiersep> dao . lock <identifiersep> <identifier> ( security <identifiersep> group . get <identifiersep> id ( ) , false ) ; \n \t5 if ( <identifier> <identifiersep> lock == null ) { \n <ect>
\t4 log . debug ( <identifier> + <string_literal> + request . get <identifiersep> request <identifiersep> url ( ) ) ; } \n \t3 string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t3 new throwable ( <string_literal> ) . <identifier> <identifiersep> stack <identifiersep> trace ( new <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t3 string stack <identifiersep> trace = <identifier> . to <identifiersep> string ( ) ; \n <ect>
\t2 for ( index <identifiersep> event <identifiersep> listener listener : <identifier> ) { \n \t3 try { \n \t4 listener . <identifier> <identifiersep> index <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , index <identifiersep> <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 string <identifier> <identifiersep> string = <identifier> <identifiersep> wait ( ) ; \n \t2 if ( <identifier> <identifiersep> string != null ) { \n \t3 return get <identifiersep> <identifier> <identifiersep> status <identifiersep> from <identifiersep> string ( <identifier> <identifiersep> string ) ; \n \t2 } else { \n <ect>
\t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> ) { \n \t3 final file <identifier> = get <identifiersep> output <identifiersep> file ( this . output <identifiersep> <identifier> , <number_literal> , file <identifiersep> index ) ; \n \t3 <identifier> = new <identifier> <identifiersep> <identifier> ( io <identifiersep> <identifier> . <identifier> <identifiersep> file <identifiersep> for <identifiersep> <identifier> ( <identifier> ) ) ; \n <ect>
\t5 <identifier> <identifiersep> on <identifiersep> next <identifiersep> or <identifiersep> <identifier> <identifiersep> is <identifiersep> <identifier> = false ; \n \t5 <comment> \n \t5 next <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> num -= <identifier> <identifiersep> <identifier> ; } \n \t3 } catch ( throwable e ) { \n <ect>
\t6 if ( ! send <identifiersep> <identifier> <identifiersep> routing <identifiersep> policy <identifiersep> <identifier> <identifiersep> update ( cmd , id , <identifier> <identifiersep> name ) ) { \n \t7 s <identifiersep> logger . debug ( <string_literal> + id + \n \t9 <string_literal> ) ; } } } \n \t3 } catch ( exception e ) { \n <ect>
\t3 return null ; } \n \t2 final map < string , <identifier> <identifiersep> authentication <identifiersep> provider > provider <identifiersep> map = \n \t4 <identifier> <identifiersep> authentication <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> authentication <identifiersep> <identifier> ( this . application <identifiersep> context ) ; \n \t2 if ( provider <identifiersep> map == null || provider <identifiersep> map . is <identifiersep> empty ( ) ) { \n <ect>
\t2 { \n \t3 log . debug ( <string_literal> + <identifier> . get <identifiersep> id ( ) ) ; \n \t3 if ( <identifier> . get <identifiersep> id ( ) == <identifier> <identifiersep> id <identifiersep> to <identifiersep> remove ) \n \t3 { \n <ect>
\t1 m = new <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <identifier> ) ; \n \t1 m . put <identifiersep> delete ( <identifier> <identifiersep> <identifier> . <identifier> , new text ( table <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ) ; \n \t1 <identifier> . add <identifiersep> <identifier> ( m ) ; \n \t1 <identifier> . close ( ) ; \n <ect>
\t2 start <identifiersep> server <identifiersep> <identifier> <identifiersep> factory ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> server . start ( ) ; \n \t2 } catch ( <identifier> <identifiersep> server <identifiersep> exception e ) { \n <ect>
\t2 return new get <identifiersep> <identifier> <identifiersep> r <identifiersep> version <identifiersep> answer ( cmd , result . <identifier> ( ) , <identifier> [ 0 ] , <identifier> [ 1 ] ) ; } \n \t1 protected answer execute ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command cmd ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> <identifiersep> <identifier> . to <identifiersep> json ( cmd ) ) ; \n <ect>
\t3 assert ( <identifier> <identifiersep> <identifier> != null ) ; \n \t3 host <identifiersep> vo <identifier> <identifiersep> <identifier> <identifiersep> host = find <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> host <identifiersep> by <identifiersep> name ( <identifier> <identifiersep> <identifier> . get <identifiersep> host <identifiersep> name ( ) ) ; \n \t3 answer answer = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send ( <identifier> <identifiersep> <identifier> <identifiersep> host . get <identifiersep> id ( ) , cmd ) ; \n \t3 if ( answer == null || ! answer . get <identifiersep> result ( ) ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void start ( <identifier> <identifiersep> context <identifier> ) throws exception { \n \t2 context = <identifier> ; \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = integer . parse <identifiersep> int ( <identifier> <identifiersep> queue <identifiersep> <identifier> <identifiersep> string ) ; } \n \t2 this . num <identifiersep> <identifier> <identifiersep> <identifier> = num <identifiersep> <identifier> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t1 } else { \n \t2 this . num <identifiersep> <identifier> <identifiersep> <identifier> = num <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> conf ; \n <ect>
\t2 this . user = user <identifiersep> to <identifiersep> <identifier> ; \n \t2 <comment> \n \t2 set <identifiersep> user <identifiersep> location ( ) ; \n <ect>
\t3 try { \n \t4 <identifier> = exchange . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } catch ( exception ignore ) { } \n \t3 if ( <identifier> == null || <identifier> . length == 0 ) { \n <ect>
\t1 log . warn ( <string_literal> , \n \t2 cluster <identifiersep> name ) ; \n \t1 return <identifier> . empty <identifiersep> set ( ) ; } \n \t1 catch ( <identifier> <identifiersep> exception <identifier> <identifiersep> exception ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t1 public void set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> num ( int new <identifiersep> <identifier> ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> num = new <identifiersep> <identifier> ; } \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> num ( ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> num ++ ; \n <ect>
\t3 result . <identifier> = ( org . apache . <identifier> . <identifier> . client . <identifier> . thrift . thrift <identifiersep> not <identifiersep> <identifier> <identifiersep> service <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> is <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t4 this . <identifier> . <identifier> ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { } } \n \t2 @ <identifier> \n \t2 public void run ( ) { \n <ect>
\t5 case on <identifiersep> <identifier> <identifiersep> version <identifiersep> action . ignore : \n \t6 <comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( string <identifier> <identifiersep> path ) throws lock <identifiersep> exception , <identifier> <identifiersep> exception { \n <ect>
\t4 if ( ! <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> write <identifiersep> timeout ) ) { \n \t5 log . error ( <string_literal> , <identifier> <identifiersep> write <identifiersep> timeout ) ; \n \t5 return false ; } \n \t3 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t1 log . error ( <string_literal> ) \n \t1 throw ex \n \t1 } finally { \n \t1 new file ( <identifier> <identifiersep> <identifier> <identifiersep> file ) . delete ( ) } \n <ect>
\t1 final string key <identifiersep> name = string . format ( <string_literal> , account <identifiersep> id , <identifier> , <identifier> ) ; \n \t1 if ( this . <identifier> ( account <identifiersep> id , key <identifiersep> name , new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( <identifier> . to <identifiersep> string ( ) . get <identifiersep> bytes ( <string_literal> ) ) ) ) { \n \t2 log . debug ( string . format ( <string_literal> + account <identifiersep> id + <string_literal> ) ) ; \n \t1 } else { \n <ect>
\t1 private boolean <identifier> ( ) { \n \t2 try { \n \t3 client <identifiersep> socket = new socket ( host , <identifier> <identifiersep> port ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 <identifier> . <identifier> ( ' / ' ) ; \n \t5 <identifier> . <identifier> ( <identifier> ) ; \n \t5 <identifier> = <identifier> . to <identifiersep> string ( ) ; } } \n \t2 } else { \n <ect>
\t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> interface . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> interface . class ) ) ; \n <ect>
\t1 <identifier> <identifiersep> web <identifiersep> <identifier> . remove ( url , name ) ; } } \n public void set <identifiersep> <identifier> <identifiersep> context ( object <identifier> ) throws json <identifiersep> exception { \n \t1 if ( <identifier> <identifiersep> web <identifiersep> <identifier> == null ) { \n \t1 return ; } \n <ect>
\t4 m <identifiersep> <identifier> <identifiersep> job <identifiersep> dao . update ( job . get <identifiersep> id ( ) , job <identifiersep> for <identifiersep> update ) ; \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } catch ( exception db <identifiersep> ex ) { \n \t4 <identifier> . <identifier> ( ) ; \n <ect>
\t4 if ( <identifier> != 0 ) { \n \t5 log . warn ( command + <string_literal> , <identifier> , <identifier> . to <identifiersep> string ( ) ) ; } \n \t4 return <identifier> . to <identifiersep> string ( ) ; \n \t3 } catch ( throwable e ) { \n <ect>
\t2 try { \n \t3 final query query = new query ( ) ; \n \t3 query . add <identifiersep> <identifier> ( <identifier> . <identifier> ( <string_literal> ) . <identifier> ( on <identifiersep> or <identifiersep> <identifier> ) ) ; \n \t3 final write <identifiersep> result <identifier> = this . <identifier> <identifiersep> template . remove ( query , <identifier> <identifiersep> authentication <identifiersep> <identifier> <identifiersep> <identifier> . class , this . collection <identifiersep> name ) ; \n <ect>
\t7 try { \n \t8 while ( config <identifiersep> set . next ( ) ) { \n \t9 string name = config <identifiersep> set . get <identifiersep> string ( 1 ) ; \n \t9 string value = config <identifiersep> set . get <identifiersep> string ( <number_literal> ) ; \n <ect>
\t2 <identifier> . <identifier> ( new <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public void run ( ) { \n \t4 server server = new server ( config . get <identifiersep> status <identifiersep> server <identifiersep> port ( ) ) ; \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> type ( <identifier> <identifiersep> <identifier> <identifiersep> type . native ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> uri ( null ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> uri ( null ) ; \n <ect>
\t1 { \n \t2 sql <identifiersep> <identifier> <identifier> <identifiersep> id = <identifier> <identifiersep> <identifier> . get ( node ) ; \n \t2 if ( <identifier> <identifiersep> id == null ) \n \t2 { \n <ect>
\t3 request <identifiersep> token = <identifier> . get <identifiersep> o <identifiersep> <identifier> <identifiersep> request <identifiersep> token ( ) ; \n \t3 request . get <identifiersep> session ( ) . set <identifiersep> attribute ( <string_literal> , request <identifiersep> token ) ; \n \t3 <comment> \n \t3 string <identifier> <identifiersep> url = <identifier> . get <identifiersep> configuration ( ) . get <identifiersep> o <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url ( ) . <identifier> ( <string_literal> ) . <identifier> ( request <identifiersep> token . get <identifiersep> token ( ) ) ; \n <ect>
\t5 <identifier> <identifiersep> log . debug ( <string_literal> + t . get <identifiersep> <identifier> ( ) + <string_literal> + <identifier> + <string_literal> + ( <identifier> == <identifier> ) \n \t7 + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <string_literal> + <identifier> + <string_literal> ) ; \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t6 if ( <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> . size ( ) >= <number_literal> ) { \n \t7 logger . error ( <string_literal> + <identifier> . on ( <string_literal> ) . <identifier> ( <identifier> <identifiersep> <identifier> ) ) ; \n \t7 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; \n \t6 } else if ( <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 target <identifiersep> <identifier> . create ( <identifier> ) ; } \n \t3 catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n <ect>
\t1 if ( <identifier> <identifiersep> dir . exists ( ) ) { \n \t2 try { \n \t2 file <identifiersep> utils . delete <identifiersep> directory ( <identifier> <identifiersep> dir ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 public boolean exists ( ) { \n \t2 try { \n \t3 return ! get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t8 <identifier> <identifiersep> log . warn ( <string_literal> + <identifier> + <string_literal> + <identifier> ) ; \n \t7 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> ) ; } \n \t5 } catch ( data <identifiersep> format <identifiersep> exception <identifier> ) { } } } } \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 if ( c == ' \\ <identifier> ) <identifier> <identifiersep> <identifier> = true ; \n \t3 } else if ( c == ' \\ \\ ' && ! <identifier> ) { \n \t4 <identifier> = true ; \n \t3 } else if ( c == ' \\ \\ ' && <identifier> && <identifier> <identifiersep> <identifier> > 0 ) { \n <ect>
\t2 get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> output ( <string_literal> ) ) ; } \n @ test \n public void test <identifiersep> <identifier> ( ) { \n \t1 try { \n <ect>
\t5 } finally { \n \t6 <identifier> <identifiersep> lock . <identifier> ( ) ; \n \t6 <identifier> . close ( ) ; } } \n \t3 } catch ( exception e ) { \n <ect>
\t1 public synchronized void check <identifiersep> session ( long session <identifiersep> id , object <identifier> ) \n \t3 throws <identifier> <identifiersep> exception . session <identifiersep> <identifier> <identifiersep> exception , \n \t3 <identifier> <identifiersep> exception . session <identifiersep> <identifier> <identifiersep> exception , \n \t3 <identifier> <identifiersep> exception . <identifier> <identifiersep> session <identifiersep> exception { \n <ect>
\t2 if ( s <identifiersep> pool == null ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + id ) ; \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> + id ) ; } \n \t2 if ( s <identifiersep> pool . get <identifiersep> status ( ) != storage <identifiersep> pool <identifiersep> status . <identifier> ) { \n <ect>
public static void error ( final string <identifier> , final string message , final throwable error ) { \n \t1 string id = ( <identifier> == null ) ? <identifier> . get <identifiersep> instance ( ) . get <identifiersep> string ( <string_literal> ) : <identifier> ; <comment> \n \t1 if ( logger . log <identifiersep> level < = i <identifiersep> logger . error ) { \n \t1 if ( logger . version <identifiersep> <identifier> != null ) { \n <ect>
\t2 try { \n \t3 string type = config . get <identifiersep> type ( ) ; \n \t3 test <identifiersep> <identifier> <identifiersep> factory factory = <identifier> <identifiersep> <identifier> . get ( type ) ; \n \t3 if ( factory == null ) { \n <ect>
\t1 <identifier> . close ( ) \n \t1 end \n <identifier> org . apache . <identifier> . <identifier> . table <identifiersep> not <identifiersep> found <identifiersep> exception , \n \t1 org . apache . <identifier> . <identifier> . table <identifiersep> not <identifiersep> enabled <identifiersep> exception = > e \n <ect>
* public void run ( ) { \n * \t1 <identifier> <identifiersep> count . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n * \t1 in <identifiersep> <identifier> . remove ( name ) ; \n * \t1 last <identifiersep> <identifier> . set ( name ) ; \n <ect>
\t4 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 } ) ) ; \n \t3 return false ; \n \t2 } else { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public data <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t1 this . <identifier> <identifiersep> service = <identifier> <identifiersep> service ; } \n @ <identifier> \n public void run ( ) { \n \t1 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> properties . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> service ( ) && <identifier> . is <identifiersep> <identifier> ( ) && <identifier> . is <identifiersep> enabled <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) { \n <ect>
<comment> \n \t1 private void <identifier> <identifiersep> data ( ) throws grid <identifiersep> exception , <identifier> <identifiersep> exception { \n <ect>
\t3 <identifier> <identifiersep> files . delete <identifiersep> dir ( <identifier> <identifiersep> dir ) ; \n \t3 <identifier> <identifiersep> files . <identifier> <identifiersep> directory ( <identifier> <identifiersep> dir ) ; \n \t3 log . info ( <string_literal> , <identifier> <identifiersep> dir . get <identifiersep> path ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 string from = new string ( <identifier> ) ; \n \t3 assert . assert <identifiersep> equals ( error <identifiersep> msg , content , from ) ; } \n \t2 { \n \t3 string <identifier> = new <identifier> <identifiersep> builder ( ) . content <identifiersep> bytes ( content . get <identifiersep> bytes ( ) ) . <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( ( <identifier> <identifiersep> public <identifiersep> key ) key <identifiersep> <identifier> . get <identifiersep> public ( ) ) ; \n <ect>
\t8 <identifier> . add ( new <identifier> <identifiersep> stack ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( object . get ( <string_literal> ) , <identifier> ) , json <identifiersep> utils . get <identifiersep> int ( object , <string_literal> , 1 ) ) ) ; } \n \t6 ) ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> . put ( key , new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( key , <identifier> , <identifier> <identifiersep> set . <identifier> <identifiersep> of ( <identifier> ) , output ) ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n \t1 log . error ( <string_literal> + sql <identifiersep> e ) ; \n \t1 return null ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> <identifiersep> e ) { \n <ect>
\t1 <identifier> <identifiersep> utils . build <identifiersep> query <identifiersep> with <identifiersep> in <identifiersep> <identifier> ( conf , <identifier> , <identifier> , <identifier> , <identifier> , <string_literal> , false , false ) ; \n \t1 for ( string query : <identifier> ) { \n \t2 log . debug ( <string_literal> + query + <string_literal> ) ; \n \t2 int <identifier> = <identifier> . execute <identifiersep> update ( query ) ; \n <ect>
\t1 protected cluster <identifiersep> state <identifier> <identifiersep> <identifier> <identifiersep> shards <identifiersep> <identifier> <identifiersep> no <identifiersep> <identifier> ( cluster <identifiersep> state cluster <identifiersep> state , <identifier> <identifiersep> service service ) { \n \t2 cluster <identifiersep> state last <identifiersep> cluster <identifiersep> state ; \n \t2 do { \n \t3 last <identifiersep> cluster <identifiersep> state = cluster <identifiersep> state ; \n <ect>
\t2 long size = <number_literal> ; \t4 <comment> \n \t2 size += key . get <identifiersep> <identifier> ( ) ; \t2 <comment> \n \t2 size += value . get <identifiersep> <identifier> ( ) ; \t1 <comment> \n \t2 if ( size > integer . max <identifiersep> value ) { \n <ect>
\t3 <identifier> <identifiersep> shutdown shutdown <identifiersep> handle = get <identifiersep> process <identifiersep> handle ( <identifier> ) ; \n \t3 if ( shutdown <identifiersep> handle != null ) { \n \t4 shutdown <identifiersep> handle . shutdown ( ) ; } \n \t3 process <identifiersep> map . remove ( <identifier> ) ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> content <identifiersep> name <identifiersep> string <identifiersep> exception e ) { \n \t3 assert . <identifier> ( <string_literal> ) ; } \n \t2 content <identifiersep> object <identifier> = content <identifiersep> object . build <identifiersep> content <identifiersep> object ( name , <string_literal> . get <identifiersep> bytes ( ) , null , null , <identifier> <identifiersep> <identifier> . first <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 assert . assert <identifiersep> true ( <identifier> <identifiersep> <identifier> . is <identifiersep> last <identifiersep> <identifier> ( <identifier> ) ) ; \n <ect>
\t2 shutdown <identifiersep> <identifier> <identifiersep> manager . remove <identifiersep> shutdown <identifiersep> <identifier> ( shutdown <identifiersep> <identifier> ) ; } \n \t1 if ( is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) <identifier> <identifiersep> <identifier> ( ) ; \n \t1 if ( lock <identifiersep> <identifier> != null ) lock <identifiersep> <identifier> . close ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 if ( null != r ) { \n \t2 try { \n \t2 r . close ( ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t5 text <identifiersep> <identifier> <identifiersep> <identifier> = ( text <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> . new <identifiersep> instance ( <identifier> . as <identifiersep> <identifier> <identifiersep> <identifier> ( ) , text <identifiersep> index ) ; \n \t4 } else if ( <identifier> != null ) { \n \t5 text <identifiersep> <identifier> <identifiersep> <identifier> = ( text <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> . new <identifiersep> instance ( text <identifiersep> index ) ; \n \t4 } else { \n <ect>
\t5 break ; \n \t4 case <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> type <identifiersep> <identifier> <identifiersep> response : \n \t5 if ( <identifier> == <identifier> <identifiersep> type . <identifier> ) { \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t5 long start <identifiersep> <identifier> <identifiersep> <identifier> = index <identifiersep> <identifier> . get <identifiersep> as <identifiersep> time ( <string_literal> + index + <string_literal> , \n \t9 time <identifiersep> value . time <identifiersep> value <identifiersep> millis ( - <identifier> ) ) . get <identifiersep> millis ( ) ; \n \t5 long stop <identifiersep> <identifier> <identifiersep> <identifier> = index <identifiersep> <identifier> . get <identifiersep> as <identifiersep> time ( <string_literal> + index + <string_literal> , \n \t9 index <identifiersep> <identifier> . get <identifiersep> as <identifiersep> time ( <string_literal> , time <identifiersep> value . time <identifiersep> value <identifiersep> <identifier> ( 1 ) ) ) . get <identifiersep> millis ( ) ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 if ( <identifier> ) { \n \t3 logger . info ( <string_literal> ) ; \n \t2 } else if ( test <identifiersep> class . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> with . class ) ) { \n \t3 if ( test <identifiersep> class . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> with . class ) . value ( ) ) { \n <ect>
\t1 { \n \t2 return new <identifier> ( metadata ) ; } \n \t1 private void create <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> metadata <identifier> ) \n \t1 { \n <ect>
\t3 <identifier> . <identifier> ( ) ; \n \t3 <comment> \n \t3 string line = <identifier> . read <identifiersep> line ( ) ; \n <ect>
\t4 <comment> \n \t4 java . <identifier> . <identifier> <identifier> = new java . <identifier> . <identifier> ( r , <identifier> , <identifier> ) ; \n \t4 return new <identifier> <identifiersep> type ( <identifier> ) ; } \n \t2 } catch ( <identifier> <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t3 return <identifier> . new <identifiersep> instance ( <identifier> ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 } catch ( exception e ) { \n <ect>
\t2 string <identifier> = entry . source ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> null <identifiersep> or <identifiersep> empty ( <identifier> ) ) { \n \t3 <identifier> = entry . item <identifiersep> stack ; \n \t3 if ( string <identifiersep> utils . is <identifiersep> null <identifiersep> or <identifiersep> empty ( <identifier> ) ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> manager . <identifier> , null , null ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 <identifier> = false ; \n <ect>
\t2 for ( cluster <identifiersep> vo cluster : <identifier> ) { \n \t3 if ( <identifier> <identifiersep> vm <identifiersep> <identifier> == null ) { \n \t4 <identifier> = <identifier> <identifiersep> resource <identifiersep> <identifier> . list <identifiersep> all <identifiersep> <identifier> <identifiersep> and <identifiersep> enabled <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( host . type . routing , cluster . get <identifiersep> id ( ) , cluster . get <identifiersep> <identifier> <identifiersep> id ( ) , cluster . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t3 } else { \n <ect>
\t4 throw new authentication <identifiersep> exception ( ) ; } \n \t3 logger . warn ( <string_literal> \n \t4 + <string_literal> , provider <identifiersep> name , failure <identifiersep> mode , provider <identifiersep> name , service ) ; \n \t3 return false ; } \n <ect>
\t2 this . id <identifiersep> to <identifiersep> function . put ( <identifier> <identifiersep> id , function ) ; \n \t2 this . id <identifiersep> to <identifiersep> request . put ( <identifier> <identifiersep> id , <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> queue < <identifier> <identifiersep> request > queue = <identifier> <identifiersep> queue ( function ) ; \n \t2 queue . add ( <identifier> ) ; \n <ect>
\t7 <identifier> <identifiersep> node . <identifier> ( true ) ; \n \t7 <comment> \n \t7 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , node . <identifier> <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> , e ) ; \n \t3 create <identifiersep> cmd <identifiersep> result <identifier> = new create <identifiersep> cmd <identifiersep> result ( null , null ) ; \n \t3 <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t5 <comment> \n \t5 for ( int i = 0 ; i < id <identifiersep> list . size ( ) ; i ++ ) { \n \t6 <identifier> <identifiersep> <identifier> id = id <identifiersep> list . get ( i ) ; \n \t6 ex . add <identifiersep> <identifier> <identifiersep> object ( id . get <identifiersep> table <identifiersep> name ( ) , id . get <identifiersep> value ( ) , id . <identifier> <identifiersep> field <identifiersep> name ( ) ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null && ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . equals ( new <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t4 s <identifiersep> logger . info ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> = false ; \n \t3 } else if ( <identifier> <identifiersep> <identifier> <identifiersep> size != null && ! <identifier> <identifiersep> <identifier> <identifiersep> size . equals ( new <identifiersep> <identifier> <identifiersep> size ) ) { \n <ect>
\t4 try { \n \t4 string is = current <identifiersep> field <identifiersep> name . <identifier> ( <identifier> + 1 , current <identifiersep> field <identifiersep> name . length ( ) - 1 ) . <identifier> ( ) ; \n \t5 array <identifiersep> index = integer . parse <identifiersep> int ( is ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t1 private boolean is <identifiersep> <identifier> ( ) { \n \t1 return <identifier> <identifiersep> <identifier> <identifiersep> class != null && <identifier> <identifiersep> <identifier> != null ; } \n \t1 void <identifier> <identifiersep> <identifier> <identifiersep> task <identifiersep> service ( long <identifier> , long <identifier> ) { \n \t1 if ( ! is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 if ( <identifier> <identifiersep> client != null ) { \n \t1 try { \n \t2 <identifier> <identifiersep> client . <identifier> ( ) ; \n \t1 } catch ( <identifier> ex ) { \n <ect>
\t2 . <identifier> <identifiersep> query ( <identifier> <identifiersep> <identifier> ) \n \t2 . with <identifiersep> <identifier> ( create <identifiersep> <identifier> ) \n \t2 . execute ( ) ; \n \t1 } catch ( connection <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> type <identifiersep> info <identifier> = get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> type <identifiersep> by <identifiersep> name ( <string_literal> , <string_literal> ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t2 <comment> \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t9 try ( final byte <identifiersep> array <identifiersep> input <identifiersep> stream in = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( <identifier> ) ) { \n \t10 handle <identifiersep> file ( security <identifiersep> context , in , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , entry <identifiersep> path ) ; } } \n \t8 <identifier> <identifiersep> <identifier> <identifiersep> entry = <identifier> <identifiersep> <identifier> <identifiersep> file . get <identifiersep> next <identifiersep> entry ( ) ; \n \t8 <identifier> <identifiersep> count ++ ; } \n <ect>
\t2 long <identifier> <identifiersep> id = <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t2 long cluster <identifiersep> id = <identifier> . get <identifiersep> cluster <identifiersep> id ( ) ; \n \t2 list < long > host <identifiersep> <identifier> <identifiersep> by <identifiersep> vm <identifiersep> count = <identifier> <identifiersep> vm <identifiersep> instance <identifiersep> dao . list <identifiersep> host <identifiersep> <identifier> <identifiersep> by <identifiersep> vm <identifiersep> count ( <identifier> <identifiersep> id , <identifier> <identifiersep> id , cluster <identifiersep> id , account . get <identifiersep> account <identifiersep> id ( ) ) ; \n <ect>
\t2 <identifier> <identifiersep> service . start ( ) ; \n \t1 } else { \n \t2 log . info ( <string_literal> ) ; } \n \t1 server . <identifier> ( ) ; \n <ect>
\t1 { \n \t1 <identifier> <identifiersep> <identifier> . on <identifiersep> <identifier> ( throwable ) ; } \n \t1 catch ( throwable ex ) \n \t1 { \n <ect>
\t2 try { \n \t3 if ( data <identifiersep> listener != null ) { \n \t4 data <identifiersep> listener . set <identifiersep> interrupted ( true ) ; \n \t4 data <identifiersep> listener = null ; \n <ect>
\t4 last <identifiersep> request = r ; \n \t4 return true ; \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 if ( to <identifiersep> <identifier> . length == 0 ) \n \t5 break ; \n \t4 client . get <identifiersep> client ( ) . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> location , byte <identifiersep> <identifier> . <identifier> ( to <identifiersep> <identifier> ) ) ; } \n \t3 client . get <identifiersep> client ( ) . <identifier> <identifiersep> file <identifiersep> <identifier> ( <identifier> <identifiersep> location ) ; \n <ect>
\t4 logger . warn ( <string_literal> , e ) ; } \n \t3 try { \n \t4 storage <identifiersep> pool <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> store . get <identifiersep> pool <identifiersep> type ( ) , <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> store . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> path ) ; } \n \t3 catch ( exception e ) { \n <ect>
\t4 if ( <identifier> <identifiersep> files . length > 0 ) \n \t4 { \n \t5 file <identifiersep> info file = <identifier> <identifiersep> files [ 0 ] ; \n \t5 <identifier> = file . <identifier> <identifiersep> name ; } } \n <ect>
\t2 add <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 current <identifiersep> url = meta <identifiersep> store <identifiersep> <identifier> . get <identifiersep> connection <identifiersep> url ( conf ) ; } } \n \t1 <comment> \n \t1 if ( <identifier> <identifiersep> conf . get <identifiersep> <identifier> <identifiersep> <identifier> ( conf , conf <identifiersep> <identifier> . <identifier> <identifiersep> enabled ) ) { \n <ect>
\t2 <comment> \n \t2 http <identifiersep> status <identifiersep> code status = request <identifiersep> body ( <string_literal> , test <identifiersep> update <identifiersep> json ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , status ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , http <identifiersep> status <identifiersep> code . no <identifiersep> content . get <identifiersep> status <identifiersep> code ( ) , status . get <identifiersep> status <identifiersep> code ( ) ) ; \n <ect>
\t5 long r = <identifier> . response . request ( ) . native <identifiersep> request ( ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> event <identifiersep> data ( r , <identifier> ) ; \n \t5 <identifier> <identifiersep> http <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> event ( r , null , 0 ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t4 string device <identifiersep> cmd = command <identifiersep> <identifier> [ 1 ] ; \n \t4 <identifier> <identifiersep> connection remote <identifiersep> <identifier> = null ; \n \t4 device <identifiersep> config device = device <identifiersep> config <identifiersep> cache . get ( device <identifiersep> id ) ; \n \t4 if ( device == null ) { \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \t2 if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) \n \t2 { \n <ect>
\t1 # <identifier> <identifier> number of <identifier> the data <identifier> not be <identifier> to the \n \t1 # <identifier> \n \t1 json <identifiersep> data = self . application <identifiersep> <identifier> <identifiersep> map . <identifier> ( <identifier> , true , set <identifiersep> <identifier> = self . set <identifiersep> <identifier> , <identifier> = self . <identifier> ) \n \t1 if json <identifiersep> data is <identifier> : \n <ect>
\t6 <comment> \n \t6 <comment> \n \t6 <comment> \n \t6 if ( debug ) \n <ect>
\t5 try { \n \t6 transport <identifiersep> response <identifiersep> options response <identifiersep> options = transport <identifiersep> response <identifiersep> options . builder ( ) . with <identifiersep> <identifier> ( true ) . build ( ) ; \n \t6 channel . send <identifiersep> response ( new string <identifiersep> message <identifiersep> response ( <string_literal> + request . message ) , response <identifiersep> options ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 if ( ! <identifier> . has <identifiersep> next ( ) ) \n \t3 return null ; \n \t2 <identifier> t = <identifier> . next ( ) ; \n \t2 if ( <identifier> . has <identifiersep> next ( ) ) \n <ect>
\t2 try { \n \t2 count ++ ; \n \t2 <identifier> <identifiersep> job ( user , job <identifiersep> id ) ; \n \t2 success = true ; \n <ect>
\t4 s <identifiersep> logger . debug ( msg <identifiersep> <identifier> ) ; \n \t4 s <identifiersep> logger . debug ( msg <identifiersep> content ) ; } \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> ( <identifier> <identifiersep> type , <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> id , cluster <identifiersep> id , msg <identifiersep> <identifier> , msg <identifiersep> content ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 try { \n \t4 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) != null ) { <comment> \n \t5 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> ( ) ; } } \n \t3 catch ( exception t ) { \n <ect>
\t5 log . info ( <string_literal> ) ; \n \t5 break <identifier> ; \n \t4 default : \n \t5 if ( <identifier> <identifiersep> state != last <identifiersep> <identifier> <identifiersep> state ) { \n <ect>
\t2 final <identifier> <identifiersep> boolean failed = new <identifier> <identifiersep> boolean ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( new <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public void on <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 { \n \t5 result . add ( <identifier> . <identifier> . <identifier> ( ) ) ; } } } \n \t2 catch ( io <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 throw new t <identifiersep> exception ( <string_literal> + session + <string_literal> ) ; } \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t7 string name = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> input <identifiersep> <identifier> ( <string_literal> , content <identifiersep> name . to <identifiersep> string ( ) ) ; \n \t7 if ( name == null ) { \n \t8 log . <identifier> ( <string_literal> ) ; \n \t8 return ; } \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> cluster ( ) . stop <identifiersep> <identifier> <identifiersep> data <identifiersep> node ( ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> cluster ( ) . start <identifiersep> nodes ( <number_literal> , <identifier> . builder ( ) . put ( <string_literal> , <number_literal> ) . build ( ) ) ; \n <ect>
\t1 try { \n \t1 <identifier> . add <identifiersep> <identifier> ( <identifier> ) ; \n \t1 <identifier> . <identifier> ( ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> dir = <identifier> . file . <identifier> <identifiersep> file \n \t2 if ( ! dir . exists ( ) ) { \n \t3 dir . <identifier> ( ) \n \t3 log . debug ( <string_literal> ) } \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> context <identifier> <identifiersep> context = ( <identifier> <identifiersep> context ) object <identifiersep> factory . build <identifiersep> bean ( class <identifiersep> name , null ) ; \n \t4 context <identifiersep> list . add ( <identifier> <identifiersep> context ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 { \n \t2 request <identifier> = it . next ( ) ; \n \t2 if ( <identifier> > <identifier> . send <identifiersep> time + <identifier> <identifiersep> timeout ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 <comment> \n \t3 create <identifiersep> <identifier> ( false ) ; \n \t3 <identifier> <identifiersep> service . start ( ) ; \n \t3 <identifier> <identifiersep> service . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t1 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) throws io <identifiersep> exception { \n \t1 <comment> \n \t1 <comment> \n \t1 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> && ! <identifier> . filter ( <identifier> - > <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) . contains ( <string_literal> ) ) . is <identifiersep> empty ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> address <identifier> = null ; \n \t3 try { \n \t4 <identifier> = <identifier> <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) ; \n \t3 } catch ( <identifier> <identifiersep> host <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n void <identifier> ( <identifier> <identifiersep> message <identifier> <identifiersep> message ) { \n \t1 if ( string <identifiersep> utils . is <identifiersep> blank ( configuration . get <identifiersep> <identifier> <identifiersep> host ( ) ) ) { \n <ect>
\t4 long start = system . <identifier> <identifiersep> time ( ) ; \n \t4 try { \n \t5 success = <identifier> <identifiersep> request <identifiersep> <identifier> . <identifier> <identifiersep> index ( current <identifiersep> <identifier> ) ; \n \t4 } catch ( exception ex ) { \n <ect>
<comment> \n \t1 public boolean add <identifiersep> key ( string key , string name ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 { \n \t3 exception = new <identifier> <identifiersep> exception ( <identifier> , <string_literal> + endpoint ) ; \n \t3 <identifier> <identifiersep> shutdown ( ) ; \n \t3 return ; } \n <ect>
\t1 set < string > <identifier> = new <identifier> <identifiersep> set < > ( ) ; \n \t1 for ( entry < key , value > entry : s ) { \n \t2 log <identifiersep> entry log <identifiersep> entry = log <identifiersep> entry . from <identifiersep> key <identifiersep> value ( entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; \n \t2 <identifier> . add ( new path ( log <identifiersep> entry . <identifier> ) . to <identifiersep> string ( ) ) ; } \n <ect>
\t2 { \n \t3 result = short . max <identifiersep> value ; } \n \t2 else \n \t2 { <comment> \n <ect>
\t2 current <identifiersep> <identifier> . put ( metadata <identifiersep> type . <identifier> , <identifier> . <identifier> <identifiersep> level ( new <identifiersep> level ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> table <identifiersep> metadata ( <identifier> , current <identifiersep> <identifier> ) ; } \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifier> , long new <identifiersep> <identifier> <identifiersep> <identifier> ) throws io <identifiersep> exception \n \t1 { \n <ect>
\t2 if ( <identifier> . is <identifiersep> not <identifiersep> blank ( url ) ) { \n \t3 try { \n \t4 return load <identifiersep> from <identifiersep> url ( new url ( url ) ) ; \n \t3 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t3 { \n \t4 <identifier> = byte . parse <identifiersep> byte ( <identifier> <identifiersep> string ) ; } \n \t3 catch ( number <identifiersep> format <identifiersep> exception <identifier> ) \n \t3 { \n <ect>
<comment> \n \t1 public static void <identifier> <identifiersep> error <identifiersep> to <identifiersep> user ( string error <identifiersep> msg , string <identifier> <identifiersep> msg , exception exception ) { \n \t2 if ( error <identifiersep> msg == null ) { \n \t3 error <identifiersep> msg = <string_literal> ; \n <ect>
\t3 @ <identifier> <identifiersep> <identifier> ( name = <string_literal> , text = <string_literal> ) string options ) { \n \t2 return send <identifiersep> <identifier> ( remote <identifiersep> <identifier> <identifiersep> address , text , options ) ; } \n \t1 private static boolean send <identifiersep> <identifier> ( string remote <identifiersep> <identifier> <identifiersep> address , string text , string options ) { \n \t2 if ( ! context . get <identifiersep> <identifier> <identifiersep> client ( ) . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t3 package <identifiersep> <identifier> . put <identifiersep> all ( class <identifiersep> <identifier> ) ; \n \t3 root <identifiersep> <identifier> . put ( package <identifiersep> path , package <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> + <identifier> + <string_literal> + e . get <identifiersep> message ( ) + <string_literal> ) ; \n <ect>
\t2 string <identifier> = <string_literal> + <identifier> + <string_literal> + <identifier> <identifiersep> ip + <string_literal> + <identifier> ; \n \t2 <comment> \n \t2 <identifier> = <identifier> . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; \n \t2 try { \n <ect>
\t1 public void close ( ) { \n \t2 <comment> \n \t2 if ( ! is <identifiersep> <identifier> . get <identifiersep> and <identifiersep> set ( true ) ) { \n <ect>
\t1 final string cluster <identifiersep> name = ( string ) resource . get <identifiersep> property <identifiersep> value ( property <identifiersep> <identifier> . get <identifiersep> property <identifiersep> id ( <string_literal> , <string_literal> ) ) ; \n \t1 <comment> \n \t1 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( resource <identifiersep> type . cluster , get <identifiersep> cluster <identifiersep> resource <identifiersep> id ( cluster <identifiersep> name ) , <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t5 if ( new <identifiersep> state == state . <identifier> ) { \n \t6 s <identifiersep> logger . debug ( <string_literal> + vm + <string_literal> + state . <identifier> + <string_literal> ) ; \n \t6 s <identifiersep> <identifier> . put ( <identifier> <identifiersep> cluster , host <identifiersep> <identifier> , vm , new <identifiersep> state ) ; \n \t5 } else if ( new <identifiersep> state == state . <identifier> ) { \n <ect>
\t5 public void run ( ) { \n \t6 try { \n \t7 local <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> info ) ; \n \t6 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 } catch ( final <identifier> <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . error ( <string_literal> ) ; \n \t4 return null ; \n \t3 } catch ( final illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> output . class ) ; \n \t1 } catch ( json <identifiersep> <identifier> <identifiersep> exception e ) { \n \t2 log . error ( <string_literal> , e ) ; } \n \t1 if ( null == <identifier> <identifiersep> output || null == <identifier> <identifiersep> output . <identifier> <identifiersep> version <identifiersep> id ) { \n <ect>
\t4 message <identifiersep> format format = new message <identifiersep> format ( format ) ; \n \t4 <identifier> . write ( format . format ( new object [ ] { package <identifiersep> string , class <identifiersep> name , super <identifiersep> class , data } ) ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 <identifier> = false ; \n <ect>
\t1 public static string <identifier> <identifiersep> <identifier> <identifiersep> value ( final key <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> key , final string value ) { \n \t2 final json <identifiersep> web <identifiersep> <identifier> <identifier> = new json <identifiersep> web <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> key ( <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> key ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( value ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( count ) ; \n \t2 stop <identifiersep> <identifier> <identifier> = new stop <identifiersep> <identifier> ( ) ; \n \t2 execute ( count ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t1 public void <identifier> ( transaction transaction ) { \n \t2 <identifier> <identifiersep> <identifier> ( <string_literal> , transaction ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> state <identifier> ( ) { \n <ect>
\t3 this . logger . debug ( <string_literal> + item + <string_literal> ) ; } \n \t2 if ( item == null ) { \n \t3 item = this . <identifier> . create <identifiersep> for <identifiersep> pool ( ) ; \n <ect>
\t2 } catch ( io <identifiersep> exception io <identifiersep> ex ) \n \t2 { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t4 delete . add ( path ) ; \n \t3 } else { \n \t4 resource <identifier> = a . get <identifiersep> resource ( path ) ; \n \t4 if ( is <identifiersep> equal ( <identifier> , <identifier> ) ) { \n <ect>
\t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . contains ( value <identifiersep> type ) \n \t4 && ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> name . contains ( value <identifiersep> type . get <identifiersep> name ( ) ) \n \t4 && ! is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type ( value <identifiersep> type ) ) \n \t3 { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( network <identifiersep> vo network <identifiersep> object , string <identifier> <identifiersep> switch <identifiersep> <identifier> , host <identifiersep> vo <identifier> <identifiersep> <identifier> <identifiersep> host ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> network <identifiersep> id ( network <identifiersep> object . get <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> == null ) { \n \t3 <comment> \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t3 <comment> \n \t3 action <identifiersep> config <identifier> <identifiersep> action <identifiersep> config = <identifier> <identifiersep> <identifier> . get <identifiersep> action <identifiersep> <identifier> ( ) . get ( action <identifiersep> name ) ; \n <ect>
<comment> \n \t5 if ( e . get <identifiersep> response ( ) . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> status <identifiersep> code ( ) == <number_literal> ) { \n \t6 logger . warn ( <string_literal> ) ; \n \t5 } else { \n <ect>
\t2 } else { \n \t3 <identifier> <identifiersep> failed ( <identifier> ) ; } } \n \t1 private void <identifier> <identifiersep> equals ( e <identifiersep> equals <identifier> ) \n \t1 { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . write ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , 0 , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . length ) ; \n \t2 <identifier> <identifiersep> <identifier> . close ( ) ; \n \t2 check <identifiersep> <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> version ( <identifier> <identifiersep> <identifier> <identifiersep> base , <string_literal> . get <identifiersep> bytes ( ) , system <identifiersep> configuration . long <identifiersep> timeout , put <identifiersep> handle ) ; \n \t2 check <identifiersep> data ( check <identifiersep> <identifier> <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t2 } else { \n <ect>
\t2 if ( item . request <identifiersep> <identifier> == null ) { \n \t3 if ( log <identifiersep> <identifier> ) logger . <identifier> ( this , <string_literal> + source + <string_literal> + <identifier> ) ; \n \t3 return false ; } \n \t2 if ( item . <identifier> <identifiersep> to == null ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 transport . write ( client <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . set ( ) ; } \n \t1 private void send <identifiersep> new <identifiersep> <identifier> ( ) \n \t3 throws transport <identifiersep> exception { \n <ect>
\t3 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> , \n \t5 <identifier> <identifiersep> <identifier> . size ( ) ) ; \n \t2 } catch ( exception e ) { \n \t3 <comment> \n <ect>
\t4 log . info ( <string_literal> + date ) ; \n \t3 } catch ( exception e ) { \n \t4 log . error ( <string_literal> + date ) ; } \n \t2 } else { \n <ect>
\t6 log . debug ( <string_literal> + <identifier> [ i ] ) ; \n \t5 } else { \n \t6 int num <identifiersep> <identifier> = m . group <identifiersep> count ( ) ; \n \t6 for ( int <identifier> = 0 ; <identifier> < = num <identifiersep> <identifier> ; <identifier> ++ ) { \n <ect>
\t3 if ( <identifier> <identifiersep> by != <identifier> <identifiersep> <identifier> . data <identifiersep> type . <identifier> ) { \n \t4 log . warn ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> by = <identifier> <identifiersep> <identifier> . data <identifiersep> type . <identifier> ; } } \n \t2 if ( ! <identifier> <identifiersep> input . is <identifiersep> empty ( ) && <identifier> <identifiersep> mode == <identifier> <identifiersep> mode . check <identifiersep> all <identifiersep> <identifier> ) { \n <ect>
\t3 logger . error ( <string_literal> , ex ) ; \n \t3 <identifier> <identifiersep> context . set <identifiersep> attribute ( web <identifiersep> application <identifiersep> context . root <identifiersep> web <identifiersep> application <identifiersep> context <identifiersep> attribute , ex ) ; \n \t3 throw ex ; } \n \t2 catch ( error <identifier> ) { \n <ect>
\t4 } finally { \n \t5 if ( ! <identifier> ) { \n \t6 logger . error ( <string_literal> ) ; } } \n \t3 } catch ( final <identifier> <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 for ( <identifier> <identifiersep> session . <identifier> <identifier> : this . <identifier> . values ( ) ) { \n \t4 <identifier> . <identifier> ( ) ; } } \n \t2 catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> set . <identifier> <identifiersep> message ( test <identifiersep> <identifier> <identifiersep> name <identifiersep> 1 , <identifier> <identifiersep> to <identifiersep> send [ 0 ] ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> set . <identifier> <identifiersep> message ( test <identifiersep> <identifier> <identifiersep> name <identifiersep> <number_literal> , <identifier> <identifiersep> to <identifiersep> send [ 0 ] ) ; \n \t2 wait <identifiersep> write ( <number_literal> ) ; \n \t2 test <identifiersep> msg <identifiersep> <identifier> <identifiersep> service . <identifier> <identifiersep> <identifier> = new date ( ) ; \n <ect>
\t3 string <identifier> <identifiersep> <identifier> = config . get <identifiersep> property ( configuration <identifiersep> <identifier> + <string_literal> ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> all ( <string_literal> | \\ <string_literal> , <string_literal> ) ; } \n \t3 string <identifier> = <identifier> <identifiersep> path + <identifier> <identifiersep> name + <string_literal> ; \n <ect>
\t4 if ( <identifier> . <identifier> <identifiersep> with ( action <identifiersep> <identifier> ) ) { \n \t5 string target <identifiersep> url = get <identifiersep> target <identifiersep> url ( <identifier> , <identifier> ) ; \n \t5 request <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> request <identifiersep> <identifier> ( target <identifiersep> url ) ; \n \t5 if ( <identifier> != null ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 properties <identifiersep> <identifier> <identifier> <identifiersep> properties = config . get <identifiersep> <identifier> <identifiersep> properties ( ) ; \n \t2 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> properties . get <identifiersep> property ( <identifier> <identifiersep> <identifier> <identifiersep> type ) ) ; \n \t2 if ( config . is <identifiersep> <identifier> ( ) && ! <identifier> . is <identifiersep> cluster <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 xml . <identifier> ( <string_literal> ) ; \n \t3 end <identifiersep> response ( response , xml . to <identifiersep> string ( ) ) ; \n \t3 <identifier> <identifiersep> context . <identifier> <identifiersep> transaction ( ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> stream <identifiersep> <identifier> <identifiersep> test . class ) ; \n \t1 static final int total <identifiersep> event <identifiersep> count = <number_literal> ; <comment> \n \t1 public static void <identifier> ( string [ ] <identifier> ) throws exception { \n \t2 final <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . from <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t1 <comment> \n \t1 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> property ( <identifier> , <identifier> <identifiersep> <identifier> ) == null ) { \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t1 } else { \n <ect>
\t4 && get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> element ( ) . has <identifiersep> attribute ( <string_literal> ) ) { \n \t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> utils . <identifier> ( get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> element ( ) . get <identifiersep> attribute ( <string_literal> ) ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> != null \n \t4 && ! ( <identifier> <identifiersep> utils . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) || <identifier> <identifiersep> utils . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ) ) { \n <ect>
\t4 <identifier> <identifiersep> context = <identifier> <identifiersep> context . get <identifiersep> instance ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> context . <identifier> ( <identifier> . get <identifiersep> key <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , null ) ; \n \t4 s <identifiersep> logger . info ( <string_literal> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t6 <identifier> <identifiersep> client . <identifier> ( conf ) ; \n \t6 <identifier> <identifiersep> client . start ( ) ; \n \t5 } else { \n \t6 <identifier> <identifiersep> client = null ; \n <ect>
\t4 <identifier> <identifiersep> service . add <identifiersep> action <identifiersep> listener ( new action <identifiersep> listener ( ) { \n \t5 @ <identifier> \n \t5 public void action <identifiersep> <identifier> ( action <identifiersep> event e ) { \n \t6 if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 <identifier> <identifiersep> <identifier> = create <identifiersep> class <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> = create <identifiersep> class <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( throwable t ) { \n \t3 handle <identifiersep> throwable ( t ) ; \n <ect>
\t3 if ( <identifier> . length > 1 ) { \n \t4 <identifier> = <identifier> [ 1 ] ; <comment> \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
string get <identifiersep> <identifier> <identifiersep> string ( ) { \n \t1 return <identifier> <identifiersep> string ; } \n private boolean <identifier> ( string input , string <identifier> ) { \n \t1 if ( ! error <identifiersep> <identifier> . contains <identifiersep> key ( <identifier> ) ) { \n <ect>
\t2 check <identifiersep> values ( values , <identifier> ) ; } \n \t1 @ test \n \t1 public void delete <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception { \n \t2 string [ ] [ ] values = <identifier> <identifiersep> values ( ) ; \n <ect>
\t3 builder . <identifier> ( <string_literal> + user <identifiersep> authentication . get <identifiersep> name ( ) ) ; \n \t3 logger . debug ( builder . to <identifiersep> string ( ) ) ; } \n \t2 o <identifiersep> <identifier> <identifiersep> token access <identifiersep> token = token <identifiersep> store . get <identifiersep> access <identifiersep> token ( authentication ) ; \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + vm <identifiersep> id + <string_literal> ) ; \n \t3 return new <identifier> <identifiersep> access <identifiersep> authentication <identifiersep> answer ( cmd , false ) ; } \n \t2 string <identifier> = cmd . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> == null || ! <identifier> . equals ( vm . get <identifiersep> <identifier> <identifiersep> password ( ) ) ) { \n <ect>
\t2 try { \n \t3 log . debug ( <string_literal> + <string_literal> ) ; \n \t3 log . info ( <string_literal> + <string_literal> ) ; \n \t3 log . warn ( <string_literal> + <string_literal> ) ; \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
<comment> \n \t1 public synchronized void remove <identifiersep> <identifier> ( <identifier> <identifier> ) { \n <ect>
\t3 exchange . set <identifiersep> exception ( e ) ; } \n \t2 return exchange . has <identifiersep> out ( ) ? exchange . get <identifiersep> out ( ) : exchange . get <identifiersep> in ( ) ; } \n \t1 @ <identifier> \n \t1 protected message run ( ) throws exception { \n <ect>
\t4 method <identifiersep> type <identifier> = method <identifiersep> type . method <identifiersep> type ( return <identifiersep> type , <identifier> <identifiersep> runtime <identifiersep> exception . class ) ; \n \t4 handle = method <identifiersep> <identifier> . catch <identifiersep> exception ( handle , <identifier> <identifiersep> runtime <identifiersep> exception . class , <identifier> <identifiersep> exception . as <identifiersep> type ( <identifier> ) ) ; \n \t3 } else { \n \t4 handle = method <identifiersep> <identifier> . catch <identifiersep> exception ( handle , <identifier> <identifiersep> runtime <identifiersep> exception . class , <identifier> <identifiersep> exception ) ; } \n <ect>
\t1 out . <identifier> ( <string_literal> ) ; \n \t1 try { \n \t1 s = conn . create <identifiersep> <identifier> ( <identifier> <identifiersep> table . name , <identifier> . empty ) ; \n \t1 } catch ( table <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t1 if ( <identifier> <identifiersep> meta == null ) { \n \t1 try { \n \t2 <identifier> <identifiersep> meta = get <identifiersep> <identifier> <identifiersep> meta ( <identifier> <identifiersep> id , <identifier> <identifiersep> url ) ; \n \t2 if ( <identifier> <identifiersep> meta == null ) { \n <ect>
\t3 <string_literal> + \n \t3 <string_literal> + \n \t3 <string_literal> <identifier> \\ <string_literal> + \n \t3 <string_literal> + \n <ect>
<comment> \n \t4 s <identifiersep> logger . debug ( <string_literal> , <identifier> ) ; } \n \t3 if ( next <identifiersep> status == status . <identifier> ) { \n \t4 <comment> \n <ect>
\t4 <identifier> = true ; } \n \t3 catch ( exception e ) \n \t3 { \n \t4 <identifier> = new <identifier> ( ) ; \n <ect>
\t2 if ( ! <identifier> . has <identifiersep> next ( ) ) { \n \t3 <identifier> . close ( ) ; \n \t3 return <identifier> ; } \n \t2 if ( <identifier> <identifiersep> key != null && <identifier> <identifiersep> key . length ( ) > 1 ) \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = null ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> job <identifiersep> info <identifiersep> bean current <identifiersep> job = read <identifiersep> <identifier> <identifiersep> job ( <identifier> , <identifier> <identifiersep> job . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t3 log . error ( <string_literal> + <identifier> <identifiersep> job ) ; \n <ect>
\t1 if self . is <identifiersep> <identifier> ( ) : \n \t1 check <identifiersep> <identifier> ( [ <string_literal> , self . resource . <identifier> <identifiersep> <identifier> ] ) \n \t1 logger . info ( <string_literal> <identifier> self ) \n \t1 else : \n <ect>
\t2 } catch ( no <identifiersep> class <identifiersep> <identifier> <identifiersep> found <identifiersep> error e ) { \n \t3 log . warn ( <string_literal> , log <identifiersep> level <identifiersep> <identifier> , logger <identifiersep> name , e ) ; \n \t3 return false ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 status <identifiersep> manager status <identifiersep> manager = <identifier> . get <identifiersep> status <identifiersep> manager ( ) ; \n \t2 on <identifiersep> <identifier> <identifiersep> status <identifiersep> listener on <identifiersep> <identifier> <identifiersep> listener = new on <identifiersep> <identifier> <identifiersep> status <identifiersep> listener ( ) ; \n \t2 status <identifiersep> manager . add ( on <identifiersep> <identifier> <identifiersep> listener ) ; \n \t2 logger logger = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) ; \n <ect>
\t2 for ( int <identifier> <identifiersep> id : <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> id ) ; \n \t3 entity <identifiersep> <identifier> entity = network <identifiersep> system . get <identifiersep> entity ( <identifier> <identifiersep> id ) ; \n \t3 if ( ! entity . has <identifiersep> <identifier> ( network <identifiersep> <identifier> . class ) ) { \n <ect>
\t5 else \n \t6 out . <identifier> ( 1 ) . <identifier> ( <string_literal> , <identifier> <identifiersep> key . class , key <identifiersep> type , key <identifiersep> id , <identifier> , key <identifiersep> id ) ; \n \t5 all <identifiersep> <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> key ) ; } } \n \t3 catch ( exception e ) { \n <ect>
\t3 <comment> \n \t1 } else if ( <identifier> != null ) { \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; \n \t1 } else { \n <ect>
\t4 system . out . <identifier> ( <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> length ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> dir + <string_literal> ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; } } \n \t1 public boolean <identifier> ( ) throws io <identifiersep> exception , <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> exception { \n <ect>
\t3 long public <identifiersep> <identifier> <identifiersep> <identifier> = null ; \n \t3 if ( public <identifiersep> <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( static <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> public <identifiersep> ip ) ) { \n \t4 public <identifiersep> <identifier> <identifiersep> <identifier> = public <identifiersep> <identifier> <identifiersep> <identifier> . get ( static <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> public <identifiersep> ip ) ; } \n \t3 if ( private <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t5 int <identifier> = 0 ; \n \t5 while ( <identifier> <identifiersep> count != <identifier> <identifiersep> count ) { \n \t6 message msg = consumer . <identifier> ( message <identifiersep> <identifier> <identifiersep> timeout ) ; \n \t6 if ( msg == null ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> + <string_literal> ) ; \n \t3 list < ? extends <identifier> <identifiersep> account > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> account <identifiersep> dao . list <identifiersep> by <identifiersep> <identifier> <identifiersep> id ( <identifier> . get <identifiersep> id ( ) ) ; \n \t3 for ( <identifier> <identifiersep> account <identifier> <identifiersep> account : <identifier> <identifiersep> <identifier> ) { \n \t4 result = result && <identifier> <identifiersep> account <identifiersep> from <identifiersep> <identifier> ( <identifier> <identifiersep> account . get <identifiersep> <identifier> <identifiersep> id ( ) , <identifier> <identifiersep> account . get <identifiersep> account <identifiersep> id ( ) ) ; } \n <ect>
\t1 private <identifier> <identifiersep> listener <identifier> <identifiersep> listener = new <identifier> <identifiersep> listener ( ) { \n \t2 @ <identifier> \n \t2 public void handle <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) { \n <ect>
private <identifier> <identifiersep> boolean <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> boolean ( false ) ; \n @ <identifier> \n void <identifier> ( ) { \n \t1 <identifier> . <identifier> ( this ) ; \n <ect>
\t3 <identifier> . remove ( ) ; \n \t3 found = true ; \n \t3 break ; } } \n \t2 if ( ! found ) { \n <ect>
\t2 try { \n \t3 return get <identifiersep> file <identifiersep> <identifier> ( <identifier> <identifiersep> file <identifiersep> <identifier> , get <identifiersep> file <identifiersep> <identifier> ( ) , new array <identifiersep> list < > ( get <identifiersep> file <identifiersep> <identifier> ( ) . length ) ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t1 thread <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 assert <identifiersep> null ( thread <identifiersep> <identifier> . exception ) ; \n \t1 <comment> \n \t1 <comment> \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 for ( string <identifier> : source . list ( null ) ) { \n \t3 for ( version version : source . <identifier> ( <identifier> ) ) { \n <ect>
\t4 } else { \n \t5 <identifier> <identifiersep> <identifier> . add ( null ) ; } \n \t4 break ; } \n \t4 default : \n <ect>
\t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( string name , map < string , object > <identifier> ) throws configuration <identifiersep> exception { \n <ect>
\t2 token . set <identifiersep> is <identifiersep> <identifier> ( true ) ; \n \t2 token . set <identifiersep> token ( <identifier> . <identifier> <identifiersep> session <identifiersep> token ( ) ) ; \n \t2 return token ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 return is <identifiersep> time <identifiersep> <identifier> ( object ) ; \n \t1 case string : \n \t2 return is <identifiersep> string ( object ) ; \n \t1 default : \n <ect>
\t4 system <identifiersep> <identifier> . get <identifiersep> id ( ) , 0 , <identifier> <identifiersep> service <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 try { \n \t3 <identifier> = <identifier> <identifiersep> it <identifiersep> <identifier> . <identifier> ( <identifier> , template , <identifier> <identifiersep> service <identifiersep> <identifier> , <identifier> , <identifier> , null , system <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 public <identifier> <identifiersep> location <identifiersep> response <identifier> ( final string client <identifiersep> ip , final <identifier> <identifiersep> location <identifiersep> request location ) { \n \t2 logger . debug ( <string_literal> , client <identifiersep> ip ) ; \n \t2 <identifier> <identifiersep> location <identifiersep> response <identifier> = <identifier> ( client <identifiersep> ip ) ; \n \t2 if ( <identifier> == null && location != null ) { \n <ect>
\t3 string msg = <string_literal> + <identifier> <identifiersep> port <identifiersep> <identifier> <identifiersep> name ; \n \t3 s <identifiersep> logger . error ( msg ) ; \n \t3 throw new exception ( msg ) ; } \n \t2 else { \n <ect>
\t5 test <identifiersep> filter . add <identifiersep> test <identifiersep> filter ( new <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> filter ( new <identifier> <identifiersep> array < file > ( <identifier> <identifiersep> <identifier> ) ) ) ; \n \t5 test <identifiersep> filter . add <identifiersep> test <identifiersep> filter ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> filter ( ) ) ; \n \t5 test <identifiersep> filter . add <identifiersep> test <identifiersep> filter ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> filter ( <identifier> <identifiersep> host ) ) ; \n \t5 test = new <identifier> <identifiersep> test <identifiersep> file <identifiersep> <identifier> ( test <identifiersep> file , test <identifiersep> filter ) . process ( ) ; \n <ect>
\t3 <identifier> < <identifier> > <identifier> = <identifier> . <identifier> ( false ) ; \n \t3 if ( <identifier> . has <identifiersep> next ( ) ) { \n \t4 <identifier> <identifier> = <identifier> . next ( ) ; \n \t4 msg = <identifier> . get <identifiersep> short <identifiersep> message ( ) ; } \n <ect>
\t2 if ( type == host . type . storage ) { \n \t3 return <identifier> <identifiersep> <identifier> ; } \n \t2 string host <identifiersep> <identifier> = <identifier> . get <identifiersep> host <identifiersep> <identifier> ( ) ; \n \t2 if ( host <identifiersep> <identifier> != null ) { \n <ect>
\t2 int <identifier> = <identifier> ; \n \t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . create ( source , <identifier> ) ; \n \t2 <identifier> += <identifier> <identifiersep> <identifier> . get <identifiersep> size ( ) ; \n \t2 <comment> \n <ect>
\t3 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> next <identifiersep> <identifier> ( load <identifiersep> <identifier> ) ) { \n \t4 log . warn ( <string_literal> ) ; \n \t4 break ; } \n \t3 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 return true ; } \n \t4 s <identifiersep> logger . warn ( <string_literal> ) ; \n \t4 return false ; \n \t3 } catch ( throwable e ) { \n <ect>
\t2 <comment> \n \t2 long <identifier> = <identifier> <identifiersep> context . job <identifiersep> queue ( ) . get <identifiersep> max <identifiersep> <identifier> ( ) ; \n \t2 if ( ( <identifier> > job <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> network ) && ( <identifier> <identifiersep> context . <identifier> ( ) . get <identifiersep> <identifier> ( ) > <number_literal> * <number_literal> ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t5 session . get <identifiersep> <identifier> ( ) . <identifier> ( <string_literal> + <identifier> , <string_literal> + <identifier> ) ; } \n \t3 } ; \n \t3 double t = test . run ( ) ; \n \t3 execution <identifiersep> <identifier> . add ( t ) ; \n <ect>
\t1 static void <identifier> <identifiersep> m <identifiersep> bean ( <identifier> <identifiersep> bean <identifier> ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> m <identifiersep> bean ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> object <identifiersep> name <identifiersep> exception e ) { \n <ect>
\t4 logger . debug ( <string_literal> , i ) ; \n \t4 <identifier> <identifiersep> file data = <identifier> <identifiersep> service . get <identifiersep> <identifier> <identifiersep> <identifier> ( i , <identifier> <identifiersep> info . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) , \n \t6 <identifier> <identifiersep> info . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t4 byte <identifiersep> stream . write ( data . get <identifiersep> data ( ) ) ; } \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> item <identifiersep> update . set <identifiersep> <identifier> ( false ) ; \n \t2 } else { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> item <identifiersep> update . set <identifiersep> <identifier> ( true ) ; } \n \t2 this . set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 output <identifiersep> stream <identifier> = super . get <identifiersep> output <identifiersep> stream ( ) ; \n \t3 byte <identifiersep> array bytes = <identifier> <identifiersep> byte <identifiersep> <identifier> ( ) ; \n \t3 bytes . write <identifiersep> to ( <identifier> ) ; \n <ect>
\t2 transaction <identifiersep> map . put ( <identifier> <identifiersep> id , <identifier> <identifiersep> event <identifiersep> <identifier> . from <identifiersep> long ( event <identifiersep> <identifier> ) ) ; } } \n \t1 set <identifiersep> <identifier> < long , long > <identifier> <identifiersep> <identifier> = queue . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 try { \n \t1 for ( file log : <identifier> ) { \n <ect>
\t1 return map ; } \n static public map < string , string > get <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t1 target target = get <identifiersep> target ( ) ; \n \t1 if ( target == null ) { \n <ect>
\t2 catch ( runtime <identifiersep> exception e ) \n \t2 { \n \t3 if ( ! ( e instanceof last <identifiersep> error <identifiersep> exception ) ) \n \t4 throw e ; \n <ect>
\t6 <identifier> . <identifier> <identifiersep> <identifier> ( ( <identifier> ) new <identifiersep> <identifier> . <identifier> ( ) , s <identifiersep> wait ) ; } } } } \n \t1 static int base <identifiersep> local <identifiersep> num = 0 ; \n \t1 public instance <identifiersep> field <identifiersep> <identifier> <identifier> ( body <identifier> , <identifier> <identifiersep> <identifier> < unit > <identifier> , instance <identifiersep> field <identifiersep> <identifier> lock , <identifier> <identifier> <identifiersep> <identifier> , \n \t3 boolean <identifier> ) { \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> ( update . get <identifiersep> <identifier> ( ) ) ; } \n \t2 try { \n \t3 <identifier> = <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( illegal <identifiersep> state <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t7 logger . debug ( <string_literal> , host ) ; } } \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> last <identifiersep> <identifier> = <identifier> <identifiersep> this <identifiersep> <identifier> ; } \n \t3 } catch ( runtime <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t1 try { \n \t1 properties . load ( input <identifiersep> stream ) ; \n \t1 input <identifiersep> stream . close ( ) ; \n \t1 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . create ( ) . with <identifiersep> mode ( create <identifiersep> mode . <identifier> ) . for <identifiersep> path ( <string_literal> + <identifier> , new byte [ 0 ] ) ; \n \t1 } catch ( exception e ) { \n \t2 <comment> \n \t2 if ( ! ( e instanceof <identifier> <identifiersep> exception ) || ( ( <identifier> <identifiersep> exception ) e ) . code ( ) != <identifier> <identifiersep> exception . code . <identifier> ) { \n <ect>
\t2 if ( <identifier> <identifiersep> context == null ) { \n \t3 throw new <identifier> <identifiersep> configuration <identifiersep> exception ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t3 result . set <identifiersep> success <identifiersep> is <identifiersep> set ( true ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t2 final thread client <identifiersep> thread = new thread ( client , <string_literal> ) ; \n \t2 client <identifiersep> thread . start ( ) ; \n \t2 client . wait <identifiersep> for <identifiersep> <identifier> ( true ) ; \n \t2 assert <identifiersep> true ( client . is <identifiersep> <identifier> ) ; \n <ect>
\t3 logger . error ( <string_literal> , e ) ; } \n \t2 <comment> \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != 0 && <identifier> <identifiersep> <identifier> >= <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 final <identifier> <identifiersep> configuration <identifiersep> factory factory = new <identifier> <identifiersep> configuration <identifiersep> factory ( ) ; \n \t2 final collection < ticket <identifiersep> <identifier> > <identifier> = ticket <identifiersep> <identifier> . find <identifiersep> all ( ) ; \n \t2 <identifier> . for <identifiersep> <identifier> ( t - > { \n \t3 final map <identifiersep> config map <identifiersep> config = factory . build <identifiersep> map <identifiersep> config ( <identifier> , t . get <identifiersep> properties ( ) . get <identifiersep> storage <identifiersep> name ( ) , t . get <identifiersep> properties ( ) . get <identifiersep> storage <identifiersep> timeout ( ) ) ; \n <ect>
<number_literal> . build ( ) ; \n \t4 response . add <identifiersep> <identifier> <identifiersep> store <identifiersep> <identifier> ( store <identifiersep> response ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 response . set <identifiersep> error ( <identifier> <identifiersep> utils . <identifier> <identifiersep> error ( error <identifiersep> code <identifiersep> <identifier> , e ) ) ; \n <ect>
\t1 string <identifier> <identifiersep> query = query . <identifier> ( <identifier> <identifiersep> token , <string_literal> ) ; \n \t1 return get <identifiersep> <identifier> <identifiersep> info <identifiersep> for <identifiersep> <identifier> <identifiersep> query ( <identifier> <identifiersep> query ) ; } \n protected map < string , list < integer > > get <identifiersep> <identifier> <identifiersep> info <identifiersep> for <identifiersep> <identifier> <identifiersep> query ( string <identifier> ) { \n \t1 result <identifiersep> set <identifier> ; \n <ect>
\t3 <comment> \n \t3 resource = load <identifiersep> resource ( sql <identifiersep> error <identifiersep> code <identifiersep> <identifier> <identifiersep> path ) ; \n \t3 if ( resource != null && resource . exists ( ) ) { \n \t4 <identifier> . load <identifiersep> bean <identifiersep> <identifier> ( resource ) ; \n <ect>
\t3 assert . not <identifiersep> null ( this . server , <string_literal> ) ; \n \t3 assert . not <identifiersep> null ( this . object <identifiersep> <identifier> , <string_literal> ) ; \n \t3 collection < object <identifiersep> name > object <identifiersep> <identifier> = this . <identifier> <identifiersep> m <identifiersep> bean <identifiersep> <identifier> ( ) ; \n \t3 if ( object <identifiersep> <identifier> . size ( ) < 1 ) { \n <ect>
\t6 channel . <identifier> <identifiersep> <identifier> ( true ) ; \n \t6 <identifier> . close ( ) ; \n \t6 return ; } } \n \t4 catch ( io <identifiersep> exception e ) { \n <ect>
\t3 int <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . parse <identifiersep> int ( config <identifiersep> dao . get <identifiersep> value ( <string_literal> ) , <number_literal> ) ; \n \t3 int <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . parse <identifiersep> int ( config <identifiersep> dao . get <identifiersep> value ( <string_literal> ) , <number_literal> ) ; \n \t3 <identifier> <identifiersep> test <identifiersep> <identifier> <identifiersep> task = new test <identifiersep> <identifier> ( this , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t2 <identifier> <identifiersep> current <identifiersep> <identifier> = new date ( ) ; \n <ect>
\t6 found <identifiersep> <identifier> = true ; \n \t6 break ; \n \t5 } catch ( throwable e ) { \n \t6 log . debug ( <string_literal> , c , <identifier> , e ) ; } } } } \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> metadata ( ) { \n <ect>
\t3 <identifier> . add ( <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> <identifier> ( <identifier> ) ) ; \n \t2 } else if ( ! ( cmd . get <identifiersep> entity <identifiersep> type ( ) == null || cmd . get <identifiersep> entity <identifiersep> type ( ) . is <identifiersep> empty ( ) ) ) { \n \t3 string type = cmd . get <identifiersep> entity <identifiersep> type ( ) ; \n <ect>
\t3 string json = create <identifiersep> json <identifiersep> <identifier> ( <identifier> <identifiersep> model ) ; \n \t3 <identifier> . write ( json . get <identifiersep> bytes ( ) ) ; \n \t3 <identifier> . close ( ) ; \n \t3 build <identifiersep> context . <identifier> ( out ) ; \n <ect>
\t6 <comment> \n \t6 <identifier> <identifiersep> <identifier> = true ; \n \t6 send <identifiersep> command <identifiersep> <identifier> <identifiersep> response ( cmd ) ; \n \t5 } else { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 data <identifiersep> in = new data <identifiersep> input <identifiersep> stream ( new <identifier> <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> stream ) ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> + \n \t5 <string_literal> ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . close ( ) ; \n <ect>
\t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t1 <comment> \n \t1 string <identifier> = null ; \n \t1 try { \n <ect>
\t1 final long start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 <identifier> . <identifier> ( <identifier> ) ; \n \t1 final long end = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 final long <identifier> = end - start ; \n <ect>
\t3 log . warn ( <string_literal> ) ; } } \n \t1 public void process <identifiersep> transaction <identifiersep> <identifier> ( transaction <identifiersep> <identifier> <identifiersep> event transaction <identifiersep> <identifier> <identifiersep> event ) { \n <ect>
\t2 load <identifiersep> values ( values ) ; \n \t2 new <identifiersep> <identifier> ( ) ; \n \t2 set < key <identifiersep> <identifier> > <identifier> = delete <identifiersep> values ( <number_literal> ) ; \n \t2 <identifier> ( ) ; \n <ect>
\t6 i . remove ( ) ; \n \t6 try { \n \t7 is . close ( ) ; \n \t6 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 answer answer = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> send ( <identifier> . get <identifiersep> id ( ) , cmd ) ; \n \t3 if ( answer != null ) { \n \t4 host <identifiersep> status = answer . get <identifiersep> result ( ) ? status . <identifier> : status . <identifier> ; } \n \t2 } catch ( exception e ) { \n <ect>
\t4 <comment> \n \t2 catch ( runtime <identifiersep> exception ex ) \n \t2 { \n \t3 <comment> \n <ect>
\t5 <identifier> <identifiersep> log . info ( log , <string_literal> , name , version ) ; } \n \t3 <comment> \n \t3 map < string , list < string > > map <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> ( data <identifiersep> access <identifiersep> <identifier> <identifiersep> <identifier> . get ( server . get <identifiersep> <identifier> <identifiersep> context ( ) ) ) ; \n \t3 if ( server <identifiersep> config . empty ) { \n <ect>
\t2 if ( host == null ) { \n \t3 s <identifiersep> logger . error ( <string_literal> ) ; \n \t3 system . <identifier> ( 1 ) ; } \n \t2 if ( port == null ) { \n <ect>
\t4 log . debug ( msg ) ; \n \t3 } else { \n \t4 properties . load ( input <identifiersep> stream ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 return false ; } \n \t1 protected abstract cluster <identifiersep> <identifier> <identifiersep> exception check <identifiersep> <identifier> ( request request , cluster <identifiersep> state state ) ; \n \t1 @ <identifier> \n \t1 protected final void do <identifiersep> execute ( final request request , action <identifiersep> listener < response > listener ) { \n <ect>
\t3 <comment> \n \t3 logger . warn ( <string_literal> + ( <identifier> . is <identifiersep> <identifier> ( ) ? \n \t5 properties <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> properties ( ) . get ( <string_literal> ) + <string_literal> : <string_literal> ) + \n \t5 properties <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> properties ( ) . get ( <string_literal> ) ) ; \n <ect>
\t3 <identifier> . create ( <string_literal> , null , <identifier> . <identifier> <identifiersep> all <identifiersep> <identifier> , create <identifiersep> mode . <identifier> ) ; \n \t3 assert . <identifier> ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t3 string <identifier> <identifiersep> name = <identifier> <identifiersep> answer . get <identifiersep> local <identifiersep> <identifier> <identifiersep> name ( ) ; \n \t3 list < storage <identifiersep> pool <identifiersep> vo > local <identifiersep> storage <identifiersep> <identifier> = this . <identifier> <identifiersep> store <identifiersep> dao . list <identifiersep> local <identifiersep> storage <identifiersep> pool <identifiersep> by <identifiersep> path ( pool . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) , <identifier> <identifiersep> name ) ; \n \t3 for ( storage <identifiersep> pool <identifiersep> vo local <identifiersep> storage <identifiersep> pool : local <identifiersep> storage <identifiersep> <identifier> ) { \n \t4 if ( <identifier> <identifiersep> name . equals ( local <identifiersep> storage <identifiersep> pool . get <identifiersep> path ( ) ) ) { \n <ect>
\t4 final answer [ ] answer = send <identifiersep> <identifier> <identifiersep> command ( <identifier> <identifiersep> <identifier> <identifiersep> id , host <identifiersep> id , current <identifiersep> <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> <identifiersep> id , event . start <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t4 if ( answer == null || ! answer [ 0 ] . get <identifiersep> result ( ) ) { \n \t5 result = false ; } \n \t3 } catch ( final exception ex ) { \n <ect>
\t4 . add <identifiersep> web <identifiersep> socket <identifiersep> listener ( new web <identifiersep> socket <identifiersep> text <identifiersep> listener ( ) { \n \t5 @ <identifier> \n \t5 public void on <identifiersep> message ( string message ) { \n \t6 <identifier> . add ( message ) ; \n <ect>
\t2 <identifier> = true ; \n \t2 } else { \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , source , destination , <identifier> ) ; } \n \t1 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . and ( <identifier> . entity ( ) . get <identifiersep> name ( ) , <identifier> <identifiersep> <identifier> . <identifier> . <identifier> , name ) ; \n \t3 <identifier> . and ( <identifier> . entity ( ) . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> . <identifier> . null ) ; \n \t3 list < <identifier> <identifiersep> snapshot <identifiersep> on <identifiersep> <identifier> <identifiersep> vo > <identifier> = <identifier> . list ( ) ; \n \t3 if ( <identifier> . size ( ) > 1 ) { \n <ect>
\t5 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> info ( ) . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> . type <identifiersep> int <identifiersep> <identifier> ) ; \n \t3 <identifier> . <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t3 return <identifier> ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 { \n \t2 @ <identifier> \n \t2 public <identifier> handle ( <identifier> <identifiersep> <identifier> . timeout . <identifier> <identifier> , <identifier> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> state <identifier> , log log ) \n \t2 { \n <ect>
\t3 if ( <identifier> . length != <number_literal> ) { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t3 int <identifier> = get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> to ( int . class , <identifier> [ 0 ] ) ; \n \t3 int max = get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> to ( int . class , <identifier> [ 1 ] ) ; \n <ect>
\t5 queue <identifiersep> <identifier> ( new cluster <identifiersep> manager <identifiersep> message ( cluster <identifiersep> manager <identifiersep> message . message <identifiersep> type . node <identifiersep> <identifier> ) ) ; \n \t4 } catch ( throwable e ) { \n \t5 s <identifiersep> logger . error ( <string_literal> , e ) ; \n \t5 if ( is <identifiersep> root <identifiersep> <identifier> <identifiersep> connection <identifiersep> <identifier> ( e . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 assert <identifiersep> not <identifiersep> null ( client <identifiersep> entity ) ; \n \t2 log . info ( <string_literal> , client <identifiersep> entity . get <identifiersep> properties ( ) ) ; \n \t2 int status <identifiersep> code = response <identifiersep> <identifier> . get ( <number_literal> ) . get <identifiersep> status <identifiersep> code ( ) ; \n \t2 assert <identifiersep> equals ( http <identifiersep> status <identifiersep> code . no <identifiersep> content . get <identifiersep> status <identifiersep> code ( ) , status <identifiersep> code ) ; \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> status <identifiersep> store . <identifier> ( status , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> store <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t2 <comment> \n \t2 send ( <string_literal> , <number_literal> ) ; \n \t2 stop <identifiersep> <identifier> <identifier> = new stop <identifiersep> <identifier> ( ) ; \n \t2 send ( <string_literal> , count ) ; \n <ect>
\t2 object <identifiersep> name query = new object <identifiersep> name ( <identifier> + <string_literal> + get <identifiersep> name ( true ) + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> ) ; \n \t2 java . <identifier> . set < object <identifiersep> name > set = <identifier> <identifiersep> server . query <identifiersep> <identifier> ( query , null ) ; \n \t2 object <identifiersep> name <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = set . <identifier> ( ) . next ( ) ; \n \t2 <identifier> = m <identifiersep> bean <identifiersep> server <identifiersep> <identifier> <identifiersep> handler . new <identifiersep> <identifier> <identifiersep> instance ( <identifier> <identifiersep> server , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> m <identifiersep> bean . class , true ) ; \n <ect>
\t4 new string ( event . get <identifiersep> body ( ) . array ( ) , <identifier> . for <identifiersep> name ( <string_literal> ) ) ) ; \n \t1 return status . failed ; } \n \t1 @ <identifier> \n \t1 public status <identifier> <identifiersep> <identifier> ( list < <identifier> <identifiersep> <identifier> <identifiersep> event > <identifier> ) throws <identifier> <identifiersep> remote <identifiersep> exception { \n <ect>
\t4 <identifier> = <identifier> ( <identifier> <identifiersep> file , <identifier> ) \n \t4 <identifier> = <identifier> . <identifier> ( ) \n \t4 <identifier> = <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> ) \n \t4 if <identifier> ( <identifier> ) == 0 : \n <ect>
\t4 this . <identifier> = address <identifiersep> array ; \n \t4 if ( this . <identifier> <identifiersep> connection <identifiersep> factory != null ) { \n \t5 this . <identifier> <identifiersep> connection <identifiersep> factory . set <identifiersep> <identifier> ( <identifier> ) ; } \n \t4 return ; } } \n <ect>
\t3 if ( lock ( job <identifiersep> id ) ) { \n \t4 <identifier> ( store ) ; } \n \t3 else { \n \t4 queue <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> <identifiersep> command ( job <identifiersep> id ) , lock <identifiersep> failure <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
<comment> \n public static list < <identifier> <identifiersep> test <identifiersep> case > find <identifiersep> all <identifiersep> test <identifiersep> <identifier> ( ) { \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> connection ( ) throws <identifier> <identifiersep> <identifier> { \n <ect>
\t7 break ; \n \t6 default : \n \t7 break ; } } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 logger . error ( <string_literal> , <identifier> <identifiersep> count <identifiersep> <identifier> , command ) ; \n \t2 return false ; } \n \t1 string location = response . get <identifiersep> first <identifiersep> header <identifiersep> or <identifiersep> null ( location ) ; \n \t1 if ( location == null ) { \n <ect>
\t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , ex ) ; \n \t3 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . resource <identifiersep> <identifier> <identifiersep> error , ex . get <identifiersep> message ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> operation <identifiersep> exception ex ) { \n <ect>
\t5 } catch ( final io <identifiersep> exception e ) { } } } \n \t3 try { \n \t4 thread . <identifier> ( <identifier> ) ; \n \t3 } catch ( final interrupted <identifiersep> exception e ) { } } \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> ( 1 . 0 ) ; \n \t3 if ( <identifier> . equals ( <identifier> , data ) ) { \n \t4 <identifier> <identifiersep> <identifier> ++ ; \n \t4 int <identifier> <identifiersep> success = <number_literal> * <identifier> <identifiersep> <identifier> / <identifier> <identifiersep> <identifier> ; \n <ect>
\t3 string <identifier> = <string_literal> ; \n \t3 string <identifier> = <string_literal> ; \n \t3 try { \n \t3 if ( <identifier> . <identifier> ( <identifier> ) ) \n <ect>
\t2 <identifier> <identifiersep> manager <identifier> <identifiersep> manager = new <identifier> <identifiersep> manager ( context <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; \n \t2 file <identifier> = new file ( <identifier> . <identifier> <identifiersep> dir ) ; \n \t2 file [ ] files = <identifier> . list <identifiersep> files ( ) ; \n \t2 if ( files == null ) { \n <ect>
\t1 pool <identifiersep> state pool = <identifier> . get ( pool <identifiersep> name ) ; \n \t1 session . <identifier> <identifiersep> <identifier> ( ) ; \n \t1 if ( pool != null && pool . <identifier> . remove ( session ) ) { \n \t2 return remove <identifiersep> session <identifiersep> result . <identifier> ; } } \n <ect>
\t3 final <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> , network , <identifier> . get <identifiersep> <identifier> <identifiersep> uri ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> uri ( ) , network <identifiersep> <identifier> , \n \t5 <identifier> <identifiersep> network <identifiersep> model . is <identifiersep> security <identifiersep> group <identifiersep> <identifier> <identifiersep> in <identifiersep> network ( network ) , <identifier> <identifiersep> network <identifiersep> model . get <identifiersep> network <identifiersep> <identifier> ( vm . get <identifiersep> <identifier> <identifiersep> type ( ) , network ) ) ; \n \t3 if ( <identifier> instanceof network <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 if ( ! ( ( network <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) . <identifier> <identifiersep> <identifier> ( <identifier> , network , vm , <identifier> , context ) ) { \n <ect>
\t9 assert <identifiersep> equals ( <string_literal> , <identifier> . get ( <string_literal> ) ) ; \n \t9 assert <identifiersep> equals ( exchange . get <identifiersep> exchange <identifiersep> id ( ) , <identifier> . get ( <string_literal> ) ) ; \n \t9 assert <identifiersep> equals ( exchange . get <identifiersep> in ( ) . get <identifiersep> message <identifiersep> id ( ) , <identifier> . get ( <string_literal> ) ) ; \n \t9 assert <identifiersep> equals ( <string_literal> , <identifier> . get ( <string_literal> ) ) ; \n <ect>
\t3 query . add <identifiersep> <identifier> ( <identifier> . <identifier> ( <string_literal> ) . is ( key ) ) ; \n \t3 final write <identifiersep> result <identifier> = this . <identifier> <identifiersep> template . remove ( query , <identifier> <identifiersep> authentication <identifiersep> <identifier> <identifiersep> <identifier> . class , this . collection <identifiersep> name ) ; \n \t3 logger . info ( <string_literal> , <identifier> . get <identifiersep> n ( ) ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = 1 \n \t2 self . logger . info ( <string_literal> ) \n \t1 if <identifier> <identifiersep> <identifier> * <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : \n \t2 <identifier> <identifiersep> <identifier> = long ( <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> / <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size ) ) \n <ect>
\t6 return cluster <identifiersep> state . builder ( current <identifiersep> state ) . put <identifiersep> <identifier> ( <identifier> <identifiersep> in <identifiersep> <identifier> . type , <identifier> ) . build ( ) ; } } \n \t4 return current <identifiersep> state ; } \n \t3 @ <identifier> \n \t3 public void on <identifiersep> failure ( string source , exception e ) { \n <ect>
\t2 try { \n \t3 test <identifiersep> <identifier> <identifiersep> resource test <identifiersep> <identifier> <identifiersep> resource = new test <identifiersep> <identifier> <identifiersep> resource ( <identifier> ) ; \n \t3 transaction <identifiersep> manager . get <identifiersep> transaction ( ) . <identifier> <identifiersep> resource ( test <identifiersep> <identifier> <identifiersep> resource ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 for ( final node <identifiersep> interface node : <identifier> . node <identifiersep> query ( ) . get <identifiersep> as <identifiersep> list ( ) ) { \n \t4 <identifier> . delete ( node ) ; } \n \t3 <identifier> . success ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t4 success = empty <identifiersep> <identifier> ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 success = false ; } \n \t3 if ( success ) { \n <ect>
\t3 filter <identifiersep> config <identifiersep> <identifier> <identifier> = new filter <identifiersep> config <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> . set <identifiersep> filter ( <identifier> ) ; \n \t3 <identifier> . set <identifiersep> filter <identifiersep> name ( <identifier> . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 filter <identifiersep> <identifier> . add <identifiersep> filter ( <identifier> ) ; \n <ect>
<comment> \n \t1 public boolean <identifier> <identifiersep> <identifier> ( <identifier> <identifier> , string <identifier> , string <identifier> <identifiersep> code , string transport , long <identifier> <identifiersep> on ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t1 if ( <identifier> <identifiersep> handle == null ) { \n \t2 log . warn ( <string_literal> ) ; \n \t2 return ; } \n \t1 if ( operation <identifiersep> log == null ) { \n <ect>
\t2 } finally { \n \t3 try { \n \t4 out . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e <identifiersep> io ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
private < <identifier> > void assert <identifiersep> <identifier> ( final <identifier> key ) { \n \t1 <identifier> <identifiersep> cache <identifiersep> <identifier> cache <identifiersep> <identifier> = \n \t3 cache ( <identifier> [ 0 ] ) . get <identifiersep> <identifier> <identifiersep> cache ( ) . get <identifiersep> <identifier> <identifiersep> manager ( ) . get <identifiersep> cache <identifiersep> <identifier> ( ) ; \n \t1 final list < address > <identifier> = cache <identifiersep> <identifier> . get <identifiersep> <identifier> ( key ) . write <identifiersep> <identifier> ( ) ; \n <ect>
\t5 log . debug ( x <identifiersep> log . <identifier> , <string_literal> , node <identifiersep> job . node <identifiersep> name ) ; } \n \t4 else { \n \t5 if ( context . status == status . failed ) { \n \t6 status = status . failed ; \n <ect>
\t2 error <identifiersep> <identifier> = null ; \n \t2 <identifier> <identifiersep> <identifier> ( e ) ; \n \t2 this . uri = <identifier> <identifiersep> uri ; \n \t2 if ( mode == <identifier> <identifiersep> exception <identifiersep> mode . <identifier> <identifiersep> error ) \n <ect>
\t2 final <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> queue <identifiersep> item > <identifier> = \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> queue <identifiersep> item . <identifier> <identifiersep> <identifier> ( system . current <identifiersep> time <identifiersep> millis ( ) - time <identifiersep> unit . <identifier> . to <identifiersep> millis ( <number_literal> ) ) ; \n \t2 int <identifier> <identifiersep> queue <identifiersep> <identifier> = collection <identifiersep> utils . <identifier> ( data <identifiersep> <identifier> , 0 , collection <identifiersep> utils . count ( <identifier> ) ) ; \n \t2 if ( <identifier> <identifiersep> queue <identifiersep> <identifier> > 0 ) { \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n \t3 log . warn ( <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 { \n \t3 try \n \t3 { \n <ect>
\t7 log . debug ( <string_literal> ) ; \n \t7 log . debug ( <string_literal> ) ; \n \t7 log . debug ( <string_literal> , key ) ; \n <ect>
\t2 && ( ! ( service instanceof <identifier> ) || ( service instanceof <identifier> && <identifier> <identifiersep> <identifier> . contains ( service ) ) ) ) { \n \t2 try { \n \t2 ( ( <identifier> ) service ) . stop ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 <comment> \n \t4 try { \n \t5 send <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , password , <identifier> , <identifier> , <string_literal> , context ) ; \n \t4 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 return <identifier> <identifiersep> <identifier> ( msg ) ; } \n \t2 start ( ) ; \n \t2 object new <identifiersep> msg = filter ( msg ) ; \n \t2 if ( new <identifiersep> msg == null ) { \n <ect>
\t2 final string max <identifiersep> as <identifiersep> string = get <identifiersep> <identifier> <identifiersep> value ( ) ; \n \t2 long <identifier> = number <identifiersep> utils . to <identifiersep> long ( max <identifiersep> as <identifiersep> string ) ; \n \t2 long <identifier> <identifiersep> <identifier> = <identifier> - <identifier> + 1 ; <comment> \n \t2 if ( <identifier> > <identifier> ) { \n <ect>
\t3 <identifier> . create ( <string_literal> , null , <identifier> . <identifier> <identifiersep> all <identifiersep> <identifier> , create <identifiersep> mode . <identifier> ) ; \n \t3 assert . <identifier> ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t2 write <identifiersep> <identifier> . <identifier> read <identifiersep> <identifier> ) { \n \t1 final int <identifier> <identifiersep> <identifier> = ( <identifier> . length - 1 ) ; \n \t1 int <identifier> <identifiersep> code = write <identifiersep> <identifier> . <identifier> <identifiersep> code ( key , <identifier> , length ) ; \n \t1 int <identifier> = <identifier> <identifiersep> code & <identifier> <identifiersep> <identifier> ; \n <ect>
\t6 if ( <identifier> . contains ( new <identifiersep> <identifier> ) ) { \n \t7 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + new <identifiersep> <identifier> + \n \t9 <string_literal> ) ; } \n \t6 <identifier> . add ( new <identifiersep> <identifier> ) ; } \n <ect>
\t5 <identifier> <identifiersep> <identifier> . send ( <identifier> . to <identifiersep> bytes ( ) ) ; } \n \t3 } catch ( final <identifier> <identifiersep> channel <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + cmd . to <identifiersep> string ( ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 for ( string group : <identifier> . get <identifiersep> job <identifiersep> group <identifiersep> <identifier> ( ) ) { \n \t1 <comment> \n \t1 for ( job <identifiersep> key job <identifiersep> key : <identifier> . get <identifiersep> job <identifiersep> <identifier> ( group <identifiersep> <identifier> . job <identifiersep> group <identifiersep> equals \n \t2 ( execution <identifiersep> job . <identifier> <identifiersep> execution <identifiersep> job <identifiersep> group ) ) ) { \n <ect>
\t1 <identifier> <identifiersep> service . set <identifiersep> user <identifiersep> <identifier> ( <string_literal> , <identifier> ) ; \n \t1 return get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } else { \n \t1 string <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( ' \\ <identifier> , ' ' ) . <identifier> ( ' \\ <identifier> , ' ' ) ; <comment> \n <ect>
\t3 if ( create && ! this <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t4 try { \n \t5 file <identifiersep> on <identifiersep> <identifier> . create <identifiersep> new <identifiersep> file ( ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 private void execute <identifiersep> all <identifiersep> <identifier> ( stream < index > <identifier> , function < index , <identifier> < ? > > function , <identifier> <identifiersep> <identifier> < object > <identifier> ) \n \t1 { \n \t2 if ( function == null ) \n \t2 { \n <ect>
\t3 <comment> \n \t3 try { \n \t4 model <identifiersep> <identifier> <identifiersep> client . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t1 <comment> \n \t1 public static synchronized void <identifier> ( string file , string <identifier> ) { \n <ect>
\t5 p . set <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t5 p . set <identifiersep> <identifier> ( entry . get <identifiersep> value ( ) ) ; \n \t5 context . get <identifiersep> user <identifiersep> service ( ) . <identifier> <identifiersep> <identifier> ( p ) ; } } } \n \t2 catch ( exception e ) { \n <ect>
\t1 public static void do <identifiersep> <identifier> ( final i <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , final set < i <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> , \n \t3 final set < i <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> , final i <identifiersep> <identifier> <identifier> ) \n \t3 throws <identifier> <identifiersep> target <identifiersep> exception , <identifier> <identifiersep> error <identifiersep> exception { \n \t2 if ( <identifier> == null ) { \n <ect>
protected void <identifier> <identifiersep> group <identifiersep> to <identifiersep> <identifier> ( string <identifier> , string name ) { \n \t1 logger . debug ( <string_literal> , <identifier> , name ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> id = <identifier> . get ( security <identifiersep> client . <identifier> <identifiersep> security <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( <identifier> , name ) , 0 ) . get <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t1 security <identifiersep> client . <identifier> <identifiersep> security <identifiersep> group <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( <identifier> , name , new user <identifiersep> id <identifiersep> group <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> id , name ) ) ; \n <ect>
\t4 . set <identifiersep> password ( password ) \n \t4 . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> default ( ) ) \n \t4 . set <identifiersep> time <identifiersep> <identifier> ( time <identifiersep> <identifier> . get <identifiersep> default ( ) ) ; \n \t2 try { \n <ect>
\t6 job <identifiersep> <identifier> = <identifier> . to <identifiersep> string ( ) ; \n \t6 logger . info ( job <identifiersep> <identifier> + <string_literal> ) ; \n \t6 context . add <identifiersep> <identifier> <identifiersep> job ( <identifier> ) ; \n \t6 job <identifiersep> pool . execute ( new job <identifiersep> <identifier> ( <identifier> ) ) ; \n <ect>
\t2 final network <identifiersep> config network <identifiersep> config = new network <identifiersep> config ( ) \n \t3 . set <identifiersep> port ( cluster . get <identifiersep> port ( ) ) \n \t3 . set <identifiersep> port <identifiersep> <identifier> <identifiersep> <identifier> ( cluster . is <identifiersep> port <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) \n \t3 . set <identifiersep> <identifier> ( <identifier> <identifiersep> config ) ; \n <ect>
\t4 final <identifier> <identifiersep> method <identifier> <identifiersep> method = find <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> method , <identifier> <identifiersep> method . class ) ; \n \t4 final byte [ ] <identifier> <identifiersep> <identifier> <identifiersep> bytes = get <identifiersep> <identifier> <identifiersep> bytes ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t4 a . set <identifiersep> <identifier> <identifiersep> configuration ( new <identifier> <identifiersep> <identifier> <identifiersep> configuration ( <identifier> <identifiersep> <identifier> <identifiersep> bytes , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> method ) ) ; \n \t3 } else { \n <ect>
\t2 assert . assert <identifiersep> true ( <string_literal> , <identifier> <identifiersep> write <identifiersep> <identifier> . get ( ) == num <identifiersep> <identifier> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 set <identifiersep> <identifier> ( <number_literal> , <number_literal> , <number_literal> , <number_literal> ) ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t5 store . <identifier> <identifiersep> local <identifiersep> <identifier> <identifiersep> lock ( ) ; \n \t5 message . <identifier> <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . <identifier> <identifiersep> <identifier> ( ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . <identifier> <identifiersep> shards ( ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . <identifier> <identifiersep> shards ( ) . get ( 0 ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . <identifier> <identifiersep> shards ( ) . get ( 0 ) . current <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; } \n <ect>
\t7 if ( <identifier> != null ) { \n \t8 <identifier> <identifiersep> <identifier> <identifiersep> group <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> group < abstract <identifiersep> <identifier> <identifiersep> group < ? > > ( i , group ) ; \n \t8 <identifier> . <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> name , <identifier> ) ; } \n \t6 } catch ( exception e ) { \n <ect>
\t2 } catch ( throwable t ) { \n \t3 <comment> \n \t3 <comment> \n \t3 <comment> \n <ect>
\t5 s <identifiersep> logger . info ( <string_literal> + ( shutdown <identifiersep> wait <identifiersep> <identifier> / <number_literal> ) + <string_literal> + vm <identifiersep> name ) ; \n \t5 return <identifier> <identifiersep> <identifier> <identifiersep> no <identifiersep> check ( ) ; } \n \t4 return true ; \n \t3 } catch ( exception e ) { \n <ect>
\t6 } catch ( io <identifiersep> exception e ) { \n \t7 <comment> \n \t7 <comment> \n \t7 if ( input <identifiersep> handler . get <identifiersep> input <identifiersep> type ( ) == input <identifiersep> type . <identifier> ) { \n <ect>
<comment> \n \t1 private static int handle <identifiersep> <identifier> <identifiersep> exception ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 { \n \t3 if ( t instanceof thread <identifiersep> <identifier> ) \n \t4 throw ( thread <identifiersep> <identifier> ) t ; \n \t3 else \n <ect>
\t1 public void <identifier> ( <identifier> <identifiersep> event event ) { \n \t2 if ( <identifier> <identifiersep> <identifier> || check <identifiersep> <identifier> ( ) ) { \n \t3 <identifier> <identifiersep> <identifier> ( event ) ; \n \t2 } else { \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> <identifier> ( grid <identifiersep> cache <identifiersep> <identifier> <identifiersep> ex < <identifier> , v > <identifier> ) { \n \t2 assert <identifier> != null ; \n <ect>
\t3 @ <identifier> \n \t3 public void log ( int level , string message ) { \n \t4 if ( level == <identifier> || level == error ) { \n <ect>
\t3 public void handle <identifiersep> throwable ( security <identifiersep> context security <identifiersep> context , throwable t , abstract <identifiersep> <identifier> <identifier> ) { \n \t4 logger . warn ( <string_literal> , new object [ ] { <identifier> , t . get <identifiersep> message ( ) } ) ; } \n \t3 @ <identifier> \n \t3 public void handle <identifiersep> transaction <identifiersep> failure ( security <identifiersep> context security <identifiersep> context , throwable t ) { \n <ect>
<comment> \n \t1 private final string <identifier> <identifiersep> <identifier> <identifiersep> config ; \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> config ( map conf ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> . get ( 0 ) . get <identifiersep> state ( ) == network <identifiersep> <identifier> . state . enabled ) { \n \t4 <comment> \n \t4 list < network <identifiersep> vo > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> network <identifiersep> <identifier> . list <identifiersep> <identifier> <identifiersep> for <identifiersep> account ( <identifier> . get <identifiersep> id ( ) , <identifier> . get <identifiersep> id ( ) , network . <identifier> <identifiersep> type . <identifier> ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 string <identifier> <identifiersep> path = configuration . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t2 string <identifier> <identifiersep> directory <identifiersep> path = configuration . get <identifiersep> <identifier> <identifiersep> directory ( ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> , <identifier> <identifiersep> directory <identifiersep> path ) ; \n <ect>
\t1 private static <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ; \n \t1 private static <identifier> <identifiersep> <identifier> load <identifiersep> <identifier> ( string <identifier> <identifiersep> version ) throws <identifier> <identifiersep> operation <identifiersep> exception { \n \t2 class < ? > <identifier> <identifiersep> <identifier> <identifiersep> class ; \n \t2 if ( <string_literal> . equals ( <identifier> <identifiersep> version ) ) { \n <ect>
\t4 for ( string <identifier> : get <identifiersep> vm <identifiersep> <identifier> ( ) ) { \n \t5 if ( <identifier> . equals ( remove ) ) { \n \t6 logger . debug ( <string_literal> + remove ) ; \n \t5 } else { \n <ect>
\t3 c . <identifier> ( <identifier> <identifiersep> update <identifiersep> factory . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , get <identifiersep> super <identifiersep> <identifier> ( <identifier> ) , <identifier> . get <identifiersep> context <identifiersep> id ( ) ) ) ; \n \t3 c . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> create <identifiersep> <identifier> ( <identifier> ) ) ; \n \t3 return c ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 if ( ! add ) { \n \t3 list < <identifier> <identifiersep> vo > <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . list <identifiersep> by <identifiersep> network <identifiersep> id ( network . get <identifiersep> id ( ) ) ; \n \t3 for ( <identifier> <identifiersep> vo <identifier> : <identifier> ) { \n \t4 if ( <identifier> . get <identifiersep> vm <identifiersep> type ( ) == null && <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . equals ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) && <identifier> . get <identifiersep> i <identifiersep> <identifier> ( ) . equals ( network . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 <comment> \n \t2 string remote <identifiersep> device ; \n \t2 if ( uri . get <identifiersep> <identifier> ( ) . equals ( <string_literal> ) ) { \n \t3 remote <identifiersep> device = <string_literal> + uri <identifiersep> host <identifiersep> ip + uri . get <identifiersep> path ( ) ; \n <ect>
\t4 case <identifier> <identifiersep> state : \n \t5 <identifier> <identifiersep> status <identifier> <identifiersep> <identifier> = remote <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> status ( ) ; \n \t5 return new string <identifiersep> type ( <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ) ; \n \t4 case <identifier> : \n <ect>
\t5 = <identifier> <identifiersep> <identifier> . <identifier> ( ) . next ( ) ; \n \t4 security <identifiersep> <identifier> = <identifier> <identifiersep> context . get <identifiersep> service ( <identifier> <identifiersep> <identifier> ) ; } } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t1 @ <identifier> \n \t1 @ <identifier> ( <string_literal> ) \n \t1 @ path ( <string_literal> ) \n \t1 public string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( @ <identifier> <identifiersep> <identifier> context <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) throws io <identifiersep> exception { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 if ( configuration . is <identifiersep> <identifier> ( ) ) { \n \t1 log . info ( <string_literal> ) ; \n \t1 return ; } \n \t1 if ( configuration . provider ( ) == null ) { \n <ect>
\t4 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> vm <identifiersep> group ( vm <identifiersep> <identifier> , current <identifiersep> state ) ; \n \t3 } catch ( resource <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t4 throw <identifier> ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> ) ; } \n \t3 return null ; } \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) > <identifier> <identifiersep> max <identifiersep> <identifier> ) { \n <ect>
@ <identifier> \n public void end ( int <identifier> ) { \n \t1 <identifier> <identifiersep> transaction <identifiersep> if <identifiersep> <identifier> ( ) ; \n \t1 <identifier> <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ; \n <ect>
\t4 logger . info ( <string_literal> + user <identifiersep> name ) ; \n \t4 logger . info ( <string_literal> ) ; \n \t4 return true ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 c . table <identifiersep> <identifier> ( ) . create ( table <identifiersep> name ) ; \n \t1 <identifier> <identifiersep> set < text > <identifier> = new <identifier> <identifiersep> set < > ( ) ; \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t1 <identifier> . add ( new text ( <string_literal> + i ) ) ; } \n <ect>
\t3 } else { \n \t4 logger . warn ( <string_literal> ) ; \n \t4 success <identifiersep> <identifier> <identifiersep> authentication = false ; } \n \t2 } catch ( final abstract <identifiersep> ticket <identifiersep> exception e ) { \n <ect>
\t4 map . entry < ? , ? > <identifier> = ( map . entry < ? , ? > ) it . next ( ) ; \n \t4 string key = ( string ) <identifier> . get <identifiersep> key ( ) ; \n \t4 string value = ( string ) <identifier> . get <identifiersep> value ( ) ; \n \t4 if ( value == null ) { \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \t3 return ; } \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> port == null || ! <identifier> <identifiersep> port . is <identifiersep> <identifier> ( ) ) { \n <ect>
<number_literal> get <identifiersep> context ( ) . session <identifiersep> key <identifiersep> manager ( ) ) ; \n \t2 long <identifier> = get <identifiersep> context ( ) . <identifier> ( ) . <identifier> ( ) ; \n \t2 if ( ( <identifier> - <identifier> ) > <number_literal> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 logger . warn ( <string_literal> , key ) ; \n \t3 return ; } \n \t2 string location <identifiersep> id = string <identifiersep> utils . <identifier> <identifiersep> <identifier> ( key , <string_literal> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( location <identifiersep> id ) ) { \n <ect>
<comment> \n \t1 public void debug <identifiersep> <identifier> <identifiersep> <identifier> ( string filter ) \n \t1 { \n <ect>
<comment> \n \t1 private list < metadata <identifiersep> <identifier> > load <identifiersep> metadata <identifiersep> from <identifiersep> resource ( final metadata <identifiersep> filter metadata <identifiersep> filter , final resource resource , final string entity <identifiersep> id ) { \n <ect>
\t8 public void run ( ) { \n \t9 try { \n \t10 log . info ( <string_literal> ) ; \n \t10 assert <identifiersep> true ( <string_literal> , <identifier> <identifiersep> message <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) ; \n <ect>
\t4 for ( int i = 0 ; i < <identifier> . get <identifiersep> length ( ) ; i ++ ) { \n \t5 <identifier> <identifiersep> node <identifiersep> map attributes = <identifier> . item ( i ) . get <identifiersep> attributes ( ) ; \n \t5 attributes . remove <identifiersep> <identifier> <identifiersep> item ( attribute ) ; } \n \t3 } catch ( x <identifiersep> path <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 return true ; \n \t4 } else { \n \t5 handler . on <identifiersep> input ( ( <identifier> <identifiersep> input ) command ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> , ex ) ; \n \t4 <identifier> <identifiersep> log <identifiersep> <identifier> . <identifier> ( <string_literal> + \n \t5 db . get <identifiersep> name ( ) + <string_literal> ) ; \n \t4 return ; } \n <ect>
\t1 private <identifier> <identifiersep> input <identifiersep> stream <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> file <identifiersep> format <identifier> , element <identifier> <identifiersep> element ) throws <identifier> <identifiersep> exception { \n \t2 source <identifiersep> target <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = v <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> element ) ; \n \t2 int target <identifiersep> index = <identifier> <identifiersep> <identifier> . get <identifiersep> target <identifiersep> unit <identifiersep> index ( ) ; \n \t2 int source <identifiersep> index = <identifier> <identifiersep> <identifier> . get <identifiersep> source <identifiersep> unit <identifiersep> index ( ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> from <identifiersep> store <identifiersep> <identifier> ( message ) ) { \n \t5 log . trace ( <string_literal> , this , message . get <identifiersep> message <identifiersep> id ( ) , message . get <identifiersep> message <identifiersep> id ( ) . get <identifiersep> <identifier> <identifiersep> or <identifiersep> <identifier> <identifiersep> long ( ) ) ; } \n \t3 } else { \n <ect>
\t1 <identifier> <identifiersep> input <identifiersep> format . set <identifiersep> filter <identifiersep> <identifier> ( conf , p ) ; \n \t1 return filter <identifiersep> <identifier> . get ( p ) ; \n \t1 } else { \n \t1 <comment> \n <ect>
\t4 <comment> \n \t4 wait <identifiersep> for <identifiersep> data <identifiersep> <identifier> ( wait <identifiersep> time <identifiersep> <identifier> ) ; } \n \t2 } catch ( <identifier> <identifiersep> service <identifiersep> exception <identifier> ) { \n \t3 log . error ( <string_literal> ) ; \n <ect>
\t2 } catch ( resource <identifiersep> exception e ) { \n \t3 <comment> \n \t3 if ( e . get <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> exception ) { \n \t4 throw ( <identifier> <identifiersep> exception ) e . get <identifiersep> <identifier> ( ) ; } \n <ect>
\t3 if ( null != connection ) { \n \t4 try { \n \t5 connection . close ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception <identifier> <identifiersep> ex ) { \n <ect>
\t5 <identifier> <identifiersep> volume <identifiersep> host <identifiersep> dao . update ( volume <identifiersep> host . get <identifiersep> id ( ) , volume <identifiersep> host ) ; } \n \t4 continue ; } \n \t3 <comment> \n \t3 if ( volume <identifiersep> host . get <identifiersep> <identifier> <identifiersep> state ( ) != status . <identifier> ) { \n <ect>
\t1 this . <identifier> = <identifier> ; \n \t1 this . lock <identifiersep> file = lock <identifiersep> file ; \n \t1 this . lock <identifiersep> file <identifiersep> stream = <identifier> . <identifier> ( lock <identifiersep> file ) ; \n \t1 this . <identifier> <identifiersep> id = <identifier> <identifiersep> id ; \n <ect>
\t4 connection <identifiersep> map . put ( client <identifiersep> key , <identifier> ) ; \n \t4 s <identifiersep> logger . info ( <string_literal> + <identifier> ) ; \n \t4 <identifier> <identifiersep> load <identifiersep> <identifier> = true ; \n \t3 } else if ( ! <identifier> . is <identifiersep> <identifier> <identifiersep> end <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> vo static <identifiersep> <identifier> <identifiersep> <identifier> = \n \t6 new <identifier> <identifiersep> <identifier> <identifiersep> vo ( null , ip . get <identifiersep> id ( ) , 0 , <number_literal> , <identifier> <identifiersep> utils . all <identifiersep> <identifier> . to <identifiersep> string ( ) , <identifier> . get <identifiersep> network <identifiersep> id ( ) , vm . get <identifiersep> account <identifiersep> id ( ) , vm . get <identifiersep> <identifier> <identifiersep> id ( ) , \n \t8 <identifier> . static <identifiersep> <identifier> , null , null , null , null , null ) ; \n \t4 result . add ( static <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t1 public <identifier> <identifiersep> cache ( map conf ) { \n \t2 this . <identifier> <identifiersep> conf = new configuration ( ) ; \n \t2 string <identifier> <identifiersep> host <identifiersep> name = ( string ) conf . get ( config . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 integer <identifier> <identifiersep> port = <identifier> <identifiersep> <identifier> <identifiersep> utils . parse <identifiersep> int ( conf . get ( config . <identifier> <identifiersep> <identifier> <identifiersep> port ) ) ; \n <ect>
\t2 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove <identifiersep> listener ( this ) ; \n \t2 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = null ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t5 data <identifiersep> to <identifiersep> send = new json <identifiersep> object ( ) . put ( <string_literal> , <identifier> ) . to <identifiersep> string ( ) ; \n \t4 } else { \n \t5 logger . warn ( <string_literal> , type ) ; } \n \t3 } else { \n <ect>
\t6 string key = ( string ) e . next <identifiersep> element ( ) ; \n \t6 string value = ( string ) ( ( <identifier> <identifiersep> <identifier> ) <identifier> ) . object <identifiersep> for <identifiersep> key ( key ) ; \n \t6 key <identifiersep> <identifier> . add <identifiersep> object ( new <identifier> <identifiersep> key <identifiersep> value <identifiersep> <identifier> ( key , <identifier> <identifiersep> <identifier> . current <identifiersep> <identifier> ( ) . <identifier> <identifiersep> string <identifiersep> for <identifiersep> key <identifiersep> with <identifiersep> default ( value ) ) ) ; } } \n \t4 <identifier> <identifiersep> <identifier> = key <identifiersep> <identifier> ; } \n <ect>
\t2 } catch ( final exception e ) { \n \t3 logger . error ( e . get <identifiersep> message ( ) , e ) ; } \n \t2 return <identifier> . empty ( ) ; } \n \t1 private static json <identifiersep> web <identifiersep> key <identifiersep> set build <identifiersep> json <identifiersep> web <identifiersep> key <identifiersep> set ( final resource resource ) throws exception { \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> user <identifiersep> list <identifiersep> <identifier> ( json <identifiersep> object source , json <identifiersep> object user <identifiersep> list , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception , json <identifiersep> exception { \n \t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> user <identifiersep> list <identifiersep> <identifier> ( json <identifiersep> object source , json <identifiersep> object user <identifiersep> list , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception , json <identifiersep> exception { \n <ect>
\t3 <comment> \n \t3 if ( ! ( <identifier> instanceof <identifier> <identifiersep> <identifier> ) ) \n \t4 return ; \n <ect>
\t2 <comment> \n \t2 if ( <identifier> == null ) { \n \t3 <identifier> <identifiersep> <identifier> = null ; \n \t3 return ; } \n <ect>
\t2 <string_literal> + <identifier> + <string_literal> \n \t3 + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t1 } finally { \n \t1 if ( ! success ) { \n <ect>
\t3 if ( <identifier> <identifiersep> service . get <identifiersep> <identifier> <identifiersep> config ( ) . is <identifiersep> <identifier> <identifiersep> package <identifiersep> on <identifiersep> failed <identifiersep> <identifier> ( ) ) { \n \t4 try { \n \t5 store <identifiersep> package <identifiersep> as <identifiersep> file ( <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 data <identifiersep> queue . <identifier> ( queue <identifiersep> item ) ; } } \n private static class db <identifiersep> <identifier> <identifiersep> service implements <identifier> { \n \t1 @ <identifier> \n \t1 public void run ( ) { \n <ect>
\t4 for ( <identifier> <identifiersep> <identifier> <identifier> : group <identifiersep> <identifier> ) { \n \t5 <identifier> <identifiersep> <identifier> . add ( <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; } \n \t4 return <identifier> <identifiersep> <identifier> . contains ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 } catch ( io <identifiersep> exception e ) { \n \t6 logger . warn ( <string_literal> , e ) ; \n \t6 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> by ) ; } \n \t5 if ( as <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> <identifiersep> in ( job ) . <identifier> <identifiersep> build ( <identifier> ) ) { \n <ect>
\t4 return ; \n \t3 } else { \n \t4 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> id + <string_literal> + ( ( answer != null ) ? answer . get <identifiersep> <identifier> ( ) : <string_literal> ) ) ; } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 { \n \t4 <identifier> . send <identifiersep> request ( ) ; } \n \t3 catch ( <identifier> <identifiersep> exception e ) \n \t3 { \n <ect>
\t1 object <identifiersep> <identifier> <identifier> = new object <identifiersep> <identifier> ( ) ; \n \t1 input <identifiersep> stream is = \n \t2 exchange <identifiersep> utils . class . get <identifiersep> class <identifiersep> <identifier> ( ) . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ; \n \t1 if ( is == null ) { \n <ect>
\t1 for ( final load <identifiersep> <identifier> <identifiersep> policy <identifiersep> type <identifiersep> <identifier> from : <identifier> <identifiersep> policy <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> type <identifiersep> <identifier> . is <identifiersep> empty ( ) || <identifier> <identifiersep> type <identifiersep> <identifier> . contains ( from . get <identifiersep> policy <identifiersep> type <identifiersep> name ( ) ) ) \n \t2 policy <identifiersep> <identifier> . add ( load <identifiersep> <identifier> <identifiersep> <identifier> . as <identifiersep> policy <identifiersep> type <identifiersep> <identifier> . instance . <identifier> ( from ) ) ; } \n \t1 } catch ( final exception ex ) { \n <ect>
\t6 <comment> \n \t6 process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <number_literal> , <identifier> , <identifier> <identifiersep> to , false , true , <identifier> <identifiersep> type , <identifier> <identifiersep> type ) ; } } \n \t3 } ) ; \n \t2 } else { \n <ect>
\t3 <identifier> . add ( new <identifier> < network <identifiersep> vo , <identifier> <identifiersep> <identifier> > ( <identifier> <identifiersep> network <identifiersep> <identifier> . <identifier> <identifiersep> network ( system <identifiersep> <identifier> , <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( default <identifiersep> network . get <identifiersep> network <identifiersep> <identifier> <identifiersep> id ( ) ) , <identifier> , null , null , false ) . get ( 0 ) , default <identifiersep> <identifier> ) ) ; \n \t3 for ( network <identifiersep> <identifier> <identifiersep> vo <identifier> : <identifier> ) { \n \t4 <identifier> . add ( new <identifier> < network <identifiersep> vo , <identifier> <identifiersep> <identifier> > ( <identifier> <identifiersep> network <identifiersep> <identifier> . <identifier> <identifiersep> network ( system <identifiersep> <identifier> , <identifier> , <identifier> , null , null , false ) . get ( 0 ) , null ) ) ; } \n \t2 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t2 { \n \t3 thread . <identifier> ( <number_literal> ) ; } \n \t2 catch ( interrupted <identifiersep> exception ex ) \n \t2 { \n <ect>
\t3 json . write <identifiersep> end <identifiersep> object ( ) ; \n \t3 object <identifiersep> <identifier> . set <identifiersep> <identifier> ( false ) ; } \n \t2 catch ( io <identifiersep> exception e ) \n \t2 { \n <ect>
\t4 input <identifiersep> stream is = method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) ; \n \t4 map < string , string > values = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( is , \n \t6 new string [ ] { <string_literal> } ) ; \n \t4 if ( values . get ( <string_literal> ) == null ) { \n <ect>
\t2 if ( <identifier> . length == 0 ) { \n \t3 return null ; } \n \t2 string <identifier> <identifiersep> <identifier> = <identifier> [ 0 ] ; \n \t2 string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 for ( <identifier> <identifiersep> action <identifiersep> bean action : <identifier> ) { \n \t3 <comment> \n \t3 <comment> \n \t3 if ( ( num <identifiersep> <identifier> <identifiersep> to <identifiersep> start < 0 ) || ( <identifier> < num <identifiersep> <identifier> <identifiersep> to <identifiersep> start ) ) { \n <ect>
\t6 ? <identifier> . by <identifiersep> provider ( this . provider <identifiersep> class ) . <identifier> ( ) \n \t6 : <identifier> . by <identifiersep> default <identifiersep> provider ( ) . <identifier> ( ) ; \n \t2 if ( boolean <identifiersep> utils . to <identifiersep> boolean ( ignore <identifiersep> xml <identifiersep> configuration ) ) { \n \t3 configuration . ignore <identifiersep> xml <identifiersep> configuration ( ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null || c <identifiersep> <identifier> == null ) { \n \t3 <identifier> <identifiersep> state = <identifier> <identifiersep> <identifier> <identifiersep> exchange . enum <identifiersep> <identifier> <identifiersep> state . <identifier> ; \n \t3 return ; } \n \t2 if ( c <identifiersep> <identifier> . <identifier> <identifiersep> from ( ) < = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> from ( ) ) { \n <ect>
\t1 <identifier> . <identifier> ( ) ; <comment> \n \t1 <identifier> . <identifier> ( ) ; \n \t1 } catch ( <identifier> <identifiersep> connection <identifiersep> <identifier> <identifiersep> exception e ) { \n \t1 success = false ; \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t4 <comment> \n <ect>
\t6 assert ( start <identifiersep> <identifier> > 0 ) ; \n \t6 assert ( end <identifiersep> <identifier> > 0 ) ; \n \t6 <identifier> <identifiersep> base <identifiersep> file <identifiersep> name = line . <identifier> ( start <identifiersep> <identifier> + 1 , end <identifiersep> <identifier> ) ; \n \t5 } else { \n <ect>
\t4 read <identifiersep> write <identifiersep> lock . write <identifiersep> lock ( ) . <identifier> ( ) ; } \n \t3 ++ <identifier> ; \n \t3 if ( <identifier> >= <identifier> ) { \n \t4 string message = <string_literal> + job <identifiersep> id + <string_literal> + storage <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) + <string_literal> ; \n <ect>
\t8 num <identifiersep> <identifier> <identifiersep> <identifier> ++ ; } } \n \t6 <identifier> = new long ( <identifier> . long <identifiersep> value ( ) + <identifier> . long <identifiersep> value ( ) ) ; \n \t5 } while ( ( <identifier> != null ) && ! <identifier> . is <identifiersep> empty ( ) ) ; \n <ect>
\t3 system <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name , <identifier> . name ) ; } \n \t2 catch ( exception e ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( this : : update <identifiersep> <identifier> , <number_literal> , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t5 key <identifiersep> value <identifiersep> <identifier> <identifiersep> <identifier> = message . key <identifiersep> value <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t5 log . debug ( <string_literal> , key <identifiersep> value <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t5 <comment> \n \t5 <identifier> = message . <identifier> ( ) ; \n <ect>
\t4 { \n \t5 return item ; } } } \n \t2 catch ( exception ex ) \n \t2 { \n <ect>
\t6 s <identifiersep> logger . info ( <string_literal> ) ; \n \t5 break ; \n \t4 } catch ( exception e ) { \n <ect>
\t7 <identifier> <identifiersep> count ++ ; \n \t6 } else { \n \t7 <identifier> <identifiersep> count ++ ; } } \n \t4 } catch ( exception e ) { \n <ect>
\t3 <identifier> . <identifier> ( ) . <identifier> ( msg ) ; \n \t3 logger . debug ( <string_literal> , msg . get <identifiersep> <identifier> ( ) ) ; \n \t3 return true ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 public int <identifier> <identifiersep> <identifier> ( ) { \n \t2 log . info ( <string_literal> ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n <ect>
class <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> { \n \t1 @ <identifier> ( <string_literal> ) \n \t1 <identifier> <identifier> <identifiersep> date <identifiersep> for <identifiersep> <identifier> <identifiersep> method ( <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> , bean : <identifier> , <identifier> : string ) { \n \t2 try { \n <ect>
\t2 try { \n \t3 <identifier> = get <identifiersep> property <identifiersep> as <identifiersep> int ( <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { <comment> \n <ect>
\t4 public void run ( ) { \n \t5 log . info ( <string_literal> + runtime . get <identifiersep> runtime ( ) . total <identifiersep> <identifier> ( ) ) ; \n \t5 system . <identifier> ( ) ; \n \t5 system . run <identifiersep> <identifier> ( ) ; \n <ect>
<comment> \n \t2 public boolean set <identifiersep> null <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t3 if ( ! <identifier> <identifiersep> <identifier> ) return false ; \n \t3 handle = method <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( null <identifiersep> <identifier> , 0 , target <identifiersep> type . <identifier> <identifiersep> array ( ) ) ; \n <ect>
\t2 api <identifiersep> context api <identifiersep> context = new api <identifiersep> context ( ) ; \n \t2 api <identifiersep> context . set <identifiersep> configuration <identifiersep> map ( m ) ; \n \t2 string <identifier> <identifiersep> url = session . get <identifiersep> <identifier> <identifiersep> url ( <string_literal> , <identifier> , \n \t4 api <identifiersep> context ) ; \n <ect>
\t1 if ( should <identifiersep> run <identifiersep> next <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , current <identifiersep> <identifier> ) && from <identifiersep> <identifier> != null && msg <identifiersep> id <identifiersep> <identifier> != null ) { \n \t1 <comment> \n \t1 <comment> \n \t1 <comment> \n <ect>
\t3 try { \n \t4 return m <identifiersep> <identifier> . get <identifiersep> lock ( m <identifiersep> <identifier> . read <identifiersep> resource ( m <identifiersep> <identifier> <identifiersep> context <identifiersep> id ) ) . is <identifiersep> <identifier> <identifiersep> by ( \n \t5 m <identifiersep> <identifier> . get <identifiersep> request <identifiersep> context ( ) . get <identifiersep> current <identifiersep> user ( ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 with <identifier> { \n protected <identifier> function : <identifier> <identifiersep> <identifier> <identifiersep> function [ <identifier> , <identifier> , out ] = <identifier> <identifiersep> <identifier> \n protected <identifier> <identifier> <identifiersep> set : <identifier> [ <identifier> <identifiersep> in ] = <identifier> <identifiersep> <identifier> \n <identifier> <identifier> <identifier> ( <identifier> : configuration ) : unit = { \n <ect>
\t3 { server <identifiersep> log . error ( <string_literal> + ex . get <identifiersep> message ( ) , ex ) ; system . <identifier> ( 1 ) ; } } \n \t2 try { \n \t3 server . start ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t4 <identifier> . <identifier> <identifiersep> message ( <identifier> , m <identifiersep> <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 logger . error ( <string_literal> , <identifier> ( ) , e ) ; \n \t3 } catch ( field <identifiersep> exception e ) { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 native <identifiersep> <identifier> . get <identifiersep> instance ( <string_literal> ) ; \n \t3 } catch ( <identifier> <identifiersep> error e ) { \n <ect>
\t2 <identifier> += node <identifiersep> list <identifiersep> to <identifiersep> string ( <identifier> . get <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> name ( <string_literal> ) , <string_literal> ) ; \n \t2 <identifier> += node <identifiersep> list <identifiersep> to <identifiersep> string ( <identifier> . get <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> name ( <string_literal> ) , <string_literal> ) ; \n \t2 try { \n \t3 file file = new file ( file <identifiersep> name ) ; \n <ect>
\t2 return thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ; } \n \t1 } ; \n \t1 <comment> \n \t1 final <identifier> <identifiersep> model model = factory . create ( ) ; \n <ect>
\t1 @ db \n \t1 public boolean remove ( long id ) { \n \t2 <comment> \n \t2 if ( id != null && id . long <identifiersep> value ( ) == <identifier> . root <identifiersep> <identifier> ) { \n <ect>
\t1 public final void <identifier> <identifiersep> <identifier> ( final string . . . <identifier> <identifiersep> values ) { \n \t2 <identifier> ( <identifier> <identifiersep> mode . ignore <identifiersep> url <identifiersep> <identifier> , <identifier> <identifiersep> values ) ; } \n \t1 private void <identifier> ( final <identifier> <identifiersep> mode <identifier> <identifiersep> mode , final string . . . <identifier> <identifiersep> values ) { \n \t2 string <identifier> <identifiersep> url = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> url ( <identifier> <identifiersep> values ) ; \n <ect>
\t3 } else if ( <identifier> . contains ( a <identifiersep> id ) ) { \n \t4 type = <string_literal> ; \n \t3 } else { \n \t4 throw new illegal <identifiersep> state <identifiersep> exception ( a <identifiersep> id + <string_literal> ) ; } \n <ect>
\t5 v . <identifier> <identifiersep> close ( c ) ; \n \t5 s . close ( ) ; \n \t5 v . <identifier> <identifiersep> close ( c ) ; \n \t4 } catch ( throwable e ) { <comment> \n <ect>
\t2 <comment> \n \t2 if ( session <identifiersep> id == null ) { \n \t3 <comment> \n \t3 session <identifiersep> id = java . <identifier> . <identifier> . <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ; \n <ect>
\t3 try { \n \t4 path <identifiersep> utils . <identifier> ( path ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> + path , e ) ; } } \n <ect>
\t3 <identifier> . <identifier> ( <identifier> , <string_literal> , \n \t6 new object [ ] { context <identifiersep> name } , \n \t6 new string [ ] { <string_literal> } ) ; \n \t2 } else { \n <ect>
\t1 throws io <identifiersep> exception , <identifier> <identifiersep> exception { \n \t1 final http <identifiersep> <identifier> <identifiersep> request request = ( http <identifiersep> <identifier> <identifiersep> request ) <identifier> ; \n \t1 final http <identifiersep> <identifier> <identifiersep> response response = ( http <identifiersep> <identifier> <identifiersep> response ) <identifier> ; \n \t1 if ( is <identifiersep> filter <identifiersep> <identifier> ( request ) ) { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + pool . get <identifiersep> id ( ) + <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> storage <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> ) ; } \n \t3 return false ; } \n \t2 if ( total <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < ( total <identifiersep> <identifier> <identifiersep> size + <identifier> <identifiersep> size ) ) { \n <ect>
\t2 map cache <identifiersep> map = cache . to <identifiersep> map ( ) ; \n \t2 if ( cache <identifiersep> map != null ) { \n \t2 set = cache <identifiersep> map . entry <identifiersep> set ( ) ; } } \n \t1 } else { \n <ect>
\t3 logger . error ( <string_literal> + <identifier> . get <identifiersep> channel ( ) , e ) ; \n \t3 <comment> \n \t1 } ) ; \n \t1 } catch ( final exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> ( ( ) - > { \n \t3 try { \n \t3 <identifier> <identifiersep> <identifier> . execute ( ( ) - > next <identifiersep> filter . on <identifiersep> request ( <identifier> , request <identifiersep> context , <identifier> <identifiersep> <identifier> ) ) ; \n \t3 } catch ( <identifier> <identifiersep> execution <identifiersep> exception e ) { \n <ect>
\t3 string <identifier> = <identifier> . to <identifiersep> string ( ) ; \n \t3 string cmd = string . format ( <string_literal> , <identifier> ) ; \n \t3 if ( ! <identifier> <identifiersep> cmd <identifiersep> <identifier> . <identifier> <identifiersep> execute <identifiersep> cmd ( <identifier> <identifiersep> connection , cmd ) ) { \n \t4 throw new configuration <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> ip + <string_literal> + cmd ) ; } \n <ect>
\t4 assert <identifiersep> equals ( <string_literal> + i + <string_literal> + entry + ' ] ' , put <identifiersep> <identifier> ? 1 : null , \n \t5 entry . <identifier> <identifiersep> get <identifiersep> or <identifiersep> <identifier> ( false ) ) ; } \n \t3 if ( cache . is <identifiersep> <identifier> ( ) ) { \n \t4 entry = ( ( grid <identifiersep> <identifier> <identifiersep> cache <identifiersep> <identifier> ) cache ) . <identifier> ( ) . map ( ) . get <identifiersep> entry ( key ) ; \n <ect>
\t1 try { \n \t1 final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( long . parse <identifiersep> long ( <identifier> <identifiersep> id ) ) ; \n \t1 return true ; \n \t1 } catch ( final <identifier> <identifiersep> exception exception ) { \n <ect>
\t3 catch ( null <identifiersep> <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception <identifier> ) \n \t3 { \n \t4 value = <string_literal> ; } \n \t3 config <identifiersep> map . put ( name , value ) ; } \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> context == null ) { \n \t3 log . warn ( <string_literal> , <identifier> <identifiersep> id ) ; \n \t3 return new <identifier> <identifiersep> map < > ( ) ; } \n <comment> \n <ect>
\t7 + exception , exception ) ; } \n \t3 } else { \n \t4 store . remove ( id ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 object <identifiersep> <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> object <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , \n \t3 field <identifiersep> <identifier> ) ; \n \t2 <identifier> = new array <identifiersep> list < object > ( num <identifiersep> <identifier> ) ; } } \n \t1 catch ( exception e ) { \n <ect>
\t3 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> array ; } \n \t2 <identifier> <identifiersep> cache cache = stream . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> cache ( ) ; \n \t2 if ( cache == null ) \n \t2 { \n <ect>
\t3 string status <identifiersep> message = info . get <identifiersep> status <identifiersep> message ( ) ; \n \t4 logger . debug ( <string_literal> + <identifier> ) ; \n <ect>
\t2 if ( ! status ) { \n \t3 log . info ( <string_literal> ) ; \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> list . size ( ) ; i ++ ) { \n \t4 log . info ( i + <string_literal> + <identifier> <identifiersep> list . get ( i ) . to <identifiersep> string ( ) ) ; } \n <ect>
\t1 public default <identifiersep> registered <identifiersep> service <identifiersep> <identifier> <identifiersep> provider ( final string <identifier> <identifiersep> mode ) { \n \t2 super ( <identifier> <identifiersep> mode , false ) ; } \n \t1 @ <identifier> \n \t1 public string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final principal principal , final service service , final registered <identifiersep> service registered <identifiersep> service ) { \n <ect>
\t2 x <identifiersep> log log = x <identifiersep> log . get <identifiersep> log ( get <identifiersep> class ( ) ) ; \n \t2 try { \n \t3 return <identifier> . <identifier> ( ) ; } \n \t2 catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 <identifier> <identifiersep> http <identifiersep> consumer answer = new <identifier> <identifiersep> http <identifiersep> consumer ( this , <identifier> , get <identifiersep> configuration ( ) ) ; \n \t2 <identifier> <identifiersep> consumer ( answer ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> http <identifiersep> server != null ) { \n \t3 answer . set <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> factory ( <identifier> <identifiersep> <identifier> <identifiersep> http <identifiersep> server . get <identifiersep> server <identifiersep> <identifier> <identifiersep> factory ( ) ) ; \n <ect>
\t8 <identifier> . delete <identifiersep> on <identifiersep> <identifier> ( ) ; } } } \n \t4 } catch ( <identifier> <identifiersep> format <identifiersep> exception <identifier> ) { \n \t5 logger . debug ( <string_literal> , input <identifiersep> file . get <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) , <identifier> . get <identifiersep> message ( ) ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t4 <identifier> = 0 ; \n \t4 system . out . <identifier> ( <string_literal> ) ; \n \t3 } catch ( throwable e ) { \n \t4 <comment> \n <ect>
\t5 string next <identifiersep> string = <identifier> . next <identifiersep> string ( ) ; \n \t5 try { \n \t6 return <identifier> . new <identifiersep> instance ( next <identifiersep> string ) ; \n \t5 } catch ( <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception | <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
\t4 + <string_literal> + <identifier> ) ; \n \t2 return info ; } \n \t1 protected void <identifier> <identifiersep> vm ( <identifier> conn , final string vm <identifiersep> name , \n \t3 final string <identifier> ) { \n <ect>
\t3 } else if ( is <identifiersep> <identifier> <identifiersep> local <identifiersep> <identifier> <identifiersep> store ( ) ) { \n \t4 file <identifier> = new file ( get <identifiersep> <identifier> <identifiersep> store <identifiersep> to <identifiersep> <identifier> ( ) ) ; \n \t4 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t4 if ( ! <identifier> . exists ( ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> = <string_literal> ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t1 <comment> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> task ( ) { \n <ect>
\t1 return parse ( builder , connection . get <identifiersep> input <identifiersep> stream ( ) , url . to <identifiersep> string ( ) ) ; } \n private <identifier> parse ( <identifier> <identifiersep> builder builder , input <identifiersep> stream is , \n \t1 string system <identifiersep> id ) throws io <identifiersep> exception , <identifier> <identifiersep> exception { \n \t1 if ( ! <identifier> ) { \n <ect>
\t1 if ( message . get <identifiersep> error <identifiersep> <identifier> ( ) != null ) { \n \t1 try { \n \t2 default <identifiersep> error <identifiersep> <identifier> = message . get <identifiersep> error <identifiersep> <identifier> ( ) . error ( message , t ) ; } \n \t1 catch ( final throwable <identifier> <identifiersep> error ) { \n <ect>
\t3 assert log != null ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t3 <identifier> <identifiersep> session <identifiersep> model = ( entry . get <identifiersep> type ( ) == <identifier> <identifiersep> session . class ) ? <identifier> <identifiersep> <identifier> . get <identifiersep> default <identifiersep> <identifier> <identifiersep> session ( ) : <identifier> <identifiersep> <identifier> . get <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> session ( ) ; \n \t2 } else { \n \t3 <identifier> <identifiersep> session <identifiersep> model = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> session <identifiersep> model ( <identifier> <identifiersep> session <identifiersep> name ) ; } \n \t2 if ( <identifier> <identifiersep> session <identifiersep> model == null ) { \n <ect>
\t2 log . warn ( <string_literal> \n \t4 + <string_literal> + <identifier> + <string_literal> ) ; \n \t2 thread . <identifier> ( <identifier> * <identifier> ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> config <identifiersep> <identifier> = <identifier> . get <identifiersep> manager ( configuration <identifiersep> manager . class ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao = <identifier> . get <identifiersep> dao ( <identifier> <identifiersep> <identifier> <identifiersep> dao . class ) ; \n \t2 <identifier> <identifiersep> host <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( host <identifiersep> <identifier> . class ) ; \n \t2 if ( <identifier> <identifiersep> host <identifiersep> <identifier> == null || ! <identifier> <identifiersep> host <identifiersep> <identifier> . is <identifiersep> set ( ) ) { \n <ect>
\t6 return false ; } \n \t5 if ( <identifier> == <identifier> . <identifier> || <identifier> == <identifier> . <identifier> || <identifier> == <identifier> . <identifier> ) { \n \t6 if ( vm . get <identifiersep> host <identifiersep> id ( ) != null ) { \n \t7 if ( ! send <identifiersep> stop ( <identifier> , <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> <identifiersep> to <identifiersep> stop , false ) ) { \n <ect>
\t9 exchange exchange , channel <identifiersep> <identifier> <identifiersep> listener listener ) { \n \t2 channel <identifiersep> <identifier> <identifier> ; \n \t2 if ( remote <identifiersep> address != null ) { \n <ect>
\t2 <identifier> <identifiersep> manager <identifier> <identifiersep> manager = new <identifier> <identifiersep> manager ( context <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; \n \t2 file <identifier> = new file ( <identifier> . <identifier> <identifiersep> dir ) ; \n \t2 file [ ] files = <identifier> . list <identifiersep> files ( ) ; \n \t2 if ( files == null ) { \n <ect>
\t5 if ( <identifier> <identifiersep> ip <identifiersep> <identifier> ( <identifier> . get <identifiersep> id ( ) , account . account <identifiersep> id <identifiersep> system , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> system <identifiersep> account ( ) ) ) { \n \t6 <identifier> <identifiersep> ip <identifiersep> address <identifiersep> dao . <identifier> <identifiersep> ip <identifiersep> address ( <identifier> . get <identifiersep> id ( ) ) ; \n \t5 } else { \n \t6 success = false ; \n <ect>
\t2 try : \n \t2 vm <identifiersep> <identifier> = self . host <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( list <identifiersep> host [ 0 ] . id , list <identifiersep> host [ 1 ] . id , self . check <identifiersep> vm <identifiersep> <identifier> <identifiersep> on <identifiersep> host ) \n \t2 vm <identifiersep> <identifier> = self . host <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( list <identifiersep> host [ 1 ] . id , list <identifiersep> host [ 0 ] . id , self . check <identifiersep> vm <identifiersep> <identifier> <identifiersep> on <identifiersep> host ) \n \t2 <identifier> exception as e : \n <ect>
\t5 if ( account <identifiersep> id <identifiersep> final != null ) { \n \t6 <identifier> <identifiersep> resource . set <identifiersep> account <identifiersep> id ( account <identifiersep> id <identifiersep> final ) ; } \n \t5 <identifier> <identifiersep> resource = <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> ( <identifier> <identifiersep> resource ) ; \n \t4 } catch ( exception e ) { \n <ect>
private void close ( input <identifiersep> stream is ) { \n \t1 try { \n \t1 is . close ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 if ( <identifier> != null ) <identifier> . close ( ) ; \n \t3 } catch ( io <identifiersep> exception ex ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> debug ( ) ) \n <ect>
\t1 throws io <identifiersep> exception \n { \n \t1 if ( <identifier> . length < <number_literal> ) \n \t1 { \n <ect>
\t3 response = new response ( request , <identifier> [ 0 ] , <identifier> <identifiersep> node <identifiersep> id , - 1 ) ; } \n \t2 try { \n \t3 <identifier> . send ( response . to <identifiersep> bytes ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> channel <identifiersep> exception e ) { \n <ect>
\t4 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map . contains <identifiersep> key ( <identifier> <identifiersep> name . get <identifiersep> <identifier> ( ) ) ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map . put ( <identifier> <identifiersep> name . get <identifiersep> <identifier> ( ) , new <identifier> <identifiersep> list < > ( ) ) ; } \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map . get ( <identifier> <identifiersep> name . get <identifiersep> <identifier> ( ) ) . add ( <identifier> <identifiersep> name ) ; } } \n \t2 catch ( <identifier> <identifiersep> exception | sql <identifiersep> exception e ) { \n <ect>
public boolean <identifier> <identifiersep> all <identifiersep> files ( ) { \n \t1 return <identifier> <identifiersep> all <identifiersep> files ; } \n private void <identifier> <identifiersep> <identifier> ( ) { \n \t1 if ( ! <identifier> <identifiersep> all <identifiersep> files ) { \n <ect>
private void update <identifiersep> <identifier> ( update <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> message ) { \n \t1 <identifier> <identifiersep> <identifier> <identifier> = message . get <identifiersep> <identifier> ( ) ; \n \t1 string job <identifiersep> id = message . get <identifiersep> job <identifiersep> id ( ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 is <identifiersep> <identifier> <identifiersep> <identifier> . set ( true ) ; } \n \t1 public void <identifier> <identifiersep> <identifier> ( ) \n \t1 { \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception <identifier> <identifiersep> exception ) { \n \t3 <comment> \n \t3 response . set <identifiersep> status ( <identifier> <identifiersep> exception . get <identifiersep> status ( ) ) ; \n \t2 } catch ( json <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t5 result . add ( <identifier> <identifiersep> filter ) ; } } } \n \t2 return result ; } \n \t1 private long get <identifiersep> query <identifiersep> filter <identifiersep> <identifier> ( set < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > filter <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 long filter <identifiersep> <identifier> = 0 ; \n <ect>
\t3 <identifier> . system <identifiersep> user ( ) . get <identifiersep> <identifier> <identifiersep> id ( ) . equals ( user <identifiersep> id ) || \n \t3 <identifier> . <identifier> <identifiersep> system <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> id ( ) . equals ( user <identifiersep> id ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t2 <comment> \n <ect>
\t2 first <identifiersep> <identifier> . read <identifiersep> bytes ( read ) ; \n \t2 put <identifiersep> queue . put ( <identifier> <identifiersep> data <identifiersep> message . data <identifiersep> message ( read ) ) ; \n \t2 <comment> \n \t1 } catch ( exception ex ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> m <identifiersep> bean ( <string_literal> , <string_literal> + <identifier> . get <identifiersep> id ( ) ) ; \n \t4 } catch ( final exception e ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + e . to <identifiersep> string ( ) ) ; } \n \t3 } else { \n <ect>
\t2 default <identifiersep> config . set <identifiersep> thread <identifiersep> model ( <identifier> <identifiersep> thread <identifiersep> model . get <identifiersep> instance ( <string_literal> ) ) ; \n \t2 <identifier> . <identifier> ( this . <identifier> , new server <identifiersep> session <identifiersep> handler ( cache , <identifier> <identifiersep> version , <identifier> , <identifier> <identifiersep> time ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> factory <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> factory ( ) ; \n \t2 <identifier> . get <identifiersep> filter <identifiersep> <identifier> ( ) . add <identifiersep> first ( <string_literal> , new <identifier> <identifiersep> <identifier> <identifiersep> filter ( <identifier> ) ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> snapshot ( snapshot <identifiersep> info snapshot , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < create <identifiersep> cmd <identifiersep> result > <identifier> ) { \n \t2 create <identifiersep> cmd <identifiersep> result result = null ; \n \t2 try { \n <ect>
\t1 @ <identifier> \n \t1 configuration <identifiersep> dao <identifier> <identifiersep> config <identifiersep> dao ; \n \t1 @ <identifier> \n \t1 protected list < storage <identifiersep> pool > <identifier> ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> vm <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> list <identifier> , int return <identifiersep> <identifier> <identifiersep> to ) { \n <ect>
\t2 <identifier> <identifiersep> context . add <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> ( new <identifier> <identifiersep> http <identifiersep> <identifier> ( ) ) , <string_literal> ) ; \n \t2 try { \n \t3 server . start ( ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 logger . debug ( <string_literal> + <identifier> <identifiersep> builder <identifiersep> factory . new <identifiersep> instance ( ) . get <identifiersep> class ( ) ) ; \n \t2 try { \n \t3 class < ? extends object > <identifier> <identifiersep> version = class . for <identifiersep> name ( <string_literal> ) ; \n <ect>
\t4 log . warn ( <string_literal> , <identifier> ) ; } \n \t3 catch ( command <identifiersep> exception <identifier> ) { \n \t4 <identifier> <identifiersep> msg = <identifier> . get <identifiersep> message ( ) ; \n \t4 <identifier> <identifiersep> code = <identifier> . get <identifiersep> error <identifiersep> code ( ) . to <identifiersep> string ( ) ; \n <ect>
\t5 create <identifiersep> index <identifiersep> request . <identifier> ( <identifier> . get ( index ) ) ; \n \t5 logger . info ( <string_literal> , index , <identifier> ) ; \n \t5 map < string , string > <identifier> = get <identifiersep> <identifier> ( client , index , \n \t7 <identifier> != null ? new <identifier> <identifiersep> set < > ( <identifier> ) : null ) ; \n <ect>
\t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 <identifier> = <identifier> + <string_literal> ; \n \t3 json = <identifier> + <string_literal> + i ; \n \t3 <identifier> = <identifier> + <string_literal> + i + <string_literal> ; \n <ect>
\t4 <identifier> <identifiersep> entry <identifier> = <identifier> . next <identifiersep> element ( ) ; \n \t4 add <identifiersep> <identifier> ( new <identifier> <identifiersep> entry ( file , <identifier> . get <identifiersep> name ( ) , <identifier> . get <identifiersep> size ( ) ) ) ; } \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 final list < string > nodes ; \n \t2 logger . info ( <string_literal> + num <identifiersep> nodes + <string_literal> ) ; \n \t2 nodes = <identifier> <identifiersep> cluster ( ) . start <identifiersep> nodes ( num <identifiersep> nodes , \n \t3 <identifier> . builder ( ) . put ( index <identifiersep> <identifier> . <identifier> <identifiersep> max <identifiersep> <identifier> . get <identifiersep> key ( ) , <identifier> <identifiersep> int <identifiersep> <identifier> ( <number_literal> , <number_literal> ) ) . build ( ) ) ; \n <ect>
\t1 public static final int connection <identifiersep> timeout = client <identifiersep> base . connection <identifiersep> timeout ; \n \t1 private final <identifier> <identifiersep> base <identifier> = new <identifier> <identifiersep> base ( ) ; \n \t1 @ <identifier> \n \t1 public void set <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t5 } else { \n \t6 log . info ( <string_literal> ) ; \n \t6 return 1 ; } \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 while ( file <identifiersep> <identifier> . has <identifiersep> next ( ) ) { \n \t1 try { \n \t2 <identifier> . add ( ( ( file ) file <identifiersep> <identifier> . next ( ) ) . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t6 string name = <identifier> <identifiersep> <identifier> . get <identifiersep> name ( ) ; \n \t6 <comment> \n \t6 if ( name . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t7 <comment> \n <ect>
\t4 <identifier> . set <identifiersep> value ( i <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> table <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> metadata <identifiersep> url <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> table ( table <identifiersep> name . value <identifiersep> of ( <identifier> <identifiersep> name <identifiersep> list [ 0 ] ) , <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> table ( table <identifiersep> name . value <identifiersep> of ( <identifier> <identifiersep> name <identifiersep> list [ 0 ] ) ) ; } \n \t2 } else { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 update <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> filter ) ; \n \t4 try { \n <ect>
\t3 for ( <identifier> <identifiersep> store <identifier> : <identifier> ) { \n \t4 output <identifiersep> <identifier> . add ( <identifier> . get <identifiersep> s <identifiersep> file ( ) . get <identifiersep> file <identifiersep> name ( ) ) ; } \n \t3 conf . set ( <identifier> <identifiersep> property . map <identifiersep> output <identifiersep> <identifier> . to <identifiersep> string ( ) , load <identifiersep> <identifier> . <identifier> ( output <identifiersep> <identifier> , <string_literal> ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t7 <identifier> <identifiersep> session . get <identifiersep> remote <identifiersep> address ( ) , \n \t7 <identifier> <identifiersep> session . get <identifiersep> local <identifiersep> address ( ) ) ; \n \t5 return ; } \n \t3 } else { \n <ect>
\t2 private void <identifier> ( ) { \n \t3 try { \n \t4 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) . <identifier> ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . <identifier> ( <string_literal> ) ; } \n \t3 string <identifier> = org . apache . <identifier> . <identifier> . string <identifiersep> utils . <identifier> <identifiersep> end ( <identifier> . to <identifiersep> string ( ) , <string_literal> ) ; \n \t3 <identifier> <identifiersep> connection . <identifier> ( null , <number_literal> , <number_literal> ) ; \n \t3 if ( ! <identifier> <identifiersep> connection . <identifier> <identifiersep> with <identifiersep> password ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> password ) ) { \n <ect>
\t4 return ; } \n \t3 try { \n \t4 channel . send ( new message ( null , new request ( request . put , <identifier> , data ) ) ) ; } \n \t3 catch ( exception ex ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t6 db . <identifier> <identifiersep> <identifier> ( ) ; \n \t6 db . get <identifiersep> <identifier> ( ) . close ( ) ; \n \t6 db = null ; \n \t5 } catch ( exception e ) { \n <ect>
\t3 <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t3 if ( <identifier> . next ( ) ) { \n \t4 return <identifier> . get <identifiersep> string ( 1 ) ; } \n \t2 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t2 if ( status != status . <identifier> <identifiersep> <identifier> ) { \n \t3 return null ; } \n \t2 return <identifier> . get <identifiersep> object <identifiersep> stream ( <identifier> , <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) , <identifier> ) ; } \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> error ( ) { \n <ect>
<comment> \n \t1 public boolean check <identifiersep> <identifier> <identifiersep> <identifier> ( final http <identifiersep> <identifier> <identifiersep> request request , final string name ) { \n \t2 final string <identifier> = request . get <identifiersep> <identifier> ( name ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> = null ; \n \t4 if ( host != null ) { \n \t5 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> <identifier> <identifiersep> type <identifiersep> and <identifiersep> version ( host . get <identifiersep> <identifier> <identifiersep> type ( ) , host . get <identifiersep> <identifier> <identifiersep> version ( ) ) ; \n \t4 } else { \n <ect>
<comment> \n \t1 public void <identifier> ( final map < string , object > configuration ) { \n \t2 <comment> \n <ect>
\t1 # <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> value is in bytes . <identifier> , <identifier> it by <number_literal> . \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size = ( long ( ( 0 . <number_literal> * <identifier> <identifiersep> <identifier> <identifiersep> thread <identifiersep> for <identifiersep> <identifier> ) / <number_literal> ) ) * <identifier> <identifiersep> to <identifiersep> bytes \n \t1 # <identifier> value for <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n \t1 <identifier> <identifiersep> <identifier> = max ( total <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> node * 0 . <number_literal> , total <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> node - self . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ) \n <ect>
\t5 : load <identifiersep> <identifier> ; <comment> \n \t3 <identifier> <identifiersep> load <identifiersep> by ( load <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> next <identifiersep> <identifier> ( load <identifiersep> <identifier> ) ) { \n <ect>
\t4 log . debug ( <string_literal> + r . get <identifiersep> id ( ) ) ; \n \t4 <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( r . get <identifiersep> id ( ) , event . host <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> on <identifiersep> host ( ( host <identifiersep> vo ) r , true ) ; \n \t3 } catch ( exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> message get <identifiersep> value <identifiersep> message ( ) { \n \t2 if ( is <identifiersep> get <identifiersep> <identifier> == false ) { \n <ect>
\t5 ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ? boolean . true : boolean . false ) , \n \t5 ( <identifier> <identifiersep> <identifier> ( ) ? boolean . true : boolean . false ) \n \t3 } ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t2 network <identifiersep> utils . ip <identifiersep> port <identifiersep> <identifier> current <identifiersep> listener = properties . get <identifiersep> first ( ) ; \n \t2 system . set <identifiersep> property ( <string_literal> , current <identifiersep> listener . get <identifiersep> <identifier> <identifiersep> ip ( ) ) ; \n \t2 string <identifier> = properties . get <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> provider <identifiersep> config . set <identifiersep> properties ( <identifier> ) ; \n <ect>
\t3 result . <identifier> = ( table <identifiersep> not <identifiersep> found <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t4 else \n \t5 logger . trace ( <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t5 return result <identifiersep> <identifier> * <number_literal> ; \n \t4 } else { \n \t5 throw new <identifier> <identifiersep> store <identifiersep> exception ( <string_literal> ) ; } \n \t3 } catch ( exception ex ) { \n <ect>
\t7 logger . debug ( <string_literal> ) ; \n \t7 message <identifiersep> handler . send <identifiersep> set <identifiersep> group <identifiersep> id ( <identifier> <identifiersep> <identifier> , group <identifiersep> id , this ) ; \n \t7 state = <identifier> <identifiersep> <identifier> <identifiersep> state . group <identifiersep> id <identifiersep> <identifier> ; } \n \t5 } else { \n <ect>
\t1 if ( null != <identifier> ) { \n \t2 try { \n \t2 <identifier> . close ( ) ; \n \t2 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t3 public void <identifier> ( ) throws exception { \n \t4 from ( <string_literal> ) . <identifier> ( <identifier> ( <string_literal> ) ) ; \n \t4 from ( <string_literal> ) . process ( new <identifier> ( ) { \n \t5 public void process ( exchange exchange ) throws exception { \n <ect>
\t2 <identifier> <identifier> = null ; \n \t2 try { \n \t3 file file = <identifier> <identifiersep> builder <identifiersep> <identifier> . find <identifiersep> <identifier> <identifiersep> properties ( new file ( root <identifiersep> path ) ) ; \n \t3 if ( file == null ) { \n <ect>
\t3 logger . debug ( <string_literal> \n \t5 + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t2 if ( ! <identifier> <identifiersep> filter . is <identifiersep> <identifier> <identifiersep> <identifier> ( filter ) ) { \n \t3 storage <identifiersep> <identifier> <identifiersep> level = storage <identifiersep> <identifier> <identifiersep> level . no <identifiersep> <identifier> ; \n <ect>
\t6 <identifier> = this . <identifier> . get <identifiersep> <identifier> ( this . <identifier> ) ; } \n \t5 this . <identifier> ++ ; \n \t5 return <identifier> ; } \n \t4 catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t6 log . error ( e . get <identifiersep> message ( ) , e ) ; } \n \t5 session <identifiersep> <identifier> . remove ( ) ; } } \n \t3 <comment> \n \t3 if ( <identifier> > <identifier> ) { \n <ect>
\t2 <identifier> . on <identifiersep> error ( e ) ; } } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> success ( <identifier> result ) \n \t1 { \n <ect>
\t2 } catch ( interrupted <identifiersep> exception <identifier> ) { \n \t3 logger . error ( <string_literal> + store <identifiersep> name , <identifier> ) ; \n \t3 return false ; \n \t2 } catch ( execution <identifiersep> exception <identifier> ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 grid <identifiersep> node node = <identifier> . <identifier> ( ) . node ( e . get <identifiersep> key ( ) ) ; \n \t4 if ( node != null ) \n \t5 nodes . put ( node . id ( ) , node ) ; \n <ect>
\t6 snapshot <identifiersep> store <identifiersep> <identifier> . set <identifiersep> string ( <number_literal> , <identifier> <identifiersep> path ) ; \n \t6 snapshot <identifiersep> store <identifiersep> <identifier> . set <identifiersep> long ( <number_literal> , <identifier> <identifiersep> id ) ; \n \t6 snapshot <identifiersep> store <identifiersep> <identifier> . execute <identifiersep> update ( ) ; } \n \t4 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 protected <identifiersep> <identifier> = <identifier> <identifiersep> text ( protected <identifiersep> <identifier> ) ; \n \t3 protected <identifiersep> password = <identifier> <identifiersep> text ( protected <identifiersep> password ) ; \n \t3 if ( protected <identifiersep> <identifier> == null || protected <identifiersep> password == null ) { \n \t4 logger . error ( <string_literal> ) ; \n <ect>
\t2 } else { \n \t3 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> += <identifier> <identifiersep> <identifier> ; } } \n \t2 write <identifiersep> <identifier> <identifiersep> size = ( int ) ( <identifier> <identifiersep> <identifier> / num <identifiersep> <identifier> ) ; } } \n <ect>
\t8 } else if ( m <identifiersep> device instanceof set <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t9 ( ( set <identifiersep> <identifier> <identifiersep> <identifier> < ? > ) m <identifiersep> device ) . set <identifiersep> value ( ( ( <identifier> <identifiersep> type ) command ) . to <identifiersep> <identifier> <identifiersep> <identifier> ( ) , \n <number_literal> provider . get <identifiersep> device <identifiersep> options ( item <identifiersep> name ) ) ; \n \t8 } else { \n <ect>
\t6 } catch ( exception e ) { \n \t7 log . error ( e . get <identifiersep> message ( ) ) ; \n \t7 exchange . get <identifiersep> out ( ) . set <identifiersep> body ( null ) ; } } \n \t5 private void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) throws exception { \n <ect>
<comment> \n \t1 private void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> result s , int num ) { \n \t2 if ( ignore <identifiersep> <identifier> ( s ) ) { \n <ect>
\t3 return true ; } \n \t2 string <identifier> <identifiersep> path ; \n \t2 vm <identifiersep> template <identifiersep> vo <identifier> = <identifier> <identifiersep> template <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> <identifiersep> id ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t6 log . debug ( <string_literal> + <identifier> ) ; } \n \t5 store ( new <identifier> <identifiersep> <identifier> <identifiersep> command ( ) . set <identifiersep> transaction <identifiersep> info ( transaction <identifiersep> id <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> local ( <identifier> ) ) , false , null , null ) ; } \n \t4 for ( transaction <identifiersep> id <identifier> : to <identifiersep> <identifier> ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 boolean is <identifiersep> system <identifiersep> vm = ( vm . get <identifiersep> type ( ) == type . <identifier> <identifiersep> <identifier> || vm . get <identifiersep> type ( ) == type . <identifier> <identifiersep> storage <identifiersep> vm ) ; \n \t4 try { \n \t5 success = <identifier> <identifiersep> static <identifiersep> <identifier> ( ip . get <identifiersep> id ( ) , vm . get <identifiersep> id ( ) , is <identifiersep> system <identifiersep> vm ) ; \n \t4 } catch ( network <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t5 socket <identifiersep> manager . <identifier> <identifiersep> socket <identifiersep> manager ( ) ; \n \t5 <identifier> <identifiersep> log . warn ( <string_literal> + group <identifiersep> name ) ; \n \t4 } catch ( exception e ) { \n \t5 <comment> \n <ect>
\t2 p . load ( properties ) ; \n \t2 final in <identifiersep> <identifier> <identifiersep> directory <identifiersep> server <identifiersep> config config = \n \t3 new in <identifiersep> <identifier> <identifiersep> directory <identifiersep> server <identifiersep> config ( p . get <identifiersep> property ( <string_literal> ) ) ; \n \t2 config . add <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( p . get <identifiersep> property ( <string_literal> ) , p . get <identifiersep> property ( <string_literal> ) ) ; \n <ect>
\t1 public void <identifier> <identifiersep> cluster ( instance <identifiersep> id instance <identifiersep> id , uri <identifier> ) \n \t1 { \n \t2 if ( <identifier> <identifiersep> context . is <identifiersep> failed <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( instance <identifiersep> id ) ) \n \t2 { \n <ect>
\t3 result += job . get <identifiersep> <identifier> ( ) ; } \n \t2 return result ; } \n \t1 private void <identifier> ( in <identifiersep> <identifier> <identifiersep> job job ) throws illegal <identifiersep> state <identifiersep> exception , io <identifiersep> exception { \n \t2 if ( <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
<comment> \n \t1 public void <identifier> ( final int <identifier> ) { \n <ect>
\t8 . <identifier> ( this . <identifier> <identifiersep> info . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ( ) ) \n \t8 . root <identifiersep> <identifier> ( this . <identifier> <identifiersep> info . get <identifiersep> root <identifiersep> <identifier> ( ) ) \n \t8 . create ( ) ; \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 assert <identifiersep> <identifier> ( client . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> put <identifiersep> <identifier> ( <string_literal> ) \n \t4 . set <identifiersep> type ( <string_literal> ) . set <identifiersep> <identifier> ( <identifier> . builder ( ) \n \t6 . put ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> path ( ) ) ) ) ; \n <ect>
\t4 int <identifier> <identifiersep> count = 0 ; \n \t4 while ( <identifier> <identifiersep> count < <identifier> <identifiersep> message <identifiersep> count ) { \n \t5 message message = consumer . <identifier> ( <number_literal> ) ; \n \t5 if ( message == null ) { \n <ect>
\t9 s <identifiersep> logger . debug ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t9 for ( <identifier> <identifiersep> resource <identifiersep> vo <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t10 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> . get <identifiersep> id ( ) ) ) { \n <number_literal> s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> id ) ; } } } \n <ect>
\t2 <identifier> = ( <identifier> <identifiersep> <identifier> ) <identifier> ; \n \t1 } else { \n \t2 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <identifier> , <string_literal> ) ; } } \n \t1 if ( <identifier> != null ) { \n <ect>
\t3 try { \n \t4 this . <identifier> . <identifier> ( <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> client <identifiersep> xml ) ; \n \t4 this . <identifier> . stop ( <identifier> <identifiersep> with <identifiersep> remote <identifiersep> <identifier> <identifiersep> connection <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 db . create <identifiersep> <identifier> <identifiersep> set ( <string_literal> + <string_literal> + <identifier> <identifiersep> store . get <identifiersep> name ( ) ) . <identifier> ( ) ; \n \t1 long start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 for ( int i = 0 ; i < <identifier> <identifiersep> store . get <identifiersep> size ( ) ; i ++ ) { \n \t1 queue <identifiersep> set . add ( get ( i ) ) ; } \n <ect>
\t1 public result <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> date ( ) throws interrupted <identifiersep> exception { \n \t2 lock . lock ( ) ; \n \t2 try { \n \t3 if ( ! stop <identifiersep> <identifier> ) { \n <ect>
\t2 return new array <identifiersep> list < > ( ) ; } \n \t1 public boolean update <identifiersep> group ( final <identifier> <identifiersep> group group ) { \n \t2 if ( group == null ) { \n \t3 return false ; } \n <ect>
\t2 boolean <identifier> = <identifier> <identifiersep> current <identifiersep> <identifier> . remove ( address ) ; \n \t3 <identifier> = true ; \n \t2 if ( <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t4 string <identifier> <identifiersep> name = <string_literal> + value ; \n \t4 assert . assert <identifiersep> false ( <identifier> . <identifier> ( content <identifiersep> name . from <identifiersep> native ( <identifier> <identifiersep> name ) , null ) ) ; } \n \t2 } catch ( <identifier> <identifiersep> content <identifiersep> name <identifiersep> string <identifiersep> exception e ) { \n \t3 assert . <identifier> ( e . get <identifiersep> message ( ) ) ; } \n <ect>
\t2 string response = <identifier> . get ( <string_literal> ) ; \n \t2 if ( user == null || <identifier> == null || <identifier> == null || <identifier> == null || \n \t3 uri == null || <identifier> == null || <identifier> == null || response == null ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
static void <identifier> <identifiersep> test <identifiersep> list <identifiersep> logger ( final int <identifier> ) { \n \t1 final logger logger = logger <identifiersep> context . get <identifiersep> logger ( logger <identifiersep> name ) ; \n \t1 long start = system . <identifier> <identifiersep> time ( ) ; \n \t1 for ( int i = 0 ; i < <identifier> ; i ++ ) { \n <ect>
\t1 string <identifier> <identifiersep> id = null ; \n \t1 try { \n \t2 <identifier> <identifiersep> id = input . get <identifiersep> instance <identifiersep> type ( ) . <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> id ( ) ; \n \t1 } catch ( final no <identifiersep> such <identifiersep> element <identifiersep> exception ex ) { \n <ect>
\t3 int <identifier> = wait <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , 0 ) ; \n \t3 log . debug ( <string_literal> + integer . to <identifiersep> string ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) + <string_literal> + integer . to <identifiersep> string ( <identifier> ) + <string_literal> ) ; \n \t3 thread . <identifier> ( <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 log . debug ( <string_literal> + snapshot <identifiersep> id + <string_literal> ) ; \n \t1 try { \n \t1 <identifier> <identifiersep> manager . delete <identifiersep> snapshot ( snapshot <identifiersep> id , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t10 <identifier> <identifiersep> transport ( transport ) ; } } \n \t8 } else { \n \t9 <identifier> . add ( <identifier> ) ; } } \n \t6 } catch ( exception e ) { \n <ect>
\t5 if ( i != <identifier> . size ( ) - 1 ) \n \t6 <identifier> . <identifier> ( <string_literal> ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n \t5 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n <ect>
\t1 protected void handle <identifiersep> message <identifiersep> <identifier> ( message < ? > message ) { \n \t2 object <identifier> = message . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifier> = <identifier> . <identifier> . <identifier> . native . get ( <identifier> . class ) ; \n \t4 return new native <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } catch ( native <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t6 build <identifiersep> event <identifiersep> attribute <identifiersep> map ( authentication . get <identifiersep> principal ( ) , service , provider ) ) ; \n \t4 return collection <identifiersep> utils . <identifier> <identifiersep> set ( event ) ; } \n \t3 logger . warn ( <string_literal> , provider <identifiersep> found . get ( ) ) ; \n \t3 return null ; } \n <ect>
public map < string , string > get <identifiersep> configuration <identifiersep> <identifier> ( cluster cluster , \n <number_literal> config <identifiersep> <identifier> <identifiersep> <identifier> config <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t1 map < string , string > config <identifiersep> <identifier> = new <identifier> <identifiersep> map < > ( ) ; \n \t1 if ( id == null || id . is <identifiersep> empty ( ) ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t4 if ( <identifier> - channel . get <identifiersep> last <identifiersep> <identifier> ( ) > time <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t5 <comment> \n \t5 long last <identifiersep> <identifier> = ( long ) channel . get <identifiersep> property ( connection <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n \t5 if ( last <identifiersep> <identifier> != null && <identifier> - last <identifiersep> <identifier> > timeout ) { \n <ect>
\t6 filter <identifier> <identifiersep> filter = <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> name . get ( filter <identifiersep> <identifier> . get <identifiersep> filter <identifiersep> name ( ) ) ; \n \t6 if ( <identifier> <identifiersep> filter != null ) { \n \t7 <identifier> . add ( <identifier> <identifiersep> filter ) ; \n \t6 } else { \n <ect>
\t4 int test <identifiersep> <identifier> = <identifier> <identifiersep> state <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> id , <identifier> ) ; \n \t4 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) . equals ( <identifier> <identifiersep> id ) ) { \n \t5 if ( test <identifiersep> <identifier> < current <identifiersep> <identifier> ) { \n \t6 <comment> \n <ect>
\t3 <identifier> <identifiersep> <identifier> = 0 ; \n \t3 total <identifiersep> <identifier> = 0 ; \n \t3 int <identifier> <identifiersep> <identifier> = 0 ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 for ( string object : <identifier> ) { \n \t4 list < <identifier> <identifiersep> data > list = null ; \n \t4 byte [ ] bytes = <identifier> <identifiersep> client . read <identifiersep> object ( <identifier> , object ) ; \n \t4 if ( ( list = read ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( bytes ) ) ) == null ) { \n <ect>
\t4 <string_literal> + e . get <identifiersep> message ( ) + \n \t4 ( <identifier> . is <identifiersep> <identifier> ( ) ? <string_literal> : <string_literal> ) \n \t3 ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t8 <identifier> <identifiersep> resource <identifiersep> value resource <identifiersep> value = null ; \n \t8 try { \n \t9 resource <identifiersep> value = <identifier> . resource <identifiersep> query ( resource <identifiersep> id ) ; \n \t8 } catch ( <identifier> <identifiersep> <identifier> e ) { \n <ect>
\t2 table <identifiersep> utils . create <identifiersep> table <identifiersep> if <identifiersep> not <identifiersep> exists ( <identifier> <identifiersep> <identifier> <identifiersep> db <identifiersep> client , request ) ; \n \t2 logger . debug ( <string_literal> , request . get <identifiersep> table <identifiersep> name ( ) ) ; \n \t2 table <identifiersep> utils . wait <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> db <identifiersep> client , request . get <identifiersep> table <identifiersep> name ( ) ) ; \n \t2 final <identifier> <identifiersep> table <identifiersep> request <identifier> <identifiersep> table <identifiersep> request = new <identifier> <identifiersep> table <identifiersep> request ( ) . with <identifiersep> table <identifiersep> name ( request . get <identifiersep> table <identifiersep> name ( ) ) ; \n <ect>
\t2 public object get <identifiersep> state ( ) { \n \t3 return state ; } \n \t2 <comment> \n \t2 @ <identifier> public collection < ? extends grid <identifiersep> <identifier> <identifiersep> job > <identifier> ( int grid <identifiersep> size , object <identifier> ) { \n <ect>
\t2 exchange answer <identifiersep> json = <identifier> . send ( <string_literal> , ex - > { \n \t3 ( ( data <identifiersep> type <identifiersep> <identifier> ) ex . get <identifiersep> in ( ) ) . set <identifiersep> body ( <identifier> <identifiersep> json , new data <identifiersep> type ( <string_literal> ) ) ; \n \t2 } ) ; \n \t2 thread . <identifier> ( <number_literal> ) ; \n <ect>
\t2 log . info ( <string_literal> , <identifier> , <identifier> , <identifier> . get <identifiersep> class ( ) ) ; } \n \t1 protected void test <identifiersep> data <identifiersep> format ( string data <identifiersep> format ) throws exception { \n \t2 test <identifiersep> data <identifiersep> format ( <string_literal> + data <identifiersep> format , data <identifiersep> format ) ; } \n \t1 protected void test <identifiersep> data <identifiersep> format ( string <identifier> <identifiersep> <identifier> , string data <identifiersep> format ) throws exception { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = boolean . parse <identifiersep> boolean ( <identifier> . get ( <string_literal> ) ) ; \n \t2 <identifier> <identifiersep> <identifier> = <identifier> . get ( config . <identifier> <identifiersep> storage <identifiersep> <identifier> . key ( ) ) ; \n \t2 string <identifier> = <identifier> . get ( <string_literal> ) ; \n \t2 if ( ! <string_literal> . equals <identifiersep> ignore <identifiersep> case ( <identifier> ) ) { \n <ect>
\t2 <identifier> = <identifier> . <identifier> ( 1 ) ; \n \t2 try { \n \t3 o = java . <identifier> . <identifier> . <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( java . <identifier> . <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t5 if ( local . is <identifiersep> <identifier> ( remote ) == false ) { \n \t6 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n \t6 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + local + <string_literal> + remote , null ) ; } } \n \t3 } else { \n <ect>
\t1 public void <identifier> <identifiersep> <identifier> ( ) { \n \t2 <comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t4 config , \n \t4 io <identifiersep> <identifier> , \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> utils . address <identifiersep> <identifier> . no <identifiersep> address <identifiersep> <identifier> ) ; \n \t3 <comment> \n <ect>
\t2 if ( all <identifiersep> <identifier> . size ( ) > 0 ) \n \t2 { \n \t3 <comment> \n \t3 try { \n <ect>
\t4 final string network = <identifier> <identifiersep> address . get ( 0 ) . <identifier> ( ) ; \n \t4 final string <identifier> = <identifier> <identifiersep> address . get ( 1 ) . <identifier> ( ) ; \n \t4 try { \n \t5 this . <identifier> <identifiersep> network <identifiersep> <identifier> = <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> name ( network ) ; \n <ect>
\t4 lock <identifiersep> map . put ( <identifier> , <identifier> ) ; \n \t3 } finally { \n \t4 entry <identifiersep> lock . <identifier> ( ) ; } \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t5 throwable exception = e ; \n \t5 if ( e instanceof <identifier> <identifiersep> target <identifiersep> exception ) { \n \t6 exception = e . get <identifiersep> <identifier> ( ) ; } \n <ect>
\t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> client <identifiersep> <identifier> . <identifier> <identifiersep> in <identifiersep> <identifier> ( <string_literal> , <string_literal> , <string_literal> ) . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t4 break ; } \n \t3 else { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t4 <comment> \n <ect>
\t2 network <identifiersep> <identifier> <identifier> = <identifier> ( <string_literal> , <string_literal> ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> name ( <string_literal> ) ; \n \t2 <identifier> . start ( ) ; \n \t2 if ( ! <identifier> ) { \n <ect>
\t6 logger . info ( <string_literal> + delete <identifiersep> <identifier> <identifiersep> <identifier> \n \t9 + <string_literal> + file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t6 thread . <identifier> ( delete <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
<comment> \n \t2 public void message <identifiersep> <identifier> <identifiersep> failed ( message <identifiersep> <identifier> <identifiersep> failed <identifiersep> event <identifier> ) \n \t2 { \n <ect>
\t3 return null ; } \n \t2 try { \n \t3 return cmd . get <identifiersep> name ( <identifier> <identifiersep> action <identifiersep> service . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> text <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } finally { \n \t3 <identifier> . close ( ) ; } \n \t2 <identifier> . close ( false , close ) ; } \n \t1 private void delete <identifiersep> <identifier> <identifiersep> thread ( int num <identifiersep> <identifier> , int num <identifiersep> <identifier> , int num <identifiersep> <identifier> <identifiersep> <identifier> ) throws exception { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t2 long <identifier> <identifiersep> time = <identifier> . get <identifiersep> long ( <string_literal> , - 1 ) ; \n \t2 try { \n \t3 text = <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> . get ( <string_literal> ) ) ; \n \t2 } catch ( illegal <identifiersep> <identifier> e ) { \n <ect>
\t2 return super . send <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> queue ( context , message <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( connection <identifiersep> context context , <identifier> <identifiersep> info <identifier> <identifiersep> info , <identifier> <identifiersep> <identifier> <identifiersep> destination destination ) { \n \t2 if ( is <identifiersep> log <identifiersep> all ( ) || is <identifiersep> log <identifiersep> <identifier> <identifiersep> <identifier> ( ) || is <identifiersep> log <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 private static boolean <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> <identifier> ( @ <identifier> final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , final string <identifier> , @ <identifier> final <identifier> <identifier> ) throws <identifier> <identifiersep> test <identifiersep> <identifier> <identifiersep> exception { \n \t2 try { \n \t3 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> boolean <identifiersep> <identifier> ( <identifier> , <identifier> . get <identifiersep> map ( ) ) ; \n \t2 } catch ( @ <identifier> final illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <comment> \n \t2 if ( ! <identifier> ) { \n <ect>
\t6 if ( <identifier> != null ) { \n \t7 try { \n \t8 <identifier> . close ( ) ; } \n \t7 catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 set < string > current <identifiersep> set = get <identifiersep> <identifier> <identifiersep> to <identifiersep> files <identifiersep> to <identifiersep> be <identifiersep> <identifier> ( conn ) ; \n \t2 log . info ( <string_literal> , current <identifiersep> set ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> file ) ; \n <ect>
private string <identifier> = null ; \n private long target <identifiersep> size = - 1 ; \n private <identifier> <identifiersep> context <identifier> <identifiersep> context ; \n public <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> <identifier> ( ) { \n <ect>
\t4 error ++ ; } \n \t3 else if ( ( api . get <identifiersep> response <identifiersep> type ( ) != response <identifiersep> type . error ) && ( api . get <identifiersep> response <identifiersep> code ( ) == <number_literal> ) ) { \n \t4 <comment> \n \t4 if ( api . set <identifiersep> <identifier> ( this . get <identifiersep> <identifier> ( ) ) == false ) { \n <ect>
\t3 line = <identifier> . read <identifiersep> line ( ) ; \n \t3 properties <identifier> = <identifier> <identifiersep> utils . parse <identifiersep> <identifier> ( line ) ; \n \t3 string value = <identifier> . get <identifiersep> property ( <string_literal> ) ; \n \t3 if ( value == null ) { \n <ect>
public class <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> java <identifiersep> <identifier> <identifiersep> handler implements <identifier> <identifiersep> java <identifiersep> <identifier> <identifiersep> handler , <identifier> { \n \t1 public static class <identifier> <identifiersep> <identifier> <identifiersep> handler implements <identifier> <identifiersep> java <identifiersep> <identifier> <identifiersep> handler { \n \t2 @ <identifier> \n \t2 public object [ ] <identifier> ( map < string , object > <identifier> ) { \n <ect>
\t3 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , response . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> status <identifiersep> code ( ) ) ; \n \t3 assert . assert <identifiersep> equals ( <string_literal> , <string_literal> , response . get <identifiersep> first <identifiersep> header ( <string_literal> ) . get <identifiersep> value ( ) ) ; \n \t3 <comment> \n \t3 string entity = entity <identifiersep> utils . to <identifiersep> string ( response . get <identifiersep> entity ( ) ) ; \n <ect>
\t5 input <identifiersep> stream in = new <identifier> <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> socket . get <identifiersep> input <identifiersep> stream ( ) , <identifier> <identifiersep> size ) ; \n \t5 <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> message <identifiersep> <identifier> ( in , this ) ; } } \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) <identifier> <identifiersep> log . debug ( get <identifiersep> <identifier> ( ) + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> . start <identifiersep> <identifier> ( ) ; \n <ect>
\t4 <identifier> <identifiersep> in = true ; \n \t3 set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t3 logger . debug ( <string_literal> ) ; \n \t2 } else \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> , <identifier> ) ; \n \t3 throw new server <identifiersep> exception ( <string_literal> , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t1 <comment> \n \t1 public int execute <identifiersep> <identifier> ( <identifier> <identifiersep> connection connection , string <identifier> , string [ ] <identifier> ) throws sql <identifiersep> exception { \n <ect>
\t5 log . debug ( string . format ( <string_literal> , <identifier> . size ( ) , <identifier> . get <identifiersep> path ( ) ) ) ; } } \n \t4 log . debug ( <string_literal> + file . get <identifiersep> path ( ) ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> store <identifiersep> <identifier> . size ( ) > 0 ) { \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> store <identifiersep> <identifier> , true ) ; \n \t4 } catch ( exception exception ) { \n <ect>
\t1 public long get <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> millis ( ) { \n \t2 return max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> millis ; } \n \t1 public void set <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> millis ( long max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> millis ) { \n \t2 if ( max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> millis < <number_literal> * <number_literal> ) { \n <ect>
\t2 final map < string , object > attributes = this . <identifier> <identifiersep> <identifier> . get <identifiersep> user ( <identifier> ) ; \n \t2 if ( attributes == null || attributes . is <identifiersep> empty ( ) \n \t4 || ! attributes . contains <identifiersep> key ( <identifier> <identifiersep> authentication <identifiersep> properties . get <identifiersep> <identifier> <identifiersep> attribute ( ) ) \n \t4 || ! attributes . contains <identifiersep> key ( <identifier> <identifiersep> authentication <identifiersep> properties . get <identifiersep> password <identifiersep> attribute ( ) ) ) { \n <ect>
\t5 attribute <identifiersep> name , <identifier> <identifiersep> attribute <identifiersep> name ) ; } } } \n \t1 private static void process <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> attributes ( final map < string , object > <identifier> <identifiersep> attributes , \n <number_literal> final map < string , object > attributes <identifiersep> to <identifiersep> <identifier> , final <identifier> <identifier> <identifiersep> file , final string key ) { \n \t2 try { \n <ect>
private static final logger log = logger . get <identifiersep> logger ( <identifier> <identifiersep> <identifier> <identifiersep> factory . class ) ; \n public <identifier> get <identifiersep> <identifier> ( file file ) throws file <identifiersep> not <identifiersep> found <identifiersep> exception { \n \t1 log . debug ( <string_literal> + file ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> file ( file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> api <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t3 return null ; \n \t2 } catch ( xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 connection <identifiersep> uri = <string_literal> ; \n \t2 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> connection <identifiersep> factory ( connection <identifiersep> uri ) ; \n \t2 <identifier> . start ( ) ; \n <ect>
\t2 logger . debug ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t2 logger . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 logger . debug ( <string_literal> + <identifier> <identifiersep> mode ) ; \n \t2 logger . debug ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t5 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + i + <string_literal> + \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> from + <string_literal> + <identifier> . <identifier> + <string_literal> ) ; } \n \t4 final <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> file , <identifier> . read ( location . <identifier> ( get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> name ( i ) ) ) ) ; \n \t4 found <identifiersep> <identifier> . add ( <identifier> ) ; \n <ect>
\t1 if ( <identifier> != null ) { \n \t1 if ( should <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 string <identifier> <identifiersep> <identifier> = storage <identifiersep> properties . get <identifiersep> storage <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t4 if ( time <identifiersep> <identifier> <identifiersep> last <identifiersep> update > <identifier> / <number_literal> ) { \n \t5 <identifier> . <identifier> <identifiersep> <identifier> ( access <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ) ; \n \t5 last <identifiersep> update = system . current <identifiersep> time <identifiersep> millis ( ) ; } \n \t3 } catch ( storage <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 task . <identifier> ( task <identifiersep> <identifier> ) ; \n \t3 return task ; } \n \t2 catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
\t5 log . warn ( <string_literal> + <identifier> <identifiersep> class <identifiersep> name ) ; \n \t4 } else { \n \t5 log . warn ( <string_literal> + <identifier> <identifiersep> class <identifiersep> name + <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; } \n \t3 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
\t3 if ( string <identifiersep> utils . is <identifiersep> blank ( result ) ) { \n \t4 try { \n \t5 result = io <identifiersep> utils . to <identifiersep> string ( <identifier> , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> ) ; } \n \t4 catch ( io <identifiersep> exception e ) { \n <ect>
\t2 log . info ( <string_literal> , status <identifiersep> code ) ; \n \t2 assert <identifiersep> equals ( http <identifiersep> status <identifiersep> <identifier> . not <identifiersep> found . get <identifiersep> status <identifiersep> code ( ) , response <identifiersep> <identifier> . get ( <number_literal> ) . get <identifiersep> status <identifiersep> code ( ) ) ; \n \t2 final exception exception = ( exception ) response <identifiersep> <identifier> . get ( <number_literal> ) . get <identifiersep> body ( ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( exception ) ; \n <ect>
\t3 <identifier> <identifiersep> listener = new client <identifiersep> session <identifiersep> channel . message <identifiersep> listener ( ) { \n \t4 public void on <identifiersep> message ( client <identifiersep> session <identifiersep> channel channel , message message ) { \n \t5 log . debug ( <string_literal> , message ) ; \n \t5 if ( ! message . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t8 break ; } \n \t6 } catch ( final remote <identifiersep> exception e ) { \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> service ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n <ect>
\t5 message <identifiersep> <identifier> message <identifiersep> <identifier> = message <identifiersep> <identifier> . <identifier> ( ) ; \n \t5 <identifier> <identifiersep> request ( channel , message <identifiersep> <identifier> ) ; } } } } \n \t1 private boolean <identifier> <identifiersep> check ( long <identifier> <identifiersep> time , long timeout <identifiersep> <identifier> , int message <identifiersep> size ) { \n \t2 if ( timeout <identifiersep> <identifier> != - 1 && <identifier> <identifiersep> time >= timeout <identifiersep> <identifier> ) { \n <ect>
\t2 if ( ! is <identifiersep> <identifier> <identifiersep> network ( ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> = manager . find <identifiersep> <identifier> <identifiersep> network <identifiersep> id ( network ) ; \n \t3 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 public void run ( ) { \n \t3 try { \n \t3 system . out . <identifier> ( run <identifiersep> <identifier> <identifiersep> test ( <identifier> , num <identifiersep> <identifier> , <identifier> ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 return <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> cache + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> cache \n \t5 + <string_literal> + last <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 try ( final <identifier> <identifier> = <identifier> . <identifier> ( ) ) { \n \t4 node <identifiersep> <identifier> = <identifier> . node <identifiersep> query ( node <identifiersep> interface . class ) . get <identifiersep> as <identifiersep> list ( ) . <identifier> ( ) ; \n \t4 <identifier> . success ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t8 do <identifiersep> <identifier> <identifiersep> from <identifiersep> queue ( consumer . get <identifiersep> queue ( ) ) ; } \n \t7 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception | <identifier> <identifiersep> io <identifiersep> exception e ) { \n \t8 this . logger . error ( <string_literal> , e ) ; \n \t8 if ( e . get <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> application <identifiersep> context <identifiersep> <identifier> <identifiersep> exception ) { \n <ect>
\t5 . for <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> - > { \n \t6 try { \n \t7 <identifier> <identifiersep> <identifier> . delete ( ) ; \n \t6 } catch ( storage <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . put ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; } \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( <string_literal> ) ) { \n \t3 string value = ( string ) <identifier> <identifiersep> <identifier> . get ( <string_literal> ) ; \n <ect>
\t2 ++ this . <identifier> ; \n \t2 try { \n \t2 if ( ! <identifier> . list ( <identifier> . not ( <identifier> <identifiersep> filter . instance ) ) . is <identifiersep> empty ( ) && current <identifiersep> host . has <identifiersep> <identifier> ( ) ) { \n \t3 if ( update <identifiersep> entry . instance . <identifier> ( current <identifiersep> host ) ) { \n <ect>
\t1 private void process <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 list < security <identifiersep> group <identifiersep> <identifier> <identifiersep> vo > <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 int num <identifiersep> <identifier> = <identifier> . size ( ) ; \n \t2 if ( num <identifiersep> <identifier> > 0 ) { \n <ect>
\t2 if ( this . connection <identifiersep> factory == null ) { \n \t3 logger . warn ( <string_literal> ) ; \n \t3 return false ; } \n \t2 if ( this . <identifier> <identifiersep> request == null ) { \n <ect>
\t1 <comment> \n \t1 map < string , string > <identifier> <identifiersep> user <identifiersep> attributes = user <identifiersep> attribute <identifiersep> <identifier> . <identifier> ( ) ; \n \t1 <comment> \n \t1 set <identifiersep> <identifier> <identifiersep> attributes ( <identifier> <identifiersep> <identifier> <identifiersep> configuration , <identifier> <identifiersep> user <identifiersep> attributes ) ; \n <ect>
\t5 entity . entity ( <string_literal> , <identifier> <identifiersep> type . text <identifiersep> <identifier> <identifiersep> type ) ) ; \n \t3 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> request , response . get <identifiersep> status ( ) ) ; \n \t3 string entity = response . read <identifiersep> entity ( string . class ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> exception e = new <identifier> <identifiersep> <identifier> <identifiersep> exception ( string . class . <identifier> ( entity ) ) ; \n <ect>
\t1 try { \n \t1 for ( file <identifiersep> status <identifier> : get <identifiersep> <identifier> <identifiersep> server ( ) . get <identifiersep> file <identifiersep> system ( ) \n \t2 . <identifier> <identifiersep> status ( new path ( location , <string_literal> ) ) ) { \n \t2 try { \n <ect>
\t3 throw new <identifier> <identifiersep> error <identifiersep> exception ( <string_literal> + <string_literal> + e . get <identifiersep> message ( ) , e ) ; } } \n \t1 private table <identifiersep> <identifier> <identifier> <identifiersep> table <identifiersep> <identifier> ( <identifier> <identifiersep> request <identifier> <identifiersep> request ) { \n \t2 table <identifiersep> <identifier> <identifier> = null ; \n \t2 try { \n <ect>
\t2 <comment> \n \t2 try { \n \t3 delete <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . <identifier> . <identifier> . api . <identifier> . <identifier> . class , <identifier> <identifiersep> log <identifiersep> <identifier> ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t6 <identifier> . add ( <identifier> ) ; } \n \t4 } finally { \n \t5 is . close ( ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t3 } ) ; } \n \t1 <comment> \n \t1 @ <identifier> public boolean on <identifiersep> <identifier> <identifiersep> <identifier> ( grid <identifiersep> cache <identifiersep> entry <identifiersep> ex < <identifier> , v > entry , grid <identifiersep> cache <identifiersep> <identifier> <identifiersep> <identifier> < <identifier> > <identifier> ) { \n <ect>
\t4 if ( this . <identifier> <identifiersep> <identifier> . get <identifiersep> value ( this . <identifier> <identifiersep> context , message , boolean . class ) ) { \n \t5 <identifier> <identifiersep> <identifier> . add ( message ) ; } \n \t4 else { \n <ect>
\t5 <comment> \n \t5 <comment> \n \t5 <identifier> <identifiersep> send <identifiersep> <identifier> ( load <identifiersep> test . <identifier> <identifiersep> <identifier> , load <identifiersep> test . message <identifiersep> size ) ; } } \n \t2 } catch ( exception x ) { \n <ect>
\t2 final <identifier> <identifiersep> source < <identifier> <identifiersep> <identifier> <identifiersep> type , <identifier> <identifiersep> <identifier> > <identifier> = test <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> source ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . <identifier> <identifiersep> by ( <number_literal> , <number_literal> ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> ( ) == null || ! <identifier> . get <identifiersep> <identifier> ( ) . equals <identifiersep> ignore <identifiersep> case ( this . handler <identifiersep> <identifier> ) ) { \n \t3 logger . warn ( <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) , this . handler <identifiersep> <identifier> ) ; \n \t3 return new <identifier> <identifiersep> <identifier> <identifiersep> collection ( ) ; } \n \t2 if ( <identifier> . get <identifiersep> principal ( ) == null ) { \n <ect>
\t5 <comment> \n \t5 try { \n \t6 metadata <identifiersep> resource . <identifier> <identifiersep> local ( i <identifiersep> resource . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . new <identifiersep> <identifier> ( 1 ) ) ; } \n \t5 catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = p . parse ( new url ( <identifier> ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . <identifier> ( <identifier> ) ; \n \t2 <identifier> output <identifiersep> stream = <identifier> . create ( out <identifiersep> file ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> format format = new <identifier> <identifiersep> <identifier> <identifiersep> format ( ) ; \n <ect>
\t4 object root <identifiersep> value = parse <identifiersep> for <identifiersep> <identifier> ( <identifier> , state ) ; \n \t4 if ( root <identifiersep> value != null ) { \n \t5 json <identifiersep> <identifier> . <identifier> <identifiersep> put ( options , <string_literal> , root <identifiersep> value ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 catch ( <identifier> <identifiersep> exception . no <identifiersep> node <identifiersep> exception <identifier> ) { } } \n \t4 else { \n \t5 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + \n \t7 <string_literal> ) ; } } } \n <ect>
\t3 do <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 log . debug ( <string_literal> , <identifier> . stop <identifiersep> and <identifiersep> <identifier> ( ) ) ; \n \t3 if ( ! context . get <identifiersep> <identifier> <identifiersep> data ( ) . is <identifiersep> <identifier> ( ) ) { <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> meta <identifiersep> for <identifiersep> <identifier> ( ) ; \n <ect>
\t2 client <identifiersep> socket . get <identifiersep> input <identifiersep> stream ( ) . close ( ) ; \n \t2 if ( ! client <identifiersep> socket . is <identifiersep> <identifier> ( ) ) { \n \t3 log . warn ( <string_literal> ) ; \n \t3 client <identifiersep> socket . close ( ) ; } \n <ect>
\t7 <comment> \n \t7 <identifier> <identifiersep> <identifier> ++ ; \n \t7 <comment> \n \t5 } catch ( null <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> queue = new <identifier> <identifiersep> <identifier> <identifiersep> queue < db <identifiersep> <identifier> . <identifier> <identifiersep> value > ( ) ; \n \t2 is <identifiersep> run <identifiersep> <identifier> = new <identifier> <identifiersep> boolean ( false ) ; \n \t2 <identifier> <identifiersep> thread = new thread ( this ) ; \n \t2 <identifier> <identifiersep> thread . start ( ) ; \n <ect>
\t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n \t6 <identifier> <identifiersep> log . debug ( <string_literal> ) ; \n \t5 socket . close ( ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t3 } else if ( ! <identifier> . get <identifiersep> string ( 1 ) . equals ( <string_literal> ) ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + <identifier> . get <identifiersep> string ( 1 ) ) ; } \n \t3 <identifier> . close ( ) ; \n \t3 <identifier> . close ( ) ; \n <ect>
\t2 assert false ; \n \t1 } catch ( throwable e ) { \n \t2 <comment> \n \t1 <identifier> ( ( ) - > check <identifiersep> <identifier> <identifiersep> count ( 0 , 1 , 0 ) && check <identifiersep> <identifier> <identifiersep> count ( 1 , 0 , 1 ) && check <identifiersep> <identifier> <identifiersep> count ( <number_literal> , 0 , 1 ) ) ; \n <ect>
\t1 try { \n \t2 return double . value <identifiersep> of ( key ) . <identifier> <identifiersep> to ( double . value <identifiersep> of ( value ) ) >= 0 ; \n \t1 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n \t2 <comment> \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( transport <identifier> , string v <identifiersep> s , string v <identifiersep> c , byte [ ] i <identifiersep> s , byte [ ] i <identifiersep> c ) throws <identifier> <identifiersep> security <identifiersep> exception , transport <identifiersep> exception { \n \t2 super . <identifier> ( <identifier> , v <identifiersep> s , v <identifiersep> c , i <identifiersep> s , i <identifiersep> c ) ; \n \t2 <identifier> . <identifier> ( ) ; \n <ect>
\t1 { \n \t2 <identifier> <identifiersep> log . warn ( build <identifiersep> log <identifiersep> message ( method , <string_literal> , build <identifiersep> error <identifiersep> message ( ex ) , <identifier> <identifiersep> <identifier> , request <identifiersep> context ) , ex ) ; } \n \t1 else \n \t1 { \n <ect>
<comment> \n \t1 public synchronized void session <identifiersep> failed ( ) \n \t1 { \n <ect>
\t2 try { \n \t3 if ( to <identifiersep> <identifier> != null ) { \n \t4 in <identifiersep> <identifier> = <identifier> <identifiersep> utils . get <identifiersep> instance ( ) . get <identifiersep> <identifier> ( to <identifiersep> <identifier> ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public synchronized boolean <identifier> <identifiersep> read ( <identifier> <identifier> , int <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> in <identifiersep> <identifier> ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t6 class < x <identifiersep> path <identifiersep> factory > <identifier> = <identifier> <identifiersep> context . get <identifiersep> class <identifiersep> <identifier> ( ) . <identifier> <identifiersep> class ( <identifier> <identifiersep> factory <identifiersep> class <identifiersep> name , x <identifiersep> path <identifiersep> factory . class ) ; \n \t6 if ( <identifier> != null ) { \n \t7 log . debug ( <string_literal> , <identifier> ) ; \n \t7 <identifier> <identifiersep> factory = <identifier> <identifiersep> context . get <identifiersep> <identifier> ( ) . new <identifiersep> instance ( <identifier> ) ; \n <ect>
\t5 <identifier> . set <identifiersep> string ( <number_literal> , vm <identifiersep> name ) ; \n \t5 <identifier> . set <identifiersep> long ( <number_literal> , <identifier> <identifiersep> <identifier> <identifiersep> id ) ; \n \t5 <identifier> . set <identifiersep> long ( <number_literal> , is <identifiersep> default ) ; \n \t5 <identifier> . execute <identifiersep> update ( ) ; } } \n <ect>
\t5 start . <identifier> ( ) ; \n \t5 remove ( store , <identifier> , <identifier> , <identifier> ( 1 , <number_literal> ) ) ; \n \t5 <identifier> . count <identifiersep> <identifier> ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> context context = <identifier> <identifiersep> <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t2 <identifier> <identifiersep> log = context . log <identifiersep> manager ( ) . get <identifiersep> log ( <identifier> <identifiersep> it . class ) ; \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> context <identifier> = java <identifiersep> <identifier> . for <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t4 config . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( <identifier> ) ; \n \t3 } catch ( key <identifiersep> <identifier> <identifiersep> exception | no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 ( ( <identifier> <identifiersep> response ) <identifier> ) . set <identifiersep> header ( value , key ) ; } \n \t2 else if ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 ( ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) . set <identifiersep> header <identifiersep> for <identifiersep> key ( value , key ) ; } \n \t2 else { \n <ect>
\t5 enabled <identifiersep> <identifier> <identifiersep> <identifier> . add ( <identifier> ) ; \n \t5 if ( r instanceof device <identifiersep> configuration ) { \n \t6 ( ( device <identifiersep> configuration ) r ) . <identifier> ( <identifier> ) ; } \n \t4 } catch ( configuration <identifiersep> exception <identifier> ) { \n <ect>
\t1 public static class < ? extends <identifier> <identifiersep> <identifier> <identifiersep> service > get <identifiersep> <identifier> <identifiersep> service <identifiersep> <identifier> ( ) { \n \t2 return <identifier> <identifiersep> service <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 protected void <identifier> ( ) { \n <ect>
\t2 try { \n \t3 <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> xml <identifiersep> <identifier> . <identifier> <identifiersep> name ) ; \n \t2 } catch ( content <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 string <identifier> = e . get <identifiersep> message ( ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> name = <identifier> <identifiersep> name ; \n \t3 <identifier> <identifiersep> <identifier> = <identifier> ; } \n \t2 public void run ( ) { \n \t3 system . out . <identifier> ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> name + <string_literal> ) ; \n <ect>
\t4 output = new <identifier> <identifiersep> output <identifiersep> stream ( socket . get <identifiersep> output <identifiersep> stream ( ) , <identifier> <identifiersep> size ) ; \n \t4 get <identifiersep> state <identifiersep> from <identifiersep> application ( state <identifiersep> <identifier> , output , false ) ; } \n \t3 catch ( throwable e ) { \n <ect>
\t3 <comment> \n \t3 store . load <identifiersep> x <identifiersep> <identifier> <identifiersep> collection ( <identifier> <identifiersep> <identifier> , this . context , true ) ; \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } else { \n \t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> + <string_literal> + <identifier> <identifiersep> id ) ; } \n \t3 if ( user <identifiersep> account == null ) { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> , port ) ; \n \t2 logger . info ( <string_literal> , port ) ; \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t4 assert <identifiersep> equals ( <string_literal> + \n \t8 <string_literal> , <identifier> . text ( ) ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> node <identifiersep> <identifier> ( <identifier> , 1 , <identifier> . empty <identifiersep> set ( ) ) ; } } } \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t3 <comment> \n \t3 return ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> array current <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 if ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> && <identifier> . get <identifiersep> current <identifiersep> url ( ) . equals ( uri ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> . equals ( <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> ) ) { \n \t3 new <identifiersep> <identifier> = ( short ) ( this . target <identifiersep> <identifier> + <identifier> ) ; \n \t2 } else if ( <identifier> <identifiersep> <identifier> . equals ( <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> ) ) { \n \t3 new <identifiersep> <identifier> = ( short ) ( this . target <identifiersep> <identifier> - <identifier> ) ; } \n <ect>
\t3 if ( user <identifiersep> id <identifiersep> <identifier> != null ) { \n \t4 user <identifiersep> id = long . parse <identifiersep> long ( user <identifiersep> id <identifiersep> <identifier> ) ; \n \t4 s <identifiersep> user <identifiersep> id . set ( user <identifiersep> id ) ; \n \t4 if ( user <identifiersep> id == - 1 ) { \n <ect>
\t6 listener . on <identifiersep> <identifier> ( ) ; \n \t5 } else { \n \t6 listener . on <identifiersep> <identifier> ( ) ; } \n \t4 } catch ( throwable e ) { \n <ect>
\t2 int boolean <identifiersep> <identifier> <identifiersep> <identifier> = properties <identifiersep> <identifier> . to <identifiersep> integer ( config . get ( <identifier> <identifiersep> boolean <identifiersep> <identifier> <identifiersep> <identifier> ) , \n \t4 <identifier> <identifiersep> boolean <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> default ) ; \n \t2 if ( boolean <identifiersep> <identifier> <identifiersep> <identifier> != boolean <identifiersep> query . get <identifiersep> max <identifiersep> <identifier> <identifiersep> count ( ) ) { \n \t3 boolean <identifiersep> query . set <identifiersep> max <identifiersep> <identifier> <identifiersep> count ( boolean <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t7 ? <string_literal> \n \t7 : ( <string_literal> + <identifier> ) ) , <identifier> ) ; } } } \n \t2 catch ( exception e ) { \n <ect>
\t2 string property <identifiersep> name = <identifier> + <string_literal> ; \n \t2 string default <identifiersep> <identifier> = <string_literal> ; \n \t2 string <identifier> = <identifier> <identifiersep> properties . get <identifiersep> property ( property <identifiersep> name ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 try { \n \t3 <identifier> = sql . execute <identifiersep> update ( \n \t4 string . format ( sql <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> , <identifier> . from ( account <identifiersep> metadata <identifiersep> class ) . get ( table . class ) . name ( ) ) \n \t3 ) ; \n <ect>
<comment> \n \t1 @ test \n \t1 public void content <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> key <identifiersep> exception , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception , illegal <identifiersep> <identifier> <identifiersep> size <identifiersep> exception , <identifier> <identifiersep> <identifier> <identifiersep> exception , io <identifiersep> exception { \n <ect>
\t5 <identifier> <identifiersep> data <identifiersep> <identifier> . put ( current <identifiersep> <identifier> <identifiersep> data <identifiersep> value . get <identifiersep> key ( ) , current <identifiersep> <identifier> <identifiersep> data <identifiersep> value . get <identifiersep> value ( ) ) ; } \n \t4 current <identifiersep> <identifier> <identifiersep> data . set <identifiersep> values ( <identifier> <identifiersep> data <identifiersep> <identifier> ) ; \n \t4 <identifier> . <identifier> ( ) ; } \n \t3 <comment> \n <ect>
\t2 assert <identifiersep> that ( routing <identifiersep> nodes . node ( <string_literal> ) . number <identifiersep> of <identifiersep> shards <identifiersep> with <identifiersep> state ( <identifier> ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 cluster <identifiersep> state = cluster <identifiersep> state . builder ( cluster <identifiersep> state ) . nodes ( <identifier> <identifiersep> nodes . builder ( cluster <identifiersep> state . nodes ( ) ) . add ( new <identifiersep> node ( <string_literal> ) ) ) . build ( ) ; \n \t2 cluster <identifiersep> state = <identifier> . <identifier> ( cluster <identifiersep> state , <string_literal> ) ; \n <ect>
\t6 for ( abstract <identifiersep> <identifier> <identifier> : node . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t7 if ( <string_literal> . equals ( <identifier> . get <identifiersep> type ( ) ) ) { \n \t8 <identifier> . delete ( <identifier> ) ; } } \n \t5 } catch ( throwable t ) { \n <ect>
<comment> \n \t1 public synchronized void stop <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> count == 0 ) { \n <ect>
\t4 . data ( false ) \n \t4 . node ( ) ; \n \t3 client client = node . client ( ) ; \n <ect>
\t6 if ( <identifier> != null ) { \n \t7 for ( byte [ ] ip : <identifier> ) { \n \t8 if ( ! is <identifiersep> <identifier> ( ip ) ) { \n \t9 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t3 assert <identifiersep> true ( <string_literal> , wait . wait <identifiersep> for ( new wait . <identifier> ( ) { \n \t4 @ <identifier> \n \t4 public boolean is <identifiersep> <identifier> ( ) throws exception { \n \t5 integer <identifier> <identifiersep> queue <identifiersep> size = ( integer ) <identifier> <identifiersep> server . get <identifiersep> attribute ( new object <identifiersep> name ( the <identifiersep> <identifier> <identifiersep> object ) , <string_literal> ) ; \n <ect>
\t1 shards <identifiersep> list . add ( <string_literal> + i ) ; } \n \t1 string shards <identifiersep> list <identifiersep> <identifier> = string <identifiersep> utils . <identifier> ( shards <identifiersep> list , ' , ' ) ; \n \t1 <comment> \n \t1 if ( ! all <identifiersep> collection <identifiersep> list . contains ( <identifier> <identifiersep> <identifier> <identifiersep> config . get <identifiersep> collection ( ) ) ) { \n <ect>
\t5 <string_literal> + <identifier> <identifiersep> context . value <identifiersep> for <identifiersep> key <identifiersep> path ( <string_literal> ) + <string_literal> + \n \t5 <string_literal> + <identifier> <identifiersep> context ( ) . value <identifiersep> for <identifiersep> key ( <string_literal> ) + <string_literal> + \n \t5 <string_literal> + <identifier> <identifiersep> context ( ) . value <identifiersep> for <identifiersep> key ( <string_literal> ) + <string_literal> , ex ) ; \n \t2 } else { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + format + <string_literal> ) ; \n \t3 return null ; } \n \t2 string <identifier> = template <identifiersep> path + file . <identifier> + template <identifiersep> name + <string_literal> + <identifier> <identifiersep> format . <identifier> . get <identifiersep> file <identifiersep> <identifier> ( ) ; \n \t2 if ( ! <identifier> <identifiersep> storage . exists ( <identifier> ) ) { \n <ect>
\t3 <identifier> . set <identifiersep> attribute ( key , <identifier> ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t3 <identifier> . start ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 string <identifiersep> <identifier> string <identifiersep> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t3 <identifier> . <identifier> ( new <identifier> <identifiersep> source ( xml <identifiersep> <identifier> ) , new stream <identifiersep> result ( string <identifiersep> <identifier> ) ) ; \n \t3 return string <identifiersep> <identifier> . to <identifiersep> string ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 log . debug ( <string_literal> + user + <string_literal> + group ) ; \n \t3 db <identifiersep> group . add <identifiersep> user <identifiersep> by <identifiersep> name ( user ) ; } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t2 log . error ( e , e ) ; \n <ect>
\t2 if ( is <identifiersep> <identifier> . get <identifiersep> and <identifiersep> set ( true ) ) { \n \t3 log . info ( <string_literal> , name ( ) ) ; \n \t3 return ; } \n \t2 long <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> ( ) ; \n <ect>
\t2 } else { \n \t3 try { \n \t4 <identifier> = new <identifier> <identifiersep> socket <identifiersep> handler ( port , <identifier> . get <identifiersep> address ( ) , node , <identifier> <identifiersep> time , get <identifiersep> <identifier> ( port ) , node . <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 public void <identifier> <identifiersep> values <identifiersep> from <identifiersep> request ( <identifier> <identifiersep> request r , <identifier> <identifiersep> context c ) { \n \t2 super . <identifier> <identifiersep> values <identifiersep> from <identifiersep> request ( r , c ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> array result = new <identifier> <identifiersep> <identifier> <identifiersep> array ( ) ; \n \t2 <identifier> <identifiersep> array <identifier> <identifiersep> field <identifiersep> values = <identifier> <identifiersep> array . <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> string ( <identifier> <identifiersep> key <identifiersep> <identifier> , <string_literal> ) ; \n <ect>
\t3 values = new array <identifiersep> list < > ( ) ; } \n \t2 values . add ( item ) ; \n \t2 files . put ( item . get <identifiersep> field <identifiersep> name ( ) , values ) ; } \n \t1 protected void process <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> field ( file <identifiersep> item item , string <identifier> ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 list < <identifier> <identifiersep> port <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> vo > <identifier> <identifiersep> p <identifiersep> <identifier> = s <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . get <identifiersep> <identifier> <identifiersep> <identifier> ( account . get <identifiersep> id ( ) , account . get <identifiersep> <identifier> <identifiersep> id ( ) , start <identifiersep> date , end <identifiersep> date , false , 0 ) ; \n \t2 if ( <identifier> <identifiersep> p <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
public void close ( ) { \n \t1 try { \n \t1 queue <identifiersep> file <identifiersep> provider . close ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 file <identifiersep> <identifier> <identifiersep> path = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> file <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( file <identifiersep> name , false , <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( file <identifiersep> <identifier> <identifiersep> path != null ) { \n \t3 <identifier> <identifiersep> <identifier> . delete <identifiersep> file ( file <identifiersep> <identifier> <identifiersep> path , <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) , true , <identifier> <identifiersep> <identifier> ) ; \n \t2 } else { \n <ect>
\t2 try { \n \t3 <identifier> = this . do <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 context context = <identifier> . get <identifiersep> context ( ) ; \n <ect>
\t3 index . set ( response . node . <identifier> <identifiersep> index + 1 ) ; \n \t3 logger . debug ( <string_literal> , response . node . <identifier> <identifiersep> index , index . get ( ) ) ; \n \t2 } else { \n \t3 index . set ( response . <identifier> <identifiersep> index + 1 ) ; \n <ect>
\t3 security <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task . instance . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> client , null ) ; } } \n \t1 try { \n \t2 <identifier> . stop ( get <identifiersep> <identifier> <identifiersep> node <identifiersep> name ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 wait ( send <identifiersep> timeout ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { } \n \t2 <identifier> = <identifier> <identifiersep> response ; \n \t2 if ( <identifier> <identifiersep> response == null ) { \n <ect>
\t2 <identifier> ( ( class < <identifier> . <identifier> . <identifier> . <identifier> . <identifier> . service > ) <identifier> ) . to <identifiersep> instance ( service ) ; \n \t2 <identifier> . add ( service ) ; \n \t2 log . info ( <string_literal> , <identifier> ) ; \n \t2 } catch ( exception exception ) { \n <ect>
\t5 <comment> \n \t5 <comment> \n \t5 <comment> \n \t5 <comment> \n <ect>
\t4 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } } \n \t2 if ( <identifier> != null ) { \n \t3 for ( handler handler : <identifier> ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> info ( ) ) \n <ect>
\t1 for ( vm <identifiersep> type <identifiersep> <identifier> v : <identifier> <identifiersep> set ) \n \t1 v . <identifier> ( <identifier> ) ; \n \t1 for ( vm <identifiersep> type <identifiersep> <identifier> v : <identifier> <identifiersep> set ) \n \t1 v . set <identifiersep> <identifier> ( vm <identifiersep> type <identifiersep> status . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t1 log . warn ( <string_literal> + \n \t1 timeout + \n \t1 <string_literal> ) ; \n \t1 if ( debug ) { \n <ect>
\t3 log . debug ( <string_literal> ) ; } \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> map <identifiersep> factory instanceof default <identifiersep> <identifier> <identifiersep> map <identifiersep> factory ) { \n \t3 <identifier> <identifiersep> map <identifiersep> factory = new <identifier> <identifiersep> map <identifiersep> factory <identifiersep> <identifier> ( ) . <identifier> ( this ) ; } \n <ect>
\t2 try { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . close ( ) ; } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t6 . add <identifiersep> web <identifiersep> socket <identifiersep> listener ( new web <identifiersep> socket <identifiersep> text <identifiersep> listener ( ) { \n \t7 @ <identifier> \n \t7 public void on <identifiersep> message ( string message ) { \n \t8 <identifier> . add ( message ) ; \n <ect>
\t2 group <identifier> <identifiersep> group = get <identifiersep> group ( <identifier> <identifiersep> name , system <identifiersep> configuration . <identifier> <identifiersep> long <identifiersep> timeout ) ; \t2 \n \t2 <comment> \n \t2 if ( null != <identifier> <identifiersep> group ) { \n \t3 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> . delete ( <identifier> <identifiersep> <identifier> <identifiersep> dir , true ) ; \n \t4 file <identifiersep> system local = file <identifiersep> system . get <identifiersep> local <identifiersep> file <identifiersep> system ( ) ; \n \t4 local . delete ( new path ( local <identifiersep> <identifier> <identifiersep> path ) , true ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 } else { \n \t5 is = exchange . get <identifiersep> in ( ) . get <identifiersep> <identifier> <identifiersep> body ( input <identifiersep> stream . class ) ; } } \n \t3 final stop <identifiersep> <identifier> <identifier> = new stop <identifiersep> <identifier> ( ) ; \n \t3 boolean answer ; \n <ect>
\t5 do <identifiersep> <identifier> <identifiersep> <identifier> = false ; \n \t4 } catch ( <identifier> <identifiersep> pool . pool <identifiersep> <identifier> <identifiersep> exception e ) { \n \t5 log . info ( <string_literal> , e . get <identifiersep> message ( ) ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> socket get <identifiersep> destination <identifiersep> <identifier> <identifiersep> socket ( <identifier> <identifiersep> <identifier> t ) throws <identifier> <identifiersep> exception { \n \t2 <identifier> <identifiersep> server ( ) ; \n \t2 if ( conn <identifiersep> host <identifiersep> name == null ) { \n <ect>
\t2 return <identifier> . <identifier> <identifiersep> list ( event . get <identifiersep> <identifier> ) ; } \n \t1 protected void <identifier> ( long timeout ) { \n \t2 if ( ! <identifier> ) { \n \t3 <identifier> = true ; \n <ect>
\t1 public static class <identifier> <identifiersep> <identifier> implements <identifier> <identifiersep> <identifier> { \n \t2 @ <identifier> \n \t2 public <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) throws interrupted <identifiersep> exception { \n \t3 <identifier> . <identifier> ( get <identifiersep> class ( ) ) ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < volume <identifiersep> api <identifiersep> result > <identifier> = <identifier> <identifiersep> service . <identifier> <identifiersep> volume <identifiersep> <identifier> ( <identifier> <identifiersep> factory . get <identifiersep> volume ( <identifier> <identifiersep> volume . get <identifiersep> id ( ) ) ) ; \n \t5 try { \n \t6 <identifier> . get ( ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> logger . end ( start , <number_literal> , \n \t6 <string_literal> , \n \t6 <identifier> <identifiersep> root , root ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> ( throwable e ) { \n \t2 this . <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n \t2 this . <identifier> = this . <identifier> = false ; \n \t2 if ( e != null ) { \n <ect>
\t3 try { \n \t4 list field <identifiersep> <identifier> = query <identifiersep> <identifier> . to <identifiersep> <identifier> <identifiersep> field <identifiersep> <identifier> ( <identifier> <identifiersep> result <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) , type ) ; \n \t4 <identifier> <identifiersep> <identifier> . add ( new <identifier> <identifiersep> query <identifiersep> info ( <identifier> <identifiersep> result <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) , field <identifiersep> <identifier> ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 boolean <identifier> <identifiersep> continue = false ; \n \t2 properties <identifier> ; \n \t2 this . thread . set <identifiersep> name ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 <identifier> <identifier> = ( <identifier> ) <identifier> ; \n \t5 <comment> \n \t5 <comment> \n \t5 <comment> \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t9 configuration <identifier> <identifiersep> conf ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> host <identifiersep> <identifier> ( <identifier> <identifiersep> conf ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> map = metadata <identifiersep> manager . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cache ( ) ; \n \t1 metadata <identifiersep> manager <identifiersep> instance = metadata <identifiersep> manager ; \n <ect>
\t3 final string session <identifiersep> id = session . get <identifiersep> id ( ) ; \n \t3 if ( session <identifiersep> id != null ) { \n \t4 <identifier> <identifiersep> <identifier> . add ( session <identifiersep> id ) ; \n \t3 } else { \n <ect>
\t1 public void <identifier> ( ) { \n \t2 logger . debug ( get <identifiersep> name ( ) + <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t3 success = element . <identifier> <identifiersep> static <identifiersep> <identifier> ( network , static <identifiersep> <identifier> ) ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 if ( ! continue <identifiersep> on <identifiersep> error ) { \n \t4 throw e ; } \n <ect>
\t2 <identifier> <identifiersep> id = ( ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <number_literal> ) ) < < <number_literal> ) | ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <number_literal> ) ) ; \n \t2 device <identifiersep> type = ( ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <number_literal> ) ) < < <number_literal> ) | ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <number_literal> ) ) ; \n \t2 device <identifiersep> id = ( ( ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <number_literal> ) ) < < <number_literal> ) | ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <number_literal> ) ) ) ; \n \t2 logger . debug ( string . format ( <string_literal> , <identifier> <identifiersep> api <identifiersep> version ) ) ; \n <ect>
\t4 <identifier> = query <identifiersep> map . get ( <string_literal> ) ; \n \t4 try { \n \t5 <identifier> = integer . parse <identifiersep> int ( <identifier> ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t2 assert . assert <identifiersep> true ( data <identifiersep> utils . <identifier> ( <identifier> . get <identifiersep> key <identifiersep> id ( key <identifiersep> <identifier> ) , \t2 key <identifiersep> <identifier> ) == 0 ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 <comment> \n \t2 if ( ( <identifier> != null ) && ( <identifier> instanceof boolean ) ) { \n \t3 answer = ( boolean ) <identifier> ; \n \t2 } else { \n <ect>
\t4 if ( <identifier> . <identifier> <identifiersep> <identifier> ( ) . is <identifiersep> <identifier> ( <identifier> ) ) { \n \t5 <identifier> . add ( <identifier> ) ; \n \t4 } else { \n \t5 if ( log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t1 protected set < event > handle <identifiersep> authentication <identifiersep> transaction <identifiersep> and <identifiersep> <identifier> <identifiersep> ticket <identifiersep> <identifier> <identifiersep> ticket ( final request <identifiersep> context context ) { \n \t2 try { \n \t3 final <identifier> <identifier> = get <identifiersep> <identifier> <identifiersep> from <identifiersep> context ( context ) ; \n \t3 authentication <identifiersep> result <identifiersep> builder builder = web <identifiersep> utils . get <identifiersep> authentication <identifiersep> result <identifiersep> builder ( context ) ; \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> event ( new <identifier> <identifiersep> event ( <identifier> <identifiersep> event . <identifier> <identifiersep> <identifier> <identifiersep> add , this , <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> ) ) ; \n \t4 if ( <identifier> && <identifier> ) start <identifiersep> <identifier> ( false ) ; \n \t3 } catch ( channel <identifiersep> exception x ) { \n <ect>
\t4 user <identifiersep> model <identifier> = <identifier> <identifiersep> and <identifiersep> <identifier> ( <identifier> , user ) ; \n \t4 if ( <identifier> != null ) { \n \t5 return <identifier> ; \n \t4 } else { \n <ect>
\t3 <comment> \n \t3 string <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 <identifier> <identifiersep> config <identifiersep> dao . update ( config . <identifier> <identifiersep> <identifier> . key ( ) , config . <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 public void on <identifiersep> <identifier> <identifiersep> exception ( exception e ) { \n \t3 <comment> \n \t2 @ <identifier> \n \t2 public void on <identifiersep> <identifier> ( ) { \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , <string_literal> ) ; \n \t3 <identifier> . set <identifiersep> <identifier> ( <identifier> . warn ) ; \n \t3 log . debug ( <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n <ect>
\t1 logger . debug ( content . to <identifiersep> string ( ) ) ; } \n \t1 try { \n \t1 <identifier> = xml <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> from <identifiersep> string ( content . to <identifiersep> string ( ) , new <identifier> <identifiersep> entity <identifiersep> <identifier> ( ) ) ; \n \t1 } catch ( xml <identifiersep> parse <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . get ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception | execution <identifiersep> exception e ) { \n \t4 <comment> \n \t4 <comment> \n <ect>
\t4 <comment> \n \t4 log . trace ( <string_literal> , channel ) ; \n \t4 pool . <identifier> <identifiersep> object ( channel <identifiersep> <identifier> ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 } else if ( ! <identifier> . is <identifiersep> <identifier> <identifiersep> end <identifiersep> <identifier> ( ) ) { \n \t4 s <identifiersep> logger . info ( <string_literal> + <identifier> ) ; \n \t4 <identifier> . <identifier> <identifiersep> client ( <identifier> ) ; \n \t3 } else if ( ! <identifier> . get <identifiersep> client <identifiersep> host <identifiersep> password ( ) . equals ( <identifier> . get <identifiersep> client <identifiersep> host <identifiersep> password ( ) ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; } \n \t2 <identifier> <identifier> <identifiersep> final <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( final <identifiersep> <identifier> ) ; \n \t2 final byte <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> final <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> data ( ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 return <identifier> . <identifier> <identifiersep> all ( <identifier> <identifiersep> string , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ) ; } \n \t1 @ <identifier> \n \t1 public boolean lock <identifiersep> for <identifiersep> <identifier> ( connection connection , list < string > <identifier> ) throws sql <identifiersep> exception { \n <ect>
\t4 snapshot <identifiersep> info snapshot <identifiersep> info = <identifier> <identifiersep> status <identifiersep> response . get <identifiersep> <identifier> ( ) . get ( 0 ) ; \n \t4 assert <identifiersep> equals ( snapshot <identifiersep> state . success , snapshot <identifiersep> info . state ( ) ) ; \n \t4 assert <identifiersep> equals ( snapshot <identifiersep> info . total <identifiersep> shards ( ) , snapshot <identifiersep> info . <identifier> <identifiersep> shards ( ) ) ; \n \t4 assert <identifiersep> equals ( 0 , snapshot <identifiersep> info . failed <identifiersep> shards ( ) ) ; \n <ect>
\t2 this . <identifier> . <identifier> <identifiersep> value ( ) ; \n \t2 <identifier> = true ; \n \t1 } catch ( illegal <identifiersep> thread <identifiersep> state <identifiersep> exception e ) { } \n \t1 if ( <identifier> ) { \n <ect>
\t1 public <identifier> <identifier> <identifiersep> <identifier> ( string name , <identifier> <identifiersep> context context ) { \n \t2 try { \n \t3 object bean = context . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> by <identifiersep> name ( <string_literal> + name ) ; \n \t3 if ( bean instanceof <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 logger . info ( \n \t6 <string_literal> ) ; \n \t5 logger . debug ( <string_literal> ) ; \n <ect>
\t2 @ <identifier> \n \t2 public void on <identifiersep> <identifier> ( <identifier> <identifier> ) { \n \t3 final string <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( object <identifiersep> <identifier> . equal <identifiersep> ignore <identifiersep> case ( <string_literal> , <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t1 private final <identifier> <identifiersep> <identifier> <identifiersep> text <identifiersep> <identifier> text <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> text <identifiersep> <identifier> ( max <identifiersep> <identifier> <identifiersep> length ) ; \n \t1 public void <identifier> ( ) { \n \t2 logger . debug ( <string_literal> ) ; } \n \t1 public void <identifier> ( ) { \n <ect>
\t4 if ( port <identifiersep> <identifier> != null && port <identifiersep> <identifier> . length ( ) > 0 ) { \n \t5 port = integer . parse <identifiersep> int ( port <identifiersep> <identifier> ) ; } } \n \t3 <identifier> <identifiersep> api = api <identifiersep> <identifier> <identifiersep> factory . build ( <identifier> , port ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t4 case request <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> failed : \n \t5 if ( key instanceof node <identifiersep> <identifier> ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t6 return ; } \n <ect>
\t2 if ( s <identifiersep> pool . get <identifiersep> status ( ) != storage <identifiersep> pool <identifiersep> status . <identifier> ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + id + <string_literal> ) ; \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> + id ) ; } \n \t2 if ( s <identifiersep> pool . is <identifiersep> local ( ) ) { \n <ect>
\t4 thread . <identifier> ( <number_literal> ) ; } \n \t2 } catch ( interrupted <identifiersep> exception p <identifiersep> i <identifiersep> ex ) { \n \t3 logger . error ( <string_literal> + p <identifiersep> i <identifiersep> ex . get <identifiersep> message ( ) ) ; \n \t2 } catch ( exception p <identifiersep> i <identifiersep> ex ) { \n <ect>
\t1 <comment> \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
<identifier> : <identifier> <identifiersep> <identifier> , \n api : api ) { \n import config . <identifier> <identifiersep> <identifier> \n if ( api . <identifier> <identifiersep> user <identifiersep> id . is <identifiersep> empty ) { \n <ect>
\t4 logger . debug ( <string_literal> , db <identifiersep> url ) ; } \n \t3 return connection ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 job . wait <identifiersep> for <identifiersep> <identifier> ( true ) ; } \n \t2 catch ( io <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; } \n \t2 catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t3 return null ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 channel . <identifier> ( 0 ) ; \n \t2 } catch ( <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t3 log . trace ( <string_literal> , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 private <identifier> <identifiersep> manager create <identifiersep> cache <identifiersep> manager ( <identifier> <identifiersep> configuration configuration ) throws io <identifiersep> exception { \n \t2 object <identifiersep> <identifier> . not <identifiersep> null ( configuration , <string_literal> ) ; \n \t2 <comment> \n \t2 if ( configuration . has <identifiersep> cache <identifiersep> manager ( ) ) { \n <ect>
\t3 <identifier> . close ( ) ; } } \n \t1 } ; \n \t1 return response . <identifier> ( stream ) . build ( ) ; \n \t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n <ect>
\t3 client <identifiersep> <identifier> <identifiersep> context = config . create <identifiersep> client <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t2 } catch ( exception e ) { \n \t3 throw new io <identifiersep> exception ( <string_literal> , e ) ; } \n \t2 long end = system . current <identifiersep> time <identifiersep> millis ( ) ; \n <ect>
\t3 try { \n \t4 file <identifier> = get <identifiersep> file ( id , root ) ; \n \t4 <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) . <identifier> ( ) ; \n \t4 files . <identifier> ( <identifier> , <identifier> ) ; \n <ect>
\t4 boolean is <identifiersep> <identifier> = conn . <identifier> <identifiersep> with <identifiersep> password ( <string_literal> , <string_literal> ) ; \n \t4 if ( is <identifiersep> <identifier> == false ) { \n \t5 return <string_literal> ; \n \t4 } else { \n <ect>
\t2 double <identifier> = double . parse <identifiersep> double ( x . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> ++ ; \n \t2 x = list . get ( <identifier> ) ; \n \t2 if ( ! x . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 this . stream . delete <identifiersep> event ( <identifier> . get ( 0 ) ) ; \n \t3 } else { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 } catch ( query <identifiersep> exception ex ) { \n <ect>
\t6 s <identifiersep> logger . debug ( <string_literal> + name ) ; } } \n \t2 } catch ( sql <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> , e ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t4 try { \n \t5 <identifier> . <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( conn ) ; \n \t5 <identifier> . add ( <identifier> . network ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t4 if ( test <identifiersep> port == 0 ) \n \t5 throw new <identifier> <identifiersep> host <identifiersep> exception ( <string_literal> ) ; \n \t4 test . set <identifiersep> <identifier> <identifiersep> port ( test <identifiersep> port ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 @ <identifier> \n \t3 public boolean answer ( <identifier> <identifiersep> on <identifiersep> <identifier> <identifier> ) throws throwable { \n \t4 logger . info ( <string_literal> ) ; \n \t4 wait <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t5 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) != null ) { \n \t6 <identifier> <identifiersep> event <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> event ( <identifier> , template . get <identifiersep> account <identifiersep> id ( ) , <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) , template . get <identifiersep> id ( ) , template . get <identifiersep> name ( ) , null , null , \n \t7 <identifier> <identifiersep> size , template . get <identifiersep> size ( ) , <identifier> <identifiersep> <identifier> <identifiersep> template . class . get <identifiersep> name ( ) , template . get <identifiersep> <identifier> ( ) ) ; \n \t5 } else { \n <ect>
<comment> \n private void <identifier> <identifiersep> <identifier> ( job <identifiersep> context context ) throws io <identifiersep> exception { \n \t1 if ( ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 logger . debug ( string . format ( <string_literal> , node . get <identifiersep> node <identifiersep> id ( ) , class <identifiersep> id ) ) ; \n \t4 return null ; } \n \t3 class < ? extends <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class > command <identifiersep> class <identifiersep> class = command <identifiersep> class . get <identifiersep> command <identifiersep> class <identifiersep> class ( ) ; \n \t3 if ( command <identifiersep> class <identifiersep> class == null ) { \n <ect>
\t2 { \n \t3 new url ( <identifier> <identifiersep> url <identifiersep> text ) ; } \n \t2 catch ( <identifier> <identifiersep> url <identifiersep> exception e ) \n \t2 { \n <ect>
\t4 output <identifiersep> stream out = new file <identifiersep> output <identifiersep> stream ( <identifier> <identifiersep> to <identifiersep> file ) ; \n \t2 ) { \n \t3 io <identifiersep> utils . <identifier> ( in , out ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
public class log <identifiersep> test { \n \t1 @ test \n \t1 public void log <identifiersep> <identifier> ( ) { \n \t2 logger log = log <identifiersep> manager . get <identifiersep> logger ( ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> network <identifiersep> model . list <identifiersep> network <identifiersep> <identifier> <identifiersep> <identifier> ( network . get <identifiersep> network <identifiersep> <identifier> <identifiersep> id ( ) ) . is <identifiersep> empty ( ) && network . get <identifiersep> <identifier> ( ) == null ) { \n \t3 return null ; } \n \t2 set < long > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> network <identifiersep> model . get <identifiersep> <identifier> <identifiersep> <identifier> ( network , <identifier> <identifiersep> ip ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 } else { \n \t3 <comment> \n \t3 thrift <identifiersep> type thrift <identifiersep> type = <identifier> <identifiersep> manager . get <identifiersep> <identifier> ( ) . get <identifiersep> thrift <identifiersep> type ( <identifier> ) ; \n \t3 if ( <identifier> ) { \n <ect>
\t1 protected static void add <identifiersep> <identifier> <identifiersep> vm <identifiersep> is <identifiersep> <identifier> <identifiersep> ip <identifiersep> <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> <identifiersep> vm , final long <identifier> <identifiersep> id <identifiersep> for <identifiersep> <identifier> <identifiersep> ip , final list < <identifier> <identifiersep> <identifier> <identifiersep> vo > <identifier> <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> vm . get <identifiersep> <identifier> <identifiersep> id <identifiersep> to <identifiersep> <identifier> <identifiersep> in ( ) . equals ( <identifier> <identifiersep> id <identifiersep> for <identifiersep> <identifier> <identifiersep> ip ) ) { \n \t3 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> vm ) ; } } \n \t1 protected <identifier> <identifiersep> <identifier> <identifiersep> vo start ( final <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> <identifiersep> vm , final map < <identifier> , object > <identifier> ) throws <identifier> <identifiersep> operation <identifiersep> exception { \n <ect>
\t3 catch ( exception e ) \n \t3 { \n \t4 if ( <identifier> . contains ( e , <identifier> <identifiersep> channel <identifiersep> exception . class ) ) \n \t4 { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> volume ( ) { \n <ect>
\t6 status <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> on ( true ) ; \n \t5 } else { \n \t6 status <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> on ( false ) ; } \n \t4 } else { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 try { \n \t3 execute <identifiersep> <identifier> <identifiersep> json <identifiersep> test ( <string_literal> , <string_literal> , true , <number_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 string <identifier> = get <identifiersep> <identifier> ( ) ; \n \t2 string id = get <identifiersep> name ( <identifier> ) ; \n \t2 <identifier> . not <identifiersep> null ( id , <string_literal> + <identifier> + <string_literal> + source <identifiersep> name ) ; \n \t2 if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> mode ( ) ) { \n <ect>
\t2 } ) ; \n \t2 <comment> \n \t1 public void <identifier> ( ) { \n \t2 if ( data == null || data . get <identifiersep> is <identifiersep> shutdown ( ) . get <identifiersep> and <identifiersep> set ( true ) ) { \n <ect>
\t1 public <identifier> <identifiersep> <identifier> read <identifiersep> from ( class < <identifier> <identifiersep> <identifier> > type , type <identifier> <identifiersep> type , \n \t7 <identifier> [ ] <identifier> , <identifier> <identifiersep> type <identifier> <identifiersep> type , \n \t7 <identifier> <identifiersep> map < string , string > http <identifiersep> <identifier> , input <identifiersep> stream entity <identifiersep> stream ) \n \t3 throws io <identifiersep> exception , web <identifiersep> application <identifiersep> exception { \n <ect>
void <identifier> ( ) \n { \n \t1 <identifier> <identifiersep> <identifier> . <identifier> ( false ) ; \n \t1 if ( is <identifiersep> <identifier> ) { \n <ect>
\t2 cluster <identifiersep> state <identifiersep> response cluster <identifiersep> state <identifiersep> response = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> state ( ) . set <identifiersep> <identifier> ( <string_literal> ) . execute ( ) . action <identifiersep> get ( ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state <identifiersep> response . get <identifiersep> state ( ) . meta <identifiersep> data ( ) . has <identifiersep> index ( <string_literal> ) , equal <identifiersep> to ( true ) ) ; } \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> node <identifiersep> and <identifiersep> <identifier> <identifiersep> data <identifiersep> node ( ) throws exception { \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> , e ) ; } } \n \t1 private void add <identifiersep> index <identifiersep> for <identifiersep> vm <identifiersep> instance ( final connection conn ) { \n \t2 <comment> \n \t2 final list < string > index <identifiersep> list = new array <identifiersep> list < string > ( ) ; \n <ect>
\t4 final integer <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> int ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . set <identifiersep> property ( <identifier> <identifiersep> <identifier> . key ( <identifier> . class , <string_literal> ) , <identifier> ) ; \n \t4 return <identifier> ; } \n \t2 } catch ( metadata <identifiersep> exception | json <identifiersep> exception | <identifier> <identifiersep> exception ex ) { \n <ect>
\t5 output . write ( <identifier> ) ; \n \t5 <identifier> ++ ; \n \t5 last <identifiersep> line = <identifier> ; } } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 final string <identifier> <identifiersep> <identifier> <identifiersep> key = name + <string_literal> ; \n \t4 if ( resource <identifiersep> <identifier> . contains <identifiersep> key ( <identifier> <identifiersep> <identifier> <identifiersep> key ) ) { \n \t5 property . set <identifiersep> <identifier> <identifiersep> name ( resource <identifiersep> <identifier> . get <identifiersep> string ( <identifier> <identifiersep> <identifier> <identifiersep> key ) ) ; <comment> \n \t4 } else { \n <ect>
\t3 error += ( registered <identifiersep> client . request <identifiersep> info . task <identifiersep> <identifier> <identifiersep> id + <string_literal> ) ; } } } \n \t1 if ( ! error . is <identifiersep> empty ( ) ) { \n \t2 log . info ( <string_literal> + error ) ; } \n \t1 if ( update <identifiersep> count == 0 ) { \n <ect>
\t1 output . write ( request . file . get <identifiersep> file <identifiersep> content ( ) . get <identifiersep> bytes ( <string_literal> ) ) ; \n \t1 output . close ( ) ; \n \t1 return response . status ( <number_literal> ) . build ( ) ; \n \t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n <ect>
\t6 version version , \n \t6 boolean remove <identifiersep> <identifier> ) \n \t2 throws path <identifiersep> not <identifiersep> found <identifiersep> exception , item <identifiersep> exists <identifiersep> exception , version <identifiersep> exception , <identifier> <identifiersep> <identifier> <identifiersep> exception , \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> operation <identifiersep> exception , lock <identifiersep> exception , <identifier> <identifiersep> item <identifiersep> state <identifiersep> exception , <identifier> <identifiersep> exception { \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 throw new <identifier> <identifiersep> request <identifiersep> exception ( msg . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t2 string <identifier> <identifiersep> name = <identifier> . get <identifiersep> name ( ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> empty ( <identifier> <identifiersep> name ) ) { \n <ect>
\t2 public void run ( ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . get ( ) ; \n \t2 } catch ( final interrupted <identifiersep> exception e ) { \n <ect>
\t4 last <identifiersep> <identifier> <identifiersep> data . add ( <identifier> <identifiersep> data <identifiersep> <identifier> ) ; \n \t4 last <identifiersep> error <identifiersep> data . add ( <identifier> <identifiersep> data <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> data . add ( <identifier> <identifiersep> data <identifiersep> <identifier> ) ; \n \t3 } else { \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> data <identifiersep> source <identifiersep> provider <identifiersep> input <identifiersep> stream <identifiersep> not <identifiersep> read ( ) throws exception { \n \t2 <comment> \n \t2 int count <identifiersep> <identifier> = count <identifiersep> files ( server <identifiersep> <identifier> <identifiersep> dir ) ; \n <ect>
<comment> \n \t1 public static synchronized void set <identifiersep> <identifier> ( boolean <identifier> ) { \n \t2 if ( logger <identifiersep> context == null ) { \n <ect>
\t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t4 <comment> \n \t5 log . debug ( <string_literal> , <identifier> ) ; } \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \t3 logger . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> query . get ( i ) . get <identifiersep> query ( ) ) ; \n \t3 logger . info ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> query <identifiersep> <identifier> . <identifier> <identifiersep> file <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> query . get ( i ) . get <identifiersep> query ( ) , configuration <identifiersep> check <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> dir ( ) ) ; <comment> \n <ect>
\t8 else { \n \t9 <identifier> . error ( log , <string_literal> + <identifier> <identifiersep> <identifier> . name ( ) + \n \t10 <string_literal> + <identifier> <identifiersep> <identifier> . execution <identifiersep> id ( ) + ' ] ' , e ) ; } } \n \t7 catch ( throwable e ) { \n <ect>
\t3 <identifier> . set <identifiersep> password ( <identifier> . get ( user <identifiersep> name ) . to <identifiersep> char <identifiersep> array ( ) ) ; \n \t2 } else { \n \t3 log . warn ( <string_literal> , user <identifiersep> name ) ; } } \n \t1 private void handle <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n <ect>
\t1 for ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t2 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> json <identifiersep> output . put <identifiersep> all ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> json <identifiersep> output ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t7 msg = <string_literal> ; } \n \t6 time <identifiersep> unit . <identifier> . <identifier> ( 1 ) ; } \n \t5 msg = <string_literal> ; \n \t4 } catch ( exception ex ) { \n <ect>
\t4 task . get <identifiersep> <identifier> ( ) . send ( request . to <identifiersep> bytes ( ) ) ; \n \t4 <comment> \n \t4 set <identifiersep> last <identifiersep> <identifier> <identifiersep> response <identifiersep> time ( ) ; \n \t3 } catch ( final <identifier> <identifiersep> channel <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> source , <identifier> <identifiersep> target , true ) ; \n \t3 return ; } \n \t2 if ( execute && ( process <identifiersep> utils . find <identifiersep> <identifier> <identifiersep> <identifier> ( id , node ) != null ) ) { \n \t3 string msg = <string_literal> + get <identifiersep> name ( ) ; \n <ect>
\t2 if ( property . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> property <identifiersep> key ( key ) ) { \n \t3 system <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> system <identifiersep> property ( key , value ) ; \n \t3 log . info ( <string_literal> , key , property . is <identifiersep> <identifier> ( key ) ? <string_literal> : value ) ; \n \t2 } else { \n <ect>
\t5 . to ( <string_literal> ) ; } \n \t2 } ; } \n \t1 private static class <identifier> <identifiersep> <identifier> implements <identifier> { \n \t2 public void process ( exchange exchange ) throws exception { \n <ect>
\t3 <identifier> . continue <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 logger . info ( <string_literal> ) ; \n \t3 <comment> \n \t3 <identifier> <identifiersep> nodes ( <string_literal> , <number_literal> ) ; \n <ect>
\t2 for ( int i = 0 ; i < count ; i ++ ) { \n \t3 list <identifiersep> index . add ( <identifier> , key ( i ) , ( long ) i ) ; \n \t3 <identifier> . <identifier> ( ) ; } \n \t2 log . info ( <string_literal> + count + <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - start ) + <string_literal> ) ; \n <ect>
\t3 stop ( ) ; \n \t3 start ( ) ; \n \t2 } catch ( configuration <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t6 break ; } } \n \t4 if ( ! host <identifiersep> <identifier> <identifiersep> access <identifiersep> pool ) { \n \t5 break ; } \n \t4 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 write <identifiersep> process <identifiersep> event . <identifier> ( <string_literal> ) ; \n \t2 if ( <identifier> == null ) { \n \t3 throw new web <identifiersep> application <identifiersep> exception ( response . status . not <identifiersep> found ) ; } \n <ect>
\t4 } else if ( job <identifiersep> key . get <identifiersep> job <identifiersep> <identifier> ( ) == null ) { \n \t5 log . warn ( <string_literal> , job <identifiersep> key ) ; \n \t5 continue ; \n \t4 } else if ( job <identifiersep> key . get <identifiersep> node <identifiersep> number ( ) == null ) { \n <ect>
\t2 if ( socket == null ) return ; \n \t2 try { \n \t3 socket . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 if ( bean . get ( ) != null ) { \n \t3 try { \n \t4 return ( t ) <identifier> . <identifier> ( bean . get ( ) ) ; \n \t3 } catch ( illegal <identifiersep> argument <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception | <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
\t1 protected string get <identifiersep> <identifier> ( ) { \n \t2 return default <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public void close ( task <identifiersep> <identifier> <identifiersep> context context ) { \n <ect>
\t6 logger . warn ( <string_literal> , get <identifiersep> node ( ) , <identifier> <identifiersep> status ) ; \n \t6 break ; } \n \t4 break ; \n \t3 case application <identifiersep> status <identifiersep> <identifier> : \n <ect>
\t4 return true ; \n \t3 <comment> \n \t3 string server <identifiersep> <identifier> = <identifier> <identifiersep> get <identifiersep> header ( response , <string_literal> ) ; \n \t3 if ( server <identifiersep> <identifier> != null ) { \n <ect>
\t2 try { \n \t3 final <identifier> <identifiersep> cluster <identifiersep> status cluster <identifiersep> status = <identifier> <identifiersep> <identifier> <identifiersep> api . get <identifiersep> <identifier> <identifiersep> cluster <identifiersep> status ( ) ; \n \t3 final string status = cluster <identifiersep> status . get <identifiersep> cluster <identifiersep> status ( ) ; \n \t3 if ( cluster <identifiersep> is <identifiersep> <identifier> ( status ) ) { \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + <identifier> . get <identifiersep> name ( ) , e ) ; \n \t2 } catch ( m <identifiersep> bean <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + <identifier> . get <identifiersep> name ( ) , e ) ; \n \t2 } catch ( not <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifiersep> exception e ) { \n <ect>
\t10 s <identifiersep> logger . debug ( <string_literal> + template <identifiersep> pool <identifiersep> vo . get <identifiersep> id ( ) + <string_literal> ) ; \n \t10 continue ; } \n \t9 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> template <identifiersep> from <identifiersep> storage <identifiersep> pool ( template <identifiersep> pool <identifiersep> vo ) ; } \n \t7 } catch ( exception e ) { \n <ect>
\t2 final node <identifiersep> state target <identifiersep> root = target . get <identifiersep> root ( ) ; \n \t2 final node <identifiersep> state <identifier> <identifiersep> source = <identifier> <identifiersep> node <identifiersep> state . <identifier> ( source <identifiersep> root , new <identifier> <identifiersep> <identifier> ( log , <string_literal> , log <identifiersep> node <identifiersep> <identifier> , - 1 ) ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 if ( target <identifiersep> root . <identifier> <identifiersep> <identifier> <identifiersep> base <identifiersep> state ( <identifier> <identifiersep> source , new <identifier> <identifiersep> equals <identifiersep> <identifier> ( log , <string_literal> ) ) ) { \n <ect>
<comment> \n \t1 public static <identifier> <identifiersep> sql <identifiersep> connection <identifiersep> manager get <identifiersep> instance ( ) throws <identifier> <identifiersep> service <identifiersep> exception { \n \t2 if ( instance == null ) { \n <ect>
\t4 if ( is <identifiersep> current ) { \n \t5 <identifier> += <number_literal> ; <comment> \n \t4 <identifier> . snapshot <identifiersep> create <identifiersep> xml ( snapshot <identifiersep> xml , <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 <identifier> = null ; \n \t4 } else if ( state == metadata <identifiersep> <identifier> ) { \n \t5 metadata <identifiersep> <identifier> = null ; \n \t4 } else { \n <ect>
\t2 if ( <identifier> != null ) \n \t3 <comment> \n \t3 <identifier> . on <identifiersep> message <identifiersep> <identifier> ( <identifier> , msg ) ; \n <ect>
\t2 session session = connection . create <identifiersep> session ( false , session . <identifier> <identifiersep> <identifier> ) ; \n \t2 destination <identifier> <identifiersep> destination = get <identifiersep> <identifier> <identifiersep> destination ( ) ; \n \t2 destination <identifier> = get <identifiersep> <identifier> ( ) ; \n \t2 destination <identifier> = get <identifiersep> <identifier> ( ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 <identifier> <identifiersep> is <identifiersep> <identifier> = false ; } \n \t1 void <identifier> ( info <identifiersep> <identifier> <identifier> , <identifier> <identifier> , boolean is <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 <identifier> . remove <identifiersep> value ( <string_literal> ) ; } \n \t3 try { \n \t4 <identifier> . process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> parse <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> ( <identifier> <identifiersep> info . get <identifiersep> code ( ) ) ; } \n \t2 <identifier> . <identifier> ( <identifier> . <identifier> ) . name ( <identifier> <identifiersep> name ) ; \n \t2 list < <identifier> <identifiersep> info > <identifier> = <identifier> <identifiersep> <identifier> . instance . find <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t10 final collection < <identifier> <identifiersep> event > <identifier> ) { \n \t2 final string remote <identifiersep> <identifier> = client <identifiersep> info <identifiersep> <identifier> . get <identifiersep> client <identifiersep> info ( ) . get <identifiersep> client <identifiersep> ip <identifiersep> address ( ) ; \n \t2 logger . debug ( <string_literal> , remote <identifiersep> <identifier> ) ; \n \t2 final long count = <identifier> . stream ( ) . filter ( e - > e . get <identifiersep> client <identifiersep> ip <identifiersep> address ( ) . equals <identifiersep> ignore <identifiersep> case ( remote <identifiersep> <identifier> ) ) . count ( ) ; \n <ect>
\t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 log . error ( e , <string_literal> ) ; \n \t3 throw new runtime <identifiersep> exception ( e ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 logger . warn ( <string_literal> ) \n \t2 user <identifiersep> output <identifiersep> file . set ( <identifier> ) } \n \t1 @ <identifier> \n \t1 void cache <identifiersep> directory ( <identifier> ) { \n <ect>
\t2 log . warn ( e ) ; } \n \t1 } else { \n \t1 file s = new file ( get <identifiersep> <identifier> <identifiersep> dir ( ) ) ; \n \t1 if ( ! s . delete ( ) ) { \n <ect>
<comment> \n \t8 return ; } } \n \t6 map < integer , resource <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> task <identifiersep> <identifier> = new <identifier> <identifiersep> map < > ( ) ; \n \t6 for ( integer task : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 final map < string , object > new <identifiersep> <identifier> <identifiersep> attributes = new <identifier> <identifiersep> map < > ( attributes ) ; \n \t2 final map < string , string > <identifier> <identifiersep> attributes <identifiersep> to <identifiersep> <identifier> = <identifier> ( new <identifiersep> <identifier> <identifiersep> attributes ) ; \n \t2 if ( registered <identifiersep> service != null && registered <identifiersep> service . get <identifiersep> access <identifiersep> <identifier> ( ) . is <identifiersep> service <identifiersep> access <identifiersep> <identifier> ( ) ) { \n \t3 <identifier> <identifiersep> attributes <identifiersep> <identifier> ( new <identifiersep> <identifier> <identifiersep> attributes , <identifier> <identifiersep> attributes <identifiersep> to <identifiersep> <identifier> , this . <identifier> <identifiersep> <identifier> , registered <identifiersep> service ) ; \n <ect>
\t3 return false ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> version <identifiersep> exception e ) { \n \t3 <comment> \n \t3 <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n <ect>
\t3 log . debug ( <string_literal> , e ) ; \n \t2 } catch ( instance <identifiersep> <identifier> <identifiersep> exists <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> + <identifier> <identifiersep> name + <string_literal> , e ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t5 . add <identifiersep> web <identifiersep> socket <identifiersep> listener ( new web <identifiersep> socket <identifiersep> listener ( ) { \n \t6 @ <identifier> \n \t6 public void on <identifiersep> text <identifiersep> <identifier> ( string message , boolean final <identifiersep> <identifier> , int <identifier> ) { \n \t7 <identifier> . add ( message ) ; \n <ect>
<comment> \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 for ( <identifier> <identifiersep> <identifier> <identifiersep> type <identifier> <identifiersep> type : <identifier> <identifiersep> <identifier> <identifiersep> type . values ( ) ) { \n \t4 string channel <identifiersep> config <identifiersep> value = <identifier> . to <identifiersep> string ( config . get ( <identifier> <identifiersep> type . channel <identifiersep> config <identifiersep> key ) , null ) ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + file . <identifier> + integer . to <identifiersep> <identifier> <identifiersep> string ( <identifier> <identifiersep> <identifier> . next <identifiersep> int ( integer . max <identifiersep> value ) ) ; \n \t3 file = new file ( <identifier> <identifiersep> <identifier> ) ; \n \t2 } while ( file . exists ( ) ) ; \n \t2 if ( ! file . <identifier> ( ) ) { \n <ect>
\t6 <identifier> <identifiersep> job <identifiersep> <identifier> job <identifiersep> <identifier> = get <identifiersep> <identifier> ( job . get <identifiersep> <identifier> ( ) ) ; \n \t6 if ( job <identifiersep> <identifier> != null ) { \n \t7 job <identifiersep> <identifier> . run <identifiersep> job ( job ) ; \n \t6 } else { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ; \n \t1 <comment> \n \t1 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( <identifier> ) ) { \n \t2 return null ; } \n <ect>
\t1 try { \n \t1 properties <identifier> = \n \t2 load <identifiersep> all <identifiersep> properties ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> location , this . class <identifiersep> <identifier> ) ; \n <ect>
\t2 try { \n \t3 return <identifier> & <identifier> [ ( int ) ( read <identifiersep> count <identifier> max <identifiersep> <identifier> <identifiersep> size ) ] ; \n \t2 } catch ( array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t3 logger . error ( <string_literal> , ex ) ; \n <ect>
\t2 } else if ( command . get <identifiersep> type ( ) == <identifier> <identifiersep> <identifier> <identifiersep> command . type . vm ) { \n \t3 result = <identifier> <identifiersep> resource <identifiersep> base . <identifier> <identifiersep> host <identifiersep> <identifier> ( conn , <string_literal> , <string_literal> , <string_literal> , <identifier> , <string_literal> , <identifier> <identifiersep> name <identifiersep> <identifier> , <string_literal> , <identifier> <identifiersep> <identifier> , <string_literal> , \n \t5 <identifier> <identifiersep> <identifier> , <string_literal> , vm <identifiersep> <identifier> ) ; \n \t3 if ( result == null || result . is <identifiersep> empty ( ) || ! boolean . parse <identifiersep> boolean ( result ) ) { \n <ect>
\t2 # <identifier> json data \n \t2 host <identifiersep> <identifier> = json . <identifier> ( <identifier> <identifiersep> json ) \n \t1 <identifier> \n \t1 <identifier> \n <ect>
\t6 for ( <identifier> <identifiersep> listener listener : <identifier> <identifiersep> listener . all ( ) ) \n \t7 listener . on <identifiersep> <identifier> ( ) ; \n \t6 <identifier> . <identifier> ( ) ; \n \t5 } else { \n <ect>
\t4 handle <identifiersep> error ( context , <identifier> <identifiersep> job , <identifier> <identifiersep> action ) ; \n \t4 return null ; } \n \t3 catch ( exception ex ) { \n \t4 context . set <identifiersep> error <identifiersep> info ( <identifier> <identifiersep> error , ex . get <identifiersep> message ( ) ) ; \n <ect>
\t2 <identifier> <identifiersep> m <identifiersep> bean = new security <identifiersep> manager <identifiersep> m <identifiersep> bean <identifiersep> <identifier> ( this ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> m <identifiersep> bean ( <string_literal> , <string_literal> , <identifier> <identifiersep> m <identifiersep> bean ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 <identifier> . add <identifiersep> error ( the <identifiersep> <identifier> , <identifier> ) ; \n \t5 log . info ( <string_literal> , e ) ; \n \t4 } else { \n \t5 <identifier> . add <identifiersep> error ( the <identifiersep> <identifier> , e ) ; \n <ect>
\t3 xml <identifiersep> <identifier> <identifiersep> <identifier> . handle <identifiersep> exception ( ex ) ; \n \t3 system . out . <identifier> ( <string_literal> ) ; } } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> input <identifiersep> stream ( ) { \n <ect>
\t4 return false ; } \n \t3 return true ; \n \t2 } catch ( exception e ) { \n \t3 if ( error ) { \n <ect>
\t2 logger . debug ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) ) ; \n \t2 int command = <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <identifier> ) ; \n \t2 switch ( command ) { \n \t3 case <identifier> <identifiersep> <identifier> <identifiersep> get : \n <ect>
\t2 authentication <identifiersep> token token = <identifier> <identifiersep> base . get <identifiersep> authentication <identifiersep> token ( \n \t3 <identifier> <identifiersep> input <identifiersep> format . class , job <identifiersep> conf ) ; \n \t2 if ( null != token && ! job <identifiersep> conf . get <identifiersep> <identifier> ( ) . get <identifiersep> all <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n \t2 <comment> \n <ect>
\t1 file <identifiersep> status file = file <identifiersep> with <identifiersep> id . get <identifiersep> file <identifiersep> status ( ) ; \n \t1 path path = file . get <identifiersep> path ( ) ; \n \t1 <identifier> <identifiersep> and <identifiersep> file <identifiersep> data <identifier> = cache . get <identifiersep> if <identifiersep> <identifier> ( path ) ; \n <ect>
\t3 string name = ( string ) entry . get <identifiersep> key ( ) ; \n \t3 if ( ! ignore <identifiersep> <identifier> <identifiersep> <identifier> . contains ( name ) ) { \n \t4 if ( name . <identifier> <identifiersep> with ( <string_literal> ) && ! name . <identifier> <identifiersep> with ( ignore <identifiersep> test <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t5 if ( configuration . get ( name ) == null ) { \n <ect>
\t6 catch ( grid <identifiersep> <identifier> <identifiersep> timeout <identifiersep> exception <identifier> ) { \n \t7 <comment> \n \t7 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } } \n <ect>
\t4 <comment> \n \t4 string text = consumer . <identifier> <identifiersep> body ( string . class , <number_literal> ) ; \n \t4 assert . assert <identifiersep> equals ( message , text ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n \t5 <identifier> <identifiersep> log . warn ( <string_literal> , <identifier> ) ; \n \t3 } catch ( runtime <identifiersep> exception e ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 <identifier> . find ( new <identifier> <identifiersep> info ( <identifier> <identifiersep> name ) ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t1 throw new no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception ( <identifier> <identifiersep> name ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t4 if ( task != null ) { \n \t5 try { \n \t6 task . <identifier> ( conn ) ; \n \t5 } catch ( final exception e ) { \n <ect>
\t3 logger . debug ( <string_literal> , item <identifiersep> name , command ) ; } \n \t2 <identifier> <identifiersep> type type = get <identifiersep> <identifier> <identifiersep> config ( item <identifiersep> name ) ; \n \t2 if ( type == null ) { \n <ect>
\t2 try { \n \t3 if ( <identifier> . contains ( name ) ) \n \t4 <identifier> . <identifier> ( name ) ; } \n \t2 catch ( exception ex ) { \n <ect>
<comment> \n \t1 public void <identifier> ( ) \n \t1 { \n <ect>
\t3 node <identifiersep> list node <identifiersep> list = ( node <identifiersep> list ) x <identifiersep> path <identifiersep> <identifier> . <identifier> ( xml <identifiersep> <identifier> , \n \t5 x <identifiersep> path <identifiersep> <identifier> . <identifier> ) ; \n \t3 return node <identifiersep> list . item ( 0 ) . get <identifiersep> node <identifiersep> value ( ) ; \n \t2 } catch ( null <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 final map < string , string > <identifier> = <identifier> <identifiersep> config <identifiersep> dao . get <identifiersep> configuration ( <string_literal> , <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = boolean . parse <identifiersep> boolean ( <identifier> . get ( <string_literal> ) ) ; \n \t2 string <identifier> = <identifier> . get ( <string_literal> ) ; \n \t2 if ( <string_literal> . equals <identifiersep> ignore <identifiersep> case ( <identifier> ) ) { \n <ect>
\t2 routing <identifiersep> table routing <identifiersep> table = routing <identifiersep> table . builder ( ) \n \t4 . add <identifiersep> as <identifiersep> new ( meta <identifiersep> data . index ( <string_literal> ) ) \n \t4 . build ( ) ; \n \t2 cluster <identifiersep> state cluster <identifiersep> state = cluster <identifiersep> state . builder ( cluster <identifiersep> name <identifiersep> <identifier> . get <identifiersep> default ( <identifier> . empty ) ) . meta <identifiersep> data ( meta <identifiersep> data ) . routing <identifiersep> table ( routing <identifiersep> table ) . build ( ) ; \n <ect>
\t2 assert <identifiersep> that ( routing <identifiersep> table . index ( <string_literal> ) . <identifier> ( 0 ) . shards ( ) . get ( 0 ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( routing <identifiersep> table . index ( <string_literal> ) . <identifier> ( 0 ) . shards ( ) . get ( 1 ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( routing <identifiersep> table . index ( <string_literal> ) . <identifier> ( 0 ) . shards ( ) . get ( 0 ) . current <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; \n \t2 assert <identifiersep> that ( routing <identifiersep> table . index ( <string_literal> ) . <identifier> ( 0 ) . shards ( ) . get ( 1 ) . current <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; \n <ect>
\t5 not <identifiersep> found ( response , security <identifiersep> context ) ; \n \t5 response . get <identifiersep> output <identifiersep> stream ( ) . close ( ) ; } \n \t4 <identifier> . success ( ) ; \n \t3 } catch ( throwable <identifier> ) { \n <ect>
<comment> \n \t2 final org . apache . <identifier> . <identifier> . <identifier> . api . model . group <identifiersep> <identifier> result = request <identifiersep> body <identifiersep> and <identifiersep> <identifier> ( <string_literal> , null , <identifier> ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , result ) ; \n <ect>
\t2 } else if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . equals ( <identifier> ) ) { \n \t3 return string . format ( <string_literal> , table <identifiersep> name , table <identifiersep> file <identifiersep> dir , \n \t5 table <identifiersep> name ) ; \n \t2 } else { \n <ect>
\t5 file <identifiersep> utils . <identifier> <identifiersep> directory ( template <identifiersep> <identifier> <identifiersep> dir , user <identifiersep> directory , <identifier> <identifiersep> file <identifiersep> date ) ; \n \t4 } else { \n \t5 logger . warn ( <string_literal> + template <identifiersep> <identifier> <identifiersep> dir + <string_literal> ) ; } } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 queue <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 message <identifiersep> consumer consumer = session . create <identifiersep> consumer ( destination ) ; \n \t2 assert <identifiersep> null ( consumer . <identifier> ( <number_literal> ) ) ; \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( ticket <identifiersep> <identifier> <identifiersep> ticket <identifiersep> id ) && service != null ) { \n \t3 final authentication <identifier> = ticket <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> authentication <identifiersep> from ( ticket <identifiersep> <identifier> <identifiersep> ticket <identifiersep> id ) ; \n \t3 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t2 <identifier> = <identifier> <identifiersep> shutdown <identifiersep> <identifier> ; \n \t2 <identifier> <identifiersep> shutdown <identifiersep> <identifier> = null ; } } \n \t1 if ( state == state . <identifier> <identifiersep> <identifier> && <identifier> == null ) \n \t1 { \n <ect>
\t4 logger . warn ( <string_literal> \n \t5 + <string_literal> \n \t5 + <string_literal> , <identifier> . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; } } \n \t2 if ( principal == null ) { \n <ect>
@ <identifier> \n public void store <identifiersep> <identifier> ( final <identifier> <identifier> , final boolean <identifier> ) throws <identifier> <identifiersep> id <identifiersep> null <identifiersep> exception , \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> exists <identifiersep> exception , <identifier> <identifiersep> storage <identifiersep> exception { \n <ect>
\t7 stop = true ; \n \t6 } else { \n \t7 throw e ; } \n \t5 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 } else if ( <identifier> == null ) { \n \t5 return <identifier> ; \n \t4 } else if ( ! <identifier> . equals ( <identifier> ) ) { \n \t5 if ( ! <identifier> ) { \n <ect>
\t3 <identifier> = system . <identifier> <identifiersep> time ( ) ; \n \t3 if ( connection <identifiersep> <identifier> <identifiersep> count == max <identifiersep> <identifier> <identifiersep> <identifier> || end - <identifier> < = 0 ) \n \t4 throw new io <identifiersep> exception ( <string_literal> + connection <identifiersep> id + <string_literal> , channel <identifiersep> <identifier> . <identifier> ( ) ) ; \n \t3 long <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> timeout ( ) * ( long ) <identifier> . <identifier> ( <number_literal> , connection <identifiersep> <identifier> <identifiersep> count ) ; \n <ect>
\t2 try { \n \t2 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( public <identifiersep> key ) ; \n \t2 if ( <identifier> <identifiersep> token . <identifier> ( <identifier> ) ) { \n \t3 <identifier> = true ; \n <ect>
\t3 if ( get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state ( ) == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> <identifier> ) { \n \t4 <comment> \n \t4 s <identifiersep> logger . info ( <string_literal> ) ; \n \t4 return true ; } \n <ect>
\t1 public void <identifier> ( ) { \n \t2 logger . debug ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> ( path p , string <identifier> , file <identifiersep> system <identifier> ) throws io <identifiersep> exception { \n \t2 for ( file <identifiersep> status <identifier> : <identifier> . list <identifiersep> status ( p ) ) { \n \t3 path <identifier> = <identifier> . get <identifiersep> path ( ) ; \n \t3 if ( <identifier> . is <identifiersep> dir ( ) ) { \n <ect>
\t2 final string <identifiersep> builder text = new string <identifiersep> builder ( <number_literal> ) ; \n \t2 for ( final string item : <identifier> ) { \n \t3 text . <identifier> ( <string_literal> ) ; \n \t3 text . <identifier> ( item ) ; } \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> [ <number_literal> ] . equals ( <string_literal> ) ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class <identifier> <identifiersep> command <identifiersep> class = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class ) node \n \t7 . get <identifiersep> command <identifiersep> class ( command <identifiersep> class . <identifier> ) ; \n \t5 if ( <identifier> <identifiersep> command <identifiersep> class == null ) { \n <ect>
\t1 public void do <identifiersep> task ( <identifier> <identifiersep> task task ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . put ( task ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t5 event <identifiersep> <identifier> . <identifier> <identifiersep> update ( item <identifiersep> name , state ) ; } \n \t3 } ; \n \t3 <identifier> <identifiersep> service . <identifier> <identifiersep> message <identifiersep> consumer ( <identifier> <identifiersep> name , state <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 <identifier> . add ( uri . get <identifiersep> host ( ) ) ; \n \t3 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 logger . <identifier> ( <string_literal> , <identifier> <identifiersep> uri ) ; } } \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t5 <identifier> ( <string_literal> \n \t7 + <identifier> ) ; } \n \t4 session . <identifier> ( ) ; \n \t3 } catch ( throwable e ) { \n <ect>
\t3 <identifier> <identifiersep> event . remove <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> event . get <identifiersep> <identifier> ( ) ) ; } \n \t2 return true ; } \n \t1 private boolean check <identifiersep> <identifier> <identifiersep> <identifier> ( element e <identifiersep> action , string <identifiersep> builder <identifier> <identifiersep> list , string <identifiersep> builder <identifier> <identifiersep> <identifier> <identifiersep> list , \n \t3 configuration conf ) throws io <identifiersep> exception { \n <ect>
\t3 <identifier> . stop <identifiersep> <identifier> ( ) ; } } \n \t1 private int get <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> test <identifiersep> execution <identifiersep> <identifier> test <identifiersep> execution <identifiersep> <identifier> ) { \n \t2 int max <identifiersep> <identifier> <identifiersep> <identifier> = test <identifiersep> execution <identifiersep> <identifier> . get <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( max <identifiersep> <identifier> <identifiersep> <identifier> > max <identifiersep> <identifier> <identifiersep> count ) { \n <ect>
\t4 return ; } \n \t3 command = string . format ( command , <identifier> <identifiersep> <identifier> . get ( 0 ) . get <identifiersep> address ( ) ) ; \n \t3 try \n \t3 { \n <ect>
\t8 <identifier> . message <identifiersep> <identifier> ( connection , status ) ; } } \n \t6 line = in . read <identifiersep> line ( ) ; } } \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 logger . debug ( <string_literal> , e ) ; } \n <ect>
\t2 <string_literal> + e . get <identifiersep> message ( ) ) ) ; \n \t1 log . error ( <string_literal> , e ) ; \n \t1 } catch ( runtime <identifiersep> exception e ) { \n \t1 if ( log . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> ( ) == null || ! <identifier> . get <identifiersep> <identifier> ( ) . equals <identifiersep> ignore <identifiersep> case ( this . handler <identifiersep> <identifier> ) ) { \n \t3 logger . warn ( <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) , this . handler <identifiersep> <identifier> ) ; \n \t3 return new <identifier> <identifiersep> <identifier> <identifiersep> collection ( ) ; } \n \t2 if ( <identifier> . get <identifiersep> principal ( ) == null ) { \n <ect>
\t3 return false ; } \n \t2 if ( this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) { \n \t3 logger . debug ( <string_literal> , get <identifiersep> name ( ) ) ; \n \t3 return true ; } \n <ect>
\t3 if ( <identifier> <identifiersep> service . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> <identifiersep> service . request <identifiersep> <identifier> ( ) ; } \n \t3 <identifier> <identifiersep> service . stop ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 on <identifiersep> <identifier> <identifiersep> thread . <identifier> ( ) ; } \n \t2 catch ( interrupted <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t4 <identifier> <identifier> <identifiersep> <identifier> = new <identifier> ( get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , session <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , response ) ; \n \t3 } else { \n \t4 if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t4 object value ; \n \t4 try { \n \t5 value = <identifier> ( value <identifiersep> byte ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t5 0 , <identifier> ) . set <identifiersep> string ( 1 , <identifier> ) . set <identifiersep> string ( <number_literal> , <identifier> <identifiersep> with <identifiersep> <identifier> ) . <identifier> <identifiersep> result ( ) ; } \n \t3 catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t4 log . error ( <string_literal> + <identifier> + <string_literal> , <identifier> ) ; } \n \t3 catch ( exception e ) { \n <ect>
\t3 if ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) > 0 ) { \n \t4 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; } \n \t2 } while ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) != 0 || \n \t4 cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) != 0 && <identifier> < <number_literal> ) ; \n <ect>
\t2 try { \n \t3 for ( int i = 0 ; i < num <identifiersep> <identifier> ; ++ i ) { \n \t4 log . info ( <string_literal> + i + <string_literal> ) ; \n \t4 test ( ) ; } \n <ect>
\t3 return ; \n \t2 if ( <identifier> . version ( ) == 1 ) \n \t3 return ; \n \t2 if ( <identifier> . <identifier> <identifiersep> to ( <identifier> ) != <identifier> <identifiersep> c ) \n <ect>
\t2 <identifier> <identifier> = create <identifiersep> <identifier> ( key <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) . get <identifiersep> <identifier> <identifiersep> host <identifiersep> name ( ) ) ; \n \t2 file <identifiersep> utils . write <identifiersep> byte <identifiersep> array <identifiersep> to <identifiersep> file ( <identifier> <identifiersep> file , <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 return <identifier> ; } \n \t1 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> user . set <identifiersep> api <identifiersep> key ( <identifier> <identifiersep> key ) ; \n \t3 <identifier> <identifiersep> user <identifiersep> dao . update ( user <identifiersep> id , <identifier> <identifiersep> user ) ; \n \t3 return <identifier> <identifiersep> key ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 throw new <identifier> <identifiersep> exception ( e ) ; } \n \t2 string cache <identifiersep> key = <string_literal> + get <identifiersep> <identifier> <identifiersep> key ( ) . to <identifiersep> string ( ) ; \n \t2 if ( is <identifiersep> input <identifiersep> <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> = ( map < integer , long > ) object <identifiersep> cache . get <identifiersep> instance ( ) . <identifier> ( cache <identifiersep> key ) ; \n <ect>
\t1 properties <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> properties . stream ( ) \n \t2 . map ( <identifier> <identifiersep> property - > new properties <identifiersep> <identifier> <identifiersep> service ( class <identifiersep> <identifier> , <identifier> <identifiersep> property ) ) \n \t2 . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> response ) ; \n \t2 filter <identifiersep> <identifier> . do <identifiersep> filter ( <identifier> <identifiersep> request , test <identifiersep> <identifier> <identifiersep> response ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> response . get <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( test <identifiersep> <identifier> <identifiersep> response . get <identifiersep> string ( ) ) ; \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> time + <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t4 throw new configuration <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> time + <string_literal> + <identifier> <identifiersep> <identifier> ) ; } \n \t3 string [ ] <identifier> <identifiersep> time <identifiersep> <identifier> = <identifier> <identifiersep> time . <identifier> ( <string_literal> ) ; \n \t3 if ( <identifier> <identifiersep> time <identifiersep> <identifier> . length != <number_literal> ) { \n <ect>
\t7 + <string_literal> + e . get <identifiersep> message ( ) + <string_literal> ) ; } \n \t6 <identifier> <identifiersep> error <identifiersep> <identifier> = true ; \n \t6 <identifier> ( <number_literal> ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 client . is <identifiersep> <identifier> ( ) ) ; \n \t2 client . <identifier> ( ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t4 log . debug ( <string_literal> + version + <string_literal> ) ; } \n \t3 return false ; } \n \t2 final string [ ] <identifier> <identifiersep> request <identifiersep> <identifier> = { header <identifiersep> <identifier> . cache <identifiersep> <identifier> <identifiersep> no <identifiersep> store } ; \n \t2 if ( has <identifiersep> cache <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from ( request , <identifier> <identifiersep> request <identifiersep> <identifier> ) ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> device . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } else if ( text . <identifier> <identifiersep> with ( <identifier> <identifiersep> <identifier> ) ) { \n \t4 int index <identifiersep> of <identifiersep> <identifier> = text . index <identifiersep> of ( <identifier> <identifiersep> <identifier> ) ; \n \t4 if ( index <identifiersep> of <identifiersep> <identifier> == - 1 || index <identifiersep> of <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> . length ( ) + <number_literal> ) { \n <ect>
\t1 if ( <identifier> . length > 0 ) { \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> . run ( new configuration ( ) , new job ( ) , <identifier> ) ; \n \t1 } else { \n <ect>
\t3 final handler <identifiersep> request < r , m > handler <identifiersep> request ; \n \t3 try { \n \t4 handler <identifiersep> request = new handler <identifiersep> request < > ( request , <identifier> <identifiersep> response <identifiersep> message <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> message <identifiersep> <identifier> ( ) , <identifier> . path <identifiersep> <identifier> ( ) , <identifier> . query <identifiersep> <identifier> ( ) ) ; \n \t3 } catch ( handler <identifiersep> request <identifiersep> exception <identifier> ) { \n <ect>
\t6 header ( <identifier> <identifiersep> endpoint . message <identifiersep> type <identifiersep> key ) . is <identifiersep> equal <identifiersep> to ( msg <identifiersep> type . execution <identifiersep> <identifier> ) ) ) . \n \t5 bean ( new count <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , execution <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; } \n \t2 } ; \n \t2 context . add <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 list < file <identifiersep> <identifier> <identifiersep> task > <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( source <identifiersep> path ) ; \n <ect>
\t1 public <identifier> <identifiersep> <identifier> <identifiersep> object object ( ) { return ( <identifier> <identifiersep> <identifier> <identifiersep> object ) value <identifiersep> for <identifiersep> <identifier> ( <string_literal> ) ; } \n \t1 public string key ( ) { return ( string ) value <identifiersep> for <identifiersep> <identifier> ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> to <identifiersep> response ( <identifier> <identifiersep> response response , <identifier> <identifiersep> context context ) { \n <ect>
\t5 try { \n \t6 channel . send <identifiersep> response ( e ) ; \n \t5 } catch ( exception <identifier> ) { \n \t6 <identifier> . add <identifiersep> <identifier> ( e ) ; \n <ect>
\t1 <comment> \n \t1 file <identifiersep> system <identifier> <identifiersep> for <identifiersep> file = file <identifiersep> system . get ( file <identifiersep> uri , conf ) ; \n \t1 return local <identifiersep> file <identifiersep> system . class . is <identifiersep> instance ( <identifier> <identifiersep> for <identifiersep> file ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> request <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> <identifiersep> endpoint <identifier> = get <identifiersep> <identifier> <identifiersep> endpoint ( <string_literal> ) ; \n \t2 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> ) ; \n <ect>
\t6 <identifier> <identifier> = <identifier> <identifiersep> to <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> ) ; \n \t6 if ( <identifier> != null ) \n \t7 new <identifiersep> set . add ( <identifier> ) ; \n \t6 else \n <ect>
\t2 network <identifiersep> <identifier> <identifier> = local <identifiersep> <identifier> . get <identifiersep> network <identifiersep> <identifier> <identifiersep> by <identifiersep> name ( <string_literal> ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t2 assert <identifiersep> true ( <identifier> . is <identifiersep> <identifier> ( ) ) ; \n \t2 assert <identifiersep> equals ( <identifier> , <identifier> ) ; \n <ect>
\t3 string <identifier> <identifiersep> xml = read <identifiersep> and <identifiersep> <identifier> <identifiersep> xml ( ) ; \n \t3 <identifier> <identifiersep> bean . set <identifiersep> <identifier> <identifiersep> job <identifiersep> xml ( <identifier> <identifiersep> xml ) ; \n \t3 log . debug ( <string_literal> + xml <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> xml ) . to <identifiersep> string ( ) ) ; } \n \t2 catch ( <identifier> <identifiersep> job <identifiersep> exception ex ) { \n <ect>
\t4 log . error ( <string_literal> , this . name , <identifier> ) ; \n \t4 try { \n \t5 this . store . stop ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 string <identifier> [ ] = <identifier> . <identifier> ( <string_literal> ) ; \n \t2 assert ( <identifier> . length == <number_literal> ) ; \n \t2 string v <identifiersep> <identifier> <identifiersep> ip = <identifier> <identifiersep> utils . <identifier> <identifiersep> to <identifiersep> ip ( <identifier> [ 1 ] ) ; \n \t2 if ( v <identifiersep> <identifier> <identifiersep> ip == null ) { \n <ect>
\t3 { \n \t4 <identifier> t = result . next ( ) ; \n \t4 system . out . <identifier> ( <identifier> <identifiersep> format . format ( t ) ) ; } \n \t2 } else { \n <ect>
\t2 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = null ; \n \t2 if ( true ) <comment> \n \t2 { \n \t3 logger . debug ( <string_literal> + <identifier> <identifiersep> class ) ; \n <ect>
\t4 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> . length ; i ++ ) { \n \t5 if ( <identifier> <identifiersep> <identifier> [ i ] < 0 || <identifier> <identifiersep> <identifier> [ i ] >= <identifier> <identifiersep> object <identifiersep> table . size ( ) ) { \n \t6 log . error ( <string_literal> , i , <identifier> <identifiersep> object <identifiersep> table . size ( ) ) ; \n \t5 } else if ( <identifier> <identifiersep> object <identifiersep> table . get ( <identifier> <identifiersep> <identifier> [ i ] ) == this ) { \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) != null ) \n \t3 throw new security <identifiersep> exception ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> . <identifier> ( ) == 0 ) { \n <ect>
\t1 } else { \n \t2 <identifier> . <identifier> ( <string_literal> ) ; } \n \t1 <identifier> <identifiersep> utils . build <identifiersep> query <identifiersep> with <identifiersep> in <identifiersep> <identifier> ( conf , <identifier> , <identifier> , <identifier> , <identifier> , <string_literal> , true , false ) ; \n \t1 for ( string query : <identifier> ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> <identifier> . execute ( new <identifier> ( ) { \n \t5 @ <identifier> \n \t5 public void run ( ) { \n <ect>
\t1 public void close ( ) throws io <identifiersep> exception { \n \t2 try { \n \t3 delete <identifiersep> <identifier> ( <identifier> , new date ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 try ( file <identifiersep> output <identifiersep> stream <identifier> = new file <identifiersep> output <identifiersep> stream ( key <identifiersep> store <identifiersep> location ) ) { \n \t1 key <identifiersep> store . set <identifiersep> key <identifiersep> entry ( <string_literal> , key <identifiersep> <identifier> . get <identifiersep> private ( ) , password , <identifier> <identifiersep> <identifier> ) ; \n \t1 key <identifiersep> store . store ( <identifier> , password ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 public void run ( ) { \n \t2 try { \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> cmd cmd = client . <identifier> <identifiersep> <identifier> <identifiersep> cmd ( <identifier> ) ; \n \t6 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> authentication ( cmd , <identifier> , <identifier> . get <identifiersep> instance ( ) ) ; \n \t6 cmd . <identifier> ( result <identifiersep> <identifier> ) . <identifier> <identifiersep> success ( ) ; \n \t5 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t1 * \t3 <identifier> <identifier> <identifier> \n \t1 * \n \t1 ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** / \n \t1 public static void <identifier> <identifiersep> <identifier> ( dir <identifiersep> context dir <identifiersep> context , string <identifier> , string <identifier> ) throws <identifier> <identifiersep> exception { \n <ect>
\t2 throw <identifier> <identifiersep> <identifier> <identifiersep> type ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; } \n \t1 try { \n \t1 m <identifiersep> table = db . get <identifiersep> table ( table <identifiersep> name [ 0 ] , table <identifiersep> name [ 1 ] ) ; \n \t1 } catch ( <identifier> <identifiersep> table <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( snapshot <identifiersep> info . get <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> <identifiersep> ex ) { \n \t2 snapshot <identifiersep> info . set <identifiersep> status ( storage <identifiersep> properties . status . failed . to <identifiersep> string ( ) ) ; \n \t2 <identifier> <identifiersep> snapshot <identifiersep> failed ( snapshot <identifiersep> id ) ; \n <ect>
\t3 <identifier> = <identifier> <identifiersep> response ( exchange , <identifier> <identifiersep> authentication <identifiersep> error . <identifier> . no <identifiersep> <identifier> <identifiersep> token , null , null ) ; \n \t3 return <identifier> <identifiersep> <identifier> . not <identifiersep> <identifier> ; } \n \t2 return ( <identifier> <identifiersep> token ( exchange , token <identifiersep> string ) ) ; } \n \t1 protected <identifier> <identifiersep> <identifier> <identifier> <identifiersep> token ( http <identifiersep> <identifier> exchange , string token <identifiersep> string ) { \n <ect>
\t5 return ; } \n \t4 if ( <identifier> == null ) { \n \t5 if ( <identifier> . is <identifiersep> <identifier> ( ) && ( system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> . time <identifiersep> last <identifiersep> connection <identifiersep> <identifier> ( ) > timeout * <number_literal> ) ) { \n \t6 <comment> \n <ect>
\t5 local <identifiersep> <identifier> <identifiersep> manager ? . send <identifiersep> <identifier> ( <identifier> ( <identifier> . <identifier> <identifiersep> update <identifiersep> <identifier> ) ) \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> short ( this , r . string . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) } \n \t3 } catch ( e : exception ) { \n \t4 <comment> \n <ect>
\t3 <identifier> . close ( ) ; \n \t3 key <identifiersep> manager . close <identifiersep> default <identifiersep> key <identifiersep> manager ( ) ; } } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t4 || config . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null ) { \n \t3 if ( <identifier> == null ) { \n \t4 log . error ( <string_literal> ) ; \n \t3 } else { \n <ect>
\t9 <comment> \n \t9 if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . this ) ; } \n \t8 @ <identifier> \n \t8 public void <identifier> ( ) { \n <ect>
\t2 if ( <identifier> <identifiersep> target <identifiersep> file != null && <identifier> <identifiersep> target <identifiersep> file != target <identifiersep> file ) { \n \t4 log . debug ( <string_literal> + <identifier> <identifiersep> target <identifiersep> file + <string_literal> + target <identifiersep> file ) ; } \n \t3 if ( ! <identifier> <identifiersep> target <identifiersep> file . <identifier> <identifiersep> to ( target <identifiersep> file ) ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t3 try { \n \t4 files = directory . list <identifiersep> all ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 final directory final <identifiersep> directory = directory ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void message <identifiersep> not <identifiersep> <identifier> ( transport <identifiersep> event e ) { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + host . get <identifiersep> id ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> total <identifiersep> <identifier> ( ) + <string_literal> + host <identifiersep> total <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . set <identifiersep> total <identifiersep> <identifier> ( host <identifiersep> total <identifiersep> <identifier> ) ; } \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> state != <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> state ( ) ) { \n <ect>
\t1 json <identifiersep> object object = new json <identifiersep> object ( ) ; \n \t1 object . put ( <string_literal> , job ) ; \n \t1 return response . <identifier> ( object ) . build ( ) ; \n \t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n <ect>
\t2 final boolean check <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> ( request , o <identifiersep> <identifier> . client <identifiersep> id ) \n \t4 && <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> ( request , o <identifiersep> <identifier> . <identifier> <identifiersep> uri ) \n \t4 && <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> ( request , o <identifiersep> <identifier> . response <identifiersep> type ) ; \n \t2 if ( ! check <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 { \n \t5 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + key ) ; } } \n \t3 catch ( final exception t ) \n \t3 { \n <ect>
\t4 ++ next <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> num ; \n \t4 last <identifiersep> id = message . get <identifiersep> <identifier> <identifiersep> message <identifiersep> id ( ) ; \n \t3 } catch ( transaction <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 ++ next <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> num ; \n <ect>
\t1 <comment> \n \t1 for ( string table : <identifier> ) { \n \t2 <identifier> <identifiersep> test <identifiersep> utils . check <identifiersep> r <identifiersep> files ( c , table , 1 , 1 , 1 , 1 ) ; } \n \t1 <comment> \n <ect>
\t1 set < uri > <identifier> = new <identifier> <identifiersep> set < uri > ( ) ; \n \t1 <identifier> . add <identifiersep> all ( <identifier> , path <identifiersep> <identifier> ) ; \n \t2 for ( uri uri : <identifier> ) { \n <ect>
\t6 <identifier> ( <string_literal> + e . get <identifiersep> message ( ) ) ; } \n \t5 <identifier> <identifiersep> list . add ( <identifier> ) ; } } \n \t3 @ <identifier> \n \t3 public void on <identifiersep> send ( <identifier> <identifiersep> <identifier> <identifier> ) { \n <ect>
\t1 try { \n \t2 <identifier> . try <identifiersep> <identifier> ( ) \n \t1 } catch { \n \t2 case e : exception = > \n <ect>
\t2 queue <identifier> = <identifier> . get <identifiersep> queue ( <string_literal> ) ; \n \t2 assert <identifiersep> that ( <string_literal> , <identifier> . <identifier> ( ) , is ( <string_literal> ) ) ; \n \t2 } catch ( exception e ) { \n \t2 <comment> \n <ect>
\t1 public void on <identifiersep> host <identifiersep> <identifier> ( host host , host <identifiersep> connection <identifiersep> pool < ? > pool ) { \n \t2 logger . info ( string . format ( <string_literal> + host ) ) ; } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> host <identifiersep> <identifier> ( host host ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + private <identifiersep> ip + <string_literal> + cmd <identifiersep> port ) ; } \n \t2 try { \n \t3 string result = <identifier> ( cmd . get <identifiersep> name ( ) , private <identifiersep> ip , cmd <identifiersep> port ) ; \n \t3 if ( result != null ) { \n <ect>
\t6 result = result <identifiersep> set . get <identifiersep> boolean ( <string_literal> ) ; } } \n \t3 } finally { \n \t4 table <identifiersep> lock . read <identifiersep> lock ( ) . <identifier> ( ) ; } \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> io <identifiersep> <identifier> . log . info ( <identifier> ( <identifier> ) + <string_literal> \n \t3 + header ( log [ <identifier> + <number_literal> ] ) + <string_literal> + integer . to <identifiersep> <identifier> <identifiersep> string ( get <identifiersep> <identifier> <identifiersep> int ( log [ <identifier> ] ) ) ) ; \n \t2 return <identifier> + <number_literal> ; } \n \t1 case set <identifiersep> <identifier> : { \n <ect>
\t1 { \n \t2 date <identifier> <identifiersep> date = date <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> start <identifiersep> of <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> date <identifiersep> <identifier> . execute ( in <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; \n \t2 if ( ! <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( <identifier> <identifiersep> date ) ) \n \t2 { \n <ect>
\t2 } catch ( <identifier> <identifiersep> operation <identifiersep> exception ex ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , ex ) ; \n \t3 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . <identifier> <identifiersep> error , ex . get <identifiersep> message ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> server <identifiersep> exception ex ) { \n <ect>
\t2 try ( input <identifiersep> stream <identifier> <identifiersep> configuration <identifiersep> file = <identifier> <identifiersep> <identifier> . class . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ) { \n \t3 if ( <identifier> <identifiersep> configuration <identifiersep> file != null ) { \n \t4 configuration = new default <identifiersep> configuration <identifiersep> builder ( ) . build ( <identifier> <identifiersep> configuration <identifiersep> file ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 long time = action . get <identifiersep> time ( ) ; \n \t2 http <identifiersep> <identifier> <identifiersep> response <identifiersep> <identifier> response = action . response ; \n \t2 if ( action . <identifier> ) { \n \t3 if ( action . response <identifiersep> content <identifiersep> type != null ) \n <ect>
\t2 system . <identifier> ( <identifier> <identifiersep> <identifier> , 0 , <identifier> , <identifier> <identifiersep> <identifier> . length , <identifier> <identifiersep> <identifier> . length ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t4 <identifier> <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list <identifiersep> root ( ) \n \t5 . get <identifiersep> group ( test <identifiersep> group <identifiersep> <identifier> ) ) ; } \n \t2 catch ( operation <identifiersep> failed <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 for ( int i = 0 ; i < grid <identifiersep> count ( ) ; i ++ ) { \n \t3 if ( i != <identifier> <identifiersep> node ) \n \t4 test <identifiersep> node <identifiersep> <identifier> = i ; } \n \t2 log . info ( <string_literal> + test <identifiersep> node <identifiersep> <identifier> ) ; \n <ect>
\t4 && ! <identifier> <identifiersep> action . equals ( context . get <identifiersep> action ( ) ) \n \t4 && ! context . get <identifiersep> <identifier> ( ) . <identifier> ( <string_literal> , <string_literal> ) . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) { \n \t4 context . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> service ( ) . <identifier> <identifiersep> <identifier> ( context ) ; } \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> group . <identifier> ( ) . size ( ) == 0 ) \n \t2 { \n \t3 logger . info ( <string_literal> ) ; \n \t3 return 0 ; } \n <ect>
\t2 byte [ ] data ; \n \t2 try { \n \t3 data = queue . <identifier> ( wait , time <identifiersep> unit . <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception <identifier> ) { \n <ect>
\t4 handle <identifiersep> data <identifiersep> <identifier> <identifiersep> <identifier> ( msg , next , this <identifiersep> <identifier> ) ; \n \t4 <identifier> . <identifier> ( ) ; \n \t4 break ; } \n \t3 if ( msg . get <identifiersep> <identifier> ( ) != <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 } catch ( io <identifiersep> exception e ) { \n \t2 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> , config , e ) ; \n \t1 } finally { \n \t2 <identifier> <identifiersep> client . close ( ) ; } } \n <ect>
\t4 <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) ; \n \t3 } catch ( exception <identifier> ) { \n \t4 <comment> \n \t3 <identifier> = <identifier> ; \n <ect>
@ <identifier> \n public static void set <identifiersep> <identifier> <identifiersep> info ( job job , string principal , authentication <identifiersep> token token ) \n \t1 throws <identifier> <identifiersep> security <identifiersep> exception { \n \t1 if ( token instanceof <identifier> <identifiersep> token ) { \n <ect>
\t2 <identifier> <identifiersep> source = new <identifier> <identifiersep> service <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = \n \t3 context . <identifier> <identifiersep> service ( <identifier> <identifiersep> service . class . get <identifiersep> name ( ) , \n \t4 <identifier> <identifiersep> source , <identifier> ) ; \n <ect>
\t3 cluster <identifiersep> state cluster <identifiersep> state = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> state ( ) . get ( ) . get <identifiersep> state ( ) ; \n \t3 <identifier> <identifiersep> in <identifiersep> <identifier> <identifier> <identifiersep> in <identifiersep> <identifier> = cluster <identifiersep> state . <identifier> ( <identifier> <identifiersep> in <identifiersep> <identifier> . type ) ; \n \t3 assert <identifiersep> equals ( 0 , <identifier> <identifiersep> in <identifiersep> <identifier> . <identifier> ( ) . size ( ) ) ; \n \t2 } , <number_literal> , time <identifiersep> unit . <identifier> ) ; \n <ect>
protected \n void parse <identifiersep> <identifier> <identifiersep> factory ( element factory <identifiersep> element ) { \n \t1 string class <identifiersep> name = <identifier> ( factory <identifiersep> element . get <identifiersep> attribute ( class <identifiersep> <identifier> ) ) ; \n \t1 if ( empty <identifiersep> <identifier> . equals ( class <identifiersep> name ) ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n \t3 logger . info ( <string_literal> , \n \t5 <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> config . exists ( ) ) { \n \t3 if ( system . get <identifiersep> property ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> config ) != null ) { \n \t4 logger . info ( <string_literal> ) ; \n \t3 } else if ( new <identifiersep> <identifier> <identifiersep> config . exists ( ) ) { \n <ect>
\t2 if ( <identifier> != null ) \n \t2 { \n \t3 for ( stream <identifiersep> event <identifiersep> handler listener : <identifier> ) \n \t4 <identifier> . add <identifiersep> event <identifiersep> listener ( listener ) ; } \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t9 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> in <identifiersep> millis ( ) > <number_literal> ) { \n <number_literal> s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> in <identifiersep> millis ( ) + <string_literal> ) ; } \n \t9 } else { \n <ect>
@ <identifier> \n public class <identifier> <identifiersep> <identifier> <identifiersep> policy implements <identifier> <identifiersep> policy < void > { \n \t1 @ <identifier> \n \t1 public void <identifier> ( final void data ) { \n <ect>
\t3 <identifier> user = user <identifiersep> manager . get <identifiersep> <identifier> ( user <identifiersep> id ) ; \n \t3 if ( user != null && ! user . is <identifiersep> group ( ) ) { \n \t4 return ( user ) user ; \n \t3 } else { \n <ect>
\t4 log . debug ( <string_literal> + <identifier> . to <identifiersep> short <identifiersep> string ( <identifier> <identifiersep> nodes ) + <string_literal> + <identifier> + \n \t5 ' ] ' ) ; } \n \t2 else { \n <ect>
\t5 cache . put <identifiersep> all ( map ) ; \n \t5 <identifier> . <identifier> ( ) ; } \n \t4 <identifier> ( <string_literal> ) ; } \n \t3 catch ( grid <identifiersep> exception e ) { \n <ect>
\t3 start <identifiersep> answer . set <identifiersep> <identifier> <identifiersep> to <identifiersep> data ( <identifier> <identifiersep> to <identifiersep> data ) ; \n \t3 return start <identifiersep> answer ; \n \t2 } finally { \n \t3 if ( state != vm <identifiersep> <identifier> <identifiersep> state . <identifier> ) { \n <ect>
\t2 <comment> \n \t2 logger . debug ( <string_literal> , e ) ; } \n \t1 } else { \n <ect>
\t3 <identifier> = new <identifiersep> <identifier> ; \n \t3 <identifier> = new resource <identifiersep> store <identifiersep> class <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t3 return true ; \n \t2 } catch ( final runtime <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 private boolean <identifier> ( ) { \n \t2 <identifier> <identifiersep> set < <identifier> <identifiersep> <identifier> < <identifier> , v > > <identifier> = new <identifier> <identifiersep> set < <identifier> <identifiersep> <identifier> < <identifier> , v > > ( new level <identifiersep> <identifier> < <identifier> , v > ( ) ) ; \n \t2 if ( <identifier> . log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 <identifier> <identifier> = entity <identifiersep> manager . find ( <identifier> . class , <identifier> <identifiersep> id ) ; \n \t4 assert <identifiersep> equals ( 1 , <identifier> . get <identifiersep> <identifier> ( ) . size ( ) ) ; \n \t3 } ) ; } \n \t2 catch ( exception e ) { \n <ect>
\t2 case session <identifiersep> status <identifiersep> message . status <identifiersep> <identifier> : \n \t3 <identifier> <identifiersep> log . info ( <string_literal> ) ; \n \t3 break ; \n \t2 case session <identifiersep> status <identifiersep> message . status <identifiersep> <identifier> : \n <ect>
\t1 @ <identifier> \n \t1 public boolean is <identifiersep> provider <identifiersep> enabled <identifiersep> in <identifiersep> <identifier> <identifiersep> network ( long <identifier> <identifiersep> <identifier> <identifiersep> id , string provider <identifiersep> name ) { \n \t2 <identifier> <identifiersep> network <identifiersep> service <identifiersep> provider <identifiersep> vo <identifier> <identifiersep> <identifier> <identifiersep> provider = <identifier> <identifiersep> p <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> service <identifiersep> provider ( <identifier> <identifiersep> <identifier> <identifiersep> id , provider <identifiersep> name ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> provider == null ) { \n <ect>
\t4 else \n \t5 logger . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t2 principal principal = null ; \n \t2 final string <identifier> <identifiersep> name = <identifier> . super <identifiersep> user <identifiersep> name . get <identifiersep> value ( ) ; \n \t2 final string super <identifiersep> user <identifiersep> <identifier> = <identifier> . super <identifiersep> user <identifiersep> password . get <identifiersep> value ( ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> empty ( value ) ) { \n <ect>
public class <identifier> <identifiersep> field <identifiersep> name <identifiersep> test { \n private static final logger log = logger . get <identifiersep> logger ( <identifier> <identifiersep> field <identifiersep> name <identifiersep> test . class ) ; \n @ test \n public void test <identifiersep> <identifier> <identifiersep> field <identifiersep> name <identifiersep> <identifier> <identifiersep> field ( ) { \n <ect>
\t3 <identifier> . <identifier> \n \t2 ) \n \t2 <identifier> . host <identifiersep> config = <identifier> . config . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> [ <string_literal> ] [ 0 ] . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> [ <string_literal> ] [ 0 ] . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> [ <string_literal> ] [ 0 ] . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> [ <string_literal> ] [ 0 ] . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n \t2 <identifier> . <identifier> [ <string_literal> ] [ <string_literal> ] = <identifier> . <identifier> . id \n <ect>
\t7 thread . <identifier> ( wait ) ; \n \t6 } catch ( final number <identifiersep> format <identifiersep> exception e ) { \n \t7 s <identifiersep> logger . debug ( <string_literal> + e . to <identifiersep> string ( ) ) ; \n \t6 } catch ( final interrupted <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> message ( string <identifier> <identifiersep> id , string message ) { \n \t2 try { \n <ect>
\t1 public session <identifiersep> config get <identifiersep> client <identifiersep> session <identifiersep> config ( destination <identifier> ) { \n \t2 if ( <identifier> <identifiersep> manager != null ) \n \t3 return <identifier> <identifiersep> manager . get <identifiersep> client <identifiersep> session <identifiersep> config ( <identifier> ) ; \n \t2 else { \n <ect>
\t4 if ( <identifier> == 0 ) { \n \t5 <comment> \n \t5 <identifier> <identifiersep> data ( ) ; \n \t4 } else if ( <identifier> == - 1 ) { \n <ect>
\t5 log . info ( <string_literal> + destination <identifiersep> name + <string_literal> + message . to <identifiersep> string ( ) ) ; \n \t5 session . <identifier> ( ) ; <comment> \n \t10 <comment> \n \t3 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 if ( update <identifiersep> bytes ( user <identifiersep> <identifier> , new <identifiersep> current <identifiersep> bytes <identifiersep> <identifier> , new <identifiersep> current <identifiersep> bytes <identifiersep> <identifier> ) ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> <identifiersep> entry <identifiersep> <identifier> ) ; \n \t4 return true ; \n \t3 } else { \n <ect>
\t5 boolean <identifier> = action <identifiersep> on [ i ] ; \n \t5 on | = <identifier> && ( <identifier> [ i ] . action . get ( ) != null ) ; } \n \t4 is <identifiersep> on = on ; \n \t3 } else { \n <ect>
<comment> \n \t2 private void execute ( grid <identifiersep> logger log ) { \n \t3 try { \n <ect>
\t5 transaction ] . <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t3 <identifier> self . <identifier> <identifiersep> <identifier> [ connection ] \n \t3 self . <identifier> <identifiersep> send <identifiersep> <identifier> ( connection ) \n \t2 else : \n <ect>
\t3 add <identifiersep> output <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> nodes . get ( <identifier> <identifiersep> id ) . <identifier> , output <identifiersep> <identifier> ) ; \n \t2 } else { \n \t3 get <identifiersep> stream <identifiersep> node ( <identifier> <identifiersep> id ) . add <identifiersep> output <identifiersep> <identifier> ( output <identifiersep> <identifier> ) ; \n <ect>
\t2 return this . <identifier> ; } \n \t1 public int test <identifiersep> <identifier> ( boolean is <identifiersep> <identifier> , x <identifiersep> <identifier> <identifiersep> context context ) \n \t1 { \n <ect>
public string body <identifiersep> <identifier> ( ) { \n \t1 return ( string ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> <identifier> . body <identifiersep> <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> body <identifiersep> <identifier> ( string value ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> data . set <identifiersep> <identifier> ( true ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> type ( ) . get <identifiersep> <identifier> <identifiersep> field ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( true ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 bean <identifiersep> info bean <identifiersep> info = <identifier> . get <identifiersep> bean <identifiersep> info ( <identifier> . get <identifiersep> class ( ) ) ; \n \t3 property <identifiersep> <identifier> [ ] <identifier> = bean <identifiersep> info . get <identifiersep> property <identifiersep> <identifier> ( ) ; \n <ect>
\t2 if ( <identifier> != null ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 final <identifier> <identifiersep> configuration <identifiersep> properties <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> bean <identifiersep> factory ( ) . get <identifiersep> bean ( <identifier> <identifiersep> configuration <identifiersep> properties . class ) ; \n \t3 final set < string > default <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> attribute <identifiersep> <identifier> ( ) . get <identifiersep> default <identifiersep> attributes <identifiersep> to <identifiersep> <identifier> ( ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void shutdown ( network <identifiersep> <identifier> <identifier> , network <identifiersep> <identifier> <identifier> ) { \n \t2 network <identifiersep> vo network <identifiersep> object = <identifier> <identifiersep> network <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> . get <identifiersep> id ( ) ) ; \n \t2 if ( network <identifiersep> object . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> || network <identifiersep> object . get <identifiersep> <identifier> <identifiersep> uri ( ) == null ) { \n <ect>
\t8 <comment> \n \t8 <identifier> . <identifier> <identifiersep> as <identifiersep> super <identifiersep> user ( task <identifiersep> class <identifiersep> name , <identifier> . empty <identifiersep> map ) ; \n \t8 <identifier> . success ( ) ; } } \n \t5 } catch ( throwable t ) { \n <ect>
\t2 <comment> \n \t2 if ( ! <identifier> . get <identifiersep> format ( ) . <identifier> ( target <identifiersep> format ) ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t1 for ( thread thread : <identifier> ) { \n \t1 try { \n \t2 thread . <identifier> ( ) ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 for ( <identifier> <identifiersep> info info : <identifier> ) { \n \t4 try { \n \t5 info . execute ( <identifier> , <identifier> ) ; \n \t4 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t3 return null ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 command . add ( <string_literal> ) ; \n \t3 command . add ( <string_literal> ) ; \n \t3 result = command . execute ( ) ; \n \t3 if ( result != null ) { \n <ect>
\t3 string <identifiersep> builder <identifier> = new string <identifiersep> builder ( ) ; \n \t3 for ( string stream : <identifier> ) { \n \t4 <identifier> . <identifier> ( stream ) . <identifier> ( <string_literal> ) ; } \n <ect>
\t4 return new <identifier> < string , integer > ( host , port ) ; \n \t3 } catch ( <identifier> <identifiersep> host <identifiersep> exception <identifier> ) { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + host ) ; } \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n <ect>
\t1 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> storage <identifiersep> <identifier> ) ; \n \t1 } else { \n \t1 <identifier> . <identifier> ( storage <identifiersep> <identifier> ) ; } \n \t1 string create <identifiersep> <identifier> = <identifier> . to <identifiersep> string ( ) ; \n <ect>
\t2 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t2 log . info ( <string_literal> , <identifier> . get <identifiersep> entity <identifiersep> <identifier> ( ) . get <identifiersep> entity <identifiersep> <identifier> ( ) ) ; \n \t2 client <identifiersep> entity <identifiersep> set entity <identifiersep> set = ( client <identifiersep> entity <identifiersep> set ) response <identifiersep> <identifier> . get ( 1 ) . get <identifiersep> body ( ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( entity <identifiersep> set ) ; \n <ect>
\t2 } ) ; \n \t2 if ( ! success ) { \n \t3 throw new <identifier> <identifiersep> http <identifiersep> exception ( <string_literal> + port . get <identifiersep> port <identifiersep> <identifier> <identifiersep> string ( ) + <string_literal> , last <identifiersep> exception . get ( ) ) ; } \n <ect>
\t2 <identifier> . stop ( ) ; \n \t2 log . info ( <string_literal> , <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( file source ) { \n <ect>
\t4 { \n \t5 <comment> \n \t5 if ( <identifier> <identifiersep> count != <identifier> <identifiersep> count && <identifier> <identifiersep> manager . is <identifiersep> <identifier> <identifiersep> manager . get ( ) ) \n \t5 { \n <ect>
\t5 <identifier> [ <identifier> ++ ] = ( byte ) ' \\ \\ ' ; } \n \t4 <identifier> [ <identifier> ++ ] = ( byte ) ' \\ \\ ' ; } \n \t3 <identifier> [ <identifier> ] = <identifier> [ i ] ; } \n \t2 <comment> <ect>
\t2 { \n \t3 storage <identifiersep> manager . start ( <identifier> <identifiersep> context , this ) ; } \n \t2 catch ( exception ex ) \n \t2 { \n <ect>
\t1 thread . <identifier> ( ( <identifier> <identifiersep> time + ( long ) ( <identifier> . <identifier> ( ) * <identifier> <identifiersep> time ) ) ) ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n \t1 <comment> \n \t1 <comment> \n <ect>
\t2 return <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> array < t > <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t2 cluster <identifiersep> info cluster <identifiersep> info = get <identifiersep> cluster <identifiersep> info ( ) ; \n \t2 try { \n \t3 listener . <identifier> ( cluster <identifiersep> info ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public void <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 logger . info ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t3 final string <identifier> = ( <identifier> . length == <number_literal> && <identifier> [ <number_literal> ] != null ) ? <identifier> [ <number_literal> ] . to <identifiersep> string ( ) : <string_literal> ; \n \t3 try ( final file <identifiersep> output <identifiersep> stream <identifier> = file . get <identifiersep> output <identifiersep> stream ( true , false ) ) { \n \t4 <identifier> . write ( content . get <identifiersep> bytes ( <identifier> ) ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 return <identifier> <identifiersep> to . get <identifiersep> <identifier> <identifiersep> uri ( ) . get <identifiersep> host ( ) ; \n \t3 } else { \n \t4 s <identifiersep> logger . warn ( <string_literal> + default <identifiersep> <identifier> ) ; \n \t4 return default <identifiersep> <identifier> ; } } \n <ect>
\t4 if ( ! get <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t5 throw new timeout <identifiersep> exception ( ) ; } } } \n \t3 return super . handle <identifiersep> default ( <identifier> , cmd ) ; } \n \t1 } ) ; \n <ect>
\t3 catch ( io <identifiersep> exception e ) { \n \t4 log . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> file , e ) ; } \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> file != null && ! <identifier> <identifiersep> file . delete ( ) ) { \n <ect>
\t3 <comment> \n \t3 status = http <identifiersep> <identifier> <identifiersep> response . <identifier> <identifiersep> service <identifiersep> <identifier> ; \n \t3 is <identifiersep> <identifier> = false ; \n \t2 } else if ( t instanceof <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> not <identifiersep> found <identifiersep> exception ) { \n <ect>
\t6 log . warn ( <string_literal> ) ; \n \t5 } else if ( update <identifiersep> count == <identifier> . execute <identifiersep> failed ) { \n \t6 log . warn ( <string_literal> ) ; } } \n \t4 try { \n <ect>
\t1 <identifier> <identifiersep> db <identifiersep> dir . <identifier> ( ) ; } \n \t1 <identifier> <identifiersep> <identifier> . put ( configuration <identifiersep> <identifier> . config <identifiersep> url , \n \t2 <string_literal> + <identifier> <identifiersep> db <identifiersep> dir . get <identifiersep> <identifier> <identifiersep> path ( ) + <string_literal> ) ; \n \t1 <identifier> <identifiersep> channel ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 string return <identifiersep> message = session . <identifier> <identifiersep> user ( user <identifiersep> name , password ) ; \n \t3 if ( return <identifiersep> message == null ) { \n \t4 logger . info ( user <identifiersep> name + <string_literal> ) ; \n \t4 logger . debug ( <string_literal> + session . get <identifiersep> user <identifiersep> id ( ) ) ; \n <ect>
\t2 s <identifiersep> logger . info ( <string_literal> + user <identifiersep> id + <string_literal> + url ) ; \n \t2 http <identifiersep> client client = new http <identifiersep> client ( ) ; \n \t2 http <identifiersep> method method = new get <identifiersep> method ( url ) ; \n \t2 int response <identifiersep> code = client . execute <identifiersep> method ( method ) ; \n <ect>
\t2 if ( field <identifiersep> <identifier> == null ) { \n \t2 throw new <identifier> <identifiersep> exception ( <string_literal> + default <identifiersep> name ) ; } \n \t2 name = field <identifiersep> <identifier> . to <identifiersep> string ( ) ; } \n \t1 catch ( final exception e ) { \n <ect>
\t3 if ( private <identifiersep> <identifier> <identifiersep> <identifier> != null ) \n \t4 context . <identifier> <identifiersep> <identifier> <identifiersep> object ( <string_literal> , private <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 if ( <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t3 return ; } \n \t2 <identifier> <identifiersep> <identifier> = true ; \n \t2 logger . debug ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) , \n \t4 <identifier> <identifiersep> state <identifiersep> type . get <identifiersep> <identifier> ( ) , value ) ; \n <ect>
\t1 <identifier> <identifiersep> source = <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> <identifiersep> file ( <identifier> <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> <identifiersep> file ( <identifier> <identifiersep> <identifier> ) ; \n \t1 final string <identifier> = <string_literal> ; \n \t1 io <identifiersep> utils . write ( content , new file <identifiersep> output <identifiersep> stream ( <identifier> <identifiersep> source ) , <identifier> ) ; \n <ect>
\t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean stop ( ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) \n \t3 <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t3 return <identifier> <identifiersep> manager . create ( ) . write ( ) \n \t2 } catch ( e : exception ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> a <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . write ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t5 } catch ( io <identifiersep> exception <identifier> ) { \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . error ) ) <identifier> <identifiersep> log . error ( <identifier> ( ) + <string_literal> , <identifier> ) ; } \n \t5 <comment> \n <ect>
\t5 } else { \n \t6 log . warn ( <string_literal> + <identifier> . get <identifiersep> exchange ( ) ) ; } } \n \t3 } catch ( throwable t ) { \n \t4 <comment> \n <ect>
\t3 <identifier> . as <identifiersep> <identifier> ( <identifier> ) , <identifier> <identifiersep> <identifier> ) ; } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> catch ( throwable e ) throws throwable { \n \t2 if ( e instanceof <identifier> <identifiersep> exception ) { \n <ect>
\t2 resource = new <identifiersep> <identifier> <identifiersep> resource <identifiersep> stream ( <identifier> , get <identifiersep> class ( ) , <string_literal> , null , null , <string_literal> ) ; \n \t2 <identifier> = new <identifier> <identifiersep> <identifier> ( resource ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 <identifier> = <identifier> . parse ( ) ; \n <ect>
\t2 } finally { \n \t3 <identifier> . set <identifiersep> <identifier> ( null ) ; \n \t3 context . set <identifiersep> task <identifiersep> <identifier> <identifiersep> state ( null ) ; \n \t3 context . set <identifiersep> task <identifiersep> properties ( null ) ; \n <ect>
\t7 s <identifiersep> logger . error ( <string_literal> + key + <string_literal> + <identifier> <identifiersep> <identifier> . get ( key ) + <string_literal> + \n \t8 item <identifiersep> name <identifiersep> element . get <identifiersep> text <identifiersep> content ( ) ) ; \n \t7 result = false ; } \n \t5 } else { \n <ect>
\t3 get <identifiersep> <identifier> ( ) . delete <identifiersep> <identifier> <identifiersep> <identifier> ( m <identifiersep> <identifier> <identifiersep> <identifier> , m <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , m <identifiersep> date <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , get <identifiersep> <identifier> ( ) ) ; \n \t3 log . info ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 get <identifiersep> <identifier> ( ) . <identifier> ( e ) ; \n <ect>
\t1 assert . <identifier> ( string . format ( <string_literal> , <identifier> <identifiersep> <identifier> ) ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t1 <comment> \n private void close <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t4 <identifier> . error ( log , <string_literal> , e ) ; \n \t4 <identifier> ( <string_literal> + msg + <string_literal> + e . get <identifiersep> message ( ) + ' ] ' , e ) ; } \n \t3 if ( log != null ) { \n <ect>
\t2 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . all <identifiersep> <identifier> . stream ( ) . map ( c - > uri <identifiersep> builder . from <identifiersep> uri ( c . get <identifiersep> uri ( ) ) . build ( ) ) . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> collection <identifier> <identifiersep> <identifier> <identifiersep> values ( final <identifier> <identifiersep> collection <identifier> , final <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 if ( <identifier> . get <identifiersep> <identifier> ( ) == null || ! <identifier> . get <identifiersep> <identifier> ( ) . equals <identifiersep> ignore <identifiersep> case ( this . handler <identifiersep> <identifier> ) ) { \n <ect>
\t3 } catch ( no <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t4 throw new <identifier> <identifiersep> operation <identifiersep> exception ( <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t4 if ( ! check <identifiersep> vm <identifiersep> on <identifiersep> host ( vm , <identifier> <identifiersep> host <identifiersep> id ) ) { \n <ect>
\t2 long millis <identifiersep> to <identifiersep> wait <identifiersep> <identifier> = <identifier> . <identifier> ( wait <identifiersep> millis , <identifier> . max ( 0 , wait <identifiersep> millis - millis <identifiersep> <identifier> <identifiersep> last ) ) ; \n \t2 try { \n \t3 thread . <identifier> ( millis <identifiersep> to <identifiersep> wait <identifiersep> <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 string code = <identifier> . get <identifiersep> code ( ) ; \n \t3 logger . info ( <string_literal> , code ) ; \n \t3 return <identifier> . get <identifiersep> code ( ) ; \n \t2 } catch ( o <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 long <identifier> <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ; \n \t4 logger . info ( <string_literal> + <identifier> <identifiersep> time + <string_literal> ) ; } \n \t3 return this . context ; } \n \t2 catch ( runtime <identifiersep> exception ex ) { \n <ect>
<comment> \n \t1 protected void handle <identifiersep> listener <identifiersep> exception ( throwable ex ) { \n <ect>
\t2 public o <identifiersep> <identifier> <identifiersep> handler <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t3 final string <identifier> <identifiersep> url = o <identifiersep> <identifier> . base <identifiersep> <identifier> <identifiersep> url . <identifier> ( <string_literal> ) \n \t4 . <identifier> ( o <identifiersep> <identifier> . access <identifiersep> token <identifiersep> url + <string_literal> + o <identifiersep> <identifier> . token <identifiersep> url ) ; \n \t3 this . <identifier> = <identifier> <identifiersep> utils . create <identifiersep> <identifier> ( <identifier> <identifiersep> url ) ; \n <ect>
\t3 return ; } \n \t2 i <identifiersep> <identifier> <identifiersep> handler <identifier> <identifiersep> handler = <identifier> <identifiersep> service . instance ( ) . get <identifiersep> <identifier> <identifiersep> handler ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> handler == null ) \n \t2 { \n <ect>
\t6 final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( m , path ) ; \n \t6 if ( <identifier> != null ) { \n \t7 <identifier> = <identifier> <identifiersep> <identifier> . load <identifiersep> <identifier> ( get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , m , <identifier> ) ; } \n \t6 if ( ! <identifier> ) { \n <ect>
\t2 log . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> name + <string_literal> + \n \t4 <string_literal> ) ; \n \t2 <identifier> . stream ( ) . for <identifiersep> <identifier> ( <identifier> - > log . warn ( <string_literal> , <identifier> ) ) ; } \n \t1 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> item ( item item , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config config , event <identifiersep> <identifier> <identifier> , int state , \n \t3 string <identifier> ) { \n <ect>
\t3 field <identifiersep> metadata < ? , ? > field <identifiersep> info = class <identifiersep> metadata . get <identifiersep> field ( field . get <identifiersep> key ( ) ) ; \n \t3 if ( field <identifiersep> info != null && check . should <identifiersep> <identifier> ( class <identifiersep> metadata , field <identifiersep> info ) ) { \n \t4 <identifier> <identifiersep> <identifier> ( target , field <identifiersep> info , field . get <identifiersep> value ( ) , context ) ; \n \t3 } else if ( field <identifiersep> info == null ) { \n <ect>
<comment> \n \t1 private long <identifier> <identifiersep> <identifier> = <number_literal> ; \n \t1 public <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t3 if ( is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t4 if ( conf . get <identifiersep> http <identifiersep> <identifier> <identifiersep> user ( ) != null && ! conf . get <identifiersep> http <identifiersep> <identifier> <identifiersep> user ( ) . equals ( <string_literal> ) ) { \n \t6 logger . debug ( <string_literal> + conf . get <identifiersep> http <identifiersep> <identifier> <identifiersep> user ( ) ) ; \n <ect>
\t4 } else { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> dao . update ( <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> run <identifiersep> id , <identifier> <identifiersep> utils . get <identifiersep> host <identifiersep> name ( ) , version , <identifier> <identifiersep> cluster <identifiersep> node <identifiersep> ip , <identifier> <identifiersep> current <identifiersep> service <identifiersep> <identifier> . get <identifiersep> service <identifiersep> port ( ) , \n \t7 date <identifiersep> <identifier> . current <identifiersep> <identifier> <identifiersep> time ( ) ) ; \n <ect>
\t2 } finally { \n \t3 try { \n \t4 <identifier> . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + user . get <identifiersep> <identifier> ( ) + <string_literal> + account <identifiersep> name ) ; \n \t4 <identifier> <identifiersep> account <identifiersep> service . create <identifiersep> user ( user . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> password ( ) , user . get <identifiersep> <identifier> ( ) , user . get <identifiersep> <identifier> ( ) , user . get <identifiersep> <identifier> ( ) , <identifier> , account <identifiersep> name , <identifier> . get <identifiersep> id ( ) , \n \t10 <identifier> . <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) , user . source . <identifier> ) ; \n \t3 } else { \n <ect>
\t4 event . event ( event <identifiersep> type . <identifier> ) ; \n \t4 event . error ( <identifier> . user <identifiersep> session <identifiersep> not <identifiersep> found ) ; \n \t4 return error <identifiersep> <identifier> . error ( session , null , response . status . <identifier> <identifiersep> request , <identifier> . <identifier> <identifiersep> provider <identifiersep> <identifier> <identifiersep> error ) ; } \n \t3 if ( user <identifiersep> session . get <identifiersep> state ( ) != user <identifiersep> session <identifiersep> model . state . <identifier> <identifiersep> out ) { \n <ect>
\t2 <identifier> ( new <identifiersep> <identifier> , root <identifiersep> <identifier> <identifiersep> map <identifiersep> id ) ; \n \t2 <identifier> <identifiersep> nodes . add <identifiersep> all ( <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , new <identifiersep> <identifier> , root <identifiersep> <identifier> <identifiersep> map <identifiersep> id ) ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) \n \t2 { \n <ect>
\t6 log . info ( <string_literal> + consumer ) ; \n \t6 consumer . set <identifiersep> message <identifiersep> listener ( listener ) ; \n \t6 <identifier> . put ( consumer , listener ) ; } \n \t4 } catch ( exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
<comment> <ect>
\t2 file <identifier> = new file ( <identifier> ) ; \n \t2 try { \n \t3 <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 void on <identifiersep> <identifier> <identifiersep> error ( final throwable t ) { \n \t2 try { \n <ect>
\t1 data <identifiersep> source <identifiersep> name = <identifier> . get <identifiersep> <identifier> <identifiersep> name ( table ) ; \n \t1 try { \n \t1 get <identifiersep> <identifier> ( ) . create <identifiersep> <identifier> <identifiersep> table ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> close <identifiersep> <identifier> ( <identifier> <identifiersep> sql ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t3 try { \n \t4 return <identifier> <identifiersep> factory . <identifier> ( <identifier> <identifiersep> db . get <identifiersep> <identifier> <identifiersep> by <identifiersep> id ( long . parse <identifiersep> long ( id <identifiersep> string ) ) ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception ex ) { \n \t4 <comment> \n <ect>
\t3 <identifier> <identifiersep> builder <identifiersep> factory . set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> builder <identifiersep> factory . set <identifiersep> x <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t3 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n \t3 log . info ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t4 int <identifier> = integer . value <identifiersep> of ( <identifier> . group ( <number_literal> ) ) ; \n \t4 int <identifier> = integer . value <identifiersep> of ( <identifier> . group ( <number_literal> ) ) ; \n \t4 int <identifier> = integer . value <identifiersep> of ( <identifier> . group ( <number_literal> ) ) ; \n \t4 int <identifier> = integer . value <identifiersep> of ( <identifier> . group ( <number_literal> ) ) ; \n <ect>
\t3 if ( ip != null ) { \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> static <identifiersep> <identifier> ( ip . get <identifiersep> id ( ) , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> account ( account . account <identifiersep> id <identifiersep> system ) , user . <identifier> <identifiersep> system , true ) ) { \n \t5 s <identifiersep> logger . debug ( <string_literal> + ip + <string_literal> + vm <identifiersep> id + <string_literal> ) ; \n \t4 } else { \n <ect>
\t1 @ event <identifiersep> handler \n \t1 private void <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> event event ) \n \t1 { \n \t2 final <identifier> start = <identifier> . create <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifier> = <identifier> <identifiersep> map . get ( number ) ; \n \t3 <identifier> . get <identifiersep> properties ( ) . update <identifiersep> <identifier> ( ( <identifier> <identifiersep> status ) status ) ; \n \t3 update <identifiersep> <identifier> <identifiersep> for <identifiersep> device ( <identifier> ) ; \n \t2 } else if ( status instanceof <identifier> <identifiersep> <identifier> <identifiersep> status && <identifier> <identifiersep> <identifier> <identifiersep> map . contains <identifiersep> key ( number ) ) { \n <ect>
\t1 set < thread > <identifier> = thread . get <identifiersep> all <identifiersep> stack <identifiersep> <identifier> ( ) . key <identifiersep> set ( ) ; \n \t1 exception e = new exception ( ) ; \n \t1 for ( thread thread : <identifier> ) { \n \t1 e . set <identifiersep> stack <identifiersep> trace ( thread . get <identifiersep> stack <identifiersep> trace ( ) ) ; \n <ect>
\t2 if ( to <identifiersep> <identifier> != null ) { \n \t3 <identifier> <identifiersep> <identifier> ( to <identifiersep> <identifier> . key <identifiersep> set ( ) , true ) ; \n \t3 to <identifiersep> <identifier> . <identifier> ( ) ; } \n \t2 } catch ( throwable t ) { \n <ect>
\t1 protected string get <identifiersep> <identifier> <identifiersep> policy <identifiersep> name <identifiersep> for ( final ticket <identifiersep> state ticket <identifiersep> state ) { \n \t2 final map < string , object > <identifier> = ticket <identifiersep> state . get <identifiersep> authentication ( ) . get <identifiersep> attributes ( ) ; \n \t2 final boolean <identifier> = ( boolean ) <identifier> . get ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . authentication <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> == null || <identifier> . equals ( boolean . false ) ) { \n <ect>
\t4 <identifier> , host <identifiersep> <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public delete <identifiersep> host <identifiersep> answer delete <identifiersep> host ( host <identifiersep> vo host , boolean is <identifiersep> <identifier> , \n \t3 boolean is <identifiersep> <identifier> <identifiersep> delete <identifiersep> storage ) throws <identifier> <identifiersep> delete <identifiersep> host <identifiersep> exception { \n <ect>
\t2 this . <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> message ( message message , session session ) throws <identifier> <identifiersep> exception { \n \t2 log . trace ( <string_literal> ) ; \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> message <identifiersep> handler handler = <identifier> <identifiersep> handler <identifiersep> map . get <identifiersep> handler ( type ) ; \n \t3 if ( handler != null ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t6 logger . warn ( <string_literal> , e ) ; } \n \t5 try { \n \t6 process . get <identifiersep> output <identifiersep> stream ( ) . close ( ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t1 if ( ! <identifier> <identifiersep> state . equals ( case <identifiersep> execution <identifiersep> state . new ) ) { \n \t1 <identifier> <identifiersep> state <identifiersep> name = <identifier> <identifiersep> state . to <identifiersep> string ( ) ; } \n \t1 case <identifiersep> execution <identifiersep> state new <identifiersep> state = execution . get <identifiersep> current <identifiersep> state ( ) ; \n \t1 string state <identifiersep> <identifier> = <identifier> <identifiersep> state <identifiersep> name + <string_literal> + execution . get <identifiersep> event <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> id + <string_literal> + new <identifiersep> state ; \n <ect>
\t3 start <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } else { \n \t3 <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 long end = system . current <identifiersep> time <identifiersep> millis ( ) ; \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> failure <identifiersep> enabled ( true ) ; \n \t2 <comment> \n \t2 try { \n <ect>
\t1 <identifier> . add ( ( <identifier> <identifiersep> data <identifiersep> <identifier> ) <identifier> ) ; } } \n @ test \n public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t1 int <identifier> <identifiersep> size = <number_literal> ; \n <ect>
public class <identifier> <identifiersep> it extends abstract <identifiersep> snapshot <identifiersep> <identifier> <identifiersep> test <identifiersep> case { \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 client client = client ( ) ; \n \t2 path location = <identifier> <identifiersep> <identifier> <identifiersep> path ( ) ; \n <ect>
\t1 integer get <identifiersep> line <identifiersep> break ( ) ; \n \t1 static boolean should <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> file this <identifiersep> file , final <identifier> <identifiersep> event <identifier> <identifiersep> state ) { \n \t2 return <identifier> <identifiersep> state . get <identifiersep> <identifier> <identifiersep> properties ( ) . contains <identifiersep> key ( <identifier> <identifiersep> <identifier> . key ( <identifier> <identifiersep> <identifier> <identifiersep> file . class , <string_literal> ) ) ; } \n \t1 static void <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> file this <identifiersep> file ) throws <identifier> <identifiersep> exception , io <identifiersep> exception { \n <ect>
\t2 assert . assert <identifiersep> equals ( 1 , has <identifiersep> <identifier> . size ( ) ) ; \n \t2 assert . assert <identifiersep> equals ( <number_literal> , has <identifiersep> <identifier> . size ( ) ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> <identifiersep> file ( string file <identifiersep> name ) { \n \t2 try { \n \t3 <identifier> <identifiersep> files . write ( <identifier> <identifiersep> file <identifiersep> <identifier> , <identifier> <identifiersep> bytes . to <identifiersep> bytes ( file <identifiersep> name + <string_literal> ) , true ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 if ( <identifier> <identifiersep> map . get ( <identifier> <identifiersep> id ) == null ) \n \t7 <identifier> <identifiersep> map . put ( <identifier> <identifiersep> id , new json <identifiersep> array ( ) ) ; \n \t6 <identifier> <identifiersep> map . get ( <identifier> <identifiersep> id ) . put ( get <identifiersep> command <identifiersep> json ( <identifier> , command ) ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t3 assert <identifier> != null ; \n \t3 assert log != null ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t4 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t5 try { \n \t6 <identifier> <identifiersep> service = get <identifiersep> <identifier> <identifiersep> service ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t5 } catch ( final remote <identifiersep> exception e ) { \n <ect>
\t6 element . <identifier> ( network , <identifier> , vm , null ) ; \n \t5 } catch ( final <identifier> <identifiersep> operation <identifiersep> exception ex ) { \n \t6 s <identifiersep> logger . warn ( <string_literal> + <identifier> . to <identifiersep> string ( ) + <string_literal> , ex ) ; \n \t5 } catch ( final resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 <identifier> . stop ( ) ; \n \t2 } else { \n \t3 log . info ( <string_literal> ) ; } \n \t2 if ( <identifier> != null && <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
private channel <identifiersep> <identifier> <identifiersep> listener close <identifiersep> listener = new channel <identifiersep> <identifier> <identifiersep> listener ( ) { \n \t1 @ <identifier> \n \t1 public void operation <identifiersep> <identifier> ( channel <identifiersep> <identifier> <identifier> ) { \n \t1 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 bytes += <identifier> . size ( ) ; \n \t5 return super . <identifier> <identifiersep> file ( file , <identifier> ) ; } \n \t3 } ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 logger . error ( <string_literal> ) ; \n \t3 throw new authentication <identifiersep> exception ( ) ; } \n \t2 final set < event > provider <identifiersep> found = check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> request ( context , service , authentication ) ; \n \t2 if ( provider <identifiersep> found != null && ! provider <identifiersep> found . is <identifiersep> empty ( ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 <identifier> <identifiersep> <identifier> cache = <identifier> <identifiersep> in <identifiersep> cache ( <identifier> . <identifier> ( ) ) ; \n \t3 if ( cache != null ) { \n \t4 if ( cache == <identifier> . <identifier> ( ) ) { \n <ect>
\t2 if ( response != null ) { \n \t3 return response ; } \n \t2 } else { \n \t2 <identifier> ( <string_literal> , context <identifiersep> id ) ; <comment> \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t1 } catch ( interrupted <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw new not <identifiersep> found <identifiersep> <identifier> <identifiersep> exception ( ex . get <identifiersep> message ( ) , ex ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t5 request . <identifier> ( ) ; \n \t4 } else { \n \t5 request . <identifier> ( close <identifiersep> timeout , time <identifiersep> unit . <identifier> ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 <identifier> = this . do <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 context context = <identifier> . get <identifiersep> context ( ) ; \n <ect>
\t3 <string_literal> ) ; \n \t2 if ( item <identifiersep> service ) { \n \t3 string <identifier> <identifiersep> service = url <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> url ( <identifier> ) ; \n \t3 <identifier> . add <identifiersep> <identifier> <identifiersep> service ( new <identifier> ( <identifier> <identifiersep> service ) ) ; } \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> dir ( ) ; \n \t1 run ( <string_literal> + db <identifiersep> name + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> result ( 0 , 0 , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> id = get <identifiersep> result ( 0 , 1 , true , <identifier> ) ; \n <ect>
\t5 log . warn ( <string_literal> , value ) ; } } } \n \t2 <comment> \n \t2 for ( string id : config <identifiersep> map . key <identifiersep> set ( ) ) { \n \t3 if ( string <identifiersep> utils . is <identifiersep> empty ( config <identifiersep> map . get ( id ) . get <identifiersep> url ( ) ) ) { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> <identifier> ( <identifier> , entry . get <identifiersep> value ( ) . <identifier> , entry . get <identifiersep> value ( ) . <identifier> , entry . get <identifiersep> key ( ) ) ; \n \t5 num <identifiersep> <identifier> ++ ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 http <identifiersep> method method = new get <identifiersep> method ( result <identifiersep> url ) ; \n \t2 while ( true ) { \n \t3 try { \n \t4 client . execute <identifiersep> method ( method ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 web <identifiersep> socket <identifiersep> data . set <identifiersep> result ( <identifier> . as <identifiersep> list ( <identifier> ) ) ; \n \t3 <comment> \n \t3 get <identifiersep> web <identifiersep> socket ( ) . send ( web <identifiersep> socket <identifiersep> data , true ) ; \n \t2 } else { \n <ect>
\t4 <comment> \n \t4 location = location + <string_literal> ; \n \t4 i <identifiersep> <identifier> <identifiersep> file = location ; \n \t3 } else { \n <ect>
\t1 @ <identifier> \n \t1 public void set <identifiersep> <identifier> ( collection < host > <identifier> , int port ) { \n \t2 try { \n \t3 if ( session != null ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void do <identifiersep> catch ( throwable e ) throws throwable { \n \t2 wait <identifiersep> <identifier> ( client . <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 state = <identifier> <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> failed ; \n <ect>
\t3 return false ; } } \n \t1 <comment> \n \t1 protected boolean <identifier> <identifiersep> <identifier> <identifiersep> message ( string <identifier> , properties <identifier> ) { \n \t2 if ( <identifier> <identifiersep> session == null ) { \n <ect>
\t2 log . debug ( <string_literal> + file . get <identifiersep> path ( ) + <string_literal> ) ; \n \t2 return <string_literal> ; } } \n \t1 final string content = get <identifiersep> file <identifiersep> content ( v <identifiersep> file ) ; \n \t1 if ( content == null ) { \n <ect>
\t5 <identifier> ( <identifier> ) ; } \n \t4 <comment> \n \t4 else if ( <identifier> . get <identifiersep> start <identifiersep> time ( ) + <number_literal> < system . current <identifiersep> time <identifiersep> millis ( ) && <identifier> . get <identifiersep> thread ( ) . get <identifiersep> <identifier> ( ) != thread . <identifier> <identifiersep> <identifier> ) { \n \t5 log log = config . get <identifiersep> request <identifiersep> timeout <identifiersep> logger ( ) ; \n <ect>
\t1 <identifier> <identifiersep> transport <identifiersep> factory . add <identifiersep> server <identifiersep> <identifier> ( thrift <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , \n \t2 <identifier> . get <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> ( ) , <identifier> , <identifier> . get <identifiersep> <identifier> <identifiersep> properties ( ) , \n \t2 new <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> handler ( <identifier> . get <identifiersep> <identifier> <identifiersep> manager ( ) ) ) ; \n \t1 } else { \n <ect>
\t3 shards = build <identifiersep> shards ( index , nodes , new <identifiersep> node <identifiersep> client ) ; \n \t3 for ( <identifier> <identifier> : shards ) { \n \t4 assert <identifiersep> version ( index , <number_literal> , <string_literal> + <identifier> . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> name ( ) , final <identifiersep> version <identifiersep> for <identifiersep> <identifier> ) ; \n \t4 assert <identifiersep> count ( index , <string_literal> + <identifier> . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> name ( ) , <number_literal> ) ; } \n <ect>
\t2 transaction . execute ( new transaction <identifiersep> <identifier> <identifiersep> no <identifiersep> return ( ) { \n \t3 @ <identifier> \n \t3 public void do <identifiersep> in <identifiersep> transaction <identifiersep> <identifier> <identifiersep> result ( final transaction <identifiersep> status status ) { \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ) == null ) { \n <ect>
\t2 log . info ( <string_literal> + <identifier> . local <identifiersep> host ( ) ) ; \n \t2 host <identifiersep> map . add <identifiersep> <identifier> ( host <identifiersep> map <identifiersep> state <identifiersep> listener . instance ) ; \n \t2 log . info ( <string_literal> + host <identifiersep> map <identifiersep> state <identifiersep> listener . instance . <identifier> <identifiersep> map ( <string_literal> ) ) ; \n \t2 update <identifiersep> entry . instance . <identifier> ( <identifier> . local <identifiersep> host ( ) ) ; \n <ect>
\t9 <identifier> <identifiersep> name <identifiersep> to <identifiersep> <identifier> . put ( <identifier> <identifiersep> name , <identifier> . to <identifiersep> string ( ) ) ; } } \n \t7 if ( <identifier> <identifiersep> field <identifiersep> <identifier> . size ( ) == 0 ) { \n \t8 break ; } } \n \t5 } catch ( <identifier> <identifiersep> token <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
void stop <identifiersep> <identifier> <identifiersep> thread ( ) { \n \t1 stop <identifiersep> <identifier> <identifiersep> thread . set ( true ) ; \n \t1 boolean <identifier> <identifiersep> status = file <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t1 if ( ! <identifier> <identifiersep> status ) { \n <ect>
\t1 public <identifier> <identifiersep> <identifier> <identifiersep> error <identifiersep> listener ( log logger ) { \n \t2 this . logger = logger ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> <identifiersep> exception ex ) throws <identifier> <identifiersep> exception { \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 try { \n \t2 <identifier> . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 case <identifier> : \n \t3 <comment> \n \t3 if ( count < max <identifiersep> <identifier> ) \n \t3 { \n <ect>
\t3 case message <identifiersep> status <identifiersep> message . status <identifiersep> send <identifiersep> failure <identifiersep> <identifier> : \n \t3 <comment> \n \t3 case message <identifiersep> status <identifiersep> message . status <identifiersep> send <identifiersep> failure <identifiersep> local : \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 for ( action <identifiersep> <identifier> action <identifiersep> <identifier> : action <identifiersep> <identifier> ) { \n \t3 action <identifiersep> <identifier> action <identifiersep> <identifier> = action <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> from <identifiersep> action <identifiersep> name ( action <identifiersep> name ) ; \n \t3 log . debug ( <string_literal> , action <identifiersep> <identifier> ) ; \n \t3 if ( action <identifiersep> <identifier> == null ) { \n <ect>
\t3 transport = null ; \n \t3 log . info ( <string_literal> ) ; } } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> method <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t4 <identifier> <identifiersep> logger . debug ( error ) ; } \n \t3 return error ; \n \t2 } catch ( security <identifiersep> exception ex ) { \n <ect>
\t1 string instance <identifiersep> name <identifiersep> path ; \n \t1 try { \n \t1 instance <identifiersep> name <identifiersep> path = get <identifiersep> instance <identifiersep> name <identifiersep> path ( <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 if ( shutdown <identifiersep> <identifier> <identifiersep> <identifier> > 0 ) { \n \t4 try { \n \t5 if ( ! <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> service , shutdown <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t6 <identifier> = true ; \n <ect>
\t1 string data <identifiersep> path = cmd <identifiersep> line . get <identifiersep> value ( path <identifiersep> <identifier> ) . to <identifiersep> string ( ) ; \n \t1 string <identifier> <identifiersep> path = cmd <identifiersep> line . get <identifiersep> value ( <identifier> <identifiersep> path <identifiersep> <identifier> ) . to <identifiersep> string ( ) ; \n \t1 list < string > <identifier> = <identifier> ( cmd <identifiersep> line . get <identifiersep> values ( <identifier> <identifiersep> <identifier> ) ) ; \n \t1 boolean <identifier> = cmd <identifiersep> line . has <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
@ <identifier> \n protected void do <identifiersep> start ( ) throws <identifier> <identifiersep> exception { \n \t1 logger . info ( <string_literal> ) ; \n \t1 source <identifiersep> <identifier> . start ( ) ; \n <ect>
\t4 logger . debug ( string . format ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) , \n \t6 this . get <identifiersep> node ( ) . get <identifiersep> device <identifiersep> id ( ) ) ) ; \n \t4 break ; \n \t3 default : \n <ect>
\t1 private <identifier> <identifiersep> group ( map < <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> > group ) { \n \t2 this . group . put <identifiersep> all ( group ) ; } \n \t1 public void add ( <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> null ( <identifier> ) ; \n <ect>
\t5 builder . header ( header . get <identifiersep> key ( ) , header . get <identifiersep> value ( ) ) ; } \n \t4 throw new <identifier> <identifiersep> in <identifiersep> exception ( error , builder . build ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t8 <string_literal> , \n \t8 <identifier> <identifiersep> thread <identifiersep> has <identifiersep> read <identifiersep> new <identifiersep> value \n \t6 ) ; } \n \t5 else { \n <ect>
\t5 try { \n \t6 <comment> \n \t6 <identifier> = index < <identifier> . size ( ) - 1 ? <identifier> . get ( index + 1 ) : <identifier> ; \n \t5 } catch ( exception e ) { \n <ect>
\t3 network = <identifier> <identifiersep> <identifier> ( network ) ; \n \t3 <identifier> = <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> ) ; \n \t4 for ( int i = 0 ; i < network . length ; i ++ ) { \n <ect>
\t2 sql = <identifier> <identifiersep> <identifier> . <identifier> . get <identifiersep> connection ( <string_literal> ) ; \n \t2 sql . execute ( string . format ( <string_literal> , <identifier> ) ) ; \n \t2 return true ; \n \t1 } catch ( exception e ) { \n <ect>
\t8 try { \n \t9 <identifier> . <identifier> <identifiersep> destination <identifiersep> <identifier> ( get <identifiersep> <identifier> <identifiersep> connection <identifiersep> context ( ) , <identifier> <identifiersep> destination ) ; \n \t9 log . debug ( <string_literal> , <identifier> <identifiersep> destination ) ; \n \t8 } catch ( exception e ) { \n <ect>
\t2 for ( node n : <identifier> . <identifier> <identifiersep> set ( ) ) { \n \t3 <identifier> <identifiersep> builder . add <identifiersep> node <identifiersep> and <identifiersep> update ( n ) ; } \n \t2 for ( default <identifiersep> <identifier> <identifier> : <identifier> . <identifier> <identifiersep> set ( ) ) { \n \t3 <identifier> <identifiersep> builder . add <identifiersep> <identifier> ( <identifier> . get <identifiersep> source ( ) , <identifier> . get <identifiersep> target ( ) , <identifier> , <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n <ect>
\t1 public response <identifier> <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifiersep> service = <identifier> . get <identifiersep> <identifier> <identifiersep> service ( ) ; \n \t2 if ( <identifier> <identifiersep> service != null ) { \n \t3 <identifier> <identifiersep> service . create <identifiersep> <identifier> ( <number_literal> , <identifier> <identifiersep> info ) ; \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> client . check <identifiersep> exists ( ) . for <identifiersep> path ( <identifier> <identifiersep> path ) == null ) { \n \t2 <comment> \n \t2 throw new exception ( <string_literal> ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t1 private request <identifiersep> handler request <identifiersep> handler = new request <identifiersep> handler ( ) ; \n \t1 private list < response <identifiersep> handler > response <identifiersep> <identifier> = new array <identifiersep> list < > ( ) ; \n \t1 public void <identifier> ( data <identifiersep> store <identifiersep> server <identifiersep> config config ) { \n \t2 logger . info ( <string_literal> , <identifier> . <identifier> <identifiersep> <identifier> ( <string_literal> ) ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 ip . set <identifiersep> new <identifiersep> <identifier> ( add <identifiersep> <identifier> ) ; \n \t4 } else { \n \t5 ip . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( public <identifiersep> <identifier> <identifiersep> info ) ; } } \n \t2 } catch ( final throwable e ) { \n <ect>
\t2 boolean entry <identifiersep> stream , set < integer > <identifier> , set < <identifier> > <identifier> <identifiersep> to <identifiersep> <identifier> , set < <identifier> > <identifier> <identifiersep> to <identifiersep> <identifier> ) { \n \t1 stream < <identifier> > stream = ( <identifier> <identifiersep> stream ? cache <identifiersep> entry <identifiersep> set . <identifier> <identifiersep> stream ( ) : cache <identifiersep> entry <identifiersep> set . stream ( ) ) \n \t3 . filter <identifiersep> <identifier> ( <identifier> <identifiersep> to <identifiersep> <identifier> ) . filter <identifiersep> key <identifiersep> <identifier> ( <identifier> ) ; \n \t1 if ( ! <identifier> <identifiersep> to <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t1 string [ ] <identifier> = get <identifiersep> <identifier> ( table <identifiersep> name , <identifier> <identifiersep> <identifier> ) ; \n \t1 try { \n \t1 run <identifiersep> import ( <identifier> ) ; \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 for ( <identifier> <identifiersep> thread entry : <identifier> ) { \n \t5 try { \n \t6 <identifier> ( entry . get <identifiersep> exchange ( ) ) ; \n \t5 } catch ( throwable e ) { \n <ect>
\t4 runtime = runtime . get <identifiersep> runtime ( <identifier> ) ; \n \t3 } catch ( throwable t ) { \n \t4 <identifier> = null ; <comment> \n <ect>
\t6 read <identifiersep> <identifier> <identifiersep> storage <identifiersep> format . <identifier> <identifiersep> <identifier> . get <identifiersep> code ( ) ) ; \n \t3 <identifier> . write ( metadata . to <identifiersep> json <identifiersep> string ( ) ) ; \n \t3 <identifier> . close ( ) ; } \n \t2 <comment> \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 index ( <string_literal> , <string_literal> , <string_literal> ) ; \n \t2 <identifier> ( ) ; \n \t2 <identifier> . start <identifiersep> <identifier> ( ) ; \n <ect>
\t3 if ( channel == null ) { \n \t4 <comment> \n \t4 <comment> \n \t4 <comment> \n <ect>
\t5 } else { \n \t6 <identifier> = <string_literal> ; \n \t6 break ; } \n \t5 default : \n <ect>
\t2 final string root <identifiersep> user = get <identifiersep> root <identifiersep> user <identifiersep> name ( <identifier> ) ; \n \t2 <identifier> . <identifier> = get <identifiersep> root <identifiersep> password ( <identifier> , root <identifiersep> user ) ; \n \t2 <identifier> <identifiersep> security ( context , <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> instance . get <identifiersep> instance ( ) . get <identifiersep> instance <identifiersep> id ( ) , root <identifiersep> user ) ; \n \t2 } else { \n <ect>
\t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> msg && <identifier> == null && \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message <identifiersep> <identifier> < = wait <identifiersep> num <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message <identifiersep> <identifier> ++ ; \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t5 <identifier> . add ( <identifier> ) ; \n \t5 for ( final byte <identifier> : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t6 final byte <identifier> = string <identifiersep> <identifier> . to <identifiersep> <identifier> <identifiersep> case ( <identifier> ) ; \n \t6 if ( <identifier> != <identifier> && <identifier> != <identifier> && <identifier> != <identifier> && <identifier> != <identifier> ) { \n <ect>
<number_literal> final boolean <identifier> <identifiersep> <identifier> ) { \n \t2 final string <identifier> <identifiersep> ticket <identifiersep> id <identifiersep> <identifier> <identifiersep> key = service . get <identifiersep> class ( ) . get <identifiersep> name ( ) ; \n \t2 <identifier> <identifiersep> ticket <identifiersep> id <identifiersep> <identifier> service <identifiersep> ticket <identifiersep> <identifier> <identifiersep> ticket <identifiersep> id <identifiersep> <identifier> = null ; \n \t2 if ( this . <identifier> <identifiersep> ticket <identifiersep> id <identifiersep> <identifier> <identifiersep> for <identifiersep> service != null && ! this . <identifier> <identifiersep> ticket <identifiersep> id <identifiersep> <identifier> <identifiersep> for <identifiersep> service . is <identifiersep> empty ( ) ) { \n <ect>
<number_literal> . get ( 0 ) \n <number_literal> . get <identifiersep> value ( ) , \n <number_literal> <string_literal> ) \n <number_literal> . <identifier> <identifiersep> to ( <identifier> <identifiersep> state . <identifier> <identifiersep> <identifier> <identifiersep> server . to <identifiersep> string ( ) ) == 0 ) { \n <ect>
\t6 account = self . account . name , \n \t6 <identifier> = self . account . <identifier> \n \t6 ) \n \t2 self . <identifier> <identifiersep> <identifier> <identifiersep> network ( <identifier> ) \n <ect>
<number_literal> @ query <identifiersep> <identifier> ( <string_literal> ) string user <identifiersep> <identifier> , \n <number_literal> @ query <identifiersep> <identifier> ( <string_literal> ) string <identifier> , \n <number_literal> @ context http <identifiersep> <identifier> <identifier> , @ context http <identifiersep> <identifier> <identifiersep> request request ) \n \t2 throws web <identifiersep> application <identifiersep> exception { \n <ect>
\t3 if ( root != null ) { \n \t4 log . error ( <string_literal> , root . to <identifiersep> string ( ) , e ) ; } \n \t3 else { \n \t4 log . error ( <string_literal> , e ) ; } \n <ect>
\t3 string <identifier> <identifiersep> address = ( string ) <identifier> <identifiersep> <identifier> . get ( 0 ) ; \n \t3 long <identifier> <identifiersep> size = ( long ) <identifier> <identifiersep> <identifier> . get ( 1 ) ; \n \t3 return new <identifier> < string , long > ( <identifier> <identifiersep> address , <identifier> <identifiersep> size ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 logger . info ( <string_literal> + this . get <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> <identifier> . get <identifiersep> value <identifiersep> state <identifiersep> map ( ) . contains <identifiersep> key ( this . values [ <identifier> <identifiersep> <identifier> <identifiersep> config . <identifier> <identifiersep> values ] ) ) { \n \t3 logger . info ( <string_literal> + this . get <identifiersep> id ( ) ) ; \n \t2 } else { \n <ect>
\t2 try { \n \t3 class < ? extends object > <identifier> <identifiersep> conn <identifiersep> <identifier> = class <identifiersep> <identifier> . for <identifiersep> name ( <string_literal> , object . class ) ; \n \t3 <identifier> = ( configuration ) <identifier> <identifiersep> conn <identifiersep> <identifier> . get <identifiersep> method ( <string_literal> ) . <identifier> ( null ) ; \n \t2 } catch ( throwable ex ) { \n <ect>
\t4 log . warn ( <identifier> <identifiersep> id , e ) ; } } } \n \t1 private void stop <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) throws exception { \n \t2 service <identifiersep> status <identifier> <identifiersep> status = <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> status ( <identifier> . get <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> <identifiersep> status == service <identifiersep> status . <identifier> ) { \n <ect>
\t2 <identifier> . remove ( node ) ; } \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n \t2 for ( n node : this ) { \n \t3 logger . debug ( <string_literal> + node ) ; \n <ect>
\t1 public boolean is <identifiersep> <identifier> <identifiersep> default <identifiersep> attributes ( ) { \n \t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean is <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> password ( ) { \n <ect>
\t2 <comment> \n \t2 service <identifiersep> <identifier> . put ( service <identifiersep> group , <identifier> <identifiersep> group <identifiersep> config ) ; } \n \t2 else \n \t2 { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> node ( <string_literal> , <identifier> <identifiersep> node ) ; \n \t2 snapshot <identifiersep> info = wait <identifiersep> for <identifiersep> <identifier> ( <string_literal> , <string_literal> , time <identifiersep> value . time <identifiersep> value <identifiersep> <identifier> ( <number_literal> ) ) ; \n \t2 logger . info ( <string_literal> , snapshot <identifiersep> info . <identifier> <identifiersep> <identifier> ( ) . size ( ) ) ; \n <ect>
\t3 this . <identifier> <identifiersep> <identifier> = 1 ; \n \t3 return this ; } \n \t2 public builder < <identifier> , v > <identifier> <identifiersep> count ( int <identifier> <identifiersep> count ) { \n \t3 if ( integer . <identifier> <identifiersep> count ( <identifier> <identifiersep> count ) != 1 || <identifier> <identifiersep> count < 0 || <identifier> <identifiersep> count > <number_literal> ) { \n <ect>
public static properties get <identifiersep> <identifier> <identifiersep> properties ( configuration configuration ) { \n \t1 properties properties = new properties ( ) ; \n \t1 <comment> \n \t1 <identifier> <identifiersep> type <identifier> <identifiersep> type = configuration . get <identifiersep> <identifier> <identifiersep> type ( ) ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> [ i ] <identifier> = array [ start + i ] ; } } \n \t3 boolean <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( ! <identifier> ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t4 <identifier> . add ( task ) ; } \n \t2 for ( integer task : <identifier> ) { \n \t3 string name = context . get <identifiersep> task <identifiersep> to <identifiersep> <identifier> ( ) . get ( task ) ; \n \t3 resource <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> ( name , get <identifiersep> <identifier> <identifiersep> node <identifiersep> task <identifiersep> <identifier> ( name ) ) ; \n <ect>
public void set <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . model . <identifier> value ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( value , <string_literal> ) ; } \n public void set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . model . <identifier> value ) { \n <ect>
\t4 <identifier> . close ( ) ; \n \t4 <identifier> <identifiersep> session . <identifier> <identifiersep> session ( ) ; \n \t3 } catch ( exception e ) { \n \t4 <identifier> ( e . get <identifiersep> message ( ) ) ; \n <ect>
\t3 <identifier> = <identifier> <identifiersep> connection . get <identifiersep> <identifier> ( ) ; \n \t3 if ( ! enabled ( table . get <identifiersep> configuration ( ) ) ) { \n \t4 logger . info ( <string_literal> ) ; \n \t4 return ; } \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> assert is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( long not <identifiersep> <identifier> <identifiersep> timeout <identifiersep> <identifier> , long <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 if ( <identifier> . int <identifiersep> value ( ) < = 0 ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> metadata <identifiersep> with <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , job . get <identifiersep> configuration ( ) ) ; \n \t3 this . delete <identifiersep> path ( job . get <identifiersep> configuration ( ) , output ) ; \n \t3 return wait <identifiersep> for <identifiersep> <identifier> ( job ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <number_literal> ) ; \n \t4 if ( system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> > <identifier> <identifiersep> run * <number_literal> ) { \n \t5 <identifier> <identifiersep> status . set <identifiersep> status ( task <identifiersep> status . run ) ; \n \t5 this . check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n <ect>
\t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + <identifier> ) ; } \n \t3 s <identifiersep> logger . info ( <string_literal> ) ; } \n \t2 if ( <identifier> <identifiersep> dir != null && <identifier> <identifiersep> dir . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
\t1 <identifier> . lock ( ) ; \n \t1 try { \n \t1 if ( <identifier> <identifiersep> <identifier> == 0 ) { \n \t2 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t2 <identifier> <identifiersep> m <identifiersep> bean . create <identifiersep> <identifier> ( <number_literal> ) ; \n \t2 set < string > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = create <identifiersep> <identifier> ( <number_literal> , <number_literal> ) ; \n \t2 state . <identifier> <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 log . info ( <string_literal> , state . <identifier> <identifiersep> <identifier> . size ( ) , state . <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + ip <identifiersep> id + <string_literal> , e ) ; \n \t3 success = false ; } \n \t2 if ( ! <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> and <identifiersep> static <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> ip ( ip <identifiersep> id , <identifier> <identifiersep> user <identifiersep> id , <identifier> ) ) { \n <ect>
\t2 if ( ! <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> ( request , o <identifiersep> <identifier> . client <identifiersep> id ) ) { \n \t3 logger . warn ( <string_literal> , <identifier> <identifiersep> type ) ; \n \t3 return false ; } \n \t2 if ( ! <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> ( request , o <identifiersep> <identifier> . <identifier> ) ) { \n <ect>
\t3 job <identifiersep> <identifier> job = new <identifiersep> job ( <identifier> <identifiersep> job . class ) . with <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> group ) . build ( ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> = new <identifiersep> <identifier> ( ) . with <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> group ) \n \t5 . with <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) . build ( ) ; \n \t3 <identifier> . <identifier> <identifiersep> job ( job , <identifier> ) ; \n <ect>
\t10 ( <identifier> ) key , null , null , null , null ) ; \n \t5 response [ ] <identifier> = get <identifiersep> <identifier> <identifiersep> channel ( ) . send ( entry . get <identifiersep> <identifier> <identifiersep> nodes ( ) , msg , <identifier> <identifiersep> channel . first <identifiersep> <identifier> , get <identifiersep> channel <identifiersep> send <identifiersep> options ( ) , get <identifiersep> <identifier> <identifiersep> timeout ( ) ) ; \n \t5 if ( <identifier> == null || <identifier> . length == 0 || <identifier> [ 0 ] . get <identifiersep> message ( ) == null ) { \n \t6 <comment> \n <ect>
\t1 public string to <identifiersep> string ( ) { \n \t2 return <identifier> <identifiersep> string + <string_literal> + <identifier> ; } } \n \t1 private map < cache <identifiersep> key , connection > connection <identifiersep> map ; \n \t1 public conn <identifiersep> cache ( ) { \n <ect>
\t2 <comment> \n \t2 <identifier> p = new <identifiersep> <identifier> ; \n \t2 new <identifiersep> <identifier> = new <identifiersep> <identifier> . <identifier> <identifiersep> host <identifiersep> name ( ) ; \n \t2 if ( new <identifiersep> <identifier> == null ) { \n <ect>
\t1 if ( ! all <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t1 <identifier> <identifiersep> device <identifier> <identifiersep> device = all <identifiersep> <identifier> <identifiersep> <identifier> . filter ( device <identifiersep> <identifier> ( ) ) . first ( ) \n \t2 . or ( all <identifiersep> <identifier> <identifiersep> <identifier> . first ( ) ) . get ( ) ; \n \t1 if ( ! device <identifiersep> <identifier> ( ) . <identifier> ( <identifier> <identifiersep> device ) ) { \n <ect>
\t2 assert <identifiersep> <identifier> ( client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> create ( <string_literal> ) . set <identifiersep> <identifier> ( <identifier> . builder ( ) \n \t3 . put ( <string_literal> , <identifier> <identifiersep> int <identifiersep> <identifier> ( 1 , <number_literal> ) ) . put ( <string_literal> , <number_literal> ) ) . get ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 client ( ) . <identifier> <identifiersep> index ( <string_literal> , <string_literal> ) . set <identifiersep> source ( json <identifiersep> builder ( ) . start <identifiersep> object ( ) . field ( <string_literal> , <string_literal> ) . end <identifiersep> object ( ) ) . get ( ) ; \n <ect>
\t2 if ( has <identifiersep> <identifier> <identifiersep> name ( ) ) { \n \t3 try { \n \t4 if ( <identifier> . is <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ) { \n \t5 return <identifier> . for <identifiersep> name ( <identifier> <identifiersep> name ) ; } \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t9 <identifier> <identifiersep> log . warn ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> ) ; } } } \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) { \n \t6 service <identifier> = <identifier> . get <identifiersep> service ( <identifier> <identifiersep> <identifier> <identifiersep> connection ) ; \n \t6 if ( <identifier> != null ) \n <ect>
\t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 return null ; \n \t2 } catch ( <identifier> <identifiersep> key <identifiersep> exception e ) { \n <ect>
\t2 } finally { \n \t2 try { \n \t3 <identifier> <identifiersep> connection <identifiersep> <identifier> . <identifier> ( ) ; } \n \t2 catch ( connection <identifiersep> exception e ) { \n <ect>
<comment> \n \t5 thread . <identifier> ( <number_literal> ) ; } \n <ect>
\t2 try { \n \t3 return <identifier> <identifiersep> manager . get <identifiersep> instance ( <identifier> <identifiersep> <identifier> . class , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> client <identifiersep> <identifier> ( ) throws throwable { \n \t2 <identifier> <identifiersep> bean <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> bean ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) == false ) { \n <ect>
\t3 if ( current <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> index != null && current <identifiersep> <identifier> <identifiersep> <identifier> == null ) { \n \t4 current <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( current <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> index , current <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t3 if ( <identifier> <identifiersep> <identifier> < - <number_literal> ) { \n \t4 is <identifiersep> <identifier> = true ; \n <ect>
\t7 s <identifiersep> logger . warn ( <string_literal> + <identifier> . <identifier> ( ) . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + host <identifiersep> id + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t7 handle <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , event . <identifier> <identifiersep> <identifier> ) ; \n \t7 throw <identifier> ; \n \t6 } else { \n <ect>
\t6 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> conf <identifiersep> path + <string_literal> ) ; \n \t6 found <identifiersep> <identifier> <identifiersep> configuration = true ; } \n \t5 if ( new file ( <identifier> <identifiersep> <identifier> <identifiersep> conf <identifiersep> path + <string_literal> ) . exists ( ) ) { \n \t6 result . add <identifiersep> resource ( new org . apache . <identifier> . <identifier> . path ( <identifier> <identifiersep> <identifier> <identifiersep> conf <identifiersep> path + <string_literal> ) ) ; \n <ect>
\t3 else if ( e . get <identifiersep> <identifier> ( ) instanceof shutdown <identifiersep> <identifier> <identifiersep> exception \n \t5 && <identifier> <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> channel <identifiersep> close ( ( shutdown <identifiersep> <identifier> <identifiersep> exception ) e . get <identifiersep> <identifier> ( ) ) ) { \n \t4 this . logger . error ( <string_literal> + consumer + <string_literal> , e ) ; } \n <ect>
\t2 if ( total <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> check == null ) { \n \t3 total <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> check = total <identifiersep> <identifier> ; \n \t3 return ; } \n \t2 if ( <identifier> . equals ( total <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> check , total <identifiersep> <identifier> ) == false ) { \n <ect>
\t2 return status . <identifier> <identifiersep> error . to <identifiersep> string ( ) ; } \n \t1 @ <identifier> \n \t1 public string handle <identifiersep> answer ( <identifier> <identifiersep> answer answer ) { \n <ect>
\t5 <identifier> <identifiersep> log . debug ( <string_literal> + entry ) ; \n \t3 } else if ( info != null && <identifier> <identifiersep> context . <identifier> <identifiersep> system ( ) . is <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( info ) ) { \n \t4 <identifier> . add ( entry ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 try { \n \t3 <identifier> = new <identifier> <identifiersep> <identifier> ( new file <identifiersep> <identifier> ( file ) ) ; \n \t3 set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> class ( ) ; } \n \t1 <comment> \n \t1 @ <identifier> \n \t1 public void test <identifiersep> <identifier> ( string host ) { \n <ect>
\t1 { \n \t2 try { \n \t3 return get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> <identifier> <identifiersep> id ( ) , this ) ; \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
public class <identifier> <identifiersep> message <identifiersep> query implements message <identifiersep> query { \n \t1 public static final int message <identifiersep> count = <number_literal> ; \n \t1 private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( <identifier> <identifiersep> message <identifiersep> query . class ) ; \n \t1 public void execute ( <identifier> <identifiersep> <identifier> <identifiersep> destination destination , message <identifiersep> listener listener ) throws exception { \n <ect>
\t2 table <identifiersep> name = <identifier> <identifiersep> <identifier> <identifiersep> table <identifiersep> name ( table <identifiersep> name ) ; \n \t2 table <identifiersep> <identifier> <identifier> = get <identifiersep> table <identifiersep> manager ( ) . get <identifiersep> table <identifiersep> <identifier> ( table <identifiersep> name , <identifier> ) ; \n \t2 <comment> \n \t2 if ( <identifier> == null || <identifier> . get <identifiersep> <identifier> ( ) == null ) { \n <ect>
\t1 public root <identifiersep> <identifier> <identifiersep> it ( node <identifiersep> store <identifiersep> <identifier> <identifier> ) { \n \t2 this . <identifier> = <identifier> ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) throws <identifier> <identifiersep> failed <identifiersep> exception { \n <ect>
\t1 public void close ( ) { \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> stream <identifiersep> id ; \n \t2 } else if ( <identifier> <identifiersep> status == <identifier> <identifiersep> status . <identifier> <identifiersep> <identifier> ) { \n \t3 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> stream <identifiersep> id ; \n \t2 } else { \n <ect>
\t2 return <identifier> ; } \n \t1 @ <identifier> \n \t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 public <identifier> add <identifiersep> consumer ( connection <identifiersep> context context , consumer <identifiersep> info info ) throws exception { \n <ect>
\t4 <identifier> . add ( resource ) ; } \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> command <identifiersep> class == null ) { \n <ect>
\t1 while ( <identifier> . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t1 <identifier> <identifiersep> entry <identifier> <identifiersep> entry = <identifier> . next <identifiersep> element ( ) ; \n \t1 if ( <identifier> <identifiersep> entry . get <identifiersep> name ( ) . <identifier> <identifiersep> with ( directory <identifiersep> path ) \n \t2 && <identifier> <identifiersep> entry . get <identifiersep> name ( ) . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
\t3 result <identifiersep> <identifier> <identifiersep> type = status . <identifier> <identifiersep> type ; \n \t2 } catch ( <identifier> <identifiersep> content <identifiersep> type <identifiersep> exception e ) { \n \t3 <identifier> = true ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 if ( account <identifiersep> id != null ) { \n \t6 if ( <identifier> <identifiersep> host . get <identifiersep> account <identifiersep> id ( ) . equals ( account <identifiersep> id ) ) { \n \t7 <identifier> <identifiersep> to <identifiersep> <identifier> . add ( <identifier> <identifiersep> host ) ; \n \t6 } else { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> port . add <identifiersep> event <identifiersep> listener ( this ) ; \n \t4 <identifier> <identifiersep> port . <identifier> <identifiersep> on <identifiersep> data <identifiersep> <identifier> ( true ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 this . consumer <identifiersep> <identifier> <identifiersep> task = null ; } } \n \t1 private void <identifier> <identifiersep> consumer ( <identifier> <identifiersep> consumer consumer ) { \n \t2 try { \n <ect>
\t4 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t5 try { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> = new <identifier> <identifiersep> key <identifiersep> <identifier> ( <identifier> <identifiersep> context ) ; \n \t5 } catch ( <identifier> <identifiersep> security <identifiersep> exception <identifier> ) { \n <ect>
\t2 log . warn ( <string_literal> + \n \t4 <string_literal> , msg , <identifier> <identifiersep> <identifier> <identifiersep> session <identifiersep> id , \n \t4 msg . <identifier> <identifiersep> session <identifiersep> id ( ) ) ; } \n \t1 private void handle <identifiersep> no <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> session <identifiersep> message msg ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 logger . trace ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> version ) ; \n \t3 try \n \t3 { \n \t4 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . contains ( connection <identifiersep> id . remote ( ) ) ) \n <ect>
\t2 <identifier> = session . create <identifiersep> <identifier> ( <identifier> ) ; \n \t2 send <identifiersep> message <identifiersep> that <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 send <identifiersep> message ( text <identifiersep> of <identifiersep> <identifier> <identifiersep> msg , <string_literal> ) ; } \n \t1 private void <identifier> <identifiersep> session ( ) throws <identifier> <identifiersep> exception { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public long get <identifiersep> connection <identifiersep> timeout ( ) { \n <ect>
\t3 if ( <identifier> != null && <identifier> . <identifier> ( ) . size ( ) > 0 ) { \n \t4 logger . info ( <string_literal> , <identifier> . <identifier> ( ) . get ( 0 ) . state ( ) ) ; \n \t4 <identifier> ( <string_literal> ) ; \n \t3 } else { \n <ect>
\t2 try { \n \t3 set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> case <identifiersep> <identifier> ( <identifier> <identifiersep> meta <identifiersep> data . <identifier> <identifiersep> <identifier> <identifiersep> case <identifiersep> <identifier> ( ) ) ; } \n \t2 catch ( sql <identifiersep> exception ex ) { \n <ect>
\t4 try { \n \t5 root root = session . get <identifiersep> <identifier> <identifiersep> root ( ) ; \n \t5 root . get <identifiersep> <identifier> ( <string_literal> ) . add <identifiersep> <identifier> ( name ) . set <identifiersep> property ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , test <identifiersep> <identifier> ) ; \n \t5 root . <identifier> ( ) ; \n <ect>
\t5 <identifier> . add ( <identifier> ) ; \n \t4 } else { \n \t5 logger . info ( <string_literal> + <identifier> <identifiersep> name ) ; } \n \t3 } else { \n <ect>
\t7 s <identifiersep> logger . debug ( <string_literal> + private <identifiersep> network ) ; \n \t6 } else { \n \t7 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> ) ; } \n \t5 } else { \n <ect>
\t3 try { \n \t4 response . put ( json <identifiersep> error , true ) ; \n \t4 log . debug ( <string_literal> , e ) ; \n \t3 } catch ( json <identifiersep> exception ex ) { \n <ect>
\t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t3 if ( format . <identifier> <identifiersep> type <identifiersep> info == null ) { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> type <identifiersep> info . class . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> ) ; } \n \t3 if ( format . <identifier> <identifiersep> values == null ) { \n <ect>
\t3 final <identifier> <identifiersep> file <identifiersep> <identifier> in = new <identifier> <identifiersep> file <identifiersep> <identifier> ( <identifier> , false ) ; \n \t3 try { \n \t4 <identifier> . assert <identifiersep> <identifier> <identifiersep> <identifier> ( in . get <identifiersep> file <identifiersep> header ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t3 } catch ( final <identifier> <identifiersep> error e ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> handle . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n \t4 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n <ect>
\t2 double <identifier> = double . parse <identifiersep> double ( x . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> ++ ; \n \t2 x = list . get ( <identifier> ) ; \n \t2 if ( ! x . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 } catch ( io <identifiersep> exception <identifier> ) { \n \t7 log . trace ( <string_literal> , <identifier> ) ; \n \t6 } else { \n <ect>
\t1 if ( is == null ) { \n \t2 <comment> \n \t2 if ( files <identifiersep> to <identifiersep> read . empty ( ) ) return false ; \n \t2 path p = files <identifiersep> to <identifiersep> read . <identifier> ( ) ; \n <ect>
\t2 log . info ( <string_literal> + <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t2 assert <identifiersep> equals ( <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t2 assert <identifiersep> equals ( <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> ) ; \n <ect>
\t3 listener . get ( ) ; \n \t3 <identifier> ( <string_literal> ) ; \n \t2 } catch ( execution <identifiersep> exception <identifier> <identifiersep> exception ) { \n \t3 throwable throwable = <identifier> <identifiersep> exception . get <identifiersep> <identifier> ( ) ; \n <ect>
\t2 if ( is <identifiersep> java <identifiersep> <identifier> ( <identifier> ) && ( <identifier> & <identifier> <identifiersep> <identifier> <identifiersep> type ) == 0 ) { \n \t3 <comment> \n \t3 type element <identifiersep> type = type <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> type ( type ) ; \n \t3 if ( element <identifiersep> type == null ) { \n <ect>
\t2 { \n \t3 return <identifier> . <identifier> ( new <identifier> <identifiersep> data <identifiersep> input <identifiersep> stream ( new <identifier> <identifiersep> input <identifiersep> stream ( <identifier> ) ) ) ; } \n \t2 catch ( io <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 return <identifier> <identifiersep> <identifier> ; } \n \t1 public message <identifiersep> <identifier> create <identifiersep> <identifier> <identifiersep> <identifier> ( destination <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 <identifier> <identifiersep> <identifier> = get <identifiersep> session ( ) . create <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( client . get <identifiersep> <identifier> <identifiersep> mode ( ) . equals <identifiersep> ignore <identifiersep> case ( <identifier> <identifiersep> <identifier> <identifiersep> properties . <identifier> <identifiersep> mode <identifiersep> <identifier> ) ) { \n <ect>
\t3 logger . warn ( <string_literal> , get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 return false ; } \n \t2 <identifier> = ! this . <identifier> || <identifier> . is <identifiersep> from <identifiersep> new <identifiersep> <identifier> ( ) ; \n \t2 if ( ! <identifier> ) { \n <ect>
\t3 if ( ! <identifier> <identifiersep> state ( vm , event . operation <identifiersep> <identifier> , host <identifiersep> id , <identifier> , <identifier> . <identifier> ) ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + vm ) ; \n \t4 throw new <identifier> <identifiersep> operation <identifiersep> exception ( <string_literal> + vm ) ; } \n \t2 } catch ( final no <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t7 + ex . get <identifiersep> message ( ) + <string_literal> ) ; \n \t3 } catch ( io <identifiersep> exception ex ) { \n \t4 if ( ! <identifier> ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t5 message . get <identifiersep> <identifier> <identifiersep> type ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , \n \t5 return <identifiersep> value == null ? <string_literal> : return <identifiersep> value . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 return return <identifiersep> value ; \n \t2 } catch ( exception t ) { \n <ect>
\t4 log . info ( <string_literal> \n \t6 + <identifier> + <string_literal> ) ; \n \t4 return job . wait <identifiersep> for <identifiersep> <identifier> ( true ) ? 0 : 1 ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t3 try { \n \t4 <identifier> . server <identifiersep> <identifier> ( event ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> status status = <identifier> . get <identifiersep> index <identifiersep> status ( key ) ; \n \t4 if ( status != <identifier> <identifiersep> status . <identifier> && ! <identifier> <identifiersep> <identifier> . contains ( status ) ) { \n \t5 is <identifiersep> <identifier> <identifiersep> index = false ; \n \t5 <identifier> <identifiersep> key <identifiersep> <identifier> . put ( key . name ( ) , status ) ; \n <ect>
\t2 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . <identifier> <identifiersep> all ( <identifier> , integer . max <identifiersep> value ) . get ( ) ; \n \t2 assert <identifiersep> equals ( 1 , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . size ( ) ) ; \n \t2 <comment> \n <ect>
\t3 throw new runtime <identifiersep> io <identifiersep> exception ( format ( <string_literal> , \n \t5 connection . <identifier> <identifiersep> and <identifiersep> connection <identifiersep> type , this , connection . <identifier> <identifiersep> and <identifiersep> connection <identifiersep> type , <identifier> ) ) ; } } \n \t1 @ <identifier> \n \t1 public void set <identifiersep> <identifier> ( boolean <identifier> ) { \n <ect>
<comment> \n <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> type <identifier> <identifiersep> <identifier> <identifiersep> type ) { \n \t1 if ( <identifier> == null ) { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 meta <identifiersep> data meta <identifiersep> data = meta <identifiersep> data . builder ( ) . put ( index <identifiersep> meta <identifiersep> data . builder ( <string_literal> ) . <identifier> ( <identifier> ( version . current ) ) . number <identifiersep> of <identifiersep> shards ( <number_literal> ) . number <identifiersep> of <identifiersep> <identifier> ( 1 ) ) . build ( ) ; \n \t2 routing <identifiersep> table <identifier> <identifiersep> routing <identifiersep> table = routing <identifiersep> table . builder ( ) . add <identifiersep> as <identifiersep> new ( meta <identifiersep> data . index ( <string_literal> ) ) . build ( ) ; \n \t2 cluster <identifiersep> state cluster <identifiersep> state = cluster <identifiersep> state . builder ( org . <identifier> . cluster . cluster <identifiersep> name . cluster <identifiersep> name <identifiersep> <identifier> . get <identifiersep> default ( <identifier> . empty ) ) . meta <identifiersep> data ( meta <identifiersep> data ) . routing <identifiersep> table ( <identifier> <identifiersep> routing <identifiersep> table ) . build ( ) ; \n <ect>
\t2 <identifier> <identifier> = <identifier> . find <identifiersep> or <identifiersep> create <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 try \n \t2 { \n \t3 string <identifier> = entity . get <identifiersep> text ( ) ; \n <ect>
\t3 boolean <identifier> = ( this . timeout >= 0 ) \n \t5 ? <identifier> <identifiersep> <identifier> <identifiersep> channel . send ( message , this . timeout ) \n \t5 : <identifier> <identifiersep> <identifier> <identifiersep> channel . send ( message ) ; \n <ect>
\t1 private int get <identifiersep> <identifier> <identifiersep> index ( resource <identifiersep> <identifier> uri , boolean warn <identifiersep> on <identifiersep> error ) { \n \t2 if ( <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( uri ) ) { \n \t3 return <identifier> <identifiersep> <identifier> . get ( uri ) ; } \n \t2 if ( warn <identifiersep> on <identifiersep> error ) { \n <ect>
\t3 throw new <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( ! <identifier> . get <identifiersep> file <identifiersep> header ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . equals ( <identifier> <identifiersep> file <identifiersep> header . <identifier> <identifiersep> <identifier> . <identifier> ) ) { \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t2 <identifier> <identifiersep> <identifier> . create <identifiersep> index ( <identifier> , output ) ; \n <ect>
\t5 throw new io <identifiersep> exception ( <identifier> ) ; } \n \t4 return input <identifiersep> stream ; } \n \t3 @ <identifier> \n \t3 public string get <identifiersep> <identifier> ( ) { \n <ect>
\t4 out . write ( <identifier> . to <identifiersep> string ( ) . get <identifiersep> bytes ( ) ) ; \n \t4 out . write ( <identifier> . null <identifiersep> byte ) ; \n \t4 out . <identifier> ( ) ; } } \n \t2 catch ( io <identifiersep> exception ex ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t9 s = new grid <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message < > ( <identifier> . <identifier> <identifiersep> id ( ) , <identifier> . update <identifiersep> <identifier> ( ) ) ; } \n \t8 if ( <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> . <identifier> ( info ) ) \n \t9 s . add <identifiersep> entry ( <identifier> , info , <identifier> ) ; \n <ect>
\t4 <identifier> . write <identifiersep> end <identifiersep> object ( ) ; \n \t3 } catch ( exception e ) { \n \t4 <identifier> . delete ( path , false ) ; \n \t4 throw e ; } \n <ect>
\t3 return new <identifier> <identifiersep> result ( model ) ; } \n \t2 if ( query . is <identifiersep> <identifier> <identifiersep> type ( ) ) \n \t2 { \n \t3 model model = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> user <identifiersep> update ( json <identifiersep> object source , json <identifiersep> object target , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> user <identifiersep> <identifier> ( long target , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception { \n <ect>
\t1 private static byte [ ] <identifier> \t1 = new byte [ <number_literal> ] ; \n \t1 protected static int \t1 stream <identifiersep> count = 0 ; <comment> \n \t1 protected static synchronized int new <identifiersep> stream <identifiersep> no ( ) \n \t1 { \n <ect>
\t2 return ; \n \t2 } finally { \n \t2 <identifier> . close ( ) ; } \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 log . info ( <string_literal> + <identifier> <identifiersep> content <identifiersep> <identifier> . get <identifiersep> length ( ) + <string_literal> + \n \t3 <identifier> <identifiersep> conf . get <identifiersep> long <identifiersep> <identifier> ( conf , conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) + <string_literal> ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> content <identifiersep> <identifier> . get <identifiersep> file <identifiersep> count ( ) + <string_literal> + \n \t3 <identifier> <identifiersep> conf . get <identifiersep> long <identifiersep> <identifier> ( conf , conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) + <string_literal> ) ; \n <ect>
private consumer < <identifier> <identifiersep> exception > on <identifiersep> routing <identifiersep> error ( ) { \n \t1 return <identifier> - > { \n \t1 try { \n \t2 <identifier> . set <identifiersep> in <identifiersep> error <identifiersep> handler ( true ) ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 transaction . <identifier> ( ) ; \n \t1 } catch ( runtime <identifiersep> exception ex ) { \n <ect>
\t1 if ( version <identifiersep> name . contains ( <string_literal> ) ) { \n \t1 <identifier> <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( c , id , <identifier> , <identifier> , <identifier> , <identifier> , job <identifiersep> status ) ; \n \t1 } else { \n \t1 <identifier> <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> next ( c , id , <identifier> , <identifier> , <identifier> , <identifier> , job <identifiersep> status ) ; } \n <ect>
\t2 this . principal <identifiersep> <identifier> <identifiersep> <identifier> = principal <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public <identifier> < authentication > get <identifiersep> <identifier> <identifiersep> authentication ( ) { \n \t2 if ( this . <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t1 <comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> node ( ) { \n <ect>
\t4 db <identifiersep> info . set <identifiersep> <identifier> ( <identifier> ) ; \n \t4 db <identifiersep> info . set <identifiersep> <identifier> ( <identifier> ) ; \n \t4 return db <identifiersep> info ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) , \n \t5 <identifier> <identifiersep> <identifier> . get <identifiersep> group <identifiersep> attribute ( ) , \n \t5 <identifier> <identifiersep> <identifier> . get <identifiersep> group <identifiersep> <identifier> ( ) , \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> group <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n <ect>
\t2 return <identifier> . get <identifiersep> <identifier> <identifiersep> store ( ) . get <identifiersep> node <identifiersep> store ( ) . <identifier> <identifiersep> info ( <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public node <identifiersep> state <identifier> ( string <identifier> ) { \n \t2 if ( ! <identifier> <identifiersep> exists ( <identifier> . get <identifiersep> <identifier> <identifiersep> store ( ) . get <identifiersep> node <identifiersep> store ( ) , <identifier> ) ) { \n <ect>
\t3 if ( add <identifiersep> a <identifiersep> queue <identifiersep> if <identifiersep> <identifier> && <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> ( ) ) \n \t3 { \n \t4 if ( <identifier> . size ( ) < <identifier> . get <identifiersep> max <identifiersep> <identifier> ( ) ) \n \t4 { \n <ect>
\t3 this . update <identifiersep> <identifier> ( ) ; \n \t3 <identifier> . update <identifiersep> <identifier> ( ) ; \n \t3 end <identifiersep> time = system . <identifier> <identifiersep> time ( ) ; \n \t3 <identifier> = end <identifiersep> time - start <identifiersep> time ; \n <ect>
\t4 if ( ! <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> ( ) ) { \n \t5 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . is <identifiersep> <identifier> ( ) ) { \n \t6 <identifier> < user > user = user <identifiersep> manager . instance . get <identifiersep> user ( entry . get <identifiersep> key ( ) ) ; \n \t6 if ( ! user . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 protected void debug <identifiersep> <identifier> ( exchange exchange , <identifier> <identifier> , \n \t7 <identifier> <identifiersep> <identifier> < ? > <identifier> , string id , string short <identifiersep> name ) { \n \t2 <comment> \n \t2 <comment> \n <ect>
\t4 . <identifier> <identifiersep> query ( <identifier> <identifiersep> <identifier> ) \n \t4 . with <identifiersep> <identifier> ( <string_literal> ) \n \t4 . execute ( ) ; \n \t2 long count = result . get <identifiersep> result ( ) . get <identifiersep> number ( ) ; \n <ect>
\t5 <identifier> <identifiersep> default <identifiersep> value = <string_literal> , \n \t5 <identifier> <identifiersep> default <identifiersep> value = <string_literal> ) final boolean <identifier> ) { \n \t2 final map < string , configuration <identifiersep> metadata <identifiersep> property > <identifier> = find ( <identifier> , <identifier> <identifiersep> utils . create <identifiersep> <identifier> ( name ) ) ; \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t4 handle <identifiersep> exception ( e ) ; } } \n \t2 @ <identifier> \n \t2 public void process <identifiersep> result ( <identifier> <identifiersep> <identifier> client , <identifier> <identifiersep> event event ) throws exception \n \t2 { \n <ect>
\t2 message <identifiersep> count = 1 ; \n \t2 connection . start ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> connection <identifier> <identifiersep> connection = ( <identifier> <identifiersep> <identifier> <identifiersep> connection ) connection ; \n \t2 <identifier> <identifiersep> count = <identifier> <identifiersep> connection . get <identifiersep> <identifier> <identifiersep> policy ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + 1 ; \n <ect>
@ test \n public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws io <identifiersep> exception { \n \t1 date date = new date ( ) ; \n \t1 string id = date . to <identifiersep> string ( ) . <identifier> ( <string_literal> , <string_literal> ) ; \n <ect>
\t3 log <identifiersep> msg ( query <identifiersep> <identifier> <identifiersep> <identifier> , query <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> query <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t2 boolean <identifier> <identifiersep> query <identifiersep> size <identifiersep> <identifier> <identifiersep> <identifier> = query <identifiersep> <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> <identifiersep> query <identifiersep> size ; \n \t2 boolean <identifier> <identifiersep> query <identifiersep> size <identifiersep> from <identifiersep> config = config . <identifier> <identifiersep> query <identifiersep> size ( ) ; \n \t2 query <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> query <identifiersep> size ( <identifier> <identifiersep> query <identifiersep> size <identifiersep> from <identifiersep> config || <identifier> <identifiersep> query <identifiersep> size <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t2 log . error ( <string_literal> + volume <identifiersep> id + <string_literal> ) ; \n \t2 return null ; \n \t2 } catch ( transaction <identifiersep> exception e ) { \n <ect>
\t2 { \n \t3 logger . error ( <string_literal> , e ) ; } \n \t2 catch ( <identifier> <identifiersep> target <identifiersep> exception e ) \n \t2 { \n <ect>
\t10 break ; } \n \t8 } catch ( <identifier> <identifiersep> metadata <identifiersep> exception e ) { \n \t9 logger . error ( <string_literal> , e ) ; } } } \n \t5 } catch ( exception e ) { \n <ect>
\t2 for ( <identifier> < ? > i : <identifier> ) { \n \t3 try { \n \t4 <identifier> ( i ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 public void handle <identifiersep> message ( message < ? > message ) throws <identifier> <identifiersep> exception { \n \t2 string session <identifiersep> id = <identifier> <identifiersep> session <identifiersep> id ( message ) ; \n \t2 if ( session <identifiersep> id == null ) { \n \t3 if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t3 set <identifiersep> last <identifiersep> <identifier> ( \n \t4 get <identifiersep> <identifier> <identifiersep> property ( last <identifiersep> <identifier> ) , get <identifiersep> <identifier> <identifiersep> property ( \n \t5 last <identifiersep> <identifier> <identifiersep> url ) ) ; \n \t2 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
private static <identifier> <identifiersep> <identifier> <identifier> ; \n @ test \n public void test <identifiersep> <identifier> ( ) throws exception \n { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 logger . debug ( <string_literal> + key + <string_literal> \n \t6 + <identifier> <identifiersep> utils . <identifier> ( <identifier> ) + <string_literal> + bean + <string_literal> ) ; } \n \t3 object return <identifiersep> value = method . <identifier> ( bean , <identifier> ) ; \n <ect>
\t3 process <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> ( <identifier> <identifiersep> id , <identifier> , <identifier> , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t2 } else { \n \t2 log . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <string_literal> ) ; } } \n \t1 } else { \n <ect>
\t3 logger . debug ( <string_literal> , ticket . get <identifiersep> id ( ) ) ; \n \t3 final ticket <identifiersep> <identifier> <identifier> = build <identifiersep> ticket <identifiersep> as <identifiersep> <identifier> ( ticket ) ; \n \t3 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket ) ; \n \t3 if ( metadata == null ) { \n <ect>
\t3 <identifier> . set <identifiersep> request <identifiersep> property ( <string_literal> , <string_literal> ) ; \n \t3 log . debug ( <string_literal> + url ) ; \n \t3 in = <identifier> <identifiersep> connection <identifiersep> check <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 catch ( io <identifiersep> exception io ) { \n <ect>
\t2 <identifier> = new <identifier> <identifiersep> input <identifiersep> stream ( new file <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> file ) ) ; \n \t2 set < string > <identifier> <identifiersep> files = new <identifier> <identifiersep> set < string > ( ) ; \n \t2 set < string > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> set < string > ( ) ; \n \t2 <identifier> <identifiersep> entry <identifier> = <identifier> . get <identifiersep> next <identifiersep> entry ( ) ; \n <ect>
\t1 class <identifier> <identifiersep> exception <identifiersep> handler implements thread . <identifier> <identifiersep> exception <identifiersep> handler { \n \t2 public throwable throwable ; \n \t2 @ <identifier> public void <identifier> <identifiersep> exception ( final thread t , final throwable e ) { \n \t3 this . throwable = e ; \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> blank ( url ) ) { \n \t3 logger . warn ( \n \t5 <string_literal> ) ; } \n \t2 db = ( string ) config . get ( <string_literal> ) ; \n <ect>
\t6 response , \n \t6 ( <identifier> <identifiersep> provider ) response <identifiersep> event . get <identifiersep> source ( ) ) ; } \n \t4 catch ( operation <identifiersep> failed <identifiersep> exception e ) \n \t4 { \n <ect>
\t3 if ( <identifier> <identifiersep> to <identifiersep> <identifier> . contains ( element . get <identifiersep> provider ( ) ) ) { \n \t4 if ( element . shutdown <identifiersep> <identifier> ( <identifier> , context ) ) { \n \t5 s <identifiersep> logger . debug ( <string_literal> + <identifier> + <string_literal> ) ; \n \t4 } else { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 log . error ( <string_literal> , e ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> success ( <identifier> result ) \n \t2 { \n <ect>
\t3 logger . warn ( <string_literal> , registered <identifiersep> service ) ; \n \t3 return false ; } \n \t2 final string <identifier> <identifiersep> uri = request . get <identifiersep> <identifier> ( o <identifiersep> <identifier> . <identifier> <identifiersep> uri ) ; \n \t2 if ( ! <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> ( registered <identifiersep> service , <identifier> <identifiersep> uri ) ) { \n <ect>
\t4 } else if ( log <identifiersep> <identifier> && <identifier> <identifiersep> cache && ! <identifier> <identifiersep> <identifier> ) \n \t5 logger . <identifier> ( this , <string_literal> ) ; \n \t4 return null ; } \n \t3 if ( <identifier> <identifiersep> cache && ! <identifier> <identifiersep> <identifier> ) { \n <ect>
<comment> \n \t1 private void log <identifiersep> <identifier> <identifiersep> failure ( string <identifier> , exception e ) { \n <ect>
\t5 if ( command instanceof <identifier> <identifiersep> type ) { \n \t6 float <identifier> = ( ( <identifier> <identifiersep> type ) command ) . float <identifiersep> value ( ) ; \n \t6 int value = ( int ) ( <identifier> * <number_literal> . ) ; \n \t6 if ( send <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , value ) ) { \n <ect>
\t1 if ( ! attributes . contains ( request . get <identifiersep> attribute ( ) ) ) { \n \t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + request . get <identifiersep> attribute ( ) ) ; } \n \t1 final service <identifiersep> builder builder = service <identifiersep> <identifier> . <identifier> ( request . get <identifiersep> class ( ) ) ; \n \t1 log . info ( <string_literal> + builder . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n <ect>
\t3 string store <identifiersep> password = string . value <identifiersep> of ( <identifier> <identifiersep> <identifier> . next <identifiersep> long ( ) ) ; \n \t3 byte [ ] <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> manager . <identifier> <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> manager . <identifier> <identifiersep> name , store <identifiersep> password ) ; \n \t3 assert ( <identifier> <identifiersep> <identifier> != null ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t2 <comment> \n \t2 final long <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> date - system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> < 0 ) { \n <ect>
\t2 file <identifiersep> input <identifiersep> stream <identifier> = new file <identifiersep> input <identifiersep> stream ( file ) ; \n \t2 int size = <identifier> <identifiersep> size ; \n \t2 byte [ ] <identifier> = new byte [ <identifier> <identifiersep> size ] ; \n \t2 do { \n <ect>
\t2 return null ; } \n \t1 private synchronized void handle <identifiersep> for <identifiersep> event <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider provider = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider ( ) ; \n \t2 if ( provider == null ) { \n <ect>
\t2 final attribute <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifiersep> <identifier> <identifiersep> object ( attribute <identifiersep> <identifier> . class ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 for ( final map . entry < string , object > e : attributes . entry <identifiersep> set ( ) ) { \n \t3 if ( e . get <identifiersep> value ( ) instanceof collection < ? > && ( ( collection < ? > ) e . get <identifiersep> value ( ) ) . is <identifiersep> empty ( ) ) { \n <ect>
\t2 return state <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> state ( t state ) { \n \t2 if ( state <identifiersep> <identifier> ) { \n <ect>
else : \n \t1 stack <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> package <identifiersep> name ( ) \n if stack <identifiersep> <identifier> <identifiersep> <identifier> is <identifier> : \n \t1 if not <identifier> : \n <ect>
\t3 query <identifiersep> <identifier> <identifier> = this . get <identifiersep> query <identifiersep> <identifier> ( sql ) ; \n \t3 if ( <identifier> != null ) { \n \t4 <identifier> . add ( <identifier> , start ) ; \n <ect>
\t4 assert <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t3 catch ( <identifier> <identifiersep> failed <identifiersep> error e ) { \n \t4 if ( i == <number_literal> ) \n \t5 throw e ; \n <ect>
\t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> instanceof throwable ) { \n \t4 <identifier> = null ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = ( throwable ) <identifier> <identifiersep> <identifier> ; \n <ect>
\t9 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . execute <identifiersep> <identifier> <identifiersep> command ( <identifier> . get <identifiersep> ip ( ) , <identifier> . get <identifiersep> port ( ) , \n <number_literal> <identifier> <identifiersep> address . get <identifiersep> address ( ) , new <identifiersep> value ) ; \n \t9 break ; } \n \t8 default : \n <ect>
\t1 @ <identifier> \n \t1 protected <identifier> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> request ( final request <identifiersep> context context ) { \n \t2 final http <identifiersep> <identifier> <identifiersep> request request = web <identifiersep> utils . get <identifiersep> http <identifiersep> <identifier> <identifiersep> request <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( context ) ; \n \t2 final string <identifier> <identifiersep> header = request . get <identifiersep> header ( <identifier> <identifiersep> <identifier> . header <identifiersep> <identifier> ) ; \n <ect>
\t4 <identifier> <identifiersep> log . debug . <identifier> ( <string_literal> + <identifier> <identifiersep> config <identifiersep> directory <identifiersep> path ) ; } \n \t3 file config <identifiersep> dir = new file ( <identifier> <identifiersep> config <identifiersep> directory <identifiersep> path ) ; \n \t3 if ( ! config <identifiersep> dir . exists ( ) ) { \n \t4 if ( ! config <identifiersep> dir . <identifier> ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> node <identifiersep> <identifier> . start <identifiersep> <identifier> ( ) ; \n \t2 set < string > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> nodes <identifiersep> set = new <identifier> <identifiersep> set < > ( nodes ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> nodes <identifiersep> set . remove ( <identifier> <identifiersep> <identifier> <identifiersep> node ) ; \n \t2 list < string > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> nodes = new array <identifiersep> list < > ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> nodes <identifiersep> set ) ; \n <ect>
\t2 message <identifiersep> json = json . <identifier> ( message ) \n \t1 <identifier> value <identifiersep> error : \n \t2 logger . exception ( <string_literal> . format ( message ) ) \n \t2 return \n <ect>
\t2 if ( value != null && value . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> enabled = true ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url <identifiersep> <identifier> = <identifier> . get ( config . <identifier> <identifiersep> <identifier> <identifiersep> url <identifiersep> <identifier> . key ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> enabled && ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url <identifiersep> <identifier> . is <identifiersep> empty ( ) ) ) { \n <ect>
\t5 path = path . <identifier> ( 0 , path . length ( ) - 1 ) ; \n \t4 path <identifier> <identifiersep> path = path . get <identifiersep> path <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( new path ( path ) ) ; \n \t4 if ( file <identifiersep> system . exists ( <identifier> <identifiersep> path ) ) { \n \t5 file <identifiersep> system . delete ( <identifier> <identifiersep> path , true ) ; \n <ect>
\t3 <identifier> ++ ; \n \t3 this . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 queue ( this , <number_literal> * <number_literal> ) ; } \n \t2 else { \n <ect>
\t3 stream <identifiersep> result <identifier> = new stream <identifiersep> result ( <identifier> ) ; \n \t3 <identifier> . <identifier> ( <identifier> <identifiersep> source , <identifier> ) ; \n \t3 return <identifier> . to <identifiersep> string ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 } catch ( io <identifiersep> exception <identifier> ) { \n \t5 debug <identifiersep> log . warn ( <string_literal> + url , <identifier> ) ; \n \t5 <identifier> . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t4 } catch ( uri <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t5 <comment> \n \t5 run ( ) ; } \n \t4 catch ( throwable t ) \n \t4 { \n <ect>
\t4 return null ; } \n \t3 return <identifier> <identifiersep> ip ; } \n \t2 long ip = <identifier> <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> ip <identifiersep> from <identifiersep> <identifier> ( <identifier> [ 0 ] , integer . parse <identifiersep> int ( <identifier> [ 1 ] ) , <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( ip == - 1 ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . set <identifiersep> field ( field , <identifier> , <identifier> <identifiersep> thread <identifiersep> context <identifiersep> class <identifiersep> <identifier> . class . get <identifiersep> name ( ) ) ; \n \t2 } catch ( exception e ) { \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } \n \t2 try { \n <ect>
\t1 map < string , string > conf <identifiersep> <identifier> = new <identifier> <identifiersep> map < string , string > ( ) ; \n \t1 try { \n \t1 <identifier> <identifiersep> <identifier> . start ( conf <identifiersep> <identifier> ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( <identifier> <identifiersep> list ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t1 } else { \n <ect>
public <identifier> <identifiersep> data <identifier> ( ) { \n \t1 return ( <identifier> <identifiersep> data ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> ( <identifier> <identifiersep> data value ) { \n <ect>
\t4 <identifier> <identifiersep> queue . <identifier> <identifiersep> <identifier> ( this ) ; \n \t4 if ( system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> > <identifier> <identifiersep> run * <number_literal> ) { \n \t5 <identifier> <identifiersep> status . set <identifiersep> status ( task <identifiersep> status . run ) ; \n \t5 this . check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n <ect>
<comment> \n private int wait <identifiersep> for <identifiersep> all <identifiersep> <identifier> <identifiersep> to <identifiersep> start ( job <identifiersep> <identifier> job <identifiersep> <identifier> , int pool <identifiersep> thread <identifiersep> count ) { \n \t1 int current <identifiersep> id = job <identifiersep> <identifier> . thread <identifiersep> start <identifiersep> count . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n <ect>
\t4 try { \n \t5 log . debug ( <string_literal> , be ) ; \n \t5 connection . <identifier> ( ) ; } \n \t4 catch ( exception <identifier> ) { \n <ect>
\t5 log . debug ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; } } \n \t3 <comment> \n \t3 <comment> \n \t3 if ( ( 0 . <number_literal> * info . get <identifiersep> <identifier> <identifiersep> size ( ) ) < = ( <identifier> <identifiersep> <identifier> + <identifier> <identifiersep> <identifier> - <identifier> <identifiersep> <identifier> <identifiersep> size ) ) { \n <ect>
\t3 <identifier> <identifiersep> data <identifier> = <identifier> [ i ] ; \n \t3 if ( i == 0 ) { \n \t4 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) . key <identifiersep> set ( ) ) ; } \n \t3 message <identifiersep> i <identifiersep> <identifier> [ i ] = ( string ) <identifier> . get ( <string_literal> ) ; \n <ect>
\t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t2 try { \n \t3 method <identifiersep> field . set ( connection , request . get <identifiersep> method ( ) ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception <identifier> ) { \n <ect>
\t1 try : \n \t1 if config . has <identifiersep> <identifier> ( user <identifiersep> <identifier> , user <identifiersep> key ) : \n \t2 property <identifiersep> map [ user <identifiersep> <identifier> ] = config . get ( user <identifiersep> <identifier> , user <identifiersep> key ) . <identifier> ( ' , ' ) \n \t1 <identifier> : \n <ect>
\t5 long t <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t5 while ( i ++ < send <identifiersep> count ) { \n \t6 <identifier> . send ( session . create <identifiersep> text <identifiersep> message ( <string_literal> ) ) ; \n \t6 if ( <identifier> == 0 ) { \n <ect>
\t3 <identifier> . <identifier> ( true , true ) ; \n \t3 <comment> \n \t3 file <identifiersep> utils . delete <identifiersep> directory ( <identifier> <identifiersep> directory ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 entity <identifiersep> manager . <identifier> ( <identifier> ) ; \n \t2 } ) ; \n \t2 do <identifiersep> in <identifiersep> <identifier> ( this : : entity <identifiersep> manager <identifiersep> factory , entity <identifiersep> manager - > { \n \t3 <identifier> <identifier> = entity <identifiersep> manager . find ( <identifier> . class , <identifier> ) ; \n <ect>
\t1 { \n \t2 <identifier> <identifiersep> <identifier> . on <identifiersep> data <identifiersep> <identifier> ( data ) ; } \n \t1 catch ( throwable ex ) \n \t1 { \n <ect>
\t3 + <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 for ( string s : <identifier> <identifiersep> <identifier> . values ( ) ) \n \t2 log . info ( <string_literal> , s ) ; \n <ect>
\t2 if ( ! <identifier> <identifiersep> dir . <identifier> <identifiersep> with ( file . <identifier> ) ) \n \t2 { \n \t3 <identifier> <identifiersep> dir += file . <identifier> ; } \n \t2 set <identifiersep> <identifier> <identifiersep> value ( context <identifiersep> <identifier> . user <identifiersep> directory <identifiersep> path , <identifier> <identifiersep> dir ) ; \n <ect>
\t2 while ( ( entry = is . get <identifiersep> next <identifiersep> entry ( ) ) != null && entry . is <identifiersep> directory ( ) ) ; \n \t2 return entry != null ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t2 { \n \t3 <identifier> <identifiersep> <identifier> . get <identifiersep> session ( session <identifiersep> id ) . start <identifiersep> session ( ) ; } \n \t2 catch ( <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 logger . error ( <string_literal> ) \n \t3 node . <identifier> . to <identifiersep> string ( <identifier> - <identifier> ) . <identifier> <identifiersep> line { line - > logger . error ( <string_literal> ) } \n \t3 <comment> \n \t3 if ( node . start <identifiersep> log . exists ( ) ) { \n <ect>
\t1 { \n \t2 try { \n \t3 return <identifier> . value <identifiersep> of ( <identifier> ) ; \n \t2 } catch ( parse <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> && <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n \t4 && ( <identifier> . get <identifiersep> current <identifiersep> url ( ) . <identifier> ( <string_literal> ) \n \t4 || <identifier> . get <identifiersep> current <identifiersep> url ( ) . <identifier> ( <string_literal> ) ) ) { \n <ect>
\t6 ip <identifiersep> <identifier> <identifiersep> command cmd = ip <identifiersep> <identifier> <identifiersep> command . value <identifiersep> of ( device <identifiersep> cmd ) ; \n \t6 device <identifiersep> cmd = cmd . get <identifiersep> command ( ) ; } \n \t5 remote <identifiersep> <identifier> . send ( device <identifiersep> cmd ) ; \n \t4 } else { \n <ect>
\t1 <identifier> <identifiersep> cache . put ( key , first <identifiersep> value ) ; \n \t1 assert <identifiersep> is <identifiersep> not <identifiersep> in <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> cache , key ) ; \n \t1 check <identifiersep> <identifier> check <identifiersep> <identifier> = new check <identifiersep> <identifier> ( ) ; \n \t1 wait <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> lock ( <identifier> <identifiersep> <identifier> <identifiersep> cache , check <identifiersep> <identifier> ) ; \n <ect>
\t2 log . trace ( <string_literal> , filter . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; } \n \t1 if ( filter . should <identifiersep> <identifier> ( http <identifiersep> <identifier> <identifiersep> request ) ) { \n <ect>
\t3 <identifier> <identifiersep> server . <identifier> <identifiersep> query ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> job job = <identifier> <identifiersep> server . store ( <string_literal> , file <identifiersep> path ) ; \n \t3 check <identifiersep> <identifier> <identifiersep> <identifier> ( job ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 if ( connection == null ) { \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 else if ( connection == <identifier> <identifiersep> connection ) { \n \t3 <comment> \n <ect>
\t1 if ( cluster <identifiersep> enabled ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> nodes = <identifier> . value <identifiersep> as <identifiersep> int ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> nodes . get <identifiersep> key ( ) , <number_literal> ) ; \n \t1 <identifier> <identifiersep> state <identifiersep> time <identifiersep> out = <identifier> . value ( <identifier> <identifiersep> <identifier> <identifiersep> state <identifiersep> timeout . get <identifiersep> key ( ) , <string_literal> ) ; \n \t1 string <identifier> = <identifier> . value ( cluster <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> key ( ) , <string_literal> ) ; \n <ect>
\t3 final host . <identifier> <identifier> = <identifier> . <identifier> . get <identifiersep> <identifier> ( conn ) ; \n \t3 if ( ! <identifier> <identifiersep> resource <identifiersep> base . get <identifiersep> host ( ) . get <identifiersep> <identifier> ( ) . equals ( <identifier> . <identifier> ) ) { \n \t4 return new cluster <identifiersep> vm <identifiersep> meta <identifiersep> data <identifiersep> <identifier> <identifiersep> answer ( command . get <identifiersep> cluster <identifiersep> id ( ) , null ) ; } \n \t2 } catch ( final throwable e ) { \n <ect>
\t5 log . trace ( <string_literal> , new object [ ] { \n \t7 configuration . get <identifiersep> <identifier> <identifiersep> name ( ) , this , remote <identifiersep> <identifier> <identifiersep> name \n \t5 } ) ; \n \t4 } else { \n <ect>
\t3 @ <identifier> \n \t3 public void on <identifiersep> failure ( <identifier> <identifiersep> exception e , client <identifiersep> <identifier> state ) { \n \t4 if ( e . mode == <identifier> <identifiersep> exception <identifiersep> mode . <identifier> ) { \n \t5 <comment> \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t5 element <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( server , input ) ; \n \t5 map < string , string > values = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( <identifier> , new string [ ] { <string_literal> } ) ; \n \t5 s <identifiersep> logger . info ( <string_literal> ) ; \n \t5 long <identifier> = long . parse <identifiersep> long ( values . get ( <string_literal> ) ) ; \n <ect>
\t4 return ; } \n \t3 <identifier> = <identifier> . process <identifiersep> header ; \n \t3 try { \n <ect>
\t3 <comment> \n \t3 int task = message . task ( ) ; \n \t3 <identifier> <identifiersep> queue queue = <identifier> <identifiersep> <identifier> . get ( task ) ; \n \t3 if ( queue == null ) { \n <ect>
\t2 try { \n \t3 connection ( ) . <identifier> ( <string_literal> ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) \n \t2 { \n <ect>
\t3 logger . info ( message + ( body == null ? <string_literal> : <string_literal> + body + <string_literal> ) ) ; \n \t3 long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 <identifier> . do <identifiersep> filter ( <identifier> , <identifier> ) ; \n \t3 long request <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ; \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t1 { \n \t1 path <identifiersep> info = request <identifiersep> uri . <identifier> ( <identifier> . length ( ) ) ; } \n \t1 else \n \t1 { \n <ect>
\t4 log <identifiersep> <identifier> <identifiersep> logger . set <identifiersep> level ( null ) ; \n \t3 return ; } \n \t2 <identifier> . <identifier> . <identifier> . <identifier> . level level = <identifier> . <identifier> . <identifier> . <identifier> . level . to <identifiersep> level ( <identifier> <identifiersep> level ) ; \n \t2 log <identifiersep> <identifier> <identifiersep> logger . set <identifiersep> level ( level ) ; \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> result result ; \n \t1 try { \n \t2 result = continue <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> id <identifiersep> exception e ) { \n <ect>
\t3 event <identifiersep> <identifier> event <identifiersep> <identifier> ) { \n \t2 get <identifiersep> <identifier> <identifiersep> data <identifiersep> request <identifier> <identifiersep> data <identifiersep> request = new get <identifiersep> <identifier> <identifiersep> data <identifiersep> request ( <identifier> <identifiersep> <identifier> . get <identifiersep> access <identifiersep> token ( ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> data <identifiersep> request ) ; \n \t2 get <identifiersep> <identifier> <identifiersep> data <identifiersep> response <identifier> <identifiersep> data <identifiersep> response = <identifier> <identifiersep> data <identifiersep> request . execute ( ) ; \n <ect>
\t5 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n \t4 else if ( t instanceof thread <identifiersep> <identifier> ) \n \t5 throw ( thread <identifiersep> <identifier> ) t ; \n \t4 else \n <ect>
\t1 logger . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> queue . size ( ) , \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> queue . size ( ) ) ; \n \t1 for ( test <identifiersep> <identifier> test <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> queue ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> context . <identifier> <identifiersep> m <identifiersep> bean ( key ) ; \n \t3 } catch ( throwable e ) { \n \t4 log . warn ( <string_literal> , key ) ; \n <ect>
<comment> \n \t1 private void send <identifiersep> <identifier> <identifiersep> command ( string item <identifiersep> name , string command , data <identifiersep> output <identifiersep> stream out <identifiersep> to <identifiersep> server , <identifier> <identifiersep> <identifier> i ) \n \t3 throws io <identifiersep> exception { \n \t2 char [ ] <identifier> = new char [ <number_literal> ] ; <comment> \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( \n \t4 <string_literal> ) ; } \n \t2 for ( map . entry < string , string > <identifier> : <identifier> . entry <identifiersep> set ( ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> data . event <identifiersep> message . new <identifiersep> builder ( ) \n \t6 . set <identifiersep> event ( event <identifiersep> <identifier> . <identifier> ( event ) ) \n \t6 . set <identifiersep> target <identifiersep> id ( <identifier> <identifiersep> <identifier> . get <identifiersep> network <identifiersep> id ( ) ) . build ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t2 configuration = <identifier> . of ( parse ( configuration <identifiersep> text ) ) \n \t1 } catch ( exception e ) { \n \t2 <identifier> . <identifier> ( ) . error ( e , e ) \n <ect>
\t2 <identifier> + <string_literal> + <identifier> <identifiersep> lock <identifiersep> id ; \n \t1 log . debug ( <string_literal> + s + <string_literal> ) ; \n \t1 int <identifier> = <identifier> . execute <identifiersep> update ( s ) ; \n \t1 if ( <identifier> < 1 ) { \n <ect>
\t4 logger . info ( <string_literal> \n \t6 + factory . get <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> node . get <identifiersep> id ( ) ) \n \t6 + <string_literal> + node . get <identifiersep> value ( ) . as <identifiersep> string ( ) \n \t6 + <string_literal> ) ; \n <ect>
\t2 response response = client . target ( <identifier> <identifiersep> url ( <string_literal> , url <identifiersep> <identifier> + <identifier> ) ) . request ( ) \n \t4 . <identifier> ( entity . entity ( <identifier> <identifiersep> attribute <identifiersep> <identifier> , <string_literal> ) ) ; \n \t2 logger . info ( <string_literal> + response . get <identifiersep> status ( ) ) ; \n \t2 string entity = response . read <identifiersep> entity ( string . class ) ; \n <ect>
\t1 void stop <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> service != null ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> service . shutdown <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> service = null ; \n <ect>
\t3 } catch ( io <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> , e ) ; \n \t4 throw new runtime <identifiersep> exception ( <string_literal> , e ) ; \n \t3 } catch ( <identifier> <identifiersep> target <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t2 result <identifiersep> set . close <identifiersep> connection ( ) ; \n \t2 result <identifiersep> set = <identifier> <identifiersep> result <identifiersep> set ; } \n \t1 return result <identifiersep> set != null ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 return <identifier> ; } \n \t1 @ <identifier> \n \t1 public synchronized void <identifier> ( ) \n \t1 { \n <ect>
\t7 <identifier> = remove <identifiersep> key <identifiersep> for <identifiersep> value ( <identifier> <identifiersep> <identifier> <identifiersep> return , <identifier> <identifiersep> <identifier> ) ; \n \t7 if ( <identifier> != null ) { \n \t8 long request <identifiersep> id <identifiersep> value = <identifier> <identifiersep> request <identifiersep> id . remove ( <identifier> <identifiersep> <identifier> ) ; \n \t8 if ( request <identifiersep> id <identifiersep> value != <identifier> . get <identifiersep> request <identifiersep> id ( ) ) { \n <ect>
<comment> \n \t1 @ test \n \t1 public void <identifier> <identifiersep> load <identifiersep> stream ( ) throws exception { \n <ect>
\t3 log . info ( <string_literal> , port , thread <identifiersep> name ) ; } } \n \t2 log . error ( <string_literal> , e ) ; \n \t2 throw new <identifier> <identifiersep> host <identifiersep> exception ( <string_literal> ) ; \n \t1 } else { \n <ect>
\t1 <comment> \n \t1 void <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> base <identifiersep> path , string build <identifiersep> path , array <identifiersep> list < string > <identifier> <identifiersep> <identifier> , file system <identifiersep> <identifier> ) \n \t3 throws <identifier> <identifiersep> exception \n \t3 { \n <ect>
\t3 <identifier> <identifiersep> host <identifiersep> info ( cmd ) ; \n \t3 cmd . set <identifiersep> <identifier> ( <string_literal> ) ; \n \t3 return new <identifier> <identifiersep> command [ ] { cmd } ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 s . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> api <identifiersep> failed <identifiersep> exception e ) { \n \t4 if ( e . get <identifiersep> <identifier> ( ) == <number_literal> ) { \n \t5 <comment> \n <ect>
\t3 try { \n \t3 if ( <identifier> != null ) \n \t4 <identifier> . stop ( ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t2 for ( <identifier> e = <identifier> <identifiersep> <identifier> <identifiersep> group . <identifier> <identifiersep> <identifier> ( ) . object <identifiersep> <identifier> ( ) ; \n \t3 e . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> object index <identifiersep> object = ( <identifier> <identifiersep> <identifier> <identifiersep> object ) e . next <identifiersep> element ( ) ; \n <ect>
\t1 this . <identifier> = <identifier> ; } \n @ <identifier> \n protected final void channel <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context <identifier> , <identifier> . <identifier> <identifiersep> message msg ) \n \t1 throws exception { \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t2 logger . info ( <string_literal> ) ; } \n \t1 system <identifiersep> properties = get <identifiersep> system <identifiersep> properties ( ) ; \n \t1 if ( system <identifiersep> properties == null || system <identifiersep> properties . length == 0 ) { \n <ect>
\t2 log . debug ( <string_literal> + <identifier> + <string_literal> + <identifier> + <string_literal> + path + \n \t3 <string_literal> + volume <identifiersep> id ) ; } \n \t1 <comment> \n \t1 if ( ! <identifier> <identifiersep> service . target <identifiersep> <identifier> ( volume <identifiersep> id , <identifier> , path , timeout , user , false <comment> ) ) { \n <ect>
\t4 } catch ( exception e ) { \n \t5 log . error ( <string_literal> , e ) ; \n \t5 throw create <identifiersep> <identifier> <identifiersep> exception ( e ) ; \n \t4 } catch ( error e ) { \n <ect>
\t4 if ( lock == null ) { \n \t5 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t5 return ; } \n \t4 if ( ! lock . lock ( <number_literal> ) ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <identifier> <identifiersep> <identifier> . on <identifiersep> <identifier> { \n \t1 case success ( <identifier> <identifiersep> status ) = > \n <ect>
\t3 <identifier> <identifiersep> device . get <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> ( ) . add <identifiersep> all ( <identifier> . as <identifiersep> list ( load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . values ( ) ) ) ; \n \t3 <identifier> <identifiersep> config ( <identifier> <identifiersep> device , device <identifiersep> config ) ; \n \t2 } else if ( device <identifiersep> type . equals ( type <identifiersep> key . <identifier> <identifiersep> <identifier> . name ( ) ) ) { \n \t3 logger . debug ( <string_literal> , logger <identifiersep> <identifier> . config , device <identifiersep> type ) ; \n <ect>
\t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n \t2 continue ; } \n \t2 if ( <identifier> <identifiersep> <identifier> . length == 0 ) { \n \t2 path p = new path ( dir + <string_literal> + table <identifiersep> id ) ; \n <ect>
\t4 return <number_literal> ; \n \t3 } else { \n \t4 s <identifiersep> logger . info ( <string_literal> + response <identifiersep> code ) ; } \n \t2 } else { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t1 else { \n \t2 log . info ( <string_literal> + \n \t3 <string_literal> ) ; } \n \t1 } catch ( meta <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> array <identifier> = ( <identifier> <identifiersep> array ) <identifier> <identifiersep> model <identifiersep> group . default <identifiersep> group ( ) . <identifier> ( ) . value <identifiersep> for <identifiersep> key <identifiersep> path ( <string_literal> ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> key <identifiersep> value <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> equal , class <identifiersep> name ) ; \n \t5 <identifier> <identifiersep> array <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> array <identifiersep> with <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t5 if ( <identifier> . count ( ) > 1 ) { \n <ect>
\t2 if ( ! file . exists ( ) ) write ( ) ; \n \t2 try ( file <identifiersep> input <identifiersep> stream in = new file <identifiersep> input <identifiersep> stream ( file ) ) { \n \t3 read ( in ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t1 public abstract void handle <identifiersep> <identifier> <identifiersep> object ( security <identifiersep> context security <identifiersep> context , t <identifier> ) throws <identifier> <identifiersep> exception ; \n \t1 public void handle <identifiersep> throwable ( final security <identifiersep> context security <identifiersep> context , final throwable t , final t current <identifiersep> object ) { \n \t2 logger . warn ( <string_literal> , t ) ; } \n \t1 public void handle <identifiersep> transaction <identifiersep> failure ( final security <identifiersep> context security <identifiersep> context , final throwable t ) { \n <ect>
\t3 throw new <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> <identifier> ) { \n \t2 <comment> \n <ect>
\t4 logger . debug ( <string_literal> , result ) ; \n \t4 if ( result != null && ! <identifier> . is <identifiersep> <identifier> <identifiersep> from ( result . get <identifiersep> class ( ) ) ) { \n \t5 throw new class <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + result + <string_literal> + result . get <identifiersep> class ( ) + <string_literal> + <identifier> ) ; } \n \t4 return ( t ) result ; } \n <ect>
\t3 final list < string > header <identifiersep> <identifier> = <identifier> . list ( request . get <identifiersep> header <identifiersep> <identifier> ( ) ) ; \n \t3 final boolean <identifier> = this . http <identifiersep> request <identifiersep> header <identifiersep> <identifier> . stream ( ) \n \t5 . <identifier> <identifiersep> <identifier> ( <identifier> - > header <identifiersep> <identifier> . stream ( ) . <identifier> <identifiersep> <identifier> ( name - > <identifier> . <identifier> ( name ) . <identifier> ( ) ) ) ; \n \t3 if ( <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> check <identifiersep> <identifier> <identifiersep> output = { <string_literal> : 0 , <string_literal> : <identifier> ( <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> , \n <number_literal> file <identifiersep> content ) . <identifier> ( ) [ 0 ] ) } \n \t1 else : \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> check <identifiersep> <identifier> <identifiersep> output = { <string_literal> : 0 , <string_literal> : <string_literal> } \n <ect>
\t1 public void test <identifiersep> location <identifiersep> info <identifiersep> test ( ) throws io <identifiersep> exception , user <identifiersep> exception { \n \t2 <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 final logger test <identifiersep> logger = <identifier> <identifiersep> logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) ; \n \t2 test <identifiersep> logger . error ( <string_literal> ) ; \n <ect>
\t1 for ( entry < key , value > entry : s ) { \n \t2 text file = new text ( ) ; \n \t2 metadata <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . get <identifiersep> file ( entry . get <identifiersep> key ( ) , file ) ; \n \t2 status status = status . parse <identifiersep> from ( entry . get <identifiersep> value ( ) . get ( ) ) ; \n <ect>
\t2 string method <identifiersep> name = get <identifiersep> get <identifiersep> method <identifiersep> name ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t2 try { \n \t3 method = o . get <identifiersep> class ( ) . get <identifiersep> method ( method <identifiersep> name ) ; \n \t2 } catch ( security <identifiersep> exception <identifier> ) { \n <ect>
<number_literal> <identifier> ) . <identifier> ( \n \t2 ' \\ <identifier> , <identifier> ) \n \t1 return result \n \t1 <identifier> : \n <ect>
\t4 return false ; } \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> . size ( ) >= <number_literal> * <identifier> <identifiersep> max <identifiersep> <identifier> <identifiersep> size ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ; \n \t1 try { \n \t1 <identifier> = <identifier> . new <identifiersep> instance ( ) ; \n \t1 } catch ( <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception <identifier> ) { \n <ect>
\t4 if ( result != null && ! result . is <identifiersep> empty ( ) ) { \n \t5 return result . get ( 0 ) ; \n \t4 } else { \n <ect>
\t5 return ; } \n \t4 final byte [ ] data = task . get <identifiersep> data ( ) ; \n \t4 final version <identifier> = request . get <identifiersep> version ( data ) ; \n \t4 if ( <identifier> . <identifier> ( ) != version . <identifier> . <identifier> ( ) && <identifier> . <identifier> ( ) != version . <identifier> . <identifier> ( ) ) { \n <ect>
\t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( service <identifiersep> configuration input ) { \n \t2 if ( state . enabled . <identifier> ( input ) && <identifier> . is <identifiersep> service <identifiersep> local ( input ) ) { \n \t2 try { \n <ect>
\t5 current <identifiersep> unit = <identifier> . get <identifiersep> <identifier> <identifiersep> of ( store <identifiersep> <identifier> ) ; \n \t5 while ( current <identifiersep> unit != null ) { \n \t6 <identifier> -= ( ( <identifier> ) current <identifiersep> unit ) . get <identifiersep> out <identifiersep> count ( ) ; \n \t6 if ( <identifier> < 0 ) { <comment> \n <ect>
\t2 } catch ( exception e ) { \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ( e ) ; } } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) throws <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception { \n <ect>
\t3 logger . debug ( <string_literal> , registered <identifiersep> service ) ; \n \t3 return null ; } \n \t2 final public <identifiersep> key public <identifiersep> key = registered <identifiersep> service . get <identifiersep> public <identifiersep> key ( ) . create <identifiersep> instance ( ) ; \n \t2 if ( public <identifiersep> key == null ) { \n <ect>
\t2 <comment> \n \t2 if ( endpoint != null ) \n \t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( endpoint ) ; \n \t2 else \n <ect>
\t3 if ( url . get <identifiersep> <identifier> ( <identifier> . check <identifiersep> key , true ) ) { \n \t4 close ( ) ; \n \t4 throw t ; \n \t3 } else { \n <ect>
\t1 public void <identifier> <identifiersep> node <identifiersep> <identifier> ( final list < <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo > node <identifiersep> list ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t3 for ( final <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo <identifier> : node <identifiersep> list ) { \n <ect>
\t3 element <identifier> <identifiersep> <identifier> = ( element ) <identifier> <identifiersep> node ; \n \t3 <comment> \n \t3 api <identifiersep> command api = new api <identifiersep> command ( <identifier> <identifiersep> <identifier> , this . get <identifiersep> <identifier> ( ) , this . get <identifiersep> <identifier> ( ) ) ; \n \t3 if ( api . get <identifiersep> name ( ) . equals ( <string_literal> ) ) { \n <ect>
\t1 public void set <identifiersep> item <identifiersep> <identifier> ( item <identifiersep> <identifier> item <identifiersep> <identifier> ) { \n \t2 logger . debug ( <string_literal> ) ; \n \t2 this . item <identifiersep> <identifier> = item <identifiersep> <identifier> ; } \n \t1 public void <identifier> <identifiersep> item <identifiersep> <identifier> ( item <identifiersep> <identifier> item <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , false ) ; \n \t2 assert <identifiersep> equals ( <number_literal> , channel <identifiersep> factory . get <identifiersep> <identifier> ( ) . size ( ) ) ; \n \t1 } finally { \n \t2 log . info ( <string_literal> + manager ( 0 ) . get <identifiersep> cache ( ) . get <identifiersep> <identifier> <identifiersep> cache ( ) . get <identifiersep> <identifier> <identifiersep> manager ( ) . get <identifiersep> transport ( ) . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t4 result = <identifier> . get <identifiersep> int ( 1 ) ; \n \t3 } else { \n \t4 log . warn ( <string_literal> ) ; } \n \t3 if ( <identifier> . next ( ) ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> , e ) ; \n \t4 set <identifiersep> pool <identifiersep> state <identifiersep> to <identifiersep> error ( <identifier> <identifiersep> storage ) ; \n \t4 throw ( <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ) e ; } \n \t3 if ( e instanceof <identifier> <identifiersep> <identifier> <identifiersep> exception ) { \n <ect>
\t2 final file <identifier> <identifiersep> execution <identifiersep> <identifier> <identifiersep> file = get <identifiersep> execution <identifiersep> <identifier> <identifiersep> file ( job <identifiersep> id ) ; \n \t2 try { \n \t3 file <identifiersep> utils . delete <identifiersep> file <identifiersep> or <identifiersep> directory ( <identifier> <identifiersep> execution <identifiersep> <identifier> <identifiersep> file ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
* \n * from ( <string_literal> ) . to ( <identifier> <identifiersep> event <identifiersep> endpoint ) ; \n * \n * void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( { @ <identifier> @ } <identifier> { @ <identifier> @ } <identifier> <identifiersep> <identifier> list { @ <identifier> < } string { @ <identifier> > } event ) { \n <ect>
\t4 <comment> \n \t4 m = class . for <identifiersep> name ( <string_literal> , true , thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) ) . get <identifiersep> method ( <string_literal> ) ; \n \t3 } catch ( exception <identifier> ) { \n \t4 <comment> \n <ect>
\t1 <identifier> <identifiersep> service to <identifiersep> shutdown = service ; \n \t1 service = null ; \n \t1 to <identifiersep> shutdown . shutdown <identifiersep> <identifier> ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifier> = e . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t4 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ; \n \t4 <identifier> <identifiersep> node < <identifier> , <identifier> > target <identifiersep> node = e . get <identifiersep> <identifier> ( ) ; \n \t4 if ( <identifier> != null && <identifier> . <identifier> <identifiersep> type ( ) . get <identifiersep> <identifier> ( <identifier> . class ) != null ) { \n <ect>
\t5 <identifier> <identifiersep> log . debug ( <string_literal> + <identifier> + <string_literal> + <identifier> ) ; \n \t5 <identifier> ++ ; } \n \t4 if ( ( <identifier> <identifier> <number_literal> ) == 0 ) { \n \t5 long time = system . current <identifiersep> time <identifiersep> millis ( ) - start ; \n <ect>
\t2 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> path + <string_literal> + <identifier> <identifiersep> base <identifiersep> name ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) == 1 ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> info <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> info = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> info ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( 0 ) . first ( ) . get <identifiersep> <identifier> ( ) ; \n <ect>
\t1 private string <identifier> ; \n \t1 @ <identifier> \n \t1 public void <identifier> ( message message , data <identifiersep> type type ) throws <identifier> <identifiersep> exception { \n \t2 object body = message . get <identifiersep> body ( ) ; \n <ect>
\t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n \t6 <identifier> <identifiersep> log . info ( <string_literal> + to <identifiersep> <identifier> + ' ' + <identifier> <identifiersep> key + ' ' + <identifier> <identifiersep> message . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t5 message = message <identifiersep> <identifier> . <identifier> ( get <identifiersep> context ( ) , message , <identifier> <identifiersep> key , <identifier> <identifiersep> message . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t5 if ( message == null ) { \n <ect>
\t3 return ; } \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 file <identifiersep> input <identifiersep> stream <identifier> = new file <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> test . get <identifiersep> <identifier> ( ) ) ; \n \t1 <identifier> = <identifier> <identifiersep> test . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t1 <identifier> . close ( ) ; \n \t1 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
public static synchronized void update <identifiersep> <identifier> <identifiersep> version ( volume <identifiersep> manager <identifier> , int <identifier> <identifiersep> version ) { \n \t1 for ( volume volume : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t1 try { \n \t2 if ( get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> version ( volume ) == <identifier> <identifiersep> version ) { \n <ect>
\t1 public void test <identifiersep> <identifier> ( string resource , string <identifier> , string <identifier> ) \n \t3 throws exception { \n \t2 logger . info ( <string_literal> , <identifier> ) ; \n \t2 create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> job ( <identifier> , <number_literal> ) ; \n <ect>
\t3 remove <identifiersep> <identifier> <identifiersep> property <identifiersep> result result = new remove <identifiersep> <identifier> <identifiersep> property <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t2 int <identifier> <identifiersep> of <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> of <identifiersep> <identifier> ( value ) ; \n \t2 int <identifier> <identifiersep> of <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> of <identifiersep> <identifier> ( value ) ; \n \t3 log . debug ( <string_literal> , <identifier> <identifiersep> of <identifiersep> <identifier> ) ; \n <ect>
\t1 public set < string > get <identifiersep> <identifier> <identifiersep> <identifier> ( map < ? , ? > <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 set < string > <identifier> <identifiersep> <identifier> = <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 string <identifier> <identifiersep> url = <identifier> <identifiersep> url <identifiersep> from <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> url == null ) { \n <ect>
\t2 this . status = status ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> result check <identifiersep> <identifier> ( ) { \n \t2 if ( status . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , \n \t5 <identifier> , \n \t5 <identifier> , false , <identifier> , error <identifiersep> <identifier> , <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( true ) ; \n <ect>
\t4 <identifier> <identifiersep> type = <identifier> <identifiersep> type . to <identifiersep> string ( ) ; \n \t4 if ( <identifier> <identifiersep> type != null ) { \n \t5 return <identifier> <identifiersep> type ; } } \n \t2 } catch ( no <identifiersep> class <identifiersep> <identifier> <identifiersep> found <identifiersep> error t ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> = <identifier> . java <identifiersep> <identifier> ; } \n \t2 if ( ! <identifier> <identifiersep> <identifier> . equals ( <identifier> . java <identifiersep> <identifier> ) && \n \t3 ! <identifier> <identifiersep> <identifier> . equals ( <identifier> . <identifier> <identifiersep> <identifier> ) ) \n \t2 { \n <ect>
<comment> \n \t1 public void error ( <identifier> <identifiersep> exception e ) throws <identifier> <identifiersep> exception \n \t1 { \n <ect>
\t4 destination destination = session . create <identifiersep> queue ( destination <identifiersep> name ) ; \n \t4 message <identifiersep> consumer consumer = session . create <identifiersep> consumer ( destination ) ; \t3 \n \t4 text <identifiersep> message msg = ( text <identifiersep> message ) consumer . <identifier> ( <number_literal> ) ; \n \t4 if ( msg != null ) { \n <ect>
\t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } \n \t2 <comment> \n \t2 network <identifiersep> <identifier> <identifiersep> vo <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( network . get <identifiersep> network <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t2 long <identifier> <identifiersep> id = <identifier> <identifiersep> ip <identifiersep> vo . get <identifiersep> <identifier> <identifiersep> id ( ) ; \n <ect>
\t3 if ( <identifier> . size ( ) > 0 ) { \n \t4 logger . debug ( <string_literal> , <identifier> . size ( ) ) ; \n \t4 try { \n \t5 if ( <identifier> . is <identifiersep> shutdown ( ) ) { \n <ect>
\t2 if ( type == null ) { \n \t3 string command = action <identifiersep> config . get <identifiersep> command ( ) ; \n \t3 if ( ( command == null ) && ( action <identifiersep> config . get <identifiersep> <identifier> ( ) == null ) \n \t4 && ( action <identifiersep> config . get <identifiersep> <identifier> ( ) == null ) ) { \n <ect>
\t4 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( \n \t6 <string_literal> \n \t8 + host . get <identifiersep> <identifier> <identifiersep> version ( ) ) ; \n \t3 } else { \n <ect>
\t2 throw new service <identifiersep> exception ( <string_literal> , e ) ; } \n \t1 } else { \n \t1 log . info ( <string_literal> ) ; } } \n private void stop <identifiersep> or <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t1 import <identifier> \n \t1 return <identifier> . <identifier> <identifiersep> user \n \t1 <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> status ( self , <identifier> <identifiersep> <identifier> <identifiersep> info , <identifier> <identifiersep> <identifier> <identifiersep> name , return <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> , <identifier> <identifiersep> time ) : \n \t1 if <identifier> <identifiersep> <identifier> <identifiersep> info is <identifier> or <identifier> not in <identifier> <identifiersep> <identifier> <identifiersep> info : \n <ect>
\t9 log . debug ( <string_literal> + field . get <identifiersep> name ( ) + <string_literal> \n <number_literal> + <identifier> . get <identifiersep> name ( ) , t ) ; } } } } } \n \t4 catch ( exception t ) { \n <ect>
\t3 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( input ) ; \n \t3 if ( <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> ( input ) && <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> list ( output ) ) ) { \n \t4 log . info ( <string_literal> ) ; \n \t4 if ( create <identifiersep> index ) { \n <ect>
\t5 <identifier> = true ; } \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t4 logger . warn ( <string_literal> , <identifier> . get <identifiersep> message ( ) , <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 } catch ( runtime <identifiersep> exception ex ) { \n \t4 if ( <identifier> <identifiersep> listener . <identifier> <identifiersep> listener <identifiersep> exception . class . is <identifiersep> <identifier> <identifiersep> from ( ex . get <identifiersep> class ( ) ) ) { \n \t5 logger . trace ( <string_literal> , ex ) ; \n \t5 return true ; } \n <ect>
\t3 int <identifier> = integer . parse <identifiersep> int ( <identifier> ) ; \n \t3 return new <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n \t3 if ( debug ) { \n <ect>
\t4 log . error ( <string_literal> , e ) ; \n \t3 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> , e ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t5 handle <identifiersep> <identifier> ( client <identifiersep> <identifier> ) ; } \n \t4 catch ( exception ex ) { \n \t5 if ( ex instanceof socket <identifiersep> exception && <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) || thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ) \n \t6 break ; \n <ect>
\t2 . filter ( <identifier> <identifiersep> info : : is <identifiersep> <identifier> ) \n \t2 . map ( <identifier> <identifiersep> info : : get <identifiersep> <identifier> ) \n \t2 . for <identifiersep> <identifier> ( load <identifiersep> <identifier> <identifiersep> <identifier> : : <identifier> <identifiersep> <identifier> <identifiersep> node <identifiersep> by <identifiersep> name ) ; } \n \t1 protected <identifier> create <identifiersep> <identifier> <identifiersep> client <identifiersep> for ( <identifier> <identifiersep> info node ) { \n <ect>
\t2 public void stop <identifiersep> test ( boolean <identifier> ) { \n \t3 log . debug ( <string_literal> , host ) ; } \n \t2 @ <identifier> \n \t2 public void <identifier> ( ) { \n <ect>
\t2 assert <identifiersep> equals ( response <identifiersep> code , <number_literal> ) ; \n \t2 conn . <identifier> ( ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> key ( ) { \n <ect>
\t4 <identifier> . execute <identifiersep> update ( ) ; \n \t4 while ( <identifier> . next ( ) ) { \n \t5 long network <identifiersep> id = <identifier> . get <identifiersep> long ( 1 ) ; \n \t5 long network <identifiersep> <identifier> <identifiersep> id = <identifier> . get <identifiersep> long ( <number_literal> ) ; \n <ect>
\t3 base . <identifier> <identifiersep> transaction ( ) ; \n \t3 throw e ; } \n \t2 finally { \n \t3 base . close ( ) ; } \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> test . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> ( <string_literal> ) ; \n \t2 } catch ( exception <identifier> ) { \n <ect>
\t3 } catch ( io <identifiersep> exception e ) { \n \t4 logger . error ( e . get <identifiersep> message ( ) , e ) ; } \n \t3 try { \n \t4 thread . <identifier> ( <number_literal> ) ; \n <ect>
\t3 } else if ( message instanceof create <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> result <identifier> = <identifier> . <identifier> ( <identifier> , <identifier> , <identifier> , <identifier> ) ; \n \t4 get <identifiersep> <identifier> ( ) . <identifier> ( <identifier> , get <identifiersep> self ( ) ) ; \n \t3 } else { \n <ect>
\t5 if ( <identifier> . is <identifiersep> <identifier> ( <number_literal> ) ) { \n \t6 logger . debug ( <string_literal> ) ; \n \t6 connection . <identifier> ( ) ; } \n \t4 } catch ( <identifier> <identifiersep> host <identifiersep> exception e ) { \n <ect>
\t2 boolean <identifier> = <identifier> . <identifier> ( new <identifier> <identifiersep> <identifier> ( test <identifiersep> <identifier> . to <identifiersep> array ( ) ) ) ; \n \t2 cache . put ( test <identifiersep> <identifier> , <identifier> ) ; \n \t2 return <identifier> ; \n \t1 } catch ( <identifier> <identifiersep> parse <identifiersep> exception | <identifier> <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t4 . set <identifiersep> user ( user ) \n \t4 . set <identifiersep> password ( password ) \n \t4 . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> default ( ) ) \n \t4 . set <identifiersep> time <identifiersep> <identifier> ( time <identifiersep> <identifier> . get <identifiersep> default ( ) ) ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> dao . update ( <identifier> . get <identifiersep> id ( ) , <identifier> ) ; \n \t5 <identifier> . <identifier> ( ) ; \n \t4 } catch ( exception e ) { \n \t5 <identifier> . <identifier> ( ) ; \n <ect>
\t3 final http <identifiersep> entity < principal > entity = new http <identifiersep> entity < > ( authentication . get <identifiersep> principal ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t3 logger . warn ( <string_literal> , authentication . get <identifiersep> principal ( ) , this . endpoint ) ; \n \t3 final response <identifiersep> entity < string > <identifier> = <identifier> <identifiersep> template . exchange ( this . endpoint , http <identifiersep> method . <identifier> , entity , string . class ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t3 <identifier> . set <identifiersep> string ( <number_literal> , name ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 return true ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 event <identifiersep> list . add ( event ) ; \n \t2 log . info ( <string_literal> + event ) ; } \n \t1 public void <identifier> ( @ <identifier> @ <identifier> <identifiersep> read ( context = <string_literal> ) @ <identifier> <identifiersep> write ( context = <string_literal> ) <identifier> <identifiersep> <identifier> event ) { \n \t2 event <identifiersep> list . add ( event ) ; \n <ect>
\t2 } finally { \n \t3 try { \n \t4 is . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> data . get <identifiersep> user <identifiersep> <identifier> ( ) , <identifier> <identifiersep> data . get <identifiersep> <identifier> ( ) , \n \t3 <identifier> <identifiersep> data . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> data . get <identifiersep> type ( ) , \n \t3 user . get <identifiersep> <identifier> <identifiersep> name ( ) , user . get <identifiersep> <identifier> <identifiersep> address ( ) , content ) ; \n \t2 if ( <identifier> . is <identifiersep> null ( response ) || response . equals ( <string_literal> ) ) { \n <ect>
\t3 return ; } \n \t2 else if ( <identifier> <identifiersep> <identifier> == null ) \n \t2 { \n <ect>
\t4 ( ( test <identifiersep> <identifier> ) current <identifiersep> target <identifiersep> <identifier> ) \n \t6 . add <identifiersep> property <identifiersep> <identifier> <identifiersep> listener ( test <identifiersep> <identifier> . name <identifiersep> property , <identifier> <identifiersep> name <identifiersep> <identifier> <identifiersep> listener ) ; } \n \t3 current <identifiersep> target <identifiersep> <identifier> . add <identifiersep> test <identifiersep> property <identifiersep> listener ( property <identifiersep> name <identifiersep> <identifier> <identifiersep> listener ) ; \n \t2 } else { \n <ect>
\t4 if ( s == null ) { \n \t5 s = session <identifiersep> factory . <identifier> <identifiersep> session ( ) ; \n \t5 thread <identifiersep> session . set ( s ) ; } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \t2 else \n \t3 system . out . <identifier> ( <string_literal> ) ; \n <ect>
\t1 public static http <identifiersep> session new <identifiersep> session ( final http <identifiersep> <identifier> <identifiersep> request request ) { \n \t2 http <identifiersep> session session = request . get <identifiersep> session ( true ) ; \n \t2 if ( session == null ) { \n \t3 if ( request instanceof <identifier> <identifiersep> http <identifiersep> <identifier> <identifiersep> request ) { \n <ect>
\t2 synchronized void log ( string id ) \n \t2 { \n \t3 logger . error ( <string_literal> , id , <identifier> ( <identifier> <identifiersep> thread , <identifier> <identifiersep> trace ) ) ; \n \t3 if ( <identifier> <identifiersep> thread != null ) \n <ect>
\t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t2 string property <identifiersep> name = <string_literal> ; \n \t2 string property <identifiersep> value = <string_literal> ; \n \t2 <identifier> . put ( property <identifiersep> name , property <identifiersep> value ) ; \n \t2 log . debug ( <string_literal> ) ; \n <ect>
\t2 network network = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( network <identifiersep> id ) ; \n \t2 if ( network != null ) { \n \t3 <identifier> <identifiersep> account <identifiersep> <identifier> . check <identifiersep> access ( <identifier> , access <identifiersep> type . <identifier> <identifiersep> entry , false , network ) ; \n \t2 } else { \n <ect>
\t4 return null ; } } \n \t2 <comment> \n \t2 if ( ! x . is <identifiersep> <identifier> ( ) ) { \n \t3 if ( execution <identifiersep> time ) \n <ect>
\t7 resource <identifiersep> <identifier> . add ( static <identifiersep> resource <identifiersep> handler ) ; \n \t6 } else { \n \t7 logger . warn ( <string_literal> , resource <identifiersep> handler <identifiersep> name , resource <identifiersep> handler <identifiersep> name ) ; } \n \t5 } else { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t6 answer . put ( <identifier> , properties ) ; } \n \t4 } else { \n \t5 string [ ] <identifier> = line . <identifier> ( <string_literal> , <number_literal> ) ; \n \t5 if ( <identifier> == null && <identifier> . length != <number_literal> ) { \n <ect>
\t6 + <string_literal> + name + <string_literal> ) ; \n \t4 current <identifiersep> source <identifiersep> property = null ; \n \t4 set <identifiersep> source <identifiersep> property <identifiersep> name ( null ) ; } \n \t3 if ( name . equals ( target <identifiersep> type ) ) { \n <ect>
\t3 <comment> \n \t3 if ( <identifier> <identifiersep> level . error == run <identifiersep> <identifier> <identifiersep> level ) { \n \t4 log . error ( <string_literal> , this . get <identifiersep> endpoint ( ) ) ; \n \t3 } else if ( <identifier> <identifiersep> level . warn == run <identifiersep> <identifier> <identifiersep> level ) { \n <ect>
\t4 if ( <identifier> <identifiersep> input != null ) { \n \t5 int c = <identifier> <identifiersep> input . read ( ) ; \n \t5 switch ( c ) { \n \t6 case <identifier> <identifiersep> <identifier> : \n <ect>
\t5 log . error ( <string_literal> + <identifier> [ i ] + <string_literal> + <identifier> + <string_literal> ) ; \n \t5 break ; } \n \t4 add <identifiersep> socket <identifiersep> to <identifiersep> pool ( <identifier> <identifiersep> pool , <identifier> [ i ] , socket ) ; \n <ect>
\t3 <identifier> . execute ( new <identifier> ( num <identifiersep> <identifier> / num <identifiersep> <identifier> ) ) ; } \n \t2 assert <identifiersep> true ( <string_literal> , wait . wait <identifiersep> for ( new wait . <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 result . success = o ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t5 <comment> \n \t5 <comment> \n \t5 <comment> \n \t5 if ( <identifier> == null && <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 assert <identifiersep> that ( client ( ) . <identifier> <identifiersep> get ( <string_literal> , <string_literal> , <string_literal> ) . execute ( ) . action <identifiersep> get ( ) . is <identifiersep> exists ( ) , equal <identifiersep> to ( true ) ) ; } \n \t2 logger . info ( <string_literal> ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 assert <identifiersep> that ( client ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> query ( query <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> query ( ) ) . execute ( ) . action <identifiersep> get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; } \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> name ) ) { \n \t2 try { \n \t2 <identifier> = <identifier> . new <identifiersep> instance ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 message <identifiersep> listener handler = create <identifiersep> message <identifiersep> handler ( session ) ; \n \t3 message <identifiersep> consumer . set <identifiersep> message <identifiersep> listener ( handler ) ; \n \t3 answer = new message <identifiersep> consumer <identifiersep> <identifier> ( session , message <identifiersep> consumer ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 sql = <identifier> . <identifier> <identifiersep> <identifier> . <identifier> . get <identifiersep> connection ( <string_literal> ) ; \n \t1 sql . execute ( <string_literal> ) ; \n \t1 return true ; \n \t1 } catch ( exception ex ) { \n <ect>
\t1 for ( <identifier> <identifiersep> location <identifier> <identifiersep> location : <identifier> <identifiersep> location . values ( ) ) { \n \t2 int x = ( int ) ( <identifier> <identifiersep> location . x ( ) * <identifier> ) + x <identifiersep> <identifier> ; \n \t2 int <identifier> = ( int ) ( <identifier> <identifiersep> location . <identifier> ( ) * <identifier> ) ; \n \t2 <identifier> <identifier> = new <identifier> ( x , <identifier> ) ; \n <ect>
\t3 <identifier> <identifiersep> event <identifiersep> <identifier> . <identifier> <identifiersep> remove ( property ) ; \n \t3 <identifier> <identifiersep> log . debug ( <string_literal> , path ) ; } \n \t2 break ; \n \t2 default : \n <ect>
\t3 if ( status != status . <identifier> ) { \n \t4 status = status . <identifier> ; } \n \t3 if ( response != null ) { \n \t4 if ( response . get <identifiersep> time <identifiersep> <identifier> ( ) == 0 ) { \n <ect>
\t2 text += new string ( <identifier> , 0 , read ) ; } \n \t1 if ( ! text . is <identifiersep> empty ( ) && ! text . <identifier> <identifiersep> with ( <string_literal> ) ) \n \t2 return ; \n \t1 thread . <identifier> ( <number_literal> ) ; } \n <ect>
\t6 return boolean . true ; } \n \t4 } ; \n \t4 <identifier> . execute ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 public map <identifier> <identifiersep> cache <identifiersep> <identifier> ( string [ ] <identifier> , int <identifier> <identifiersep> number , int <identifier> ) { \n \t2 return <identifier> ( <identifier> , string . format ( <string_literal> , <identifier> <identifiersep> number , <identifier> ) , item ) ; } \n \t1 private map <identifier> ( string [ ] <identifier> , string command , string line <identifiersep> start ) { \n \t2 if ( command == null || command . <identifier> ( ) . equals ( <string_literal> ) ) { \n <ect>
\t3 if ( <identifier> <identifiersep> from <identifiersep> snapshot . size ( ) > 0 ) { \n \t4 try { \n \t5 snapshot <identifiersep> <identifier> . process <identifiersep> event ( snapshot . event . operation <identifiersep> failed ) ; \n \t4 } catch ( no <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t5 logger . error ( <string_literal> , ex ) ; \n \t5 <identifier> . <identifier> <identifiersep> application <identifiersep> exception ( ex ) ; \n \t5 throw <identifier> ; } \n \t4 catch ( runtime <identifiersep> exception | error <identifier> ) { \n <ect>
\t4 <comment> \n <comment> \n \t4 <identifier> . close ( ) ; } \n \t3 catch ( sql <identifiersep> exception e ) { \n <ect>
\t4 system . set <identifiersep> property ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> conf , url <identifiersep> path ) ; \n \t3 } else { \n \t4 final url url = get <identifiersep> class ( ) . get <identifiersep> resource ( <string_literal> ) ; \n \t4 if ( url != null ) { \n <ect>
\t6 log . debug ( <string_literal> ) ; } \n \t5 thread . <identifier> ( <number_literal> ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 return <identifier> <identifiersep> <identifier> <identifiersep> out ( time ) ; } \n \t1 public message get <identifiersep> message ( ) { \n \t2 return <identifier> <identifiersep> message ; } \n \t1 public synchronized void set <identifiersep> message ( message message ) { \n <ect>
\t1 try { \n \t1 <identifier> . <identifier> <identifiersep> command ( <string_literal> , <identifier> , file . to <identifiersep> string ( ) ) ; \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n \t1 <comment> \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) continue ; \n \t3 logger . info ( <string_literal> + n . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 set < <identifier> <identifiersep> type <identifiersep> <identifier> > <identifier> <identifiersep> type <identifiersep> <identifier> = new <identifier> <identifiersep> set < > ( ) ; \n \t3 for ( <identifier> <identifiersep> type <identifier> <identifiersep> type : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 return build <identifiersep> <identifier> <identifiersep> response <identifiersep> entity ( o <identifiersep> <identifier> . <identifier> <identifiersep> access <identifiersep> token ) ; } \n \t2 if ( <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) . is <identifiersep> remove <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 final ticket <identifiersep> <identifier> <identifiersep> ticket ticket <identifiersep> <identifier> <identifiersep> ticket = access <identifiersep> token <identifiersep> ticket . get <identifiersep> ticket <identifiersep> <identifier> <identifiersep> ticket ( ) ; \n \t3 if ( ticket <identifiersep> <identifier> <identifiersep> ticket == null || ticket <identifiersep> <identifier> <identifiersep> ticket . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t4 <identifier> = <identifier> = 0 ; \n \t4 if ( <identifier> <identifiersep> <identifier> ) { \n \t5 ( ( <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ) <identifier> <identifiersep> <identifier> ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n <ect>
\t2 public <identifier> <identifiersep> session <identifiersep> key <identifiersep> builder get <identifiersep> builder ( ) { \n \t3 <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . add <identifiersep> <identifier> <identifiersep> data ( <string_literal> , 1 ) ; \n \t3 <identifier> <identifiersep> session <identifiersep> key <identifiersep> builder builder = <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 if ( builder == null ) { \n <ect>
\t1 return <identifier> ; } \n @ <identifier> \n public void on <identifiersep> <identifier> <identifiersep> stream <identifiersep> read ( channel <identifiersep> handler <identifiersep> context <identifier> , int stream <identifiersep> id , long error <identifiersep> code ) throws <identifier> \n { \n <ect>
\t9 if ( <identifier> == null ) { \n \t10 if ( <identifier> ) { \n <number_literal> s <identifiersep> logger . info ( <string_literal> ) ; \n \t10 } else { \n <ect>
<comment> \n \t1 public void parse ( string path ) throws config <identifiersep> exception { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> <identifier> = null ; \n \t3 string <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> default ( <string_literal> , <string_literal> ) ; <comment> \n \t3 if ( <identifier> <identifiersep> name . length ( ) > 0 ) { \n <ect>
\t5 <identifier> . <identifier> ( start ) ; \n \t5 <identifier> . <identifier> ( <identifier> ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 if ( ! stop ) { \n <ect>
\t8 new thread <identifiersep> factory <identifiersep> builder ( ) . set <identifiersep> name <identifiersep> format ( <string_literal> ) . set <identifiersep> <identifier> ( true ) . build ( ) ) ; \n \t1 public static void shutdown <identifiersep> <identifier> <identifiersep> pool ( ) { \n \t2 log . info ( <string_literal> , shutdown <identifiersep> wait ) ; \n \t2 boolean shutdown <identifiersep> <identifier> = shutdown <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( query <identifiersep> <identifier> <identifiersep> pool , ( long ) shutdown <identifiersep> wait , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t3 return ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class <identifiersep> <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class > <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class <identifiersep> <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class > ) get <identifiersep> <identifier> ( \n \t4 command <identifiersep> class . get <identifiersep> command <identifiersep> class ( ) ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 log . debug ( <string_literal> + <identifier> [ i ] . get <identifiersep> path ( ) . get <identifiersep> name ( ) ) ; } } \n \t1 assert . assert <identifiersep> true ( <identifier> <identifiersep> new <identifiersep> base ) ; } \n @ test \n public void <identifier> <identifiersep> table <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 log . info ( <string_literal> , <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> builder = <identifier> <identifiersep> <identifier> <identifiersep> builder . with <identifiersep> <identifier> ( <identifier> ) ; } \n \t1 <identifier> <identifier> = ( <identifier> ) parse <identifiersep> options . get <identifiersep> <identifier> ( parse <identifiersep> options . options <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 if ( null != <identifier> ) { \n <ect>
\t4 log . error ( <string_literal> , e ) ; } \n \t3 try { \n \t4 if ( connection != null ) connection . close ( ) ; \n \t3 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t1 if ( template <identifiersep> options . should <identifiersep> <identifier> <identifiersep> static <identifiersep> <identifier> ( ) ) { \n \t2 <identifier> <identifier> = client . get <identifiersep> configuration <identifiersep> client ( ) . list <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n \t2 for ( string network <identifiersep> id : options . get <identifiersep> network <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 log . info ( <string_literal> + next <identifiersep> update + <string_literal> + session + <string_literal> ) ; \n \t2 update <identifiersep> session <identifiersep> <identifier> ( session , next <identifiersep> update ) ; } } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> error ( throwable t ) { \n <ect>
\t2 try { \n \t3 <identifier> . set <identifiersep> <identifier> ( <identifier> . <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> dao . update ( <identifier> . get <identifiersep> id ( ) , <identifier> ) ; \n \t3 if ( ! <identifier> <identifiersep> it <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> type ( ) , vm <identifiersep> id , <identifier> <identifiersep> host <identifiersep> id ) ) { \n <ect>
\t2 <identifier> <identifiersep> cluster ( ) . start <identifiersep> node ( <identifier> <identifiersep> <identifier> ) ; \n \t2 assert <identifiersep> that ( cluster ( ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 cluster <identifiersep> <identifier> <identifiersep> response <identifier> <identifiersep> response = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> wait <identifiersep> for <identifiersep> nodes ( <string_literal> ) . execute ( ) . action <identifiersep> get ( ) ; \n \t2 assert <identifiersep> that ( <identifier> <identifiersep> response . is <identifiersep> <identifier> <identifiersep> out ( ) , equal <identifiersep> to ( false ) ) ; \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> context . job <identifiersep> queue ( ) . remove <identifiersep> job ( <identifier> ) ; \n \t2 <identifier> . get <identifiersep> <identifier> ( ) . set <identifiersep> start <identifiersep> <identifier> ( next <identifiersep> time ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t2 } finally { \n \t3 if ( build <identifiersep> <identifier> <identifiersep> with <identifiersep> stream != null ) { \n \t4 build <identifiersep> <identifier> <identifiersep> with <identifiersep> stream . <identifier> ( ) ; \n \t4 build <identifiersep> <identifier> <identifiersep> with <identifiersep> stream . <identifier> ( ) ; } \n <ect>
\t1 logger . info ( <string_literal> ) ; \n \t1 assert <identifiersep> equals ( 0 , <identifier> . get <identifiersep> <identifier> <identifiersep> files ( <identifier> . get <identifiersep> path ( ) , <string_literal> ) . size ( ) ) ; \n \t1 logger . info ( <string_literal> ) ; \n \t1 assert <identifiersep> false ( <identifier> . has <identifiersep> access ( <string_literal> , enum <identifiersep> set . of ( <identifier> <identifiersep> file <identifiersep> <identifier> . write ) ) ) ; \n <ect>
\t2 <identifier> < exchange > <identifier> = <identifier> ; \n \t2 <comment> \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> && max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > 0 ) { \n \t3 if ( files . size ( ) > max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t7 task . set <identifiersep> vm <identifiersep> create <identifiersep> <identifier> <identifiersep> task <identifiersep> state ( create <identifiersep> <identifier> <identifiersep> state . <identifier> ) ; \n \t5 } else \n \t6 continue ; \n \t4 } catch ( final exception ex ) { \n <ect>
\t1 <comment> \n \t1 <identifier> ( 0 , new <identifier> ( ) { \n \t1 @ <identifier> \n \t1 public void run ( ) { \n <ect>
\t2 <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) , <identifier> . get <identifiersep> function <identifiersep> name ( ) ) ; \n \t1 <identifier> . set <identifiersep> operation <identifiersep> handle ( <identifier> <identifiersep> handle . to <identifiersep> t <identifiersep> operation <identifiersep> handle ( ) ) ; \n \t1 <identifier> . set <identifiersep> status ( <identifier> <identifiersep> status ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 } catch ( io <identifiersep> exception <identifier> ) { \n \t4 <identifier> <identifiersep> log . error ( <string_literal> , <identifier> ) ; \n \t4 return <identifier> . empty <identifiersep> map ( ) ; \n \t3 } catch ( runtime <identifiersep> exception <identifier> ) { \n <ect>
\t5 if ( delete <identifiersep> volume <identifiersep> response != null ) { \n \t6 string <identifier> = delete <identifiersep> volume <identifiersep> response . get <identifiersep> job <identifiersep> id ( ) ; \n \t6 int <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( <identifier> ) ; \n \t6 if ( <identifier> == 1 ) { \n <ect>
\t4 destination destination = <identifier> <identifiersep> message . get <identifiersep> <identifier> <identifiersep> destination ( ) ; \n \t4 if ( destination != null ) { \n \t5 <identifier> . put ( <identifier> <identifiersep> <identifier> . destination , destination ) ; } } \n \t3 catch ( exception ex ) { \n <ect>
\t4 log . info ( <string_literal> ) ; \n \t4 try { \n \t5 <identifier> <identifiersep> conn . stop ( ) ; \n \t4 } catch ( <identifier> . <identifier> . <identifier> <identifiersep> exception <identifier> <identifiersep> <identifier> ) { \n <ect>
\t5 log . info ( <string_literal> , <identifier> . get <identifiersep> name ( ) ) ; \n \t5 <identifier> . run ( ) ; \n \t5 log . info ( <string_literal> , <identifier> . get <identifiersep> name ( ) ) ; } \n \t3 } catch ( throwable e ) { \n <ect>
<number_literal> <comment> \n <number_literal> <comment> \n \t2 <identifier> <identifiersep> message response = read <identifiersep> <identifier> <identifiersep> response ( <identifier> <identifiersep> action <identifiersep> header , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> url + <identifier> . get <identifiersep> <identifier> <identifiersep> url ( ) ) ; \n \t2 if ( response == null ) { \n <ect>
\t5 if ( <identifier> <identifiersep> id . next ( ) ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> id = <identifier> <identifiersep> id . get <identifiersep> long ( 1 ) ; \n \t6 <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t6 <identifier> . set <identifiersep> long ( 1 , <identifier> <identifiersep> <identifier> <identifiersep> id ) ; \n <ect>
\t6 if ( ! is <identifiersep> <identifier> ) { \n \t7 session . get <identifiersep> transaction ( ) . <identifier> ( ) ; } \n \t6 session . close ( ) ; } \n \t5 catch ( exception e ) { \n <ect>
\t1 conn . table <identifiersep> <identifier> ( ) . create ( table <identifiersep> name ) ; \n \t1 add <identifiersep> <identifier> ( conn , table <identifiersep> name ) ; \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> data ( conn , table <identifiersep> name ) ; \n <ect>
\t2 public void <identifier> ( ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 try { \n \t4 this . <identifier> <identifiersep> port . close ( ) ; \n <ect>
<comment> \n \t3 if ( request <identifiersep> <identifier> <identifiersep> instance . size ( ) > <number_literal> ) { \n <ect>
\t3 log <identifiersep> file = new file ( <identifier> <identifiersep> log <identifiersep> file <identifiersep> name ) ; \n \t3 if ( log <identifiersep> file . exists ( ) ) { \n \t4 file new <identifiersep> file = new file ( new <identifiersep> log <identifiersep> file <identifiersep> name ) ; \n \t4 if ( ! log <identifiersep> file . <identifier> <identifiersep> to ( new <identifiersep> file ) ) { \n <ect>
\t5 <identifier> *= <number_literal> ; \n \t4 else \n \t5 <identifier> /= <number_literal> ; } \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t7 try { \n \t8 <comment> \n \t8 resource = type . new <identifiersep> instance ( ) ; \n \t7 } catch ( throwable t ) { \n <ect>
\t4 <identifier> <identifiersep> properties . put ( <identifier> <identifiersep> <identifier> . key ( <identifier> . class , <string_literal> ) , \t4 <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> <identifiersep> properties . put ( <identifier> <identifiersep> <identifier> . key ( <identifier> . class , <string_literal> ) , \t3 <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> . create ( <identifier> <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> properties ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t5 logger . debug ( <string_literal> , \n \t7 <identifier> <identifiersep> <identifier> - 1 , <identifier> ) ; } } \n \t2 } catch ( <identifier> <identifiersep> key <identifiersep> exception e ) { \n <ect>
connection close ( ) \n { \n \t1 <identifier> <identifiersep> <identifier> < ? > <identifier> = end <identifiersep> of <identifiersep> <identifier> ; \n \t1 if ( <identifier> != null && ! <identifier> . is <identifiersep> <identifier> ( ) && ! <identifier> . <identifier> ( false ) ) { \n <ect>
\t4 log . warn ( <string_literal> , e ) ; \n \t3 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n \t4 log . warn ( <string_literal> , e ) ; \n \t3 } catch ( no <identifiersep> class <identifiersep> <identifier> <identifiersep> found <identifiersep> error e ) { \n <ect>
\t4 logger . info ( <string_literal> , <identifier> . name ) ; \n \t3 } else { \n \t4 logger . info ( <string_literal> , <identifier> . name ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 bean <identifiersep> name . delete <identifiersep> char <identifiersep> <identifier> ( bean <identifiersep> name . length ( ) - 1 ) ; \n \t2 try { \n \t3 return new object <identifiersep> name ( bean <identifiersep> name . to <identifiersep> string ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> object <identifiersep> name <identifiersep> exception e ) { \n <ect>
\t9 <identifier> . <identifier> <identifiersep> list ( new failed <identifiersep> node <identifiersep> exception ( node <identifiersep> id , <string_literal> , entry . failure ) ) , <identifier> <identifiersep> <identifier> ) ; \n \t7 } else { \n \t8 process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> list ( entry . response ) , null , <identifier> <identifiersep> <identifier> ) ; } \n \t6 } catch ( exception e ) { \n <ect>
\t1 return new <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n private static void log <identifiersep> <identifier> ( float <identifier> ) { \n \t1 int <identifier> = ( int ) ( <identifier> * <number_literal> ) ; \n \t1 if ( <identifier> <identifier> <number_literal> == 0 ) { \n <ect>
\t2 finally { \n \t3 logger . info ( <string_literal> + context <identifiersep> config ) ; \n \t3 logger . info ( <string_literal> + success <identifiersep> <identifier> . get ( ) ) ; \n \t3 logger . info ( <string_literal> + timeout <identifiersep> <identifier> . get ( ) ) ; \n <ect>
\t3 <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( response <identifiersep> type , <identifier> . get <identifiersep> <identifier> <identifiersep> key ( ) ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> ( <identifier> ) ) { \n \t4 return <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 } ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n <ect>
public class <identifier> <identifiersep> <identifier> extends abstract <identifiersep> <identifier> <identifiersep> <identifier> { \n private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( <identifier> <identifiersep> <identifier> . class ) ; \n @ <identifier> \n protected <identifier> <identifiersep> client <identifier> <identifiersep> <identifier> <identifiersep> client ( properties <identifier> ) { \n <ect>
\t2 <identifier> = stack <identifiersep> <identifier> . package <identifiersep> <identifier> <identifiersep> <identifier> \n \t1 stack <identifiersep> <identifier> <identifiersep> <identifier> = stack <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> , service <identifiersep> name = <string_literal> , <identifier> <identifiersep> name = <string_literal> ) \n \t1 if stack <identifiersep> <identifier> <identifiersep> <identifier> is <identifier> : \n \t1 <identifier> <identifier> ( <string_literal> ) \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> file = <identifier> . <identifier> <identifiersep> build <identifiersep> <identifier> <identifiersep> file , \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> java <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> java <identifiersep> <identifier> , \n \t4 local <identifiersep> state <identifiersep> <identifier> = <identifier> . local <identifiersep> state <identifiersep> <identifier> \n \t2 ) \n <ect>
\t3 if ( ! <identifier> ) { \n \t4 handle ( <string_literal> + values . size ( ) , e ) ; } } } \n \t1 private void <identifier> <identifiersep> if <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> ) { \n <ect>
\t4 list < <identifier> < application <identifiersep> state , <identifier> <identifiersep> value > > <identifier> = new array <identifiersep> list < <identifier> < application <identifiersep> state , <identifier> <identifiersep> value > > ( ) ; \n \t4 <identifier> . add ( <identifier> . create ( application <identifiersep> state . <identifier> , value <identifiersep> factory . <identifier> ( <identifier> ) ) ) ; \n \t4 <identifier> . add ( <identifier> . create ( application <identifiersep> state . status , value <identifiersep> factory . <identifier> ( true ) ) ) ; \n \t4 <identifier> . instance . add <identifiersep> local <identifiersep> application <identifiersep> <identifier> ( <identifier> ) ; } \n <ect>
\t2 <identifier> <identifiersep> object <identifier> \t2 = get <identifiersep> node ( web <identifiersep> socket <identifiersep> data . get <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> != null ) { \n \t3 if ( ! ( ( abstract <identifiersep> node ) <identifier> ) . is <identifiersep> <identifier> ( <identifier> . write , get <identifiersep> web <identifiersep> socket ( ) . get <identifiersep> security <identifiersep> context ( ) ) ) { \n \t4 get <identifiersep> web <identifiersep> socket ( ) . send ( message <identifiersep> builder . status ( ) . message ( <string_literal> ) . code ( <number_literal> ) . build ( ) , true ) ; \n <ect>
\t2 string file <identifiersep> path = <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <string_literal> ) ; \n \t2 string output <identifiersep> path = <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <string_literal> ) ; \n \t2 string input <identifiersep> format = <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <string_literal> ) ; \n \t2 if ( file <identifiersep> path == null || output <identifiersep> path == null ) { \n <ect>
\t2 for ( <identifier> <identifiersep> address <identifiersep> and <identifiersep> port node : <identifier> <identifiersep> <identifier> ) \n \t2 { \n \t3 if ( should <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from ( node ) ) \n \t3 { \n <ect>
\t5 log . debug ( <string_literal> , url ) ; \n \t5 <identifier> . start ( ) ; \n \t5 log . info ( <string_literal> , url ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 logger . debug ( <string_literal> , entity <identifiersep> id ) ; \n \t2 if ( ! metadata <identifiersep> <identifier> <identifiersep> utils . is <identifiersep> metadata <identifiersep> found <identifiersep> for <identifiersep> entity <identifiersep> id ( metadata <identifiersep> <identifier> , entity <identifiersep> id ) ) { \n \t3 logger . debug ( <string_literal> , entity <identifiersep> id ) ; \n \t3 final registered <identifiersep> service registered <identifiersep> service = get <identifiersep> registered <identifiersep> service <identifiersep> from <identifiersep> request ( request <identifiersep> context , entity <identifiersep> id ) ; \n <ect>
\t2 assert <identifiersep> equals ( response <identifiersep> code , <number_literal> ) ; \n \t2 conn . <identifier> ( ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> delete <identifiersep> <identifier> <identifiersep> version ( ) throws io <identifiersep> exception { \n <ect>
\t1 try { \n \t1 if ( socket != null ) { \n \t2 socket . close ( ) ; \n \t2 socket = null ; \n <ect>
\t3 try { \n \t4 <comment> \n \t4 throw new exception ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t6 log . debug ( <string_literal> ) ; \n \t6 try { \n \t7 query ( ) ; \n \t6 } catch ( exception e ) { \n <ect>
\t4 m = <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> type ( ) ; } } } \n \t1 public <identifier> update <identifiersep> <identifier> ( <identifier> <identifiersep> configuration r ) { \n \t2 <identifier> <identifier> = new <identifier> ( this ) ; \n \t2 <identifier> p = <identifier> <identifiersep> <identifier> ( r ) ; \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list ( ) \n \t1 { \n \t2 <identifier> <identifiersep> group root <identifiersep> group \n \t3 = <identifier> <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list <identifiersep> root ( ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> context . get <identifiersep> service <identifiersep> <identifier> ( \n \t4 <identifier> <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , <identifier> <identifiersep> filter ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> server <identifiersep> name + <string_literal> + <identifier> , e ) ; \n \t3 system . <identifier> ( 1 ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } else if ( resource <identifiersep> data <identifiersep> key != null ) { \n \t3 logger . debug ( <string_literal> + resource <identifiersep> data <identifiersep> key ) ; \n \t3 response = response <identifiersep> for <identifiersep> data <identifiersep> <identifier> <identifiersep> with <identifiersep> key ( resource <identifiersep> data <identifiersep> key ) ; } \n \t2 if ( response == null ) { \n <ect>
\t3 put ( <identifier> , <identifier> , <identifier> , i ) ; } \n \t2 if ( <identifier> != null ) { \n \t3 <comment> \n \t3 <identifier> . stop ( ) ; \n <ect>
\t2 { \n \t3 s . set <identifiersep> <identifier> <identifiersep> class ( <identifier> ) ; } \n \t2 catch ( socket <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 logger . warn ( <string_literal> , e ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 logger . warn ( <string_literal> , e ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 <comment> \n \t2 if ( <identifier> . size ( ) > 0 ) { \n \t3 <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> ( ) ; \n \t3 int n = <identifier> <identifiersep> all <identifiersep> map <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t1 public void set <identifiersep> <identifier> ( ) \n \t1 { \n \t2 if ( current <identifiersep> test <identifiersep> name != null ) \n \t2 { \n <ect>
\t3 try { \n \t4 byte <identifiersep> array <identifiersep> input <identifiersep> stream <identifier> = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( <identifier> . get <identifiersep> byte <identifiersep> array <identifiersep> value ( ) ) ; \n \t4 return <identifier> . read <identifiersep> value ( <identifier> , message . class ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 <identifier> ( ) ; \n \t2 if ( true ) \n \t2 { \n \t3 logger . debug ( <string_literal> + new date ( ) ) ; \n <ect>
\t2 { \n \t3 string <identifier> = <identifier> . get <identifiersep> property ( <string_literal> ) ; \n \t3 if ( <identifier> == null ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 logger . info ( <string_literal> ) ; \n \t5 client <identifiersep> web <identifiersep> socket <identifiersep> <identifier> . this . connection <identifiersep> <identifier> . count <identifiersep> <identifier> ( ) ; } \n \t4 @ <identifier> \n \t4 public void on <identifiersep> failure ( throwable t ) { \n <ect>
\t3 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . error ( <string_literal> ) ; \n \t4 system . <identifier> ( <identifier> <identifiersep> status . error . value ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public static <identifier> <identifiersep> model <identifier> <identifiersep> default <identifiersep> model ( ) { \n \t2 if ( ! ( <identifier> <identifiersep> model . default <identifiersep> model ( ) instanceof <identifier> <identifiersep> model ) ) { \n \t3 <identifier> <identifiersep> model . set <identifiersep> default <identifiersep> model ( <identifier> <identifiersep> default <identifiersep> model ) ; \n <ect>
\t2 <identifier> <identifier> <identifiersep> source <identifiersep> directory <identifiersep> <identifier> = <identifier> . <identifier> [ <string_literal> ] . <identifier> . with <identifiersep> type ( <identifier> <identifiersep> <identifier> : : class . java ) \n \t4 . map { p - > p . <identifier> <identifiersep> <identifier> . the < java <identifiersep> <identifier> <identifiersep> <identifier> > ( ) . source <identifiersep> <identifier> . get <identifiersep> by <identifiersep> name ( <string_literal> ) . all <identifiersep> source . source <identifiersep> <identifier> } \n \t2 <identifier> <identifier> <identifiersep> <identifier> = \n \t4 <identifier> <identifiersep> source <identifiersep> directory <identifiersep> <identifier> . <identifier> ( source <identifiersep> set ! ! . <identifier> <identifiersep> <identifier> ) { <identifier> , v - > <identifier> + v } . as <identifiersep> path . <identifier> { \n <ect>
\t3 long end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 long <identifier> = ( end <identifiersep> time - start <identifiersep> time ) / <number_literal> ; \n \t3 log . info ( <string_literal> , num <identifiersep> <identifier> . int <identifiersep> value ( ) , <identifier> ) ; \n \t3 <identifier> . put ( num <identifiersep> <identifier> , <identifier> ) ; \n <ect>
\t3 <identifier> <identifiersep> log . error ( <string_literal> + dir ) ; \n \t3 return ; } \n \t2 dir = new <identifier> <identifiersep> file ( dir , <string_literal> ) ; \n \t2 if ( ! dir . exists ( ) && ! dir . <identifier> ( ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> message == null ) { \n \t3 logger . error ( <string_literal> ) ; \n \t3 return ; } \n \t2 if ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> class ( ) != <identifier> <identifiersep> message <identifiersep> class . send <identifiersep> data ) { \n <ect>
\t5 <identifier> . add <identifiersep> <identifier> <identifiersep> configuration ( conf , <identifier> ( attributes . get <identifiersep> value ( <string_literal> ) ) ) ; \n \t4 } else if ( ( <string_literal> . equals ( <identifier> <identifiersep> name ) && state == state . <identifier> ) || <string_literal> . equals ( <identifier> <identifiersep> name ) && state == state . <identifier> ) { \n \t5 logger . debug ( <string_literal> , get <identifiersep> resource ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t4 } else if ( <string_literal> . equals ( <identifier> <identifiersep> name ) && state == state . <identifier> ) { \n <ect>
\t2 } catch ( exception e ) { \n \t3 log . error ( <string_literal> , e ) ; \n \t3 throw new runtime <identifiersep> exception ( <string_literal> + id , e ) ; } \n \t2 if ( consumer == null ) { \n <ect>
\t3 return self . socket . <identifier> ( <number_literal> ) \n \t2 <identifier> socket . error : \n \t3 <identifier> <identifiersep> <identifier> , e , <identifier> <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> info ( ) \n \t3 if get <identifiersep> <identifier> ( e ) in ( <identifier> . <identifier> , <identifier> . <identifier> ) : \n <ect>
\t2 log . info ( <string_literal> + <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> , <identifier> , <number_literal> , <number_literal> , <identifier> <identifiersep> time , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t2 assert . assert <identifiersep> equals ( <identifier> , <identifier> . get <identifiersep> client <identifiersep> port ( ) ) ; \n <ect>
\t2 string vm <identifiersep> name = cmd . get <identifiersep> name ( ) ; \n \t2 string private <identifiersep> ip = cmd . get <identifiersep> ip ( ) ; \n \t2 int cmd <identifiersep> port = cmd . get <identifiersep> port ( ) ; \n <ect>
\t1 <identifier> < long > <identifier> = <identifier> . get ( time <identifiersep> field ) ; \n \t1 if ( <identifier> != null ) { \n \t2 <identifier> < <identifier> > is <identifiersep> <identifier> <identifiersep> by = time <identifiersep> <identifier> . get ( <identifier> , time <identifiersep> field ) \n \t3 . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> id <identifiersep> manager . log . debug ( <string_literal> + <identifier> ) ; } \n \t1 if ( <identifier> <identifiersep> success . has <identifiersep> <identifier> ( s <identifiersep> <identifier> <identifiersep> message . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t2 message <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> success . get <identifiersep> <identifier> ( s <identifiersep> <identifier> <identifiersep> message . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 message <identifiersep> <identifier> . add ( <identifier> ) ; \n <ect>
\t5 return <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t3 } catch ( web <identifiersep> application <identifiersep> exception e ) { \n \t4 return e . get <identifiersep> response ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 private void log <identifiersep> all <identifiersep> <identifier> ( <identifier> <identifiersep> service <identifier> ) throws <identifier> <identifiersep> url <identifiersep> exception { \n \t2 try { \n \t3 <comment> \n \t3 set < ? > all = <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) . query <identifiersep> <identifier> ( null , null ) ; \n <ect>
\t3 <identifier> . <identifier> ( <identifier> <identifiersep> source , xml <identifiersep> output ) ; \n \t3 result <identifiersep> xml <identifiersep> <identifier> = xml <identifiersep> output . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ; \n \t3 logger . info ( xml <identifiersep> output . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception e ) { \n <ect>
\t3 s <identifiersep> logger . trace ( <string_literal> + <identifier> <identifiersep> <identifier> . size ( ) + <string_literal> ) ; } \n \t2 boolean <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> lock . lock ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> lock <identifiersep> timeout ) ; \n \t2 if ( ! <identifier> ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 <comment> \n <ect>
\t3 <identifier> <identifiersep> stream . get ( ) ; \n \t3 return true ; } \n \t2 catch ( throwable e ) \n \t2 { \n <ect>
\t9 class < ? > c = class . for <identifiersep> name ( s <identifiersep> <identifier> <identifiersep> map . get ( key ) ) ; \n \t9 test <identifiersep> case <identifier> = ( test <identifiersep> case ) c . new <identifiersep> instance ( ) ; \n \t9 execute <identifiersep> test ( key , c , <identifier> ) ; \n \t8 } catch ( exception e ) { \n <ect>
\t2 logger . warn ( <string_literal> ) ; \n \t2 <comment> \n \t2 if ( is <identifiersep> <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 if ( ! policy <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 if ( policy != null ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . delete <identifiersep> <identifier> <identifiersep> policy ( <identifier> <identifiersep> name , policy . get <identifiersep> policy <identifiersep> name ( ) ) ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . put <identifiersep> <identifier> <identifiersep> policy ( <identifier> <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> policy <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> policy <identifiersep> <identifier> ) ; \n <ect>
\t5 <identifier> <identifiersep> last <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t4 catch ( throwable throwable ) \n \t4 { \n \t5 log <identifier> <identifiersep> log = <identifier> . get <identifiersep> <identifier> <identifiersep> log ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t3 <comment> \n <ect>
\t5 request <identifiersep> <identifier> <identifiersep> <identifier> , \n \t5 response <identifiersep> <identifier> <identifiersep> <identifier> , \n \t5 context ) ; \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> + snapshot . <identifier> <identifiersep> policy <identifiersep> id ) ; } \n \t2 for ( long p <identifiersep> id : policy <identifiersep> <identifier> ) { \n \t3 if ( ! delete <identifiersep> policy ( user <identifiersep> id , p <identifiersep> id ) ) { \n \t4 success = false ; \n <ect>
\t1 return <identifier> <identifiersep> <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> provider ) ; \n \t1 } catch ( <identifier> <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . start ( ) ; \n \t2 logger logger = logger <identifiersep> context . get <identifiersep> logger ( <string_literal> ) ; \n \t2 logger . add <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> file . exists ( ) && <identifier> <identifiersep> file . <identifier> <identifiersep> read ( ) && <identifier> <identifiersep> file . is <identifiersep> file ( ) ) { \n \t4 network . set <identifiersep> device <identifiersep> <identifier> ( new <identifier> <identifiersep> device <identifiersep> <identifier> ( new file <identifiersep> <identifier> ( xml <identifiersep> dir ) , new class <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ) ; \n \t4 logger . info ( <string_literal> , <identifier> . xml <identifiersep> dir ) ; \n \t3 } else { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> exchange . get <identifiersep> state ( ) == <identifier> <identifiersep> exchange . state . <identifier> ) { \n \t4 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> cache . get ( <identifier> ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 job <identifiersep> data data = new job <identifiersep> data ( options . get <identifiersep> <identifier> ( ) , this ) ; \n \t2 storage . update ( job <identifiersep> name , data ) ; \n <ect>
<comment> \n \t1 protected void <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> set ( false , true ) ) { \n <ect>
\t2 session . set <identifiersep> attribute ( <string_literal> , <string_literal> ) ; <comment> \n \t2 assert <identifiersep> equals ( <string_literal> , session . get <identifiersep> attribute ( <string_literal> ) ) ; <comment> \n \t1 @ test \n \t1 public void read <identifiersep> write <identifiersep> <identifier> <identifiersep> type ( ) throws exception { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void start ( <identifier> <identifiersep> context <identifier> ) throws exception { \n \t2 context = <identifier> ; \n <ect>
\t1 <identifier> new <identifiersep> file = new file ( <identifier> , new <identifiersep> name ) \n \t1 if ( <identifier> . <identifier> <identifiersep> to ( new <identifiersep> file ) ) { \n \t1 <identifier> p = new <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path \n \t1 <identifier> <identifier> = new <identifiersep> file . to <identifiersep> uri . to <identifiersep> url \n <ect>
\t1 t <identifiersep> server <identifiersep> connection conn ; \n \t1 try { \n \t2 conn = this . <identifier> . <identifier> <identifiersep> set . get <identifiersep> connection ( <identifier> . current ) ; \n \t2 if ( conn != null ) { \n <ect>
<comment> \n \t1 public void set <identifiersep> error <identifiersep> count ( int <identifier> ) { \n \t2 if ( <identifier> < 0 ) { \n <ect>
\t4 logger . debug ( <string_literal> + <identifier> . <identifier> ( ) ) ; \n \t2 } else { \n <ect>
\t3 application <identifiersep> <identifier> . <identifier> . <identifier> . key ( ) ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> utils . log <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , log ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 logger . info ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t4 object <identifiersep> name o <identifiersep> name = new object <identifiersep> name ( <identifier> <identifiersep> name ) ; \n \t4 set < object <identifiersep> name > <identifier> = new <identifier> <identifiersep> set < > ( server . query <identifiersep> <identifier> ( o <identifiersep> name , null ) ) ; \n \t4 for ( object <identifiersep> name name : <identifier> ) { \n <ect>
\t3 } catch ( key <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n \t4 <comment> \n \t4 <comment> \n \t4 <comment> \n <ect>
\t2 return <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; } \n \t1 @ <identifier> \n \t1 protected <identifier> node <identifiersep> <identifier> ( int node <identifiersep> <identifier> ) { \n \t2 boolean <identifier> <identifiersep> level <identifiersep> <identifier> = <identifier> <identifiersep> boolean ( ) ; \n <ect>
\t4 log . debug ( <string_literal> + <identifier> ) ; } \n \t3 file = new file ( file <identifiersep> server . get <identifiersep> file <identifiersep> server ( ) . get <identifiersep> base <identifiersep> dir ( ) , <identifier> ) ; \n <ect>
\t2 int in <identifiersep> <identifier> = in <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 int in <identifiersep> length = in <identifiersep> <identifier> . get <identifiersep> length ( ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( in <identifiersep> data , in <identifiersep> <identifier> , in <identifiersep> length ) ) \n \t2 { \n <ect>
\t2 boolean <identifier> = false ; \n \t2 if ( attribute != null ) { \n \t3 logger . debug ( <string_literal> , attribute . get <identifiersep> name ( ) , attribute . get <identifiersep> string <identifiersep> value ( ) ) ; \n \t3 <identifier> = this . <identifier> <identifiersep> attribute <identifiersep> value . equals ( attribute . get <identifiersep> string <identifiersep> value ( ) ) ; } \n <ect>
\t4 success = true ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 logger . warn ( <string_literal> , e ) ; \n \t3 } catch ( not <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 int current <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 int current <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 log . info ( <string_literal> + last <identifiersep> <identifier> ) ; \n \t2 log . info ( <string_literal> + last <identifiersep> <identifier> ) ; \n <ect>
\t3 log . info ( <string_literal> ) ; } \n \t2 @ <identifier> \n \t2 public void <identifier> <identifiersep> <identifier> <identifiersep> store ( ) \n \t2 { \n <ect>
\t4 <identifier> <identifiersep> run ( <identifier> ) ; \n \t3 } catch ( throwable t ) { \n \t4 system . <identifier> . <identifier> ( <string_literal> + t ) ; \n \t4 t . <identifier> <identifiersep> stack <identifiersep> trace ( system . <identifier> ) ; \n <ect>
\t3 logger . debug ( <string_literal> , <identifier> ) ; } \n \t2 if ( <identifier> . get <identifiersep> return <identifiersep> attributes ( ) != null ) { \n \t3 final list < string > <identifier> <identifiersep> attributes = collection <identifiersep> utils . <identifier> <identifiersep> list ( <identifier> . get <identifiersep> return <identifiersep> attributes ( ) ) ; \n \t3 if ( ! <identifier> <identifiersep> attributes . is <identifiersep> empty ( ) ) { \n <ect>
\t4 <identifier> . update ( request . get <identifiersep> bytes ( ) ) ; \n \t4 final byte [ ] <identifier> <identifiersep> bytes = <identifier> . do <identifiersep> final ( ) ; \n \t4 return new string ( <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> bytes ) ) ; } \n \t2 } catch ( final exception ex ) { \n <ect>
\t3 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t4 final list < <identifier> <identifiersep> device <identifiersep> <identifier> > <identifier> = <identifier> . get ( map <identifiersep> key <identifiersep> <identifier> ) ; \n \t4 logger . debug ( <string_literal> , <identifier> . size ( ) ) ; \n \t4 final local <identifiersep> date <identifier> <identifiersep> date = local <identifiersep> date . <identifier> ( ) . <identifier> ( this . <identifier> <identifiersep> time , date <identifiersep> time <identifiersep> utils . to <identifiersep> <identifier> <identifiersep> unit ( this . <identifier> <identifiersep> time <identifiersep> unit ) ) ; \n <ect>
\t3 return <identifier> . get <identifiersep> <identifier> <identifiersep> stream ( <identifier> <identifiersep> index ) ; } } \n \t1 @ <identifier> \n \t1 @ <identifier> \n \t1 public string get <identifiersep> <identifier> <identifiersep> as <identifiersep> string ( result <identifiersep> set <identifier> , int <identifier> <identifiersep> index ) throws sql <identifiersep> exception { \n <ect>
\t3 <identifier> <identifiersep> <identifier> , new <identifiersep> <identifier> ) ; } \n \t1 <comment> \n \t1 for ( file <identifiersep> <identifier> <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t2 if ( ! <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t4 return ; \n \t3 case lock <identifiersep> <identifier> : \n \t4 logger . trace ( <string_literal> ) ; \n \t4 int lock <identifiersep> state = <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <identifier> + 1 ) ; \n <ect>
\t2 <identifier> <identifier> = request <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> load ) ; \n \t2 if ( <identifier> . <identifier> ( ) ) { \n \t3 <identifier> = <identifier> . group ( 1 ) ; \n \t2 } else { \n <ect>
\t2 log . debug ( <string_literal> + <identifier> . get <identifiersep> key ( ) + <string_literal> + <identifier> ) ; \n \t2 continue ; } \n \t2 string <identifier> <identifiersep> value = <identifier> . get <identifiersep> first ( <identifier> . get <identifiersep> values ( ) , null ) ; \n \t2 if ( <identifier> . check ( <identifier> <identifiersep> value , <identifier> <identifiersep> value ) ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( conn , <identifier> . get <identifiersep> table <identifiersep> name ( ) , <identifier> . <identifier> , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> size , <identifier> , \n \t4 <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 return byte . parse <identifiersep> byte ( <identifier> <identifiersep> <identifier> ( value , <string_literal> ) ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception ex ) { \n \t3 <comment> \n \t3 logger . warn ( <string_literal> , value ) ; \n <ect>
\t1 <comment> \n \t1 <identifier> <identifiersep> server <identifiersep> factory <identifiersep> list . remove ( <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> index ) ; \n \t1 client <identifiersep> port <identifiersep> list . remove ( <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> index ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove ( <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> index ) ; \n <ect>
\t4 <identifier> <identifiersep> cache <identifiersep> manager cache <identifiersep> manager = build <identifiersep> cache <identifiersep> manager ( ) ; \n \t4 cache <identifiersep> manager . get <identifiersep> cache ( <string_literal> ) ; \n \t4 cache <identifiersep> <identifier> . add <identifiersep> last ( cache <identifiersep> manager ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 process <identifiersep> new <identifiersep> <identifier> ( <identifier> , true , false , false ) ; \n \t2 } catch ( <identifier> <identifiersep> parse <identifiersep> exception e ) { \n \t3 logger . error ( this , <string_literal> + e , e ) ; \n \t3 <comment> \n <ect>
\t4 <identifier> <identifiersep> version = new <identifier> <identifiersep> map < > ( ) ; } \n \t3 map < string , <identifier> > <identifier> = ( map < string , <identifier> > ) local <identifiersep> state . get ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> == null ) { \n \t4 <identifier> = new <identifier> <identifiersep> map < > ( ) ; } \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 try { \n \t2 <identifier> . close ( ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t4 <comment> \n \t4 output <identifiersep> <identifier> . write ( <identifier> , 0 , n ) ; } \n \t3 <comment> \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> <identifiersep> date ( new date ( ) ) ; \n \t3 return <identifier> ; } \n \t2 else \n \t2 { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> m <identifiersep> bean ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> object <identifiersep> name <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + <identifier> . get <identifiersep> name ( ) , e ) ; \n \t2 } catch ( instance <identifiersep> <identifier> <identifiersep> exists <identifiersep> exception e ) { \n <ect>
\t2 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> . get <identifiersep> <identifier> ( <identifier> ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t4 + <string_literal> + service . get <identifiersep> metadata <identifiersep> location ( ) ) ; } \n \t2 metadata <identifiersep> <identifier> . set <identifiersep> id ( <identifier> <identifiersep> metadata <identifiersep> <identifier> . class . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 metadata <identifiersep> <identifier> . set <identifiersep> <identifier> ( metadata <identifiersep> <identifier> ) ; \n \t2 metadata <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t1 public static boolean assert <identifiersep> <identifier> ( final <identifier> <identifier> , exchange exchange , boolean <identifier> ) { \n \t2 if ( <identifier> ) { \n \t3 <identifier> <identifiersep> assert <identifiersep> <identifier> . assert <identifiersep> <identifier> ( <identifier> , <string_literal> , exchange ) ; } \n \t2 boolean value = <identifier> . <identifier> ( exchange ) ; \n <ect>
\t5 <identifier> <identifiersep> ticket <identifiersep> field . set <identifiersep> <identifier> <identifiersep> ticket ( ) ; \n \t4 } else { \n \t5 <identifier> <identifiersep> ticket <identifiersep> field . <identifier> <identifiersep> <identifier> <identifiersep> ticket ( ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> name != null ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> client . set <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; } \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> client . <identifier> ( <identifier> <identifiersep> <identifier> . message , text ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t7 synchronized ( <identifier> ) { \n \t8 <comment> \n \t8 if ( <identifier> . size ( ) > 1 ) { \n \t9 <identifier> . <identifier> <identifier> = <identifier> . remove ( 0 ) ; \n <ect>
\t2 <identifier> <identifier> = root . <identifier> . get ( <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> ( ) ) \n \t2 { \n \t3 log . debug ( format ( <string_literal> , <identifier> <identifiersep> <identifier> , <identifier> ) ) ; \n <ect>
\t3 return ; \n \t2 try { \n \t3 if ( msg . exchange <identifiersep> id ( ) == null ) { \n <ect>
public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t1 try { \n \t2 <identifier> . object <identifiersep> to <identifiersep> byte <identifiersep> <identifier> ( new object ( ) ) ; \n \t1 } catch ( not <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 protected void do <identifiersep> <identifier> ( <identifier> <identifiersep> data new <identifiersep> data ) { \n \t2 try { \n \t3 <identifier> <identifiersep> thread . <identifier> ( ( ) - > build <identifiersep> <identifier> ( new <identifiersep> data ) ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 return false ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( message <identifiersep> handler handler ) { \n <ect>
\t3 list < <identifier> > <identifier> = <identifier> . create <identifiersep> query ( <string_literal> ) . list ( ) ; \n \t3 assert <identifiersep> equals ( <number_literal> , <identifier> . size ( ) ) ; \n \t3 for ( <identifier> <identifier> : <identifier> ) { \n \t4 assert <identifiersep> not <identifiersep> null ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n <ect>
<comment> \n \t1 public void add <identifiersep> <identifier> ( <identifier> <identifier> ) { \n \t2 <comment> \n \t2 if ( <identifier> == this ) { \n <ect>
\t3 for ( int i = 0 ; i < <identifier> . size ( ) ; i ++ ) { \n \t4 <identifier> [ i ] = <identifier> . get ( i ) . get <identifiersep> <identifier> ( ) ; } \n \t3 return <identifier> ; \n \t2 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t1 <identifier> . <identifier> <identifiersep> all ( result ) ; \n \t1 <identifier> = <identifier> <identifiersep> transaction ( ) ; \n \t1 return result ; \n \t1 } catch ( exception ex ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> command ( string item <identifiersep> name , command command ) { \n <ect>
\t2 } , <number_literal> * <number_literal> * <identifier> , <number_literal> * <number_literal> ) ) ; \n \t2 assert <identifiersep> true ( <string_literal> + <identifier> , <identifier> . is <identifiersep> empty ( ) ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ; \n <ect>
\t2 } else if ( i < <number_literal> ) { \n \t2 logger . debug ( <string_literal> + i ) ; } } \n \t1 <identifier> . close ( ) ; \n \t1 for ( int i = <number_literal> ; i < <number_literal> ; i ++ ) { \n <ect>
\t3 public void start ( ) throws exception { \n \t4 log . info ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> store <identifiersep> start . <identifier> ( ) ; \n \t4 super . start ( ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> query <identifiersep> <identifier> . delete <identifiersep> file <identifiersep> <identifier> ( configuration <identifiersep> check <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> dir ( ) ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> query <identifiersep> <identifier> . delete <identifiersep> file <identifiersep> query <identifiersep> <identifier> ( configuration <identifiersep> check <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> dir ( ) ) ; \n \t1 <comment> \n \t1 logger . info ( <string_literal> ) ; \n <ect>
\t3 final string task <identifiersep> id = <identifier> . get <identifiersep> task <identifiersep> id ( <identifier> ) ; \n \t3 path <identifier> <identifiersep> file <identifiersep> path = new path ( <identifier> <identifiersep> dir , new path ( task <identifiersep> id ) ) ; \n \t3 for ( int <identifier> = 1 ; <identifier> . exists ( <identifier> <identifiersep> file <identifiersep> path ) ; <identifier> ++ ) { \n \t4 <identifier> <identifiersep> file <identifiersep> path = new path ( <identifier> <identifiersep> dir , task <identifiersep> id + ( <identifier> . <identifier> <identifiersep> <identifier> + <identifier> ) ) ; } \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 this . <identifier> = file <identifiersep> system . get ( uri . create ( this . <identifier> <identifiersep> url ) , <identifier> <identifiersep> config ) ; } \n \t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> ( ) throws io <identifiersep> exception { \n <ect>
\t4 int timeout = <number_literal> * <number_literal> ; \n \t4 <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> name ( ) , <identifier> , <identifier> , \n \t6 timeout , <identifier> <identifiersep> <identifier> ) ; \n \t4 if ( <identifier> == null ) { \n <ect>
\t3 <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> context <identifier> = <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> context . get <identifiersep> instance ( <string_literal> ) ; \n \t3 <identifier> . <identifier> ( null , <identifier> <identifiersep> all <identifiersep> <identifier> , null ) ; \n \t3 <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> url <identifiersep> connection . set <identifiersep> default <identifiersep> <identifier> <identifiersep> socket <identifiersep> factory ( <identifier> . get <identifiersep> socket <identifiersep> factory ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 get <identifiersep> cache ( ) . put ( url , new cache <identifiersep> entry ( last <identifiersep> <identifier> , <identifier> <identifiersep> date , <identifier> , <identifier> <identifiersep> header . get <identifiersep> <identifier> ( ) ) ) ; \n \t3 get <identifiersep> cache ( ) . put ( <identifier> <identifiersep> url ( url , <identifier> <identifiersep> header . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> header . get <identifiersep> <identifier> ( ) ) , new cache <identifiersep> entry ( last <identifiersep> <identifier> , <identifier> <identifiersep> date , <identifier> , null ) ) ; \n \t2 } else { \n \t3 if ( get <identifiersep> cache ( ) . get ( url ) != null ) { \n <ect>
\t3 if ( <identifier> != null && <identifier> . length ( ) > 0 ) { \n \t4 map . put ( <string_literal> , <identifier> ) ; } \n \t3 string [ ] <identifier> = <identifier> . get <identifiersep> <identifier> ( interface <identifiersep> class ) . get <identifiersep> method <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> . length == 0 ) { \n <ect>
\t4 return success ; } \n \t3 <comment> \n \t3 list < template <identifiersep> info > cache <identifiersep> <identifier> = <identifier> <identifiersep> factory . list <identifiersep> template <identifiersep> on <identifiersep> cache ( template . get <identifiersep> id ( ) ) ; \n \t3 for ( template <identifiersep> info <identifier> <identifiersep> on <identifiersep> cache : cache <identifiersep> <identifier> ) { \n <ect>
\t2 } catch ( io <identifiersep> exception e ) { \n \t3 service <identifiersep> local <identifiersep> exception ( e ) ; } } \n \t1 public void service <identifiersep> local <identifiersep> exception ( throwable error ) { \n \t2 log . info ( <string_literal> , error . get <identifiersep> message ( ) ) ; \n <ect>
\t1 <identifier> . set <identifiersep> property ( <string_literal> , string . value <identifiersep> of ( <identifier> <identifiersep> <identifier> . get ( ) ) ) ; \n \t1 <identifier> . set <identifiersep> property ( <string_literal> , string . value <identifiersep> of ( time <identifiersep> <identifier> . get ( ) ) ) ; \n \t1 try ( output <identifiersep> stream <identifier> = new file <identifiersep> output <identifiersep> stream ( state <identifiersep> file ) ) { \n \t1 <identifier> . store ( <identifier> , <string_literal> ) ; \n <ect>
\t4 } catch ( final <identifier> <identifiersep> operation <identifiersep> exception e ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + element . get <identifiersep> name ( ) , e ) ; \n \t5 success = false ; \n \t4 } catch ( final exception e ) { \n <ect>
\t4 logger . debug ( <string_literal> , config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> local <identifiersep> <identifier> ( ) ) ; \n \t4 logger . debug ( <string_literal> , config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> local <identifiersep> <identifier> ( ) ) ; \n \t4 logger . debug ( <string_literal> , config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> in <identifiersep> cache ( ) ) ; \n \t4 logger . debug ( <string_literal> , config . get <identifiersep> <identifier> <identifiersep> configuration ( ) . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t2 long <identifier> = in . read <identifiersep> long ( ) ; \n \t2 byte [ ] data = new byte [ length - <number_literal> ] ; \n \t2 in . read <identifiersep> bytes ( data ) ; \n \t2 if ( <identifier> ( data ) != <identifier> ) { \n <ect>
\t1 else : \n \t1 logger . info ( <string_literal> ) \n <identifier> load <identifiersep> <identifier> <identifiersep> <identifier> ( self ) : \n \t1 get <identifiersep> <identifier> <identifiersep> url = self . server <identifiersep> url + ' / <identifier> / <identifier> / ' \n <ect>
\t4 log . warn ( <string_literal> ) ; \n \t3 } else if ( this . <identifier> <identifiersep> policy instanceof <identifier> <identifiersep> <identifier> <identifiersep> policy ) { \n \t4 log . warn ( <string_literal> , ( ( <identifier> <identifiersep> <identifier> <identifiersep> policy ) <identifier> <identifiersep> policy ) . get <identifiersep> <identifier> ( ) ) ; \n \t4 log . warn ( <string_literal> ) ; \n <ect>
\t1 <identifier> . set ( <identifier> <identifiersep> <identifier> ) ; \n \t1 group <identifiersep> id = <identifier> . get <identifiersep> string ( <identifier> <identifiersep> consumer <identifiersep> <identifier> + consumer <identifiersep> config . group <identifiersep> id <identifiersep> config ) ; \n \t1 if ( group <identifiersep> id == null || group <identifiersep> id . is <identifiersep> empty ( ) ) { \n \t1 group <identifiersep> id = default <identifiersep> group <identifiersep> id ; \n <ect>
\t7 <identifier> ( <string_literal> + n + <string_literal> + <identifier> + <string_literal> + <identifier> <identifiersep> <identifier> ) ; } \n \t6 assert <identifiersep> not <identifiersep> null ( <identifier> <identifiersep> <identifier> <identifiersep> dir ) ; \n \t6 logger . info ( <string_literal> + <identifier> + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> dir ) ; \n \t6 <identifier> <identifiersep> dir = <identifier> <identifiersep> <identifier> <identifiersep> dir ; \n <ect>
\t2 <identifier> . execute ( new <identifier> ( ) { \n \t3 public void run ( ) { \n \t4 try { \n \t5 <identifier> . count <identifiersep> <identifier> ( ) ; \n <ect>
\t4 return <identifier> ( cmd , num <identifiersep> <identifier> ) ; \n \t3 } else { \n \t4 return new answer ( cmd , e ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 return ; } \n \t1 } while ( true ) ; } \n @ <identifier> public void close ( ) throws io <identifiersep> exception { \n \t1 if ( channel . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> list . add ( <identifier> <identifiersep> <identifier> <identifiersep> list . resource <identifiersep> <identifier> ) ; \n \t2 int id = <identifier> . get <identifiersep> and <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> id ( id ) ; \n \t2 collection . put ( id , <identifier> ) ; \n <ect>
\t2 try { \n \t3 class <identifier> <identifiersep> attribute <identifiersep> class = class . for <identifiersep> name ( <string_literal> ) ; \n \t3 value <identifiersep> factory <identifiersep> class <identifiersep> name <identifiersep> method = <identifier> <identifiersep> attribute <identifiersep> class . get <identifiersep> method ( <string_literal> , ( java . <identifier> . class [ ] ) null ) ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
\t1 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } } \n private synchronized set < config <identifiersep> group <identifiersep> response > create <identifiersep> config <identifiersep> <identifier> \n \t1 ( set < config <identifiersep> group <identifiersep> request > <identifier> ) throws <identifier> <identifiersep> exception , <identifier> <identifiersep> exception { \n \t1 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 public <identifier> <identifiersep> <identifier> ( byte <identifier> , byte <identifier> , byte <identifier> ) { \n \t3 this . <identifier> = <identifier> ; \n \t3 this . <identifier> = <identifier> ; \n \t3 this . <identifier> = <identifier> ; \n <ect>
\t1 string <identifier> <identifiersep> string = <string_literal> ; \n \t1 try { \n \t1 <identifier> <identifiersep> string = <identifier> . write <identifiersep> value <identifiersep> as <identifiersep> string ( as <identifiersep> json ( <identifier> ) ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 <identifier> . <identifier> ( <identifier> , <identifier> ) ; \n \t4 s <identifiersep> logger . info ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> manager <identifiersep> factory <identifier> = <identifier> <identifiersep> manager <identifiersep> factory . get <identifiersep> instance ( <string_literal> ) ; \n \t4 <identifier> . <identifier> ( <identifier> ) ; \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 server <identifiersep> socket <identifiersep> channel . <identifier> ( <identifier> , <identifier> <identifiersep> key . <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> channel <identifiersep> exception e ) { \n <ect>
\t4 default field = default . from <identifiersep> string ( attribute ) ; \n \t4 <identifier> . put ( field , value ) ; } \n \t3 catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) \n \t3 { \n <ect>
\t2 <identifier> <identifiersep> instance = <identifier> . get ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> instance == null ) { \n \t3 <identifier> <identifiersep> instance = <string_literal> ; } \n \t2 <identifier> <identifiersep> node <identifiersep> id = <identifier> <identifiersep> server <identifiersep> node . get <identifiersep> <identifier> <identifiersep> server <identifiersep> id ( ) ; \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 final string node <identifiersep> <number_literal> = <identifier> <identifiersep> cluster ( ) . start <identifiersep> node ( ) ; \n \t2 cluster <identifiersep> <identifier> <identifiersep> response cluster <identifiersep> <identifier> <identifiersep> response = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( <identifier> . <identifier> ) . set <identifiersep> wait <identifiersep> for <identifiersep> nodes ( <string_literal> ) . execute ( ) . action <identifiersep> get ( ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> <identifiersep> response . is <identifiersep> <identifier> <identifiersep> out ( ) , equal <identifiersep> to ( false ) ) ; \n <ect>
\t4 task <identifiersep> <identifier> . add ( client <identifiersep> task <identifiersep> <identifier> . <identifier> ( query <identifiersep> task ) ) ; } \n \t3 long num <identifiersep> <identifier> ; \n \t3 while ( ( num <identifiersep> <identifier> = client <identifiersep> <identifier> . get <identifiersep> num <identifiersep> <identifier> ( ) ) < <number_literal> <identifiersep> <identifier> ) { \n \t4 thread . <identifier> ( <identifier> ) ; \n <ect>
<number_literal> new <identifiersep> node <identifiersep> properties . put ( <identifier> <identifiersep> key , <identifier> <identifiersep> value ) ; \n \t10 } else { \n <number_literal> new <identifiersep> node <identifiersep> properties . put ( <identifier> <identifiersep> key , value ) ; } \n \t9 } else { \n <ect>
\t1 <identifier> . count <identifiersep> <identifier> ( ) ; \n \t1 try { \n \t2 <identifier> . <identifier> ( ) ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 if ( ! file . delete ( ) ) { \n \t3 throw new runtime <identifiersep> io <identifiersep> exception ( <string_literal> + this ) ; } } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t4 logger . debug ( <string_literal> \n \t6 + <string_literal> , \n \t5 ticket <identifiersep> <identifier> <identifiersep> ticket <identifiersep> id , service ) ; \n \t4 return false ; } } \n <ect>
\t3 try { \n \t4 if ( <identifier> != null ) { \n \t5 <identifier> . close ( ) ; } } \n \t3 catch ( io <identifiersep> exception e ) { \n <ect>
\t3 map < string , string > request <identifiersep> key <identifiersep> values = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( is , new string [ ] { <string_literal> , <string_literal> } ) ; \n \t3 <identifier> <identifiersep> api <identifiersep> key . set ( request <identifiersep> key <identifiersep> values . get ( <string_literal> ) ) ; \n \t3 return <identifiersep> value = request <identifiersep> key <identifiersep> values . get ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 final file <identifier> = file . create <identifiersep> <identifier> <identifiersep> file ( <string_literal> , <string_literal> ) ; \n \t2 try ( output <identifiersep> stream output <identifiersep> stream = new file <identifiersep> output <identifiersep> stream ( <identifier> ) ) { \n \t3 io <identifiersep> utils . <identifier> ( <identifier> <identifiersep> file , output <identifiersep> stream ) ; } \n <ect>
\t4 } else { \n \t5 <identifier> . <identifier> ( <identifier> . false ) ; \n \t5 return ; } \n \t3 } else { \n <ect>
\t2 get <identifiersep> all <identifiersep> <identifier> ( this , <identifier> ) ; \n \t2 if ( <identifier> . log . should <identifiersep> log ( log . debug ) ) \n \t3 <identifier> . log . debug ( <string_literal> + <identifier> . size ( ) + <string_literal> ) ; \n \t2 if ( ! this . equals ( <identifier> . last ( ) ) ) { \n <ect>
\t4 ( ( <identifier> <identifiersep> <identifier> ) <identifier> ) . start <identifiersep> <identifier> <identifiersep> update ( ) ; \n \t3 if ( <identifier> . equals ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> read ) ) \n \t4 ( ( <identifier> <identifiersep> <identifier> ) <identifier> ) . <identifier> <identifiersep> <identifier> <identifiersep> update ( ) ; \n \t2 } else \n <ect>
\t2 answer [ ] <identifier> = null ; \n \t2 try { \n \t3 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send ( <identifier> <identifiersep> <identifier> <identifiersep> vm . get <identifiersep> host <identifiersep> id ( ) , <identifier> ) ; \n \t2 } catch ( final operation <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 if ( null != this . <identifier> <identifiersep> import <identifiersep> process ) { \n \t1 <comment> \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> = this . <identifier> <identifiersep> import <identifiersep> process . wait <identifiersep> for ( ) ; \n <ect>
\t3 <comment> \n \t3 if ( <identifier> <identifiersep> task <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> task <identifiersep> <identifier> ( <identifier> <identifiersep> dir , job <identifiersep> url <identifiersep> <identifier> , job <identifiersep> <identifier> <identifiersep> url <identifiersep> base , user ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t5 s <identifiersep> logger . error ( msg ) ; \n \t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( msg ) ; } \n \t3 } catch ( final operation <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 if ( e . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> shards ( ) , equal <identifiersep> to ( num <identifiersep> shards . num <identifiersep> <identifier> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) , equal <identifiersep> to ( 0 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) . get <identifiersep> <identifier> <identifiersep> shards ( ) , equal <identifiersep> to ( num <identifiersep> shards . num <identifiersep> <identifier> ) ) ; } \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> number <identifiersep> <identifier> <identifiersep> data ( ) throws io <identifiersep> exception { \n <ect>
\t3 on <identifiersep> exception ( <identifier> <identifiersep> status ) ; \n \t3 logger . warn ( <string_literal> , <identifier> ) ; \n \t3 for ( entry < string , string > current <identifiersep> error : <identifier> . get <identifiersep> <identifier> ( ) . entry <identifiersep> set ( ) ) \n \t3 { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> uri <identifiersep> builder <identifiersep> <identifier> ( ) throws exception { \n \t2 uri <identifiersep> builder uri <identifiersep> builder = <identifier> <identifiersep> uri <identifiersep> builder . from <identifiersep> uri ( <identifier> <identifiersep> url ( <string_literal> ) ) ; \n \t2 uri <identifiersep> builder . <identifier> <identifiersep> <identifier> ( <string_literal> , <string_literal> ) ; \n \t2 <identifier> <identifiersep> web <identifiersep> target target = client . target ( uri <identifiersep> builder . build ( ) . to <identifiersep> string ( ) ) ; \n <ect>
\t5 s <identifiersep> logger . error ( msg ) ; \n \t5 throw new resource <identifiersep> <identifier> <identifiersep> exception ( msg , data <identifiersep> <identifier> . class , network . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) ) ; } } \n \t2 } catch ( exception ex ) { \n \t3 if ( <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> is <identifiersep> <identifier> ) { \n <ect>
\t1 protected <identifier> read <identifiersep> <identifier> ( byte [ ] <identifier> , int <identifier> , int length ) { \n \t2 try { \n \t3 return <identifier> != null ? <identifier> . <identifier> <identifiersep> from <identifiersep> <identifier> ( <identifier> : : new , <identifier> , <identifier> , length ) : null ; } \n \t2 catch ( exception ex ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> message ( ) ) ; } \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> file <identifiersep> path + <string_literal> ) ; } \n \t2 if ( ! <identifier> <identifiersep> import <identifiersep> result . get <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n \t3 for ( <identifier> <identifiersep> method <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> import <identifiersep> result . get <identifiersep> error ( ) ) { \n <ect>
\t1 bean <identifiersep> <identifier> < ? > <identifier> = root <identifiersep> <identifier> ; \n \t1 if ( path != null ) { \n \t2 <identifier> <identifiersep> property <identifiersep> value <identifier> <identifiersep> get <identifiersep> value = root <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> get <identifiersep> value ( path ) ; \n \t2 if ( <identifier> <identifiersep> get <identifiersep> value == null ) { \n <ect>
\t1 <identifier> = new <identifier> <identifiersep> <identifier> ( new output <identifiersep> stream <identifiersep> <identifier> ( out ) ) ; \n \t1 thread = new read <identifiersep> thread ( process . get <identifiersep> error <identifiersep> stream ( ) ) ; \n \t1 thread . start ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <comment> \n \t2 this . <identifier> <identifiersep> <identifier> <identifiersep> set = <identifier> <identifiersep> set . < long > builder ( ) . add <identifiersep> all ( <identifier> <identifiersep> for <identifiersep> <identifier> ) . build ( ) ; \n \t2 this . <identifier> <identifiersep> <identifier> <identifiersep> set = <identifier> <identifiersep> set . < long > builder ( ) . add <identifiersep> all ( <identifier> <identifiersep> for <identifiersep> <identifier> ) . build ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> set . is <identifiersep> empty ( ) ) { \n <ect>
\t3 if ( ! resource . exists ( ) ) { \n \t4 if ( <identifier> ) { \n \t5 throw new illegal <identifiersep> state <identifiersep> exception ( \n \t7 <string_literal> ) ; } \n <ect>
\t3 success = true ; \n \t2 } catch ( final exception e ) { \n \t3 success = false ; \n <ect>
\t2 if ( file != null && file . exists ( ) ) { \n \t3 file [ ] files = file . list <identifiersep> files ( ) ; \n \t3 if ( files != null ) { \n \t4 for ( file <identifier> : files ) { \n <ect>
\t1 { \n \t2 try { \n \t3 listener . on <identifiersep> channel <identifiersep> error ( exception ) ; } \n \t2 catch ( throwable t ) { \n <ect>
\t2 <comment> \n \t2 return field . get ( object ) ; } \n \t1 @ <identifier> \n \t1 public void set <identifiersep> field <identifiersep> value ( object object , field field , object value ) throws illegal <identifiersep> argument <identifiersep> exception , illegal <identifiersep> access <identifiersep> exception { \n <ect>
\t3 final list < <identifier> < string > > <identifier> = <identifier> . <identifier> <identifiersep> all ( <identifier> ) ; \n \t3 for ( final <identifier> < string > result : <identifier> ) { \n \t4 assert <identifiersep> not <identifiersep> null ( result . get ( ) ) ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t4 else if ( value <identifiersep> <identifier> instanceof byte [ ] ) \n \t5 value = ( byte [ ] ) value <identifiersep> <identifier> ; \n \t4 else \n \t4 { \n <ect>
\t2 if ( file . exists ( ) ) file . delete ( ) ; \n \t2 try ( file <identifiersep> output <identifiersep> stream out = new file <identifiersep> output <identifiersep> stream ( file ) ) { \n \t3 super . write ( out ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 protected abstract <identifiersep> task ( task <identifiersep> <identifier> task <identifiersep> <identifier> ) { \n <ect>
\t5 <identifier> . put ( <identifier> , <identifier> <identifiersep> message ) ; \n \t5 int size = <identifier> . size ( ) ; \n \t5 long <identifier> = <identifier> . <identifier> ( num <identifiersep> <identifier> <identifiersep> for / <number_literal> . 0 ) ; \n \t5 if ( size > <identifier> ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 private <identifier> <identifiersep> <identifier> ( ) \n \t1 { \n <ect>
\t1 public void end <identifiersep> unit ( unit <identifier> ) { \n \t2 int end <identifiersep> <identifier> <identifiersep> <identifier> = output ( ) . length ( ) - last <identifiersep> <identifier> ; \n \t2 <comment> \n \t2 if ( has <identifiersep> <identifier> ( <identifier> ) ) { \n <ect>
\t2 log . info ( <string_literal> + class <identifiersep> name + <string_literal> ) ; \n \t2 return false ; } \n \t1 @ <identifier> \n \t1 public boolean is <identifiersep> <identifier> ( ) { \n <ect>
\t3 logger . debug ( <string_literal> , options . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> host ( ) ) ; \n \t3 logger . debug ( <string_literal> , options . get <identifiersep> <identifier> <identifiersep> timeout ( ) ) ; \n \t3 logger . debug ( <string_literal> , options . get <identifiersep> max <identifiersep> wait <identifiersep> time ( ) ) ; \n \t3 logger . debug ( <string_literal> , options . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> for <identifiersep> connection <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 queue <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> <identifiersep> command ( job <identifiersep> id ) , lock <identifiersep> failure <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 log . warn ( <string_literal> + <string_literal> + e . get <identifiersep> message ( ) + <string_literal> \n \t5 + job <identifiersep> id + <string_literal> ) ; } \n \t2 finally { \n <ect>
\t2 logger . info ( <string_literal> + <identifier> . to <identifiersep> string ( <identifier> ) ) ; \n \t2 try { \n \t3 options <identifiersep> <identifier> . parse <identifiersep> options ( options , <identifier> ) ; \n \t3 logger . info ( <string_literal> + options . to <identifiersep> string ( ) + <string_literal> ) ; \n <ect>
\t3 list < string > delete <identifiersep> <identifier> = <identifier> <identifiersep> store <identifiersep> utils . get <identifiersep> key <identifiersep> list <identifiersep> from <identifiersep> id ( data , <identifier> <identifiersep> id ) ; \n \t3 <identifier> <identifiersep> store <identifiersep> utils . <identifier> <identifiersep> <identifier> ( delete <identifiersep> <identifier> , data . get <identifiersep> <identifier> <identifiersep> store ( ) , data . get <identifiersep> <identifier> <identifiersep> cluster <identifiersep> state ( ) ) ; \n \t3 log . info ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> type <identifiersep> argument ( ) . equals ( <identifier> . class ) ) { \n \t3 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> type <identifiersep> argument ( ) ) ; \n \t3 result = false ; } \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> type <identifiersep> argument ( ) . equals ( <identifier> . class ) ) { \n <ect>
\t1 <comment> \n \t1 array <identifiersep> list < string > get <identifiersep> <identifier> ( string <identifier> <identifiersep> path ) \n \t1 { \n \t2 logger . debug ( <string_literal> + <identifier> <identifiersep> path ) ; \n <ect>
\t3 if ( ! ( e instanceof last <identifiersep> error <identifiersep> exception ) ) \n \t4 logger . error ( <string_literal> , e ) ; \n \t3 last <identifiersep> error <identifiersep> exception <identifier> = ( last <identifiersep> error <identifiersep> exception ) e ; \n \t3 if ( <identifier> . get <identifiersep> error <identifiersep> code ( ) == <identifier> && is <identifiersep> <identifier> <identifiersep> system ( <string_literal> ) ) { \n <ect>
\t1 <identifier> . <identifier> <identifiersep> service <identifiersep> <identifier> <identifiersep> check ( ) ; \n \t1 } catch ( final <identifier> <identifiersep> execution <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t1 ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t4 int load = 0 ; \n \t4 for ( entry < string , string > entry : <identifier> ) { \n \t5 load ++ ; \n \t5 if ( load <identifier> 1 <identifiersep> 000 <identifiersep> 000 == 0 ) { \n <ect>
\t3 <identifier> <identifiersep> to <identifiersep> <identifier> = true ; \n \t2 else if ( <identifier> . is <identifiersep> blank <identifiersep> node <identifiersep> <identifier> ( node ) ) \n \t3 <identifier> <identifiersep> to <identifiersep> blank <identifiersep> nodes = true ; } \n \t1 public void <identifier> <identifiersep> to <identifiersep> blank <identifiersep> nodes ( ) { \n <ect>
\t3 } finally { \n \t4 try { \n \t5 builder . remove <identifiersep> <identifier> ( <identifier> , target <identifiersep> type , import <identifiersep> type <identifiersep> name ) ; \n \t4 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 if ( abstract <identifiersep> <identifier> <identifiersep> cluster <identifiersep> service . this . is <identifiersep> run <identifiersep> <identifier> ( ) ) { \n \t4 logger . debug ( <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> . start ( ) ; \n \t3 } else { \n <ect>
\t1 private void delete <identifiersep> <identifier> <identifiersep> properties ( final <identifier> < string > property <identifiersep> <identifier> ) { \n \t1 try ( final transaction <identifiersep> resource db = <identifier> . transaction <identifiersep> for ( static <identifiersep> <identifier> <identifiersep> property <identifiersep> entry . class ) ) { \n \t2 for ( final string property <identifiersep> name : property <identifiersep> <identifier> ) try { \n \t2 final static <identifiersep> <identifier> <identifiersep> property <identifiersep> entry property = <identifier> . <identifier> <identifiersep> result ( new static <identifiersep> <identifier> <identifiersep> property <identifiersep> entry ( null , property <identifiersep> name , null ) ) ; \n <ect>
<comment> \n \t1 public void <identifier> ( <identifier> <identifiersep> exception e ) throws <identifier> <identifiersep> exception \n \t1 { \n <ect>
\t2 <identifier> <identifiersep> output <identifiersep> stream = new <identifier> <identifiersep> output <identifiersep> stream ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> input <identifiersep> stream = new <identifier> <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> output <identifiersep> stream ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 public void run ( ) { \n \t5 try { \n \t6 <identifier> <identifiersep> output <identifiersep> file ( ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 to <identifiersep> be <identifiersep> <identifier> . add ( p ) ; } \n \t2 if ( p . request == null ) { \n \t3 log . warn ( <string_literal> + p ) ; \n \t2 } else if ( p . request . get <identifiersep> <identifier> ( ) . get <identifiersep> type ( ) == <identifier> <identifiersep> code . <identifier> ) { \t8 \n <ect>
\t7 } else { \n \t8 <identifier> . add <identifiersep> to <identifiersep> send <identifiersep> queue ( data ) ; } \n \t6 } else { \n \t7 if ( configuration <identifiersep> provider != null && ! configuration <identifiersep> provider . is <identifiersep> empty ( ) ) { \n <ect>
\t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n \t1 log . error ( <string_literal> + sql <identifiersep> e . to <identifiersep> string ( ) ) ; \n \t1 <identifier> ( <string_literal> + sql <identifiersep> e . to <identifiersep> string ( ) ) ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
\t2 try { \n \t3 registered <identifiersep> service <identifiersep> access <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> service <identifiersep> access <identifiersep> is <identifiersep> <identifier> ( service , registered <identifiersep> service ) ; \n \t3 return true ; \n \t2 } catch ( final <identifier> <identifiersep> service <identifiersep> exception e ) { \n <ect>
\t5 <identifier> . execute <identifiersep> update ( ) ; \n \t4 } else { \n \t5 <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t5 <identifier> . set <identifiersep> long ( 1 , <identifier> <identifiersep> <identifier> <identifiersep> id ) ; \n <ect>
\t4 . add <identifiersep> <identifier> <identifiersep> field ( <string_literal> , <identifier> <identifiersep> field ) \n \t4 . add <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> ) \n \t4 . get ( ) ; \n \t2 if ( <identifier> <identifiersep> response . get <identifiersep> failed <identifiersep> shards ( ) > 0 ) { \n <ect>
\t3 <identifier> <identifiersep> type = <identifier> <identifiersep> max <identifiersep> <identifier> <identifiersep> type . from <identifiersep> code ( message [ <number_literal> ] ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n \t3 logger . warn ( <string_literal> , message [ <number_literal> ] & <identifier> ) ; \n \t3 <identifier> <identifiersep> type = null ; } \n <ect>
\t3 assert <identifier> instanceof grid <identifiersep> <identifier> <identifiersep> event ; \n \t3 assert <identifier> . type ( ) == <identifier> <identifiersep> node <identifiersep> failed || <identifier> . type ( ) == <identifier> <identifiersep> node <identifiersep> <identifier> ; \n \t3 grid <identifiersep> <identifier> <identifiersep> event <identifier> <identifiersep> <identifier> = ( grid <identifiersep> <identifier> <identifiersep> event ) <identifier> ; \n <ect>
\t6 return <identifier> . <identifier> ; \n \t5 case <identifier> : \n \t6 return <identifier> . <identifier> ; } \n \t3 } catch ( throwable t ) { \n <ect>
\t4 return no <identifiersep> <identifier> ; } \n \t3 if ( ! this . <identifier> . is <identifiersep> <identifier> ( ) && method . get <identifiersep> <identifier> <identifiersep> class ( ) . is <identifiersep> interface ( ) && \n \t5 method . get <identifiersep> <identifier> <identifiersep> class ( ) . is <identifiersep> <identifier> <identifiersep> from ( <identifier> . class ) ) { \n <ect>
\t4 if ( in <identifiersep> type <identifiersep> name <identifiersep> to <identifiersep> <identifier> <identifiersep> name . contains <identifiersep> key ( <identifier> . get <identifiersep> type <identifiersep> name ( ) ) ) { \n \t5 if ( <identifier> . get <identifiersep> type <identifiersep> name ( ) != null ) { \n \t6 if ( ! ( <identifier> . get <identifiersep> type <identifiersep> name ( ) . equals ( <string_literal> ) ) \n \t7 && ( ! ( in <identifiersep> type <identifiersep> name <identifiersep> to <identifiersep> <identifier> <identifiersep> name . get ( <identifier> . get <identifiersep> type <identifiersep> name ( ) ) . equals ( <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ) ) ) { \n <ect>
\t6 if ( <identifier> . get <identifiersep> <identifier> ( ) == null ) { \n \t7 <identifier> . set <identifiersep> <identifier> ( new <identifier> <identifiersep> map < string , object > ( ) ) ; } \n \t6 <identifier> . get <identifiersep> <identifier> ( ) . put <identifiersep> all ( <identifier> ) ; } \n \t4 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> public <identifiersep> key <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> public <identifiersep> key <identifiersep> <identifier> ( <identifier> <identifiersep> bytes ) ; \n \t2 assert . assert <identifiersep> array <identifiersep> equals ( <identifier> <identifiersep> bytes , <identifier> . <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> public <identifiersep> key <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> public <identifiersep> key <identifiersep> <identifier> ( <identifier> . to <identifiersep> string ( ) ) ; \n \t2 assert . assert <identifiersep> equals ( <identifier> , <identifier> ) ; \n <ect>
\t1 } else if ( <string_literal> . equals <identifiersep> ignore <identifiersep> case ( value ) ) { \n \t1 log . debug ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> key ( ) , value ) ; \n \t1 return false ; \n \t1 } else { \n <ect>
\t2 if ( null == key <identifiersep> manager ) { \n \t3 log . <identifier> ( <string_literal> ) ; } \n \t2 close <identifiersep> default <identifiersep> key <identifiersep> manager ( ) ; \n \t2 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n <ect>
\t7 failed <identifiersep> <identifier> . remove ( url ) ; \n \t6 } catch ( throwable t ) { <comment> \n \t7 logger . warn ( <string_literal> + failed + <string_literal> + t . get <identifiersep> message ( ) , t ) ; } } \n \t4 } catch ( throwable t ) { <comment> \n <ect>
\t3 while ( ! interrupted ) { \n \t4 try { \n \t5 wait <identifiersep> state <identifiersep> <identifier> ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> . request <identifiersep> node <identifiersep> routing <identifiersep> info ( <identifier> . node <identifiersep> id ) ; \n \t4 break ; \n \t3 case <identifier> : \n \t4 <comment> \n <ect>
\t3 else { \n \t4 try { \n \t5 <identifier> . <identifier> ( ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t1 cache <identifiersep> manager . remove <identifiersep> from <identifiersep> <identifier> <identifiersep> cache ( wait <identifiersep> <identifier> ) ; } } \n <comment> \n public static string <identifier> ( final i <identifiersep> <identifier> <identifiersep> session session , final string class <identifiersep> name ) { \n \t1 if ( debug ) { \n <ect>
\t4 } catch ( exception ignore ) { } } \n \t3 if ( ! is <identifiersep> <identifier> ( ) ) { \n \t4 on <identifiersep> <identifier> <identifiersep> error ( e ) ; \n \t3 } else if ( ! is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 } else { \n \t4 if ( <identifier> == null ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + host <identifiersep> id + <string_literal> + <identifier> <identifiersep> node <identifiersep> id + <string_literal> ) ; \n \t4 } else { \n <ect>
\t5 <identifier> <identifiersep> command = <string_literal> ; \n \t4 else \n \t5 <identifier> <identifiersep> command = <string_literal> ; \n \t4 session <identifier> = conn . <identifier> <identifiersep> session ( ) ; \n <ect>
\t2 assert <identifiersep> true ( <identifier> . is <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 <identifier> . stop ( ) ; \n \t2 while ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 } catch ( <identifier> <identifiersep> session <identifiersep> exception e ) { \n \t6 <identifier> <identifiersep> log . error ( <string_literal> , e ) ; } } } \n \t2 public void <identifier> ( <identifier> <identifiersep> session session ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 http <identifiersep> <identifier> <identifiersep> response <identifiersep> <identifier> response = action . response ; \n \t2 if ( action . <identifier> ) \n \t2 { \n \t3 if ( action . content <identifiersep> type != null ) \n <ect>
\t7 <comment> \n \t7 <comment> \n \t7 final int <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) - 1 ; <comment> \n \t7 final boolean <identifier> = create <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> , <identifier> , context ) ; \n <ect>
\t6 | ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <identifier> + <number_literal> ) ) ; \n \t4 logger . debug ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) ) ; \n \t4 logger . debug ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) , this . <identifier> <identifiersep> <identifier> ) ; \n \t4 logger . debug ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) , this . max <identifiersep> <identifier> ) ; \n <ect>
\t4 ( <identifier> <identifiersep> object <identifiersep> builder < body > ) builder <identifiersep> factory . get <identifiersep> builder ( body . default <identifiersep> element <identifiersep> name ) ; \n \t2 final body body = body <identifiersep> builder . build <identifiersep> object ( \n \t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , body . default <identifiersep> element <identifiersep> local <identifiersep> name , <identifier> <identifiersep> <number_literal> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( ! body . get <identifiersep> <identifier> <identifiersep> xml <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t7 message message = <identifier> <identifiersep> message ( session , integer . to <identifiersep> string ( i ) , <identifier> ) ; \n \t7 <identifier> . send ( message ) ; \n \t7 session . <identifier> ( ) ; \n \t7 <identifier> <identifiersep> <identifier> ++ ; \n <ect>
\t2 <identifier> <identifiersep> endpoint <identifier> = <identifier> . get <identifiersep> endpoint ( <string_literal> , <identifier> <identifiersep> endpoint . class ) ; \n \t2 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> message <identifiersep> count ( <number_literal> ) ; \n \t2 <identifier> . assert <identifiersep> is <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . stop ( ) ; \n <ect>
\t3 if ( <identifier> < <identifier> ) { \n \t4 assert <identifiersep> that ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t4 assert <identifiersep> that ( <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ) ; } \n \t3 else { \n <ect>
\t4 case <identifier> <identifiersep> key <identifiersep> <identifier> : \n \t5 handle <identifiersep> <identifier> <identifiersep> key <identifiersep> response ( <identifier> <identifiersep> key , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> key , <identifier> . <identifier> <identifiersep> key <identifiersep> version , <identifier> ) ; \n \t5 break ; \n \t4 default : \n <ect>
\t4 <identifier> <identifiersep> client = <identifier> <identifiersep> store <identifiersep> utils . create <identifiersep> <identifier> <identifiersep> client ( conf ) ; \n \t4 <identifier> <identifiersep> <identifier> = <identifier> . new <identifiersep> array <identifiersep> list ( <identifier> <identifiersep> store <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( <identifier> <identifiersep> client , key ) ) ; \n \t4 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 model <identifiersep> <identifier> <identifiersep> path = model <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ; } \n \t2 <comment> \n \t2 file model <identifiersep> json <identifiersep> file = <identifier> <identifiersep> file ( model <identifiersep> json <identifiersep> path ) ; \n \t2 if ( model <identifiersep> json <identifiersep> file == null || ! model <identifiersep> json <identifiersep> file . exists ( ) ) { \n <ect>
\t4 } else if ( <identifier> != null ) { \n \t5 list = new <identifier> <identifiersep> list ( ( collection ) <identifier> ) ; \n \t4 } else { \n \t5 return null ; } \n <ect>
\t4 <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> set ( ) ; \n \t4 <identifier> . put ( ( ( key <identifiersep> <identifier> ) <identifier> . get <identifiersep> key ( ) ) . get <identifiersep> table <identifiersep> id ( ) . to <identifiersep> string ( ) , <identifier> <identifiersep> <identifier> ) ; } } \n \t3 log . error ( <string_literal> , <identifier> ) ; } \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . size ( ) > 0 ) { \n <ect>
\t2 assert <identifiersep> that ( state <identifiersep> response . get <identifiersep> state ( ) . meta <identifiersep> data ( ) . index ( <string_literal> ) . get <identifiersep> state ( ) , equal <identifiersep> to ( index <identifiersep> meta <identifiersep> data . state . <identifier> ) ) ; \n \t2 assert <identifiersep> that ( state <identifiersep> response . get <identifiersep> state ( ) . routing <identifiersep> table ( ) . index ( <string_literal> ) . shards ( ) . size ( ) , equal <identifiersep> to ( num <identifiersep> shards . num <identifiersep> <identifier> ) ) ; \n \t2 assert <identifiersep> equals ( state <identifiersep> response . get <identifiersep> state ( ) . routing <identifiersep> table ( ) . index ( <string_literal> ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) \n \t3 , num <identifiersep> shards . total <identifiersep> num <identifiersep> shards ) ; \n <ect>
\t4 if ( check <identifiersep> if <identifiersep> device <identifiersep> exists ( <identifier> <identifiersep> device <identifiersep> property <identifiersep> path ) ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> connection . get <identifiersep> connection ( ) . write ( <identifier> <identifiersep> device <identifiersep> property <identifiersep> path , <identifier> <identifiersep> value ) ; \n \t5 return ; <comment> \n \t4 } else { \n <ect>
\t1 @ <identifier> \n \t1 protected map < string , object > get <identifiersep> principal <identifiersep> attributes ( final principal p ) { \n \t2 try { \n \t3 return this . cache . get ( p . get <identifiersep> id ( ) , s - > { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ; \n \t5 try { \n \t6 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> log <identifiersep> file ( ) , <identifier> <identifiersep> by ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 return ; } \n \t2 <identifier> <identifier> = context . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( to . equals ( <identifier> ) ) { \n \t3 if ( log . should <identifiersep> log ( log . error ) ) \n <ect>
\t3 result . <identifier> = ( thrift <identifiersep> table <identifiersep> operation <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> is <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t9 throw new runtime <identifiersep> exception ( e ) ; } } \n \t7 @ <identifier> \n \t7 public void handle <identifiersep> exception ( transport <identifiersep> exception <identifier> ) { \n \t8 try { \n <ect>
\t2 process <identifiersep> event . <identifier> ( <string_literal> ) ; \n \t2 int id = <identifier> . get <identifiersep> and <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> id ( id ) ; \n \t2 collection . put ( id , <identifier> ) ; \n <ect>
\t2 for ( int i = 0 ; i < <identifier> ; i ++ ) { \n \t3 assert <identifiersep> <identifier> <identifiersep> count ( <identifier> <identifiersep> <identifier> [ i ] , number <identifiersep> of <identifiersep> <identifier> ) ; } } \n \t1 private void log <identifiersep> <identifier> <identifiersep> response ( int number <identifiersep> of <identifiersep> shards , long number <identifiersep> of <identifiersep> <identifier> , int <identifier> , <identifier> <identifiersep> response <identifier> <identifiersep> response ) { \n \t2 logger . info ( <string_literal> , <identifier> , <identifier> <identifiersep> response . get <identifiersep> <identifier> <identifiersep> shards ( ) , number <identifiersep> of <identifiersep> shards ) ; \n <ect>
<comment> \n \t1 public static <identifier> <identifiersep> <identifier> <identifiersep> filter build <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> filter ( final resource <identifier> <identifiersep> resource <identifiersep> location ) throws exception { \n \t2 if ( ! resource <identifiersep> utils . <identifier> <identifiersep> resource <identifiersep> <identifier> ( <identifier> <identifiersep> resource <identifiersep> location ) ) { \n <ect>
\t1 if ( ! current <identifiersep> transaction . is <identifiersep> <identifier> ( ) ) { \n \t1 runtime <identifiersep> exception e = new runtime <identifiersep> exception ( <string_literal> \n \t2 + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> + \n \t2 <string_literal> ) ; \n <ect>
\t3 false , false ) ; \n \t1 assert <identifiersep> true ( <identifier> <identifiersep> <identifier> != null ) ; \n \t1 } catch ( exception <identifier> ) { \n \t1 assert <identifiersep> true ( <string_literal> , false ) ; \n <ect>
\t4 all . put ( entry . get <identifiersep> key ( ) , <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 <comment> \n \t2 m <identifiersep> log . info ( <string_literal> , m <identifiersep> <identifier> . size ( ) ) ; \n <ect>
\t1 stop <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 <identifier> . <identifier> ( new <identifier> <identifiersep> <identifier> ( <identifier> , job <identifiersep> id . or <identifiersep> null ( ) , is <identifiersep> <identifier> ( ) ) , self ( ) ) ; } \n private void <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( ) { \n \t1 this . <identifier> = false ; \n <ect>
\t2 while ( true ) { \n \t3 try { \n \t4 collection < grid <identifiersep> node > <identifier> <identifiersep> nodes = <identifier> . <identifier> ( ) . <identifier> ( ) . nodes ( <identifier> . <identifier> ( ) , <identifier> . <identifier> <identifiersep> version ( ) ) ; \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; } \n \t1 public static void <identifier> ( ) { \n <ect>
\t2 catch ( io <identifiersep> exception e ) { \n \t3 throw new grid <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> <identifier> , e ) ; } \n \t3 log . debug ( config <identifiersep> info ( <string_literal> , <identifier> <identifiersep> host . get <identifiersep> host <identifiersep> address ( ) ) ) ; \n <ect>
\t3 { \n \t4 logger . info ( <string_literal> + request . get <identifiersep> remote <identifiersep> <identifier> ( ) ) ; } \n \t3 else \n \t3 { \n <ect>
\t3 answer = get <identifiersep> authentication <identifiersep> <identifier> ( ) . to <identifiersep> authentication ( <identifier> ) ; } \n \t2 <comment> \n \t2 if ( answer == null && <identifier> <identifiersep> thread <identifiersep> security <identifiersep> context ) { \n \t3 answer = security <identifiersep> context <identifiersep> <identifier> . get <identifiersep> context ( ) . get <identifiersep> authentication ( ) ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 return null ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 task . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> job <identifiersep> <identifier> . <identifier> <identifiersep> task ( job , task , <identifier> <identifiersep> code ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t1 string <identifier> <identifiersep> id = null ; \n \t1 try { \n \t2 <identifier> <identifiersep> id = input . get <identifiersep> instance <identifiersep> type ( ) . <identifier> <identifiersep> root ( ) . get <identifiersep> id ( ) ; \n \t1 } catch ( final exception <identifier> ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t5 try { \n \t6 current <identifiersep> value = <identifier> . parse <identifiersep> object ( ( string ) current <identifiersep> value ) ; \t1 \n \t5 } catch ( java . text . parse <identifiersep> exception ex ) { \n <ect>
\t3 } ) ) ; } \n \t2 assert <identifiersep> true ( <string_literal> , wait . wait <identifiersep> for ( new wait . <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t4 throw new server <identifiersep> api <identifiersep> exception ( base <identifiersep> cmd . <identifier> <identifiersep> action <identifiersep> error , <string_literal> + command <identifiersep> name + <string_literal> ) ; } \n \t3 <comment> \n \t3 <identifier> <identifiersep> key = user . get <identifiersep> <identifier> <identifiersep> key ( ) ; \n \t3 if ( <identifier> <identifiersep> key == null ) { \n <ect>
\t2 return super . delete ( <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> find ( <identifier> <identifier> ) \n \t1 { \n <ect>
\t4 while ( ! shutdown <identifiersep> <identifier> ) { \n \t5 <identifier> = msg <identifiersep> <identifier> . <identifier> ( <number_literal> ) ; \n \t5 if ( <identifier> != null ) { \n <ect>
\t1 private void handle <identifiersep> password <identifiersep> <identifier> ( password <identifiersep> <identifier> <identifier> ) { \n \t2 log . warn ( <string_literal> + user <identifiersep> name ) ; } \n \t1 private void handle <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 string authentication <identifiersep> id = <identifier> . get <identifiersep> authentication <identifiersep> id ( ) ; \n <ect>
\t1 { \n \t2 load <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> shutdown <identifiersep> client ( <identifier> <identifiersep> client , <identifier> <identifiersep> log ) ; } } \n \t1 catch ( exception e ) \n \t1 { \n <ect>
\t2 return new file <identifiersep> system <identifiersep> resource ( new file ( metadata <identifiersep> location , <string_literal> ) ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n \t2 if ( ! this . metadata <identifiersep> location . exists ( ) ) { \n <ect>
public class application extends <identifier> <identifiersep> application { \n \t1 public static void <identifier> ( string [ ] <identifier> ) { \n \t2 <identifier> <identifiersep> application . <identifier> ( <identifier> , application . class ) ; } \n \t1 public application ( ) { \n <ect>
\t4 log . debug ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 } else if ( state . get ( ) == state <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 if ( failure <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 if ( method . is <identifiersep> <identifier> ( ) ) \n \t1 { \n \t2 continue ; } \n \t1 add <identifiersep> action <identifiersep> resource <identifiersep> method ( action <identifiersep> resource <identifiersep> model , method ) ; } \n <ect>
\t4 logger . debug ( <string_literal> + source <identifiersep> name ) ; \n \t4 if ( source <identifiersep> id . <identifier> ( ) . length ( ) > 0 ) \n \t5 source <identifiersep> list . add ( new data <identifiersep> source ( source <identifiersep> id , source <identifiersep> name ) ) ; \n \t4 else \n <ect>
\t2 <identifier> . add ( exception ) ; } } \n \t1 <comment> \n \t1 <comment> \n \t1 <comment> \n <ect>
\t3 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( 0 ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . get ( 0 ) . <identifier> <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; \n <ect>
\t3 string <identifier> ; \n \t3 while ( ( <identifier> = in . read <identifiersep> line ( ) ) != null ) { \n \t4 <identifier> . <identifier> ( <identifier> . <identifier> ( ) ) ; \n \t4 <identifier> . <identifier> ( <string_literal> ) ; } } \n <ect>
\t1 public list < <identifier> > get <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> == null ) { \n \t3 <identifier> = new <identifiersep> array <identifiersep> list ( ) ; \n \t3 for ( <identifier> <identifiersep> <identifier> <identifiersep> provider <identifier> <identifiersep> provider : get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 break ; } } \n \t2 try { <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( this ) ; } \n \t2 catch ( runtime <identifiersep> exception ex ) { \n \t3 if ( is <identifiersep> io <identifiersep> exception ( ex ) ) \n <ect>
\t1 } else { \n \t1 <identifier> = new <identifier> <identifiersep> context ( ) ; } \n \t1 log <identifiersep> log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> name + <string_literal> ) ; \n \t1 <identifier> <identifiersep> connection <identifiersep> factory = ( <identifier> <identifiersep> connection <identifiersep> factory ) <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> name ) ; \n <ect>
\t1 @ <identifier> <identifiersep> throws \n \t1 public void handle <identifiersep> request ( final http <identifiersep> <identifier> <identifiersep> request request , final http <identifiersep> <identifier> <identifiersep> response response ) throws exception { \n \t2 response . set <identifiersep> content <identifiersep> type ( <identifier> <identifiersep> type . text <identifiersep> <identifier> <identifiersep> value ) ; \n \t2 if ( ! <identifier> <identifiersep> access <identifiersep> token <identifiersep> request ( request , response ) ) { \n <ect>
\t4 <comment> \n \t4 return ; } \n \t3 <identifier> . failed = true ; \n \t2 } else { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t2 <identifier> <identifiersep> service . get <identifiersep> <identifier> ( ) . <identifier> ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> service . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> ( true ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 logger . error ( <string_literal> , e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n \t4 logger . error ( <string_literal> , e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 logger . error ( <identifier> . to <identifiersep> string ( ) ) ; } } \n \t2 } ; \n \t2 t . start ( ) ; \n \t2 <identifier> . <identifier> ( ) ; \n <ect>
\t1 assert <identifiersep> false ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n \t1 boolean <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . has <identifiersep> next ( ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> ) { \n \t1 while ( <identifier> <identifiersep> <identifier> . has <identifiersep> next ( ) ) { \n <ect>
\t3 context . get <identifiersep> <identifier> <identifiersep> properties ( \n \t3 http <identifiersep> source <identifiersep> configuration <identifiersep> <identifier> . config <identifiersep> handler <identifiersep> <identifier> ) ; \n \t1 handler . <identifier> ( new context ( <identifier> <identifiersep> <identifier> ) ) ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
\t6 log . error ( <string_literal> + node <identifiersep> id ) ; \n \t6 error . set ( true ) ; \n \t6 return false ; } \n \t5 if ( ! msg <identifiersep> <number_literal> . equals ( msg ) ) { \n <ect>
\t3 if ( <identifier> . <identifier> ( time <identifiersep> unit . <identifier> ) > <identifier> <identifiersep> <identifier> <identifiersep> millis ) { \n \t4 <identifier> . <identifier> ( ) . start ( ) ; \n \t4 return true ; } \n <ect>
\t2 long <identifier> <identifiersep> template <identifiersep> id = <identifier> <identifiersep> volume . get <identifiersep> template <identifiersep> id ( ) ; \n \t2 long vm <identifiersep> template <identifiersep> id = vm . get <identifiersep> template <identifiersep> id ( ) ; \n \t2 if ( <identifier> <identifiersep> template <identifiersep> id != null && <identifier> <identifiersep> template <identifiersep> id . long <identifiersep> value ( ) != vm <identifiersep> template <identifiersep> id ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifier> = context . get <identifiersep> <identifier> <identifiersep> service ( ) . get <identifiersep> <identifier> ( integer . value <identifiersep> of ( id <identifiersep> number ) ) ; \n \t4 return <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ; } \n \t3 catch ( exception e ) { \n <ect>
\t2 return new org . apache . thrift . <identifier> . <identifier> <identifiersep> method <identifiersep> <identifier> < void > ( ) { \n \t2 public void on <identifiersep> <identifier> ( void o ) { } \n \t2 public void on <identifiersep> error ( java . <identifier> . exception e ) { \n \t3 if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t5 state <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new state <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> + <identifier> <identifiersep> info ) ; \n \t5 context . get ( <identifier> <identifiersep> <identifier> . class ) . <identifier> <identifiersep> state ( <identifier> <identifiersep> <identifier> ) ; \n \t5 return false ; \n \t4 } else { \n <ect>
\t4 . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> event <identifiersep> <identifier> . class . get <identifiersep> <identifier> <identifiersep> name ( ) ) \n \t4 . <identifier> ( <string_literal> ) ; \n \t2 @ <identifier> \n \t2 public void on <identifiersep> field <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t1 <identifier> . <identifier> ( ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t1 <comment> \n \t1 <comment> \n <ect>
\t2 } catch ( exception <identifier> ) { \n \t2 log . warn ( <string_literal> \n \t3 + string <identifiersep> utils . <identifier> <identifiersep> exception ( <identifier> ) ) ; } \n \t2 set <identifiersep> <identifier> ( true ) ; \n <ect>
\t3 } catch ( <identifier> <identifiersep> session <identifiersep> exception e ) { \n \t4 <identifier> <identifiersep> log . error ( <string_literal> , e ) ; \n \t4 close ( ) ; } } \n \t2 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> session session , int <identifier> ) { \n <ect>
\t2 { \n \t3 string s = <string_literal> ; \n \t3 for ( int i = 0 ; i < <number_literal> && i < <identifier> ; i ++ ) \n \t4 s += string . format ( <string_literal> , data [ <identifier> + i ] ) ; \n <ect>
\t2 logger . debug ( string . format ( <string_literal> , name , <identifier> <identifiersep> path ) ) ; } \n \t1 final file <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> native <identifiersep> <identifier> ( name , <identifier> <identifiersep> path ) ; \n \t1 <identifier> <identifiersep> path = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception error ) { \n \t3 logger . error ( <string_literal> , error ) ; \n \t3 throw error ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 string <identifier> <identifiersep> file <identifiersep> name = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> name ( <identifier> <identifiersep> id ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> id ) ; \n \t2 <identifier> <identifiersep> utils . <identifier> ( local <identifiersep> path . to <identifiersep> uri ( ) . get <identifiersep> path ( ) , file <identifiersep> <identifier> , <identifier> <identifiersep> file <identifiersep> name ) ; \n \t2 path <identifier> <identifiersep> path = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> path ( local <identifiersep> path , <identifier> <identifiersep> id ) ; \n <ect>
\t3 process <identifiersep> <identifier> ( request <identifiersep> event , server <identifiersep> transaction <identifiersep> id ) ; \n \t2 } else if ( request . get <identifiersep> method ( ) . equals ( request . <identifier> ) ) { \n \t3 process <identifiersep> <identifier> ( request <identifiersep> event , server <identifiersep> transaction <identifiersep> id ) ; \n \t2 } else { \n <ect>
\t1 else { \n \t2 add <identifiersep> object <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> <identifier> <identifiersep> group . <identifier> <identifiersep> key ) ; } } \n public void remove <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . model . <identifier> <identifiersep> event object ) { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> meta <identifiersep> from <identifiersep> cache ( <identifier> , <identifier> <identifiersep> context ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> meta <identifiersep> from <identifiersep> remote ( <identifier> , <identifier> <identifiersep> context ) ; \n \t4 } catch ( exception <identifier> ) { \n <ect>
\t1 throw new <identifier> <identifiersep> exception ( create <identifiersep> static <identifiersep> message ( <string_literal> + <identifier> ) , e ) ; } } \n @ <identifier> \n public void <identifier> ( t <identifier> , <identifier> < properties > <identifier> <identifiersep> properties ) throws <identifier> <identifiersep> exception { \n <ect>
\t3 connection <identifiersep> <identifier> <identifiersep> <identifier> . assert <identifiersep> no <identifiersep> <identifier> ( ) ; } } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> status <identifiersep> <identifier> . is <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . instance . get <identifiersep> transaction <identifiersep> manager ( ) ) ) { \n <ect>
\t4 log . error ( <string_literal> , e ) ; \n \t4 error ( e . get <identifiersep> message ( ) , <identifier> . error . error <identifiersep> code . <identifier> <identifiersep> transaction , close <identifiersep> <identifier> . remote <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message ) ; \n \t4 return ; \n \t3 } catch ( value <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t2 <identifier> <identifiersep> with <identifiersep> timeout ( close <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> connection <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifier> <identifiersep> error ( \n \t6 <string_literal> <identifier> transaction ) \n \t4 self . <identifier> . <identifier> [ transaction ] . <identifier> ( <identifier> ) \n \t2 <identifier> exception as e : \n <ect>
\t1 protected boolean <identifier> <identifiersep> <identifier> = false ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> element <identifier> <identifiersep> <identifier> <identifiersep> element ; \n \t1 list < network <identifiersep> element > network <identifiersep> <identifier> ; \n \t1 public <identifier> <identifiersep> server <identifiersep> <identifier> ( ) { \n <ect>
\t3 node <identifiersep> exists <identifiersep> policy . <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n \t1 } catch ( exception ex ) { \n \t2 <comment> \n <ect>
\t2 model . add <identifiersep> attribute ( <string_literal> , default <identifiersep> <identifier> ) ; \n \t2 try { \n \t3 get <identifiersep> current <identifiersep> user ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n \t2 final cluster <identifiersep> state state = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> state ( ) . get ( ) . get <identifiersep> state ( ) ; \n \t2 <identifier> <identifiersep> node <identifier> <identifiersep> node = state . nodes ( ) . get ( state . get <identifiersep> routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( 0 ) . <identifier> <identifiersep> <identifier> ( ) . current <identifiersep> node <identifiersep> id ( ) ) ; \n <ect>
\t2 return <identifier> <identifiersep> result . result ; } \n \t1 <comment> \n \t1 <identifier> <identifiersep> with <identifiersep> <identifier> ( conf . get <identifiersep> int <identifiersep> <identifier> ( <identifier> <identifiersep> conf . conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> thrift <identifiersep> client <identifiersep> connection <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; \n \t1 if ( <identifier> >= <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 <identifier> . add ( <identifier> . v ( ) . new <identifiersep> return <identifiersep> <identifier> ( <identifier> ) ) ; } \n \t2 if ( is <identifiersep> <identifier> ( ) ) { \n \t3 logger . info ( <string_literal> , <identifier> . get <identifiersep> name ( ) , new <identifiersep> method . get <identifiersep> name ( ) , <identifier> ) ; } \n \t2 if ( <identifier> . size ( ) < <number_literal> ) { \n <ect>
\t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) \n \t3 assert . assert <identifiersep> equals ( i , ( int ) empty . get ( i ) ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t2 string template <identifiersep> <identifier> = template . get <identifiersep> path ( template <identifiersep> name ) . to <identifiersep> string ( ) ; \n \t2 string template ; \n \t2 try { template = file <identifiersep> utils . read <identifiersep> <identifier> <identifiersep> file <identifiersep> as <identifiersep> <identifier> ( template <identifiersep> <identifier> ) ; } \n \t2 catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 return result ; } \n \t1 protected void handle <identifiersep> metadata <identifiersep> <identifier> <identifiersep> exception ( <identifier> <identifiersep> context context , throwable exception ) { \n \t2 final string [ ] <identifier> <identifiersep> <identifier> = context . get <identifiersep> config ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> . length < 1 ) { \n <ect>
\t4 do <identifiersep> count = true ; \n \t4 long <identifier> <identifiersep> value = db <identifiersep> <identifier> . add <identifiersep> and <identifiersep> get ( - <identifier> . get ( ) ) ; \n \t4 do <identifiersep> <identifier> = true ; \n \t4 log . info ( <string_literal> + this ) ; \n <ect>
\t7 <identifier> . new <identifiersep> <identifier> <identifiersep> thread <identifiersep> <identifier> ( ) . execute ( new <identifier> ( ) { \n \t8 @ <identifier> \n \t8 public void run ( ) { \n \t9 try { \n <ect>
\t2 if ( test <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t3 add <identifiersep> test <identifiersep> <identifier> ( test <identifiersep> <identifier> <identifiersep> <identifier> ) ; } } \n \t1 public void import <identifiersep> test <identifiersep> <identifier> ( ) { \n \t2 add <identifiersep> test <identifiersep> <identifier> ( ) ; \n <ect>
\t1 private void <identifier> <identifiersep> file <identifiersep> manager ( ) throws class <identifiersep> not <identifiersep> found <identifiersep> exception { \n \t2 if ( <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> file <identifiersep> manager ) ) { \n \t3 final string file <identifiersep> manager <identifiersep> class <identifiersep> name = <identifier> <identifiersep> <identifier> . get ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> file <identifiersep> manager ) ; \n \t3 final class < file <identifiersep> manager > file <identifiersep> manager <identifiersep> class = ( class < file <identifiersep> manager > ) class . for <identifiersep> name ( file <identifiersep> manager <identifiersep> class <identifiersep> name ) ; \n <ect>
<identifier> <identifiersep> <identifier> <identifiersep> handler ( <identifier> <identifiersep> event event ) { \n \t1 super ( event ) ; } \n @ <identifier> \n public void handle ( context <identifier> <identifiersep> context ) throws exception { \n <ect>
\t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> response <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , \n \t5 <identifier> . get <identifiersep> name ( ) , e . get <identifiersep> message ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> timeout <identifiersep> exception e ) { \n <ect>
\t2 try : \n \t3 try : \n \t4 <identifier> <identifiersep> host ( ) . <identifier> <identifiersep> get <identifiersep> <identifier> <identifiersep> id <identifiersep> by <identifiersep> name ( vm <identifiersep> name ) \n \t3 <identifier> no <identifiersep> vm <identifiersep> found <identifiersep> exception , e : \n <ect>
\t4 return null ; } } \n \t2 if ( user != null ) { \n \t3 <comment> \n \t3 if ( user . get <identifiersep> id ( ) == user . <identifier> <identifiersep> system ) { \n <ect>
\t4 && ( network . get <identifiersep> <identifier> <identifiersep> type ( ) == network . <identifier> <identifiersep> type . <identifier> || network . get <identifiersep> <identifier> <identifiersep> type ( ) == network . <identifier> <identifiersep> type . <identifier> && <identifier> . get <identifiersep> network <identifiersep> type ( ) == network <identifiersep> type . <identifier> ) ) { \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( network . get <identifiersep> id ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> default <identifiersep> policy ( ) , true ) ; } \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> , false , <identifier> ) ) { \n <ect>
\t3 task . <identifier> ( source <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t3 task . run ( false ) ; \n \t3 log . info ( <string_literal> ) ; \n \t3 task . <identifier> ( ) ; \n <ect>
\t1 logger . debug ( <string_literal> + ++ i ) ; \n \t1 root . debug ( <string_literal> + i ) ; \n \t1 logger . info ( <string_literal> + ++ i ) ; \n \t1 root . info ( <string_literal> + i ) ; \n <ect>
\t3 <identifier> . <identifier> ( ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t3 map < string , string > <identifier> = <identifier> <identifiersep> data <identifiersep> store . get <identifiersep> all <identifiersep> <identifier> ( <identifier> <identifiersep> path ) ; \n \t3 if ( ( <identifier> == null ) || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 string out <identifiersep> file = ( string ) attributes . get ( <string_literal> ) ; \n \t3 if ( out <identifiersep> file == null ) { \n \t4 out <identifiersep> file = <string_literal> ; } \n \t3 if ( name == null || start == null || end == null || <identifier> == null || <identifier> == null || host <identifiersep> id == null || <identifier> == null || password == null ) { \n <ect>
\t2 if ( log <identifiersep> <identifier> ) logger . <identifier> ( this , <string_literal> + m ) ; \n \t2 long <identifier> = long . value <identifiersep> of ( id ) ; \n \t2 <identifier> <identifiersep> context <identifier> = <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n \t3 <identifier> = <identifier> . as <identifiersep> list ( <string_literal> , <string_literal> ) ; } \n \t2 logger . debug ( <string_literal> , <identifier> ) ; \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t1 if ( <identifier> == null ) { \n \t1 log . error ( <string_literal> ) ; \n \t1 return null ; } \n \t1 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t5 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t4 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t4 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifier> = <identifier> . builder ( ) . put ( <string_literal> , \n \t3 <identifier> . collection <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( <identifier> <identifiersep> nodes ) ) . build ( ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> update <identifiersep> <identifier> ( ) . set <identifiersep> transient <identifiersep> <identifier> ( <identifier> ) . get ( ) ; \n <ect>
\t1 protected synchronized long get <identifiersep> store <identifiersep> message <identifiersep> size ( ) { \n \t2 try { \n \t3 return store . get <identifiersep> message <identifiersep> size ( client <identifiersep> id , <identifier> <identifiersep> name ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 session = conn . create <identifiersep> session ( false , session . <identifier> <identifiersep> <identifier> ) ; \n \t4 <identifier> = session . create <identifiersep> <identifier> ( <identifier> ) ; \n \t4 start ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . remove ( path ) \n \t2 <identifier> : \n \t3 logger . warn ( <string_literal> . format ( path , <identifier> ( <identifier> . <identifier> <identifiersep> info ( ) [ 0 ] ) ) ) \n \t2 else : \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> response ( <identifier> <identifiersep> result ) ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> . set <identifiersep> text ( e . to <identifiersep> string ( ) ) ; \n <ect>
\t1 @ <identifier> \n \t1 protected list < object > filter <identifiersep> attribute <identifiersep> values <identifiersep> by <identifiersep> <identifier> ( final set < object > attribute <identifiersep> values , final <identifier> <identifier> ) { \n \t2 return attribute <identifiersep> values . stream ( ) \n \t4 . filter ( v - > { \n <ect>
\t6 . put ( <string_literal> , <identifier> <identifiersep> <identifier> ? <string_literal> : <string_literal> ) \n \t6 . put ( <string_literal> , <identifier> <identifiersep> snapshot ? <string_literal> : <string_literal> ) ) ) ; \n \t2 create <identifiersep> index ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 return null ; } \n \t2 try { \n \t3 <identifier> = conn . list <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } catch ( final <identifier> <identifiersep> exception e ) { \n <ect>
\t2 private final log logger = log <identifiersep> factory . get <identifiersep> log ( <identifier> <identifiersep> error <identifiersep> handler . class ) ; \n \t2 @ <identifier> \n \t2 public void handle <identifiersep> error ( throwable t ) { \n \t3 if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t6 <identifier> <identifiersep> log . warn ( <string_literal> + timeout <identifiersep> <identifier> + <string_literal> + this + <string_literal> + <identifier> <identifiersep> timeout ) ; \n \t5 return ; } \n \t4 if ( <identifier> && ( <identifier> + timeout <identifiersep> <identifier> ) < <identifier> <identifiersep> next <identifiersep> run ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t4 ( <identifier> instanceof <identifier> ) ) { \n \t4 try { \n \t5 ( ( <identifier> ) <identifier> ) . start ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 public static final <identifier> <identifiersep> manager <identifiersep> factory instance = new <identifier> <identifiersep> <identifier> <identifiersep> manager <identifiersep> factory ( ) ; \n \t1 private static final <identifier> <identifiersep> manager <identifier> = new <identifier> <identifiersep> manager ( ) { \n \t2 @ <identifier> \n \t2 public void check <identifiersep> client <identifiersep> <identifier> ( <identifier> [ ] <identifier> , string s ) { \n <ect>
\t3 client <identifiersep> id = 1 ; \n \t3 message = data . <identifier> ( 1 ) ; } \n \t2 if ( ! message . contains ( <string_literal> ) ) { \n \t3 message += <string_literal> + <identifier> <identifiersep> format . format ( message <identifiersep> utils . <identifier> ( message ) ) + ' \\ <identifier> ; } \n <ect>
\t5 logger . error ( <string_literal> + stack <identifiersep> object . get <identifiersep> id ( ) + <string_literal> + stack <identifiersep> object . get <identifiersep> source <identifiersep> id ( ) + <string_literal> + stack <identifiersep> object . get <identifiersep> name ( ) ) ; } \n \t4 <identifier> <identifiersep> object = <identifier> . get <identifiersep> last <identifiersep> <identifier> <identifiersep> <identifier> ( source <identifiersep> id , <identifier> . stack ) ; \n \t4 if ( <identifier> <identifiersep> object != null ) { \n \t5 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> object . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t1 logger . trace ( <string_literal> + ++ i ) ; \n \t1 root . trace ( <string_literal> + ++ i ) ; \n \t1 logger . debug ( <string_literal> + ++ i ) ; \n \t1 root . debug ( <string_literal> + ++ i ) ; \n <ect>
\t4 <identifier> . for <identifiersep> <identifier> ( message <identifiersep> <identifier> : : put <identifiersep> if <identifiersep> <identifier> ) ; } \n \t3 return this . message <identifiersep> <identifier> . to <identifiersep> message ( data , message <identifiersep> <identifier> ) ; } \n \t2 else { \n <ect>
\t3 case <identifier> <identifiersep> registered : { \n \t4 logger . info ( <string_literal> ) ; \n \t4 break ; } \n \t3 case new <identifiersep> <identifier> : { \n <ect>
\t1 @ <identifier> \n \t1 public boolean is <identifiersep> <identifier> <identifiersep> in ( ) { \n \t2 http <identifiersep> session session = get <identifiersep> session ( false ) ; \n \t2 if ( session == null ) { \n <ect>
\t4 set < string > model <identifiersep> class <identifiersep> <identifier> = model . key <identifiersep> set ( ) ; \n \t4 <comment> \n \t4 if ( header <identifiersep> factory . <identifier> <identifiersep> model ( model <identifiersep> class <identifiersep> <identifier> ) ) { \n \t5 if ( factory . <identifier> <identifiersep> header ( ) ) { \n <ect>
\t4 ( ( <identifier> <identifiersep> socket ) socket ) . <identifier> <identifiersep> group ( <identifier> ) ; \n \t4 ( ( <identifier> <identifiersep> socket ) socket ) . set <identifiersep> time <identifiersep> to <identifiersep> <identifier> ( 1 ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> address != null ) { \n <ect>
\t2 cache . remove ( name ) ; } \n \t1 @ <identifier> \n \t1 public void close ( ) throws io <identifiersep> exception { \n \t2 if ( output <identifiersep> path != null ) { \n <ect>
\t5 logger . debug ( <string_literal> , timeout - <identifier> ) ; } \n \t4 thread . <identifier> ( <identifier> ) ; \n \t4 <identifier> = ( system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ) ; } \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t4 object <identifier> = <identifier> [ i ] ; \n \t4 method <identifiersep> handle test = null ; \n \t4 if ( <identifier> == null ) { \n \t5 test = is <identifiersep> null . as <identifiersep> type ( method <identifiersep> type . method <identifiersep> type ( boolean . class , <identifier> [ i ] ) ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . start ( <identifier> <identifiersep> context . get <identifiersep> execution <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 <comment> \n \t2 string <identifier> <identifiersep> id = <identifier> <identifiersep> <identifier> <identifiersep> client . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> context ) ; \n \t2 string <identifier> <identifiersep> id = ( string ) <identifier> <identifiersep> context . get <identifiersep> properties ( ) . get ( <identifier> <identifiersep> configuration . <identifier> <identifiersep> log <identifiersep> trace <identifiersep> id ) ; \n <ect>
\t3 final <identifier> < <identifier> <identifiersep> <identifier> > <identifier> = <identifier> . map ( this : : get <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t4 return <identifier> . get ( ) . <identifier> <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> name , <identifier> ) ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t1 protected web <identifiersep> <identifier> find <identifiersep> <identifier> <identifiersep> web <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifiersep> context <identifier> <identifiersep> <identifier> <identifiersep> context = <identifier> <identifiersep> service <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t2 service <identifiersep> <identifier> web <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> context . get <identifiersep> service <identifiersep> <identifier> ( web <identifiersep> <identifier> . class . get <identifiersep> name ( ) ) ; \n \t2 if ( web <identifiersep> <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t2 for ( int i = 0 ; i < message <identifiersep> count ; ++ i ) { \n \t3 string message = ( i == ( message <identifiersep> count / <number_literal> ) ) \n \t4 ? <identifier> <identifiersep> message <identifiersep> <identifier> . <identifier> <identifiersep> message ( i + 1 ) . <identifier> <identifiersep> first ( <string_literal> , <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . start <identifiersep> of <identifiersep> <identifier> ) \n \t4 : <identifier> <identifiersep> message <identifiersep> <identifier> . <identifier> <identifiersep> message ( i + 1 ) ; \n <ect>
\t2 if ( response . get <identifiersep> command ( ) != command <identifiersep> code ) { \n \t3 logger . error ( <string_literal> , response . get <identifiersep> command ( ) ) ; \n \t3 return false ; } \n \t2 if ( response . get <identifiersep> <identifier> ( ) . length < <number_literal> || response . get <identifiersep> <identifier> ( ) . length > <number_literal> ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t1 log . error ( <identifier> <identifiersep> type + <string_literal> , e ) ; \n \t1 throw new illegal <identifiersep> argument <identifiersep> exception ( <identifier> <identifiersep> type + <string_literal> , e ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> listener = new <identifier> <identifiersep> listener ( ) ; \n \t3 <identifier> <identifiersep> listener . start ( ) ; \n \t2 } catch ( <identifier> <identifiersep> host <identifiersep> exception exception ) { \n <ect>
\t3 <identifier> <identifiersep> client . put <identifiersep> <identifier> ( <identifier> ) ; \n \t3 log . info ( <string_literal> + \n \t5 <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> json ( <identifier> ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 . with <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> handler ( <identifier> <identifiersep> <identifier> <identifiersep> handler . <identifier> ) ; \n \t2 try { \n \t3 if ( is <identifiersep> not <identifiersep> blank ( <identifier> . get <identifiersep> api <identifiersep> url ( ) ) ) { \n \t4 builder . with <identifiersep> endpoint ( <identifier> . get <identifiersep> api <identifiersep> url ( ) ) ; } \n <ect>
\t4 thread . <identifier> ( <number_literal> ) ; \n \t4 string message <identifiersep> bytes = <string_literal> + integer . to <identifiersep> <identifier> <identifiersep> string ( <identifier> <identifiersep> <identifier> <identifiersep> no ) + <string_literal> ; \n \t4 send <identifiersep> message ( message <identifiersep> bytes , <identifier> <identifiersep> id ) ; } \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 final <identifier> <identifiersep> token <identifiersep> request request = new <identifier> <identifiersep> token <identifiersep> request ( this . get <identifiersep> client <identifiersep> id ( ) , this . get <identifiersep> client <identifiersep> <identifier> ( ) , \n \t4 this . get <identifiersep> <identifier> <identifiersep> token ( ) , this . get <identifiersep> <identifier> ( ) , this . get <identifiersep> <identifier> ( ) ) ; \n \t2 logger . debug ( <string_literal> , request ) ; \n \t2 final <identifier> <identifiersep> token <identifiersep> response response = request . execute ( ) ; \n <ect>
\t1 if ( new <identifiersep> <identifier> instanceof <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> <identifier> && ( ( <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> <identifier> ) new <identifiersep> <identifier> ) . get <identifiersep> value ( ) == null ) { \n \t2 <comment> \n \t2 new <identifiersep> <identifier> = new <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> <identifier> ( boolean . false ) ; } \n <ect>
\t5 return ; } \n \t4 try { \n \t5 this . <identifier> <identifiersep> <identifier> . wait ( <identifier> ) ; } \n \t4 catch ( interrupted <identifiersep> exception ex ) { \n <ect>
\t3 } finally { \n \t4 io <identifiersep> utils . close <identifiersep> stream ( is ) ; } \n \t3 return execute <identifiersep> result . create <identifiersep> <identifier> ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 return null ; } \n \t2 try { \n \t3 return resource . get <identifiersep> input <identifiersep> stream ( ) ; } \n \t2 catch ( io <identifiersep> exception ex ) { \n <ect>
\t3 <identifier> <identifiersep> key <identifiersep> <identifier> . set <identifiersep> key <identifiersep> info ( key <identifiersep> info <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> key <identifiersep> <identifier> ( ) . add ( <identifier> <identifiersep> key <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> key <identifiersep> <identifier> ( ) . add ( <identifier> <identifiersep> key <identifiersep> <identifier> ) ; \n \t2 } catch ( security <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t4 { \n \t5 do <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> , has <identifiersep> <identifier> ) ; } \n \t4 catch ( io <identifiersep> exception e ) \n \t4 { \n <ect>
\t1 @ <identifier> \n \t1 public void close ( ) throws io <identifiersep> exception { \n \t2 list < <identifier> > <identifier> = service . shutdown <identifiersep> <identifier> ( ) ; \n \t2 if ( ! <identifier> . is <identifiersep> empty ( ) ) \n <ect>
\t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n \t6 <identifier> <identifiersep> log . debug ( <string_literal> ) ; \n \t5 session . <identifier> <identifiersep> session ( ) ; \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 <comment> \n \t2 status <identifiersep> <identifier> . <identifier> <identifiersep> in <identifiersep> case <identifiersep> of <identifiersep> <identifier> <identifiersep> or <identifiersep> <identifier> ( <identifier> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> api <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + cmd + <string_literal> + get <identifiersep> <identifier> <identifiersep> string ( <identifier> ) + <string_literal> \n \t5 + e . to <identifiersep> string ( ) , e ) ; \n \t2 } catch ( xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 if ( run <identifiersep> read <identifiersep> action { element . name == null || element . is <identifiersep> local } ) { \n \t6 <identifier> type <identifiersep> for <identifiersep> <identifier> <identifiersep> class = <identifier> <identifiersep> type <identifiersep> for <identifiersep> <identifier> <identifiersep> class <identifiersep> or <identifiersep> null ( type <identifiersep> <identifier> . <identifier> <identifiersep> context , element ) \n \t6 if ( type <identifiersep> for <identifiersep> <identifier> <identifiersep> class == null ) { \n \t7 <identifier> <identifier> <identifiersep> text = element . <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> read <identifiersep> action ? . text ? : <string_literal> \n <ect>
\t1 <identifier> = trace . start ( <string_literal> ) ; \n \t1 try { \n \t2 count = remove <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> to <identifiersep> t <identifiersep> server ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 if ( ! x . is <identifiersep> <identifier> ( ) ) { \n \t3 log . warn ( <string_literal> + list ) ; \n \t3 return null ; } \n \t2 if ( ! <identifier> <identifiersep> value <identifiersep> <identifier> . is <identifiersep> <identifier> ( x ) ) { \n <ect>
\t2 } else { \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> list . size ( ) ; i ++ ) { \n \t4 if ( ! <identifier> <identifiersep> list . get ( i ) . equals ( <identifier> <identifiersep> list . get ( i ) ) ) { \n \t5 status = false ; \n <ect>
\t2 logger . trace ( <string_literal> + request <identifiersep> file <identifiersep> <identifier> ) ; \n \t2 final input <identifiersep> stream request <identifiersep> stream = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> case . class \n \t4 . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <identifier> <identifiersep> test <identifiersep> utils . <identifier> <identifiersep> <identifier> + <string_literal> + request <identifiersep> file <identifiersep> <identifier> ) ; \n \t2 if ( request <identifiersep> stream == null ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <identifier> <identifiersep> <identifier> . key <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> check , <string_literal> ) . equals ( <string_literal> ) ) { \n \t4 check <identifiersep> for <identifiersep> new <identifiersep> <identifier> ( ) ; } \n \t3 update <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task . execute ( ) ; \n <ect>
\t2 <identifier> <identifiersep> log <identifiersep> provider log <identifiersep> <identifier> = new <identifier> <identifiersep> log <identifiersep> provider ( ) ; \n \t2 <identifier> <identifiersep> log <identifiersep> provider log <identifiersep> provider = new <identifier> <identifiersep> log <identifiersep> provider ( log <identifiersep> <identifier> , log <identifiersep> <identifier> ) ; \n \t2 <comment> \n \t2 log log = log <identifiersep> provider . get <identifiersep> log ( get <identifiersep> class ( ) ) ; \n <ect>
\t2 assert <identifiersep> equals ( <string_literal> , number <identifiersep> of <identifiersep> <identifier> , \n \t5 <identifier> <identifiersep> service . get <identifiersep> all <identifiersep> <identifier> ( context , <identifier> <identifiersep> <identifier> ) . size ( ) ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , number <identifiersep> of <identifiersep> <identifier> , \n \t5 item <identifiersep> service . count <identifiersep> <identifier> ( context , ( ( collection ) <identifier> <identifiersep> <identifier> ) ) ) ; \n <ect>
\t3 return this . <identifier> <identifiersep> store . delete ( key , <identifier> . get <identifiersep> version ( ) ) ; \n \t2 } catch ( exception e ) { \n \t4 logger . debug ( <string_literal> + e ) ; } \n <ect>
\t4 if ( <identifier> - <identifier> . get <identifiersep> <identifier> ( ) > max <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t5 store . delete ( key <identifiersep> and <identifiersep> <identifier> . get <identifiersep> first ( ) , <identifier> ) ; \n \t5 final long <identifier> <identifiersep> <identifier> = this . delete <identifiersep> <identifier> <identifiersep> this <identifiersep> run . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + db <identifiersep> version + <string_literal> + current <identifiersep> version ) ; \n \t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + db <identifiersep> version + <string_literal> + current <identifiersep> version ) ; } \n \t2 if ( version . <identifier> ( <identifier> <identifiersep> current <identifiersep> version , <identifier> [ <identifier> . length - 1 ] . get <identifiersep> <identifier> <identifiersep> version ( ) ) != 0 ) { \n <ect>
\t2 <comment> \n \t2 log . debug ( <string_literal> ) ; \n \t2 network <identifiersep> connection . <identifier> <identifiersep> <identifier> <identifiersep> authentication ( http <identifiersep> url <identifiersep> connection , create <identifiersep> <identifier> <identifiersep> <identifier> ( principal <identifiersep> key <identifiersep> <identifier> ) ) ; \n \t1 } else { \n <ect>
\t9 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } } \n \t6 } ) ; } \n \t5 line . start ( ) ; \n \t4 } catch ( line <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 item item = <identifier> . add <identifiersep> item ( group ) ; \n \t5 item . get <identifiersep> item <identifiersep> property ( <identifier> ) . set <identifiersep> value ( group . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t5 item . get <identifiersep> item <identifiersep> property ( id <identifiersep> <identifier> ) . set <identifiersep> value ( group . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 return ; } } \n \t2 private void handle <identifiersep> message ( string from <identifiersep> port , <identifier> <identifiersep> address from <identifiersep> <identifier> , msg msg ) { \n \t3 <identifier> <identifiersep> device <identifier> = get <identifiersep> device ( from <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> connection <identifiersep> factory <identifier> <identifiersep> factory = new <identifier> <identifiersep> <identifier> <identifiersep> connection <identifiersep> factory ( <identifier> . get <identifiersep> transport <identifiersep> <identifier> ( ) . get ( 0 ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> connection conn = ( <identifier> <identifiersep> <identifier> <identifiersep> connection ) <identifier> <identifiersep> factory . create <identifiersep> connection ( <string_literal> , <string_literal> ) ; \n \t2 session <identifier> = conn . create <identifiersep> session ( false , session . <identifier> <identifiersep> <identifier> ) ; \n \t2 conn . start ( ) ; \n <ect>
public static void shutdown ( ) { \n \t1 for ( string <identifier> : <identifier> . key <identifiersep> set ( ) ) { \n \t1 entity <identifiersep> manager <identifiersep> factory <identifiersep> <identifier> <identifier> = <identifier> . remove ( <identifier> ) ; \n \t1 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 log . debug ( <string_literal> + <identifier> . get <identifiersep> count ( ) ) ; \n \t2 send <identifiersep> <identifier> ( connection , destination , <identifier> , <number_literal> ) ; \n \t2 log . debug ( <string_literal> + <identifier> . get <identifiersep> count ( ) ) ; \n \t2 <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t3 url <identifier> <identifiersep> <identifier> <identifiersep> url = new url ( get <identifiersep> <identifier> <identifiersep> base <identifiersep> <identifier> <identifiersep> url ( ) + <string_literal> ) ; \n \t3 file <identifier> <identifiersep> <identifier> <identifiersep> file = new file ( <identifier> <identifiersep> dir , <string_literal> ) ; \n \t3 file <identifiersep> utils . <identifier> <identifiersep> url <identifiersep> to <identifiersep> file ( <identifier> <identifiersep> <identifier> <identifiersep> url , <identifier> <identifiersep> <identifier> <identifiersep> file ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> socket <identifiersep> address <identifier> = new <identifier> <identifiersep> socket <identifiersep> address ( ip <identifiersep> of <identifiersep> node ( n ) , <identifier> <identifiersep> port ) ; \n \t3 logger . debug ( <string_literal> , <identifier> ) ; \n \t3 test <identifiersep> utils . wait <identifiersep> <identifier> <identifiersep> port <identifiersep> is <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 remove <identifiersep> <identifier> ( <identifier> , status . <identifier> ) ; } \n \t2 return <identifier> ; } \n \t1 @ <identifier> \n \t1 protected <identifier> <identifiersep> <identifier> create <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( final host <identifiersep> vo host , final <identifier> <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( db <identifiersep> conn , <identifier> , <identifier> ) ; <comment> \n \t2 log . warn ( <string_literal> ) ; \n \t2 db <identifiersep> conn . <identifier> ( ) ; \n \t2 throw new no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> ) ; } \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> manager . <identifier> <identifiersep> task <identifiersep> manager ( <identifier> <identifiersep> <identifier> . get <identifiersep> instance <identifiersep> id ( ) ) ; } \n \t2 final <identifier> <identifiersep> type new <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( task <identifiersep> <identifier> <identifiersep> resource <identifiersep> id ) ; \n \t2 if ( new <identifiersep> <identifier> == null ) { \n <ect>
\t8 log . info ( <string_literal> , get <identifiersep> endpoint ( ) . get <identifiersep> connection <identifiersep> string ( ) , <identifier> ) ; \n \t8 session = create <identifiersep> session ( ) ; \n \t8 <identifier> = true ; \n \t7 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 public string get <identifiersep> <identifier> ( ) { \n \t2 return <identifier> ; } \n \t1 public void set <identifiersep> <identifier> ( string <identifier> ) { \n \t2 if ( <identifier> . length ( ) > <number_literal> ) { \n <ect>
\t1 file file = new file ( <identifier> + <identifier> ) ; \n \t1 if ( file . delete ( ) ) { \n \t2 logger . info ( <string_literal> ) ; \n \t1 } else { \n <ect>
\t4 <identifier> <identifiersep> user = ( user ) session . create <identifiersep> query ( \n \t5 <string_literal> ) . set <identifiersep> string ( \n \t5 0 , <identifier> ) . set <identifiersep> string ( 1 , <identifier> ) . set <identifiersep> string ( <number_literal> , <identifier> <identifiersep> with <identifiersep> <identifier> ) . <identifier> <identifiersep> result ( ) ; } \n \t3 catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 if ( p . <identifier> <identifiersep> value ( ) != 0 ) { \n \t3 throw new runtime <identifiersep> exception ( <string_literal> \n \t5 + p . <identifier> <identifiersep> value ( ) + <string_literal> + system . get <identifiersep> property ( <string_literal> ) + <string_literal> ) ; } \n \t2 thread . <identifier> ( timeout ) ; \n <ect>
\t2 grid <identifiersep> <identifier> <identifiersep> cache <identifiersep> entry < <identifier> , v > entry = <identifier> . <identifier> ( ) . entry <identifiersep> <identifier> ( key , <identifier> <identifiersep> <identifier> , false ) ; \n \t2 assert ! entry . <identifier> ( ) ; \n \t2 if ( ! <identifier> . is <identifiersep> all ( entry , filter ) ) { \n <ect>
\t1 private void handle <identifiersep> provider <identifiersep> <identifier> ( \n \t2 <identifier> <identifiersep> provider <identifiersep> service provider ) \n \t1 { \n <ect>
\t3 file <identifiersep> output <identifiersep> stream <identifier> = new file <identifiersep> output <identifiersep> stream ( <identifier> ) ; \n \t3 <identifier> . write ( cmd <identifiersep> <identifier> . to <identifiersep> string ( ) . get <identifiersep> bytes ( ) ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t3 <identifier> . close ( ) ; \n <ect>
\t2 for ( entry < key , value > entry : conn <identifiersep> <identifier> . create <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> . empty ) ) { \n \t2 count <identifiersep> table ++ ; \n \t2 assert . assert <identifiersep> true ( <string_literal> + entry . get <identifiersep> key ( ) . to <identifiersep> string <identifiersep> no <identifiersep> <identifier> ( ) + <string_literal> \n \t3 + entry . get <identifiersep> value ( ) , entry . get <identifiersep> key ( ) . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) . <identifier> <identifiersep> with ( <identifier> <identifiersep> <identifier> ) ) ; } \n <ect>
\t3 final string <identifier> <identifiersep> key = get <identifiersep> ticket <identifiersep> <identifier> <identifiersep> key ( ticket . get <identifiersep> id ( ) ) ; \n \t3 this . client . <identifier> <identifiersep> value <identifiersep> <identifier> ( <identifier> <identifiersep> key ) . set ( <identifier> <identifiersep> ticket , get <identifiersep> timeout ( ticket ) , time <identifiersep> unit . <identifier> ) ; \n \t3 return <identifier> <identifiersep> ticket ; \n \t2 } catch ( final exception e ) { \n <ect>
\t8 <identifier> <identifiersep> id . set <identifiersep> <identifier> ( <identifier> <identifiersep> model . <identifier> <identifiersep> id <identifiersep> <identifier> ) ; \n \t8 context . get <identifiersep> <identifier> <identifiersep> service ( ) . set <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> id ) ; } \n \t7 catch ( exception e ) { \n \t8 <identifier> <identifiersep> error ( error <identifiersep> message <identifiersep> <identifier> . error <identifiersep> set <identifiersep> <identifier> <identifiersep> id , default <identifiersep> <identifier> , e . get <identifiersep> message ( ) ) ; \n <ect>
\t4 <identifier> <identifiersep> queue . put ( new <identifier> ( key , query <identifiersep> <identifier> ) ) ; } \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> . length ; i ++ ) { \n \t4 <identifier> <identifiersep> <identifier> [ i ] . <identifier> ( <number_literal> ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> [ i ] . is <identifiersep> <identifier> ( ) ) { \n <ect>
<comment> \n \t1 private <identifier> <identifiersep> context <identifier> <identifiersep> <identifier> <identifiersep> context ( ) { \n \t2 key <identifiersep> store <identifier> = key <identifiersep> store <identifiersep> <identifier> . load <identifiersep> system <identifiersep> key <identifiersep> store ( ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t1 else \n \t2 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> max <identifiersep> <identifier> ( ) ) ; \n \t1 string s = <identifier> . to <identifiersep> string ( ) ; \n \t1 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t2 assert . assert <identifiersep> true ( <string_literal> . equals ( s ) ) ; \t1 \n \t2 s = set . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> + s ) ; \n \t2 assert . assert <identifiersep> true ( <string_literal> . equals ( s ) ) ; \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> , ex ) ; \n \t3 success = false ; } \n \t2 if ( network . get <identifiersep> <identifier> <identifiersep> id ( ) != null ) { \n <ect>
\t3 self . logger . info ( <string_literal> \\ \n \t5 . format ( <identifier> <identifiersep> queue <identifiersep> name , <identifier> <identifiersep> queue <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> default <identifiersep> queue <identifiersep> <identifier> ) ) \n \t2 else : # queue <identifier> , <identifier> <identifier> <identifier> . \n \t3 self . logger . info ( <string_literal> . format ( <identifier> <identifiersep> queue <identifiersep> name , <identifier> <identifiersep> queue <identifiersep> <identifier> <identifiersep> <identifier> ) ) \n <ect>
\t3 @ <identifier> \n \t3 public void on <identifiersep> command ( object command ) { } \n \t3 @ <identifier> \n \t3 public void on <identifiersep> exception ( io <identifiersep> exception error ) { \n <ect>
\t1 case <identifier> <identifiersep> count : \n \t2 <identifier> <identifiersep> value = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> size ( ) ; \n \t2 break ; \n \t1 default : \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> ignore <identifiersep> <identifier> ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> ignore <identifiersep> <identifier> ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> time = time <identifiersep> unit . <identifier> . <identifier> ( ( system . current <identifiersep> time <identifiersep> millis ( ) - start ) , \n \t2 time <identifiersep> unit . <identifier> ) ; \n <ect>
<comment> \n static void check <identifiersep> service <identifiersep> <identifier> ( ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> all ( ) ) ; \n \t1 log . info ( <string_literal> ) ; \n \t1 action <identifiersep> log . write <identifiersep> <identifier> <identifiersep> out ( <string_literal> ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> resource <identifiersep> exception e ) { \n <ect>
\t3 long <identifier> <identifiersep> <identifier> = thread <identifiersep> local <identifiersep> <identifier> . current ( ) . next <identifiersep> long ( local <identifiersep> start <identifiersep> date , local <identifiersep> end <identifiersep> date ) ; \n \t3 try { \n \t4 date <identifiersep> string = local <identifiersep> date . of <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) . format ( <identifier> ) ; \n \t3 } catch ( date <identifiersep> time <identifiersep> parse <identifiersep> exception | number <identifiersep> format <identifiersep> exception ex ) { \n <ect>
\t2 lock . write <identifiersep> lock ( ) . lock ( ) ; \n \t2 try { \n \t3 if ( last <identifiersep> exchange <identifiersep> id != null && <identifier> <identifiersep> id != null && last <identifiersep> exchange <identifiersep> id . <identifier> <identifiersep> to ( <identifier> <identifiersep> id ) > 0 ) { \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> exception <identifier> = <identifier> <identifiersep> exception . <identifier> ( ) ; \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> task <identifiersep> job ( ) throws exception { \n <ect>
\t1 path <identifier> <identifiersep> path = new path ( output , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> output <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( input , <identifier> <identifiersep> class , <identifier> <identifiersep> path , get <identifiersep> conf ( ) ) ; \n \t1 input = <identifier> <identifiersep> path ; \n \t1 } else { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t4 new file ( new uri ( get <identifiersep> <identifier> <identifiersep> property ( last <identifiersep> <identifier> <identifiersep> url ) ) ) , false ) ; \n \t2 } catch ( exception e ) { \n \t3 <comment> \n <ect>
\t3 <comment> \n \t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this , data ) ; \n \t3 <identifier> . put ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) , <identifier> ) ; \n \t2 } catch ( throwable throwable ) { \n <ect>
\t1 protected user process <identifiersep> update ( exchange exchange ) { \n \t2 log . debug ( <string_literal> , exchange . get <identifiersep> in ( ) . get <identifiersep> body ( ) , this . get <identifiersep> configuration ( ) . get <identifiersep> id ( ) ) ; \n \t2 return service <identifiersep> <identifier> . update ( get <identifiersep> configuration ( ) . get <identifiersep> id ( ) , exchange . get <identifiersep> in ( ) . get <identifiersep> body ( user . class ) ) ; } \n \t1 protected user process <identifiersep> <identifier> ( exchange exchange ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> > 0 ) { \n \t4 source <identifiersep> <identifier> . query <identifiersep> <identifier> . try <identifiersep> <identifier> ( 0 , <identifier> <identifiersep> <identifier> ) ; } \n \t3 if ( source <identifiersep> <identifier> . <identifier> == source <identifiersep> <identifier> . total <identifiersep> <identifier> ) { \n \t4 if ( ! source <identifiersep> <identifier> . query <identifiersep> <identifier> . try <identifiersep> success ( ) ) { \n <ect>
\t3 public <identifier> <identifiersep> <identifier> < void > <identifier> ( node <identifiersep> metadata from ) { \n \t4 <identifier> <identifiersep> node ( from . get <identifiersep> id ( ) ) ; \n \t4 return <identifier> <identifiersep> <identifier> ( null ) ; } \n \t3 } , user <identifiersep> <identifier> , null , logger , <string_literal> + filter + <string_literal> ) ; \n <ect>
<comment> \n \t1 protected void assert <identifiersep> <identifier> ( string text ) throws exception { \n \t2 assert <identifiersep> <identifier> ( text , get <identifiersep> test <identifiersep> class <identifiersep> name ( ) ) ; } \n \t1 protected void assert <identifiersep> <identifier> ( final string text , final string <identifier> <identifiersep> name ) throws exception { \n <ect>
\t3 if ( <identifier> != null && <identifier> . length ( ) > 0 ) { \n \t4 map . put ( <string_literal> , <identifier> ) ; } \n \t3 string [ ] <identifier> = <identifier> . get <identifiersep> <identifier> ( interface <identifiersep> class ) . get <identifiersep> method <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> . length == 0 ) { \n <ect>
<comment> \n \t1 protected boolean do <identifiersep> <identifier> <identifiersep> attributes <identifiersep> <identifier> <identifiersep> principal <identifiersep> access ( final map < string , object > principal <identifiersep> attributes , final map < string , set < string > > <identifier> <identifiersep> attributes ) { \n <ect>
<number_literal> final principal principal ) { \n \t2 logger . debug ( <string_literal> , principal . get <identifiersep> id ( ) ) ; \n \t2 authentication . add <identifiersep> attribute ( authentication <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> , boolean . true ) ; \n \t2 authentication . add <identifiersep> attribute ( authentication <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider , provider . get <identifiersep> id ( ) ) ; \n <ect>
<comment> \n \t2 final org . apache . <identifier> . <identifier> . <identifier> . api . model . job <identifiersep> <identifier> result = request <identifiersep> body <identifiersep> and <identifiersep> <identifier> ( <string_literal> , null , <identifier> ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , result ) ; \n <ect>
\t1 <identifier> = <identifier> ; \n \t1 int read = file . read ( <identifier> , 0 , <identifier> . length ) ; \n \t2 string <identifier> = new string ( <identifier> , 0 , <number_literal> , <string_literal> ) ; \n <ect>
\t1 string <identifier> ; \n \t1 public void <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n \t2 <identifier> = <identifier> <identifiersep> <identifier> . value ( ) ; } \n \t1 public boolean is <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> interface <identifiersep> <identifier> value , <identifier> <identifiersep> <identifier> <identifiersep> context context ) { \n <ect>
\t7 <identifier> = create <identifiersep> <identifier> ( <identifier> <identifiersep> meta <identifiersep> data ) ; \n \t6 } catch ( <identifier> <identifiersep> exception ex ) { \n \t7 logger . warn ( ( ) - > new <identifier> <identifiersep> message ( <string_literal> , <identifier> <identifiersep> meta <identifiersep> data . name ( ) ) , ex ) ; } } \n \t5 if ( <identifier> != null ) { \n <ect>
static string <identifier> <identifiersep> <identifier> = \n \t1 <string_literal> <identifier> \\ <string_literal> <number_literal> \\ <string_literal> <number_literal> \\ <string_literal> <identifier> \\ <string_literal> <identifier> \\ <string_literal> ; \n static { \n \t1 log . info ( <string_literal> + host <identifiersep> url ) ; \n <ect>
\t2 <identifier> <identifiersep> message message = ( <identifier> <identifiersep> message ) e . get <identifiersep> message ( ) ; \n \t2 server . queue <identifiersep> message ( message ) ; } \n \t1 @ <identifier> \n \t1 public void exception <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context <identifier> , exception <identifiersep> event e ) { \n <ect>
\t3 long [ ] <identifier> = get <identifiersep> network <identifiersep> <identifier> ( conn , cmd . get <identifiersep> private <identifiersep> ip ( ) ) ; \n \t3 network <identifiersep> <identifier> <identifiersep> answer answer = new network <identifiersep> <identifier> <identifiersep> answer ( cmd , <string_literal> , <identifier> [ 0 ] , <identifier> [ 1 ] ) ; \n \t3 return answer ; \n \t2 } catch ( exception ex ) { \n <ect>
\t7 <identifier> <identifiersep> registered <identifiersep> service <identifiersep> <identifier> <identifiersep> metadata <identifiersep> <identifier> . class ) ; \n \t3 final <identifier> < <identifier> <identifiersep> registered <identifiersep> service <identifiersep> service <identifiersep> provider <identifiersep> metadata <identifiersep> <identifier> > <identifier> = \n \t5 <identifier> <identifiersep> registered <identifiersep> service <identifiersep> service <identifiersep> provider <identifiersep> metadata <identifiersep> <identifier> . get ( <identifier> , <identifier> , entity <identifiersep> id ) ; \n \t3 if ( <identifier> == null || ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 s <identifiersep> logger . debug ( <string_literal> + ip <identifiersep> id + <string_literal> ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> remote <identifiersep> access <identifiersep> <identifier> <identifiersep> for <identifiersep> ip ( ip <identifiersep> id , <identifier> , false ) ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 logger . error ( <string_literal> ) ; } \n \t3 catch ( interrupted <identifiersep> exception e ) \n \t3 { \n \t4 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n <ect>
<comment> \n \t1 public synchronized boolean start <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 <identifier> <identifiersep> manager <identifiersep> factory <identifier> <identifiersep> factory = <identifier> <identifiersep> manager <identifiersep> factory . get <identifiersep> instance ( get <identifiersep> default <identifiersep> <identifier> ( ) ) ; \n \t1 <identifier> <identifiersep> factory . <identifier> ( key <identifiersep> store ( <identifier> <identifiersep> <identifier> <identifiersep> configuration ) ) ; \n \t1 return <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t5 continue ; } \n \t4 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t5 string <identifier> = <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n \t5 if ( <identifier> == null ) \n <ect>
\t6 if ( api . create <identifiersep> <identifier> ( host , <identifier> . get <identifiersep> org <identifiersep> name ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) , context , <identifier> <identifiersep> private <identifiersep> <identifier> ) ) { \n \t7 <identifier> <identifiersep> url url = new <identifier> <identifiersep> url ( host , <identifier> . get <identifiersep> org <identifiersep> name ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) , <identifier> . default <identifiersep> port , true ) ; \n \t7 string file <identifiersep> path = v <identifiersep> files [ 0 ] . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t7 if ( file <identifiersep> path == null ) { \n <ect>
\t1 output <identifiersep> <identifier> . set <identifiersep> destination ( output . get <identifiersep> destination ( ) ) ; \n \t1 <identifier> <identifiersep> <identifier> . add ( output <identifiersep> <identifier> ) ; \n \t1 super . add <identifiersep> output ( output <identifiersep> <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> . put ( <string_literal> , <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 <identifier> . put ( <string_literal> , <string_literal> ) ; \n <ect>
\t3 result = new type <identifiersep> <identifier> ( id , this ) ; \n \t3 type <identifiersep> <identifier> <identifiersep> list . set ( id , result ) ; \n \t3 type <identifiersep> <identifier> <identifiersep> map . put ( local , result ) ; \n \t3 if ( debug ) { \n <ect>
\t4 <identifier> <identifiersep> stack <identifiersep> account <identifiersep> dao dao = new <identifier> <identifiersep> stack <identifiersep> account <identifiersep> dao ( ) ; \n \t4 <identifier> <identifiersep> stack <identifiersep> account account = dao . <identifier> <identifiersep> <identifier> <identifiersep> id ( account <identifiersep> id ) ; \n \t4 return account . get <identifiersep> default <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 } else { \n \t5 logger . info ( <string_literal> ) ; \n \t5 <identifier> <identifiersep> <identifier> = true ; } \n \t3 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> dir = <identifier> <identifiersep> <identifier> = system . get <identifiersep> property ( <string_literal> , <string_literal> ) ; } \n @ <identifier> \n public void stop <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws io <identifiersep> exception , interrupted <identifiersep> exception { \n \t1 if ( <string_literal> . equals <identifiersep> ignore <identifiersep> case ( system . get <identifiersep> property ( <string_literal> ) ) ) { \n <ect>
\t6 <identifier> . close ( ) ; \n \t6 <comment> \n \t6 <comment> \n \t6 if ( is <identifiersep> first <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 string user <identifiersep> <identifier> = ip <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> user <identifiersep> <identifier> ( ) ; \n \t3 logger . info ( <string_literal> + ip + <string_literal> + user <identifiersep> <identifier> ) ; \n \t3 return <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 list < transport > <identifier> <identifiersep> to <identifiersep> stop = new array <identifiersep> list < transport > ( <identifier> . size ( ) ) ; \n \t2 try { \n \t3 synchronized ( <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 if ( should <identifiersep> cache <identifiersep> result && response != null ) { \n \t3 try { \n \t4 <identifier> <identifiersep> response <identifiersep> cache . <identifier> <identifiersep> instance ( ) . cache <identifiersep> response <identifiersep> for <identifiersep> request ( action <identifiersep> class , action <identifiersep> name , request , response ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 value <identifiersep> map map <identifiersep> value ; \n \t2 try { \n \t3 map <identifiersep> value = value . as <identifiersep> map ( ) ; \n \t2 } catch ( value <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t6 logger . error ( new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + result . class . get <identifiersep> name ( ) ) ) ; \n \t6 return ; } \n \t5 <comment> \n \t5 if ( ! ( <identifier> <identifiersep> result instanceof result ) ) { \n <ect>
\t2 string content = ( string ) context . get <identifiersep> job <identifiersep> <identifier> ( ) . get <identifiersep> job <identifiersep> data <identifiersep> map ( ) . get ( job <identifiersep> data <identifiersep> content <identifiersep> key ) ; \n \t2 item <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . item <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> service ( ) ; \n \t2 event <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . event <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> service ( ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 instance . close ( ) ; } \n \t2 <identifier> . <identifier> ( ) ; \n \t2 <identifier> = false ; \n \t2 if ( logger . is <identifiersep> <identifier> ( level . info ) ) { \n <ect>
\t3 if ( input <identifiersep> stream != null ) { \n \t4 try { \n \t5 input <identifiersep> stream . close ( ) ; } \n \t4 catch ( io <identifiersep> exception io ) { \n <ect>
\t6 || event <identifiersep> content . get <identifiersep> time ( ) . is <identifiersep> <identifier> ( current <identifiersep> event <identifiersep> content . get <identifiersep> time ( ) ) ) ) { \n \t5 map . put ( event <identifiersep> content . get <identifiersep> item ( ) . get <identifiersep> name ( ) , event <identifiersep> content ) ; } } } \n \t2 for ( event <identifiersep> utils . event <identifiersep> content current <identifiersep> event <identifiersep> content : map . values ( ) ) { \n \t3 event <identifiersep> <identifier> . send <identifiersep> command ( current <identifiersep> event <identifiersep> content . get <identifiersep> item ( ) . get <identifiersep> name ( ) , current <identifiersep> event <identifiersep> content . get <identifiersep> command ( ) ) ; \n <ect>
\t2 <comment> \n \t2 node <identifiersep> <identifier> <identifiersep> <identifier> . handle <identifiersep> <identifier> <identifiersep> request ( <identifier> <identifiersep> node ( node ) , new <identifier> <identifiersep> action . <identifier> <identifiersep> <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public void on <identifiersep> success ( ) { \n <ect>
\t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t1 log . error ( <string_literal> , file , target ) ; \n \t1 throw new runtime <identifiersep> exception ( <string_literal> , e ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> . exists ( <identifier> <identifiersep> directory <identifiersep> path ) || <identifier> . <identifier> ( <identifier> <identifiersep> directory <identifiersep> path ) ) { \n \t3 file <identifiersep> system path <identifiersep> <identifier> = <identifier> . get <identifiersep> volume <identifiersep> by <identifiersep> path ( <identifier> <identifiersep> directory <identifiersep> path ) . get <identifiersep> file <identifiersep> system ( ) ; \n \t3 return <identifier> <identifiersep> directory <identifiersep> path . <identifier> <identifiersep> <identifier> ( path <identifiersep> <identifier> . get <identifiersep> uri ( ) , path <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> directory ( ) ) \n \t4 . to <identifiersep> string ( ) ; } \n <ect>
\t1 <identifier> . write ( <identifier> ) ; \n \t1 utils . log ( <string_literal> , <number_literal> , <string_literal> + output <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; } \n \t1 catch ( io <identifiersep> exception ex ) { \n \t1 if ( test <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) > 1 ) { \n <ect>
\t5 new object [ ] { <identifier> . get <identifiersep> name ( ) , get <identifiersep> host ( ) . to <identifiersep> short <identifiersep> string ( ) , <identifier> . <identifier> ( time <identifiersep> unit . <identifier> ) } ) ; } } \n \t3 } while ( ! m <identifiersep> shutdown && ! <identifier> <identifiersep> <identifier> <identifiersep> queue . is <identifiersep> empty ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t3 m <identifiersep> <identifier> . remove ( <identifier> ) ; <comment> \n <ect>
\t2 assert . assert <identifiersep> true ( <identifier> [ 1 ] . get <identifiersep> path ( ) . get <identifiersep> name ( ) . <identifier> ( <string_literal> ) ) ; \n \t2 assert . assert <identifiersep> equals ( <identifier> , <identifier> [ 0 ] . get <identifiersep> <identifier> ( ) ) ; \n \t2 assert . assert <identifiersep> equals ( <identifier> , <identifier> [ 1 ] . get <identifiersep> <identifier> ( ) ) ; } \n \t1 else { \n <ect>
\t7 string data = <identifier> <identifiersep> <identifier> ( <identifier> , index <identifiersep> <identifier> ) ; \n \t7 result . put ( <string_literal> + index + <string_literal> , data ) ; } } } \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t6 ( ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) . <identifier> ( <identifier> ) ; \n \t5 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n \t6 logger . error ( <string_literal> , e ) ; \n \t5 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> properties . set <identifiersep> property ( <string_literal> , <string_literal> ) ; \n \t3 <identifier> <identifiersep> client = new <identifier> <identifiersep> client ( <identifier> [ 0 ] . get <identifiersep> metadata <identifiersep> store ( ) . get <identifiersep> cluster ( ) , \n \t10 new <identifier> <identifiersep> client <identifiersep> config ( <identifier> <identifiersep> properties ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t6 + <string_literal> + http <identifiersep> method + <string_literal> + <identifier> ) ; } \n \t3 return false ; } \n \t2 request <identifiersep> url <identifiersep> <identifier> url = get <identifiersep> request <identifiersep> path ( request ) ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 final <identifier> current = data . get <identifiersep> <identifier> ( ) . get <identifiersep> current <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> task < <identifier> <identifiersep> log <identifiersep> <identifier> > task = <identifier> <identifiersep> <identifier> <identifiersep> task . create ( ( ) - > { \n <ect>
\t4 continue ; } \n \t3 <comment> \n \t3 success = success && <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> network ( <identifier> , network ) ; \n \t3 if ( ! success ) { \n <ect>
\t3 <comment> \n \t3 list < storage <identifiersep> pool <identifiersep> vo > storage <identifiersep> <identifier> = <identifier> <identifiersep> storage <identifiersep> pool <identifiersep> dao . list <identifiersep> <identifier> <identifiersep> by <identifiersep> cluster ( cmd . get <identifiersep> id ( ) ) ; \n \t3 if ( storage <identifiersep> <identifier> . size ( ) > 0 ) { \n <ect>
\t2 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> ( <identifier> ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> it <identifiersep> <identifier> . <identifier> ( name , template , service <identifiersep> <identifier> , <identifier> , <identifier> , null ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 boolean success = false ; \n \t1 list < m <identifiersep> <identifier> > <identifier> = null ; \n \t1 try { \n \t1 <identifier> <identifiersep> transaction ( ) ; \n <ect>
\t3 int num <identifiersep> <identifier> = 0 ; \n \t3 while ( ( line = <identifier> . read <identifiersep> line ( ) ) != null ) { \n \t4 final string [ ] <identifier> = line . <identifier> ( ) . <identifier> ( <string_literal> ) ; \n \t4 if ( <identifier> . length < <number_literal> ) { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> + vm <identifiersep> name + <string_literal> ) ; \n \t4 vm <identifiersep> <identifier> <identifiersep> state = <identifier> <identifiersep> state . <identifier> <identifiersep> <identifier> ; } \n \t3 return new check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> answer ( cmd , vm <identifiersep> <identifier> <identifiersep> state , <identifier> <identifiersep> port ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 int port = url . get <identifiersep> port ( ) ; \n \t4 server <identifiersep> info = new server <identifiersep> info ( <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> server <identifiersep> name ( ) , address , port ) ; \n \t4 server <identifiersep> info . set <identifiersep> <identifier> ( <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> ( ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> && <identifier> <identifiersep> <identifier> ) { \n \t5 <identifier> . add ( <identifier> ) ; } } \n \t3 return <identifier> ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 assert <identifiersep> user <identifiersep> manager ( ) ; \n \t3 return user <identifiersep> manager . get <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception | <identifier> <identifiersep> <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t1 @ <identifier> \n \t1 public void do <identifiersep> get ( http <identifiersep> <identifier> <identifiersep> request request , http <identifiersep> <identifier> <identifiersep> response response ) \n \t3 throws <identifier> <identifiersep> exception , io <identifiersep> exception { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> <identifiersep> name ) ; \n \t4 return null ; } \n \t3 return <identifier> ; \n \t2 } catch ( final socket <identifiersep> exception e ) { \n <ect>
\t3 <identifier> command = new <identifier> ( true , <string_literal> , <identifier> <identifiersep> timeout , s <identifiersep> logger ) ; \n \t3 command . add ( <identifier> <identifiersep> <identifier> ) ; \n \t3 result = command . execute ( ) ; \n \t3 if ( result != null ) { \n <ect>
\t1 log . info ( msg ) ; \n \t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> service . <identifier> <identifiersep> task <identifiersep> <identifier> ( msg ) ; } \n \t1 log . info ( <string_literal> ) ; \n \t1 config <identifiersep> request . process ( ) ; \n <ect>
@ test \n public void test <identifiersep> <identifier> <identifiersep> table <identifiersep> <identifier> ( ) throws exception { \n \t1 string create <identifiersep> table = <identifier> . get <identifiersep> create <identifiersep> table <identifiersep> <identifier> ( ) ; \n \t1 string load <identifiersep> data = <identifier> . get <identifiersep> load <identifiersep> data <identifiersep> <identifier> ( ) ; \n <ect>
\t4 <identifier> <identifiersep> resource resource = <identifier> . read <identifiersep> resource ( <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t4 <identifier> <identifiersep> <identifier> . write <identifiersep> next ( \n \t5 new string [ ] { <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> path ( resource ) , <identifier> . get <identifiersep> mode ( ) . to <identifiersep> string ( ) } ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 <identifier> <identifiersep> key <identifiersep> value <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> key <identifiersep> value <identifiersep> <identifier> ( a <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t6 try { \n \t7 add <identifiersep> <identifier> ( ( <identifier> ) <identifier> . <identifier> <identifiersep> object <identifiersep> for <identifiersep> key ( <string_literal> ) ) ; \n \t6 } catch ( exception ex ) { \n <ect>
\t1 @ <identifier> \n \t1 private logger log ; \n \t1 @ <identifier> <identifiersep> <identifier> \n \t1 public object <identifier> ( <identifier> <identifiersep> context <identifier> ) throws exception { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> + path + <string_literal> + content <identifiersep> type ) ; \n \t2 } else { \n <ect>
\t1 public void <identifier> <identifiersep> <identifier> ( ) { \n \t2 <identifier> = new <identifier> <identifiersep> name <identifiersep> <identifier> ( put <identifiersep> handle , this ) ; \n \t2 <identifier> = new <identifier> <identifiersep> name <identifiersep> <identifier> ( get <identifiersep> handle , this ) ; } \n \t1 public int handle <identifiersep> name <identifiersep> <identifier> ( content <identifiersep> name p , array <identifiersep> list < content <identifiersep> name > n ) { \n <ect>
\t2 set < <identifier> <identifiersep> address > <identifier> <identifiersep> to <identifiersep> remove = new <identifier> <identifiersep> set < > ( ) ; \n \t3 logger . debug ( <string_literal> , endpoint , <identifier> ) ; \n \t2 if ( token <identifiersep> metadata . is <identifiersep> <identifier> ( endpoint ) ) \n <ect>
\t3 @ request <identifiersep> <identifier> ( value = <string_literal> , <identifier> = false ) integer <identifier> ) { \n \t2 try { \n \t3 return <identifier> <identifiersep> service . get <identifiersep> <identifier> <identifiersep> <identifier> ( table , <identifier> , <identifier> , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 start <identifiersep> <identifier> ( ) ; } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> start ( ) throws exception { \n \t2 <identifier> = endpoint . create <identifiersep> <identifier> ( ) ; \n <ect>
\t4 builder . <identifier> ( <identifier> . get <identifiersep> line <identifiersep> number ( ) ) ; \n \t4 builder . <identifier> ( <string_literal> ) ; \n \t4 builder . <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> number ( ) ) ; \n \t4 builder . <identifier> ( <string_literal> ) ; } } \n <ect>
\t2 public t get <identifiersep> value ( ) { \n \t3 try { \n \t4 return ( t ) server . get <identifiersep> attribute ( object <identifiersep> name , attribute <identifiersep> name ) ; \n \t3 } catch ( m <identifiersep> bean <identifiersep> exception | attribute <identifiersep> not <identifiersep> found <identifiersep> exception | instance <identifiersep> not <identifiersep> found <identifiersep> exception | <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( ! bean <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> <identifier> ( <identifier> ) ) { \n \t4 bean <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> <identifier> ( <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . add ( element ) ; \n <ect>
\t3 service <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( base <identifiersep> <identifier> . <identifier> ( ) . with <identifiersep> <identifier> ( <string_literal> , <number_literal> ) . <identifier> ( <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> bytes ) ) ) ; \n \t3 service <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 service <identifiersep> <identifier> . add ( service <identifiersep> <identifier> ) ; \n \t3 } catch ( final <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 return <identifier> <identifiersep> object ; } \n @ <identifier> \n public void remove ( ) { \n \t1 <comment> \n <ect>
\t1 public void close ( ) throws exception { \n \t2 log . info ( <string_literal> ) ; \n \t2 super . close ( ) ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + cmd . get <identifiersep> access <identifiersep> <identifier> ( network <identifiersep> element <identifiersep> command . <identifier> <identifiersep> ip ) \n \t6 + <string_literal> + result . <identifier> ( ) ) ; \n \t4 return new answer ( cmd , false , <string_literal> + result . <identifier> ( ) ) ; } \n <ect>
\t3 int code = http <identifiersep> <identifier> <identifiersep> response . <identifier> <identifiersep> <identifier> <identifiersep> request ; \n \t3 response . set <identifiersep> status ( code ) ; \n \t3 response . get <identifiersep> <identifier> ( ) . <identifier> ( <identifier> <identifiersep> method <identifiersep> result . json <identifiersep> error ( code , <string_literal> + <identifier> . get <identifiersep> message ( ) ) ) ; \n \t2 } catch ( json <identifiersep> parse <identifiersep> exception <identifier> ) { \n <ect>
\t3 + <string_literal> ) ; \n \t2 this . connection . set <identifiersep> transaction <identifiersep> <identifier> ( \n \t3 connection . transaction <identifiersep> read <identifiersep> <identifier> ) ; \n \t2 } else { \n <ect>
\t1 <identifier> <identifiersep> type < ? > <identifier> <identifiersep> type = type <identifiersep> manager . get <identifiersep> <identifier> <identifiersep> type ( target <identifiersep> type ) ; \n \t1 if ( <identifier> <identifiersep> type != null ) { \n \t2 return new <identifier> <identifiersep> bean <identifiersep> property <identifiersep> <identifier> <identifiersep> collection ( <identifier> , target <identifiersep> type , <identifier> <identifiersep> type ) ; } \n \t1 } catch ( null <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 logger . info ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> + v + <string_literal> \n \t5 + has <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ) ; \n \t3 return true ; \n \t2 } else { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> <identifiersep> state ( new <identifiersep> state ) ; } } } \n \t1 try { \n \t1 create <identifiersep> and <identifiersep> execute <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> files <identifiersep> action <identifiersep> for <identifiersep> <identifier> ( service <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> map , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map , cluster . get <identifiersep> cluster <identifiersep> name ( ) , false ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> < string , string > service <identifiersep> version = cluster <identifiersep> service <identifiersep> version <identifiersep> map . get ( <identifier> <identifiersep> name ) ; \n \t2 for ( string <identifier> <identifiersep> name : service <identifiersep> version . key <identifiersep> set ( ) ) { \n \t3 <identifier> ( <string_literal> , <identifier> <identifiersep> name , <identifier> <identifiersep> name , string <identifiersep> utils . <identifier> ( service <identifiersep> version . get ( <identifier> <identifiersep> name ) , <string_literal> ) ) ; } } } \n \t1 <comment> \n <ect>
\t1 this . db = db ; } \n @ <identifier> \n public void execute ( context context ) throws sql <identifiersep> exception { \n \t1 list < string > <identifier> <identifiersep> to <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) ; \n <ect>
\t3 ( code == - 1 || \n \t2 ( code >= e . start <identifiersep> <identifier> && code < = e . start <identifiersep> <identifier> + e . length ) ) ) { \n \t2 <comment> \n \t3 <comment> \n <ect>
\t4 throw new <identifier> <identifiersep> error <identifiersep> exception ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> error <identifiersep> <identifier> . <identifier> <identifiersep> url , \n <number_literal> <string_literal> ) ; } \n \t3 return ( collection ) <identifier> ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public boolean <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> for <identifiersep> network ( long network <identifiersep> id , <identifier> <identifier> ) throws resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 list < load <identifiersep> <identifier> <identifiersep> vo > <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . list <identifiersep> by <identifiersep> network <identifiersep> id <identifiersep> and <identifiersep> <identifier> ( network <identifiersep> id , <identifier> ) ; \n <ect>
\t3 <identifier> . set <identifiersep> shutdown <identifiersep> <identifier> ( <string_literal> ) ; \n \t3 try { \n \t4 <identifier> . get <identifiersep> connection ( ) ; \n \t3 } catch ( exception <identifier> ) { } \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 property <identifiersep> directory . get <identifiersep> property <identifiersep> entry ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> value ( body <identifiersep> <identifier> ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t2 for ( <identifier> <identifiersep> model <identifier> <identifiersep> model : <identifier> <identifiersep> <identifier> . values ( ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> model . on <identifiersep> <identifier> <identifiersep> <identifier> ( this ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 } else if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) > 1 ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> path + <string_literal> + \n \t6 <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> base <identifiersep> name ) ; \n \t4 return null ; } } \n <ect>
\t3 logger . warn ( <string_literal> \n \t4 + <string_literal> \n \t4 + <string_literal> \n \t4 + <string_literal> , principal <identifiersep> id , this . <identifier> <identifiersep> attribute , <identifier> <identifiersep> policy <identifiersep> attributes , principal <identifiersep> id ) ; } \n <ect>
\t3 if ( job . get <identifiersep> <identifier> <identifiersep> delete <identifiersep> <identifier> ( ) ) { \n \t4 return delete <identifiersep> status . job <identifiersep> do <identifiersep> not <identifiersep> delete ; } \n \t3 <identifier> <identifiersep> state . <identifier> . remove ( job <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> state . job <identifiersep> <identifier> . remove <identifiersep> node ( job <identifiersep> <identifier> ) ; \n <ect>
\t3 this . cluster . <identifier> ( ) ; } } \n \t1 private void <identifier> <identifiersep> cluster ( ) { \n \t2 if ( this . cluster != null ) { \n \t3 shutdown ( ) ; } \n <ect>
\t5 response = response + <string_literal> + host + <string_literal> + port ; } \n \t4 response = response + <string_literal> ; \n \t4 return response ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 n = <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> . size ( ) - <identifier> ; } \n \t1 <identifier> <identifiersep> set < string > <identifier> = new <identifier> <identifiersep> set < > ( <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> . <identifier> <identifiersep> list ( <identifier> , <identifier> + n ) ) ; \n \t1 { \n <ect>
\t3 case <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : { \n \t4 <comment> \n \t4 break ; } \n \t3 case <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : \n <ect>
\t3 final string <identifiersep> builder command <identifiersep> line = get <identifiersep> command <identifiersep> line ( ) ; \n \t3 if ( command <identifiersep> line != null ) { \n \t4 cmd = command <identifiersep> line . to <identifiersep> string ( ) ; \n \t4 string [ ] <identifier> = { <string_literal> , <string_literal> , cmd } ; \n <ect>
\t4 grid <identifiersep> cache <identifiersep> <identifier> <identifier> = cache . <identifier> ( ) ; \n \t4 if ( <identifier> != null ) \n \t5 <identifier> . <identifier> ( ) ; } } \n \t2 catch ( grid <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n <ect>
\t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t2 try { \n \t3 cluster <identifiersep> state . try <identifiersep> to <identifiersep> be <identifiersep> <identifier> ( path , host . get <identifiersep> bytes ( ) ) ; \n \t2 } catch ( node <identifiersep> exists <identifiersep> exception e ) { \n \t3 cluster <identifiersep> state . node <identifiersep> <identifier> ( path , true ) ; \n <ect>
\t1 assert <identifiersep> true ( <identifier> <identifiersep> base <identifiersep> name . <identifier> <identifiersep> with ( <string_literal> ) ) ; \n \t1 assert <identifiersep> true ( <identifier> <identifiersep> base <identifiersep> name . length ( ) > <string_literal> . length ( ) ) ; \n \t1 string class <identifiersep> name = <identifier> <identifiersep> base <identifiersep> name . <identifier> ( 0 , <identifier> <identifiersep> base <identifiersep> name . length ( ) \n \t1 - <string_literal> . length ( ) ) ; \n <ect>
\t2 string <identifiersep> <identifier> <identifier> <identifiersep> value <identifiersep> <identifier> <identifiersep> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 <identifier> = message <identifiersep> <identifier> . get <identifiersep> instance ( <string_literal> ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 logger . error ( <string_literal> , e ) ; } \n \t3 try { \n \t4 this . client . <identifier> <identifiersep> <identifier> ( this . <identifier> <identifiersep> timeout ) ; } \n \t3 catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 message = <identifier> <identifiersep> input . read <identifiersep> line ( ) ; \n \t3 logger . debug ( <string_literal> , message ) ; \n \t2 } catch ( io <identifiersep> exception io <identifiersep> exception ) { \n <ect>
\t2 illegal <identifiersep> argument <identifiersep> exception e = <identifier> <identifiersep> throws ( illegal <identifiersep> argument <identifiersep> exception . class , ( ) - > command . execute ( routing <identifiersep> <identifier> , false ) ) ; \n \t2 assert <identifiersep> equals ( <string_literal> + <identifier> + <string_literal> + <identifier> + <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> , e . get <identifiersep> message ( ) ) ; } \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> data <identifiersep> node ( ) { \n \t2 <identifier> <identifiersep> service <identifier> = create <identifiersep> <identifier> <identifiersep> service ( <identifier> . builder ( ) . put ( <string_literal> , <number_literal> ) . build ( ) ) ; \n <ect>
<comment> \n \t1 public final void <identifier> ( <identifier> <identifier> ) throws data <identifiersep> access <identifiersep> exception { \n \t2 try { \n <ect>
\t4 } ) ; \n \t4 } else { \n \t4 log . warn ( <string_literal> + <identifier> <identifiersep> host + <string_literal> ) ; } } } } \n \t2 } catch ( exception ex ) { \n <ect>
\t2 <identifier> <identifiersep> byte <identifiersep> cache . <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> == null ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t5 } catch ( exception e ) { \n \t6 log . warn ( <string_literal> , <identifier> , \n \t7 new <identifiersep> <identifier> ) ; } \n \t4 } else { \n <ect>
\t2 file config <identifiersep> file = new file ( config <identifiersep> <identifier> , config . get <identifiersep> id ( ) + <string_literal> ) ; \n \t2 try { \n \t3 config <identifiersep> file . delete ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> log . error ( <string_literal> , <identifier> ) ; \n \t3 <comment> \n \t3 throw <identifier> ; \n \t2 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 <identifier> <identifiersep> list . add ( <identifier> ) ; } } } \n private boolean load <identifiersep> <identifier> ( <identifier> <identifier> ) { \n \t1 input <identifiersep> stream <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = null ; \n <ect>
\t2 assert . assert <identifiersep> true ( base <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> type ( ( byte ) <identifier> , ( byte ) <identifier> ) == base <identifiersep> utils . base <identifiersep> <identifier> <identifiersep> type . <identifier> ) ; \n \t2 assert . assert <identifiersep> true ( base <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> type ( ( byte ) <identifier> , ( byte ) <identifier> ) == base <identifiersep> utils . base <identifiersep> <identifier> <identifiersep> type . <identifier> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( ) { \n <ect>
\t2 <identifier> <identifiersep> log . error ( log <identifiersep> template , <string_literal> , get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( session <identifiersep> log <identifiersep> entry ) , \n \t3 format <identifiersep> message ( session <identifiersep> log <identifiersep> entry ) ) ; \n \t2 return ; \n \t1 case session <identifiersep> log . <identifier> : \n <ect>
\t1 <identifier> . run ( test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cmd . get ( ) . get ( 0 ) ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> table <identifier> = client . get <identifiersep> table ( db <identifiersep> name , table <identifiersep> name ) ; \n \t1 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t1 <comment> \n <ect>
\t1 private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( base <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test . class ) ; \n \t1 @ <identifier> <identifiersep> class \n \t1 public static void <identifier> <identifiersep> class ( ) { \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> connection ( ) ) ; \n <ect>
\t2 command . add ( <string_literal> ) ; \n \t2 command . add ( <string_literal> ) ; \n \t2 string result = command . execute ( ) ; \n \t2 if ( result != null ) { \n <ect>
\t2 assert . assert <identifiersep> true ( <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> time <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> result result = <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 assert . assert <identifiersep> not <identifiersep> null ( result ) ; \n <ect>
\t6 } catch ( exception e ) { \n \t7 log . warn ( <string_literal> ) ; } } } } \n \t3 <comment> \n \t3 if ( conf <identifiersep> file != null && conf <identifiersep> file . exists ( ) ) { \n <ect>
<comment> \n \t1 final public < t extends root <identifiersep> <identifier> <identifiersep> entity > long put <identifiersep> resource ( string <identifier> <identifiersep> path , t <identifier> , long new <identifiersep> <identifier> , <identifier> < t > <identifier> ) throws io <identifiersep> exception { \n \t2 <identifier> <identifiersep> path = <identifier> ( <identifier> <identifiersep> path ) ; \n <ect>
\t1 { \n \t2 try { \n \t3 return get <identifiersep> url ( <identifier> , <identifier> , name , <identifier> , <identifier> , context ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t5 <identifier> , \n \t5 <string_literal> , \n \t5 get <identifiersep> sql <identifiersep> string ( ) \n \t3 ) ; } \n <ect>
\t4 if ( ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t5 <identifier> . close ( ) ; } \n \t3 } catch ( sql <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t2 <identifier> <identifiersep> <identifier> . set <identifiersep> volume <identifiersep> id ( <identifier> . get <identifiersep> <identifier> <identifiersep> volume ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> id ( <identifier> . get <identifiersep> <identifier> <identifiersep> account <identifiersep> number ( ) ) ; \n \t2 <identifier> . get <identifiersep> snapshot <identifiersep> set ( ) . add ( <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) != null ) { \n \t3 string <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t3 string version = <identifier> . get <identifiersep> <identifier> <identifiersep> version ( ) ; \n \t3 if ( new file ( <identifier> ) . exists ( ) && version != null ) { \n <ect>
\t4 entity . get <identifiersep> <identifier> <identifiersep> body ( ) , \n \t4 entity . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t3 entity . set <identifiersep> <identifier> ( <identifier> <identifiersep> info . get <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t4 if ( <identifier> != null ) { \n \t5 <identifier> . get <identifiersep> public <identifiersep> <identifier> ( ) . add ( <identifier> ) ; } \n \t4 set <identifiersep> <identifier> <identifiersep> info ( create <identifiersep> <identifier> <identifiersep> info ( <identifier> <identifiersep> user . get <identifiersep> id ( ) , <identifier> ) , <identifier> ) ; \n \t3 } else { \n <ect>
\t1 resource <identifiersep> <identifier> ( ) { \n \t2 try { \n \t3 <identifier> <identifiersep> service = file <identifiersep> <identifier> . get <identifiersep> default ( ) . new <identifiersep> <identifier> <identifiersep> service ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 this . <identifier> <identifiersep> <identifier> = null ; \n \t3 if ( <identifier> != null ) { \n \t4 <identifier> . shutdown ( status ) ; } } \n \t2 catch ( exception e ) { \n <ect>
\t1 public service <identifier> ( final request <identifiersep> context request <identifiersep> context , final web <identifiersep> context web <identifiersep> context , final base <identifiersep> client client ) { \n \t2 final string client <identifiersep> id = get <identifiersep> <identifier> <identifiersep> client <identifiersep> id ( web <identifiersep> context , client ) ; \n \t2 final transient <identifiersep> session <identifiersep> ticket ticket = this . ticket <identifiersep> <identifier> . get <identifiersep> ticket ( client <identifiersep> id , transient <identifiersep> session <identifiersep> ticket . class ) ; \n \t2 if ( ticket == null ) { \n <ect>
<number_literal> access <identifiersep> <identifier> <identifiersep> context ) ; } \n \t2 catch ( <identifier> <identifiersep> action <identifiersep> exception x ) \n \t2 { \n \t3 throwable e = x . get <identifiersep> <identifier> ( ) ; \n <ect>
\t2 try { \n \t3 map < object , object > <identifier> <identifiersep> conf = <identifier> <identifiersep> config . read <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> conf ( id , data . get <identifiersep> <identifier> <identifiersep> store ( ) ) ; \n \t3 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> utils . to <identifiersep> json ( <identifier> <identifiersep> conf ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , thread <identifiersep> pool , handle <identifiersep> <identifier> , empty <identifiersep> <identifier> <identifiersep> provider , ( ) - > state <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . start ( ) ; \n \t2 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 { \n <ect>
\t3 string <identifier> = v . get <identifiersep> property <identifiersep> path ( ) . to <identifiersep> string ( ) ; \n \t3 if ( ! is <identifiersep> null <identifiersep> or <identifiersep> empty ( <identifier> ) ) { \n \t4 <identifier> = <identifier> + <string_literal> + <identifier> ; } \n \t3 add ( new <identifier> <identifiersep> message ( <identifier> , msg ) ) ; \n <ect>
\t8 <identifier> <identifiersep> instance <identifiersep> id . set <identifiersep> string ( <number_literal> , private <identifiersep> ip ) ; \n \t8 try ( result <identifiersep> set <identifier> <identifiersep> instance <identifiersep> id = <identifier> <identifiersep> instance <identifiersep> id . execute <identifiersep> query ( ) ; ) { \n \t9 if ( ! <identifier> <identifiersep> instance <identifiersep> id . next ( ) ) { \n \t10 <comment> \n <ect>
\t3 try { \n \t4 int <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( network , <identifier> , <identifier> ) ; \n \t4 <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> queue <identifiersep> item <identifiersep> dao . <identifier> ( item ) ; \n \t5 return queue <identifiersep> vo ; } \n \t3 } ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 log . info ( <string_literal> , <identifier> ) ; } \n \t3 catch ( exception e ) { \n \t4 throw new <identifier> <identifiersep> exception ( <string_literal> + <identifier> , e ) ; } } \n \t2 <comment> \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> blank ( ticket <identifiersep> id <identifiersep> to <identifiersep> get ) ) { \n \t3 return null ; } \n \t2 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket <identifiersep> id <identifiersep> to <identifiersep> get ) ; \n \t2 if ( metadata == null ) { \n <ect>
\t2 string <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> path = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> path ( system <identifiersep> property , handler , m <identifiersep> logger ) \n \t4 + file . path <identifiersep> <identifier> \n \t4 + builder . <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> path ( properties . get <identifiersep> property ( <string_literal> , <string_literal> ) ) ; \n \t2 properties . set <identifiersep> property ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> path ) ; \n <ect>
\t1 try { \n \t1 if ( <identifier> != null ) { \n \t2 <identifier> . close ( ) ; } \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t1 string <identifier> = <identifier> <identifiersep> <identifier> [ i ] ; \n \t1 int sql <identifiersep> type = <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n \t1 string java <identifiersep> type = to <identifiersep> java <identifiersep> type ( <identifier> , sql <identifiersep> type ) ; \n \t1 if ( null == java <identifiersep> type ) { \n <ect>
protected connection get <identifiersep> connection ( ) { \n \t1 try { \n \t1 return get <identifiersep> test <identifiersep> server ( ) . get <identifiersep> connection ( ) ; \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t5 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> host <identifiersep> name ( ) != null ) \n \t6 ip <identifiersep> <identifier> <identifiersep> list . add ( <identifier> . get <identifiersep> <identifier> <identifiersep> host <identifiersep> name ( ) ) ; } } \n \t3 if ( ! ip <identifiersep> <identifier> <identifiersep> list . contains ( this . <identifier> <identifiersep> node . get <identifiersep> host ( ) ) ) { \n \t4 logger . info ( <string_literal> + ip <identifiersep> <identifier> <identifiersep> list ) ; \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> find ( string name ) throws remote <identifiersep> exception { \n \t2 if ( ! <identifier> . contains <identifiersep> key ( name ) ) { \n \t3 try { \n <ect>
\t3 if ( to <identifiersep> delete . size ( ) > 0 ) { \n \t4 log . warn ( <string_literal> ) ; \n \t4 for ( <identifier> <identifiersep> meta meta : to <identifiersep> delete ) { \n \t5 log . warn ( <string_literal> , meta . get <identifiersep> <identifier> ( ) , meta . get <identifiersep> id ( ) ) ; } \n <ect>
\t1 public <identifier> <identifiersep> query <identifiersep> <identifier> <identifiersep> error <identifiersep> handler ( logger logger ) { \n \t2 this . logger = logger ; } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> error ( throwable error , query <identifiersep> message < ? , ? > query <identifiersep> message , message <identifiersep> handler message <identifiersep> handler ) { \n <ect>
\t3 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n \t4 logger . info ( <string_literal> + <identifier> <identifiersep> name ) ; \n \t4 <identifier> <identifiersep> info <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> by <identifiersep> name ( <identifier> <identifiersep> name ) ; \n \t4 if ( <identifier> != null ) { \n <ect>
\t3 return null ; } \n \t2 <comment> \n \t2 x <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
end \n <identifier> runtime <identifiersep> error , <string_literal> if <identifier> \n # assert <identifier> <identifier> from new location . \n is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , r ) \n <ect>
\t2 <identifier> <identifier> = <identifier> <identifiersep> factory . <identifier> ( <string_literal> , <string_literal> ) ; \n \t2 return <identifier> ; } \n \t1 public static void load <identifiersep> data ( <identifier> <identifier> , string file ) \n \t1 { \n <ect>
\t3 <identifier> <identifiersep> time <identifier> = update <identifiersep> and <identifiersep> log ( <identifier> <identifiersep> version <identifiersep> name . to <identifiersep> string ( ) , <identifier> , <identifier> <identifiersep> version <identifiersep> name ) ; \n \t3 assert . assert <identifiersep> true ( <identifier> <identifiersep> <identifier> . is <identifiersep> version <identifiersep> of ( <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) , test <identifiersep> name ) ) ; \n \t3 assert . assert <identifiersep> equals ( <identifier> , <identifier> ) ; \n \t3 assert . assert <identifiersep> true ( <string_literal> , <identifier> . is <identifiersep> <identifier> ( ) ) ; \n <ect>
\t2 assert <identifiersep> that ( <identifier> <identifiersep> snapshot <identifiersep> response . get <identifiersep> <identifier> <identifiersep> info ( ) . total <identifiersep> shards ( ) , <identifier> <identifiersep> <identifier> ( 0 ) ) ; \n \t2 assert <identifiersep> that ( client . <identifier> <identifiersep> get ( <identifier> <identifiersep> index <identifiersep> name , type <identifiersep> name , <identifier> <identifiersep> id ) . get ( ) . is <identifiersep> exists ( ) , equal <identifiersep> to ( true ) ) ; } \n \t1 public void test <identifiersep> <identifier> <identifiersep> index <identifiersep> <identifier> ( ) { \n \t2 client client = client ( ) ; \n <ect>
\t2 for ( <identifier> <identifiersep> session session : <identifier> <identifiersep> <identifier> ) { \n \t3 try { \n \t4 session . close ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 <identifier> = new <identifier> <identifiersep> input <identifiersep> stream ( is ) ; \n \t3 try { \n \t4 <identifier> = new input <identifiersep> stream <identifiersep> <identifier> ( <identifier> , <string_literal> ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> field ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t4 set <identifiersep> field <identifiersep> value ( field , cmd , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( final illegal <identifiersep> argument <identifiersep> exception <identifier> <identifiersep> ex ) { \n <ect>
try { \n \t1 if ( <identifier> <identifiersep> conf . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> conf ( ) , <identifier> <identifiersep> conf . conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> nodes ) ) { \n \t2 remove <identifiersep> all <identifiersep> <identifier> <identifiersep> nodes ( ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> target ( ) . <identifier> <identifiersep> volume <identifiersep> from <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( null , null ) ) . set <identifiersep> context ( context ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> volume , <identifier> <identifiersep> volume , <identifier> ) ; \n \t3 return <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 try { thread . <identifier> ( <number_literal> ) ; } catch ( throwable t ) { } \n \t3 <comment> \n \t3 try ( final <identifier> <identifier> = <identifier> . <identifier> ( ) ) { \n <ect>
\t3 logger . debug ( <string_literal> , <identifier> <identifiersep> conf ) ; \n \t3 final resource <identifier> = this . resource <identifiersep> <identifier> . get <identifiersep> resource ( <identifier> <identifiersep> conf ) ; \n \t3 if ( <identifier> != null && <identifier> . exists ( ) ) { \n \t4 final string url <identifiersep> path = <identifier> . get <identifiersep> url ( ) . to <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t5 } while ( <identifier> . <identifier> <identifiersep> and <identifiersep> set ( <identifier> , <identifier> | ( 1 < < thread ) ) ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n \t5 <comment> \n \t3 } catch ( exception e ) { \n <ect>
\t1 public <identifier> <identifiersep> data <identifiersep> type get <identifiersep> data <identifiersep> type ( ) { \n \t2 try { \n \t3 return data <identifiersep> type . new <identifiersep> instance ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> message = node . <identifier> ( \n \t5 command <identifiersep> class . set <identifiersep> message ( <identifier> , ( <identifier> <identifiersep> <identifier> ) <identifier> . <identifier> <identifiersep> from <identifiersep> command <identifiersep> to <identifiersep> value ( item , command ) ) , \n \t5 command <identifiersep> class , endpoint <identifiersep> id ) ; } \n \t2 if ( <identifier> <identifiersep> message == null ) { \n <ect>
\t4 <identifier> ++ ; \n \t3 message message = session . create <identifiersep> message ( ) ; \n \t3 message . set <identifiersep> string <identifiersep> property ( <string_literal> , filter ? <string_literal> : <string_literal> ) ; \n \t3 <identifier> . send ( <identifier> , message ) ; } \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( runtime <identifiersep> exception e ) { \n \t3 num <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t2 } catch ( storage <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t3 return null ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 if ( function . n <identifiersep> <identifier> <identifiersep> request . get <identifiersep> or <identifiersep> else ( 1 ) > 1 ) { \n \t2 if ( function . <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> request <identifiersep> <identifier> <identifiersep> <identifier> ) \n <ect>
\t2 <identifier> . <identifier> ( <string_literal> + stream <identifiersep> <identifier> . get <identifiersep> line <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> service . get <identifiersep> instance ( ) . set <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> template ) ; } \n \t1 @ <identifier> \n \t1 public status <identifier> ( connection connection , string default <identifiersep> <identifier> ) { \n <ect>
\t1 @ <identifier> \n \t1 public authentication <identifiersep> result build ( final service service ) { \n \t2 final authentication authentication = build <identifiersep> authentication ( ) ; \n \t2 if ( authentication == null ) { \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> < <identifier> <identifiersep> item > query ( filter <identifiersep> <identifier> filter ) { \n \t2 logger . debug ( <string_literal> ) ; \n \t2 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t1 r = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( new file <identifiersep> input <identifiersep> stream ( <identifier> ) ) ) ; \n \t1 for ( string <identifier> <identifiersep> line : <identifier> <identifiersep> <identifier> ) { \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> line , r . read <identifiersep> line ( ) ) ; } \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 integer id = key <identifiersep> list . index <identifiersep> of ( key ) ; \n \t3 <comment> \n \t3 map < byte <identifiersep> array , byte [ ] > <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> map = node <identifiersep> to <identifiersep> <identifier> <identifiersep> data . get ( node <identifiersep> id ) ; \n \t3 if ( <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> map == null ) { \n <ect>
\t3 && <identifier> . get <identifiersep> state ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) != <identifier> <identifiersep> state . <identifier> ) { \n \t2 log . debug ( <string_literal> , <identifier> ) ; \n \t2 return false ; } \n \t1 } else if ( ! <identifier> . <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t5 log . debug ( <string_literal> + msg ) ; \n \t4 return ; } \n \t3 if ( ! is <identifiersep> local <identifiersep> node <identifiersep> <identifier> ( ) && <identifier> <identifiersep> node <identifiersep> id . equals ( msg . <identifier> <identifiersep> node <identifiersep> id ( ) ) ) { \n <ect>
\t1 } catch ( java . <identifier> . socket <identifiersep> exception e ) { \n \t1 logger . info ( <string_literal> ) ; \n \t1 } catch ( interrupted <identifiersep> io <identifiersep> exception e ) { \n \t1 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n <ect>
\t4 this . set <identifiersep> response <identifiersep> object ( response ) ; \n \t3 } else { \n \t4 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . <identifier> <identifiersep> error , <string_literal> ) ; } \n \t2 } catch ( network <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t1 if ( connection <identifiersep> timeout < <number_literal> ) { \n \t2 logger . warn ( <string_literal> , pool <identifiersep> name , connection <identifiersep> timeout ) ; \n \t2 connection <identifiersep> timeout = connection <identifiersep> timeout ; } \n \t1 if ( <identifier> <identifiersep> timeout < <number_literal> ) { \n <ect>
\t1 public <identifier> <identifiersep> <identifier> ( command <identifiersep> builder builder , config config , command <identifier> , command <identifier> , <identifier> <identifiersep> context context ) { \n \t1 super ( builder , config , <identifier> , <identifier> , context ) ; \n \t1 config <identifier> <identifiersep> <identifier> <identifiersep> config = get <identifiersep> <identifier> ( ) . get <identifiersep> config ( config , <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> config , context ) ; \n <ect>
\t2 { \n \t3 key key = <identifier> . get <identifiersep> key ( ) ; \n \t3 map . put <identifiersep> if <identifiersep> <identifier> ( key , <identifier> ) ; \n \t3 return key ; } \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> blank ( token <identifiersep> <identifier> ) || ! boolean <identifiersep> utils . to <identifiersep> boolean ( token <identifiersep> <identifier> ) ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 return super . build ( ticket <identifiersep> <identifier> <identifiersep> ticket , request ) ; } \n \t2 final string <identifier> = this . token <identifiersep> ticket <identifiersep> builder . build ( ticket <identifiersep> <identifier> <identifiersep> ticket ) ; \n <ect>
\t5 s <identifiersep> logger . error ( <string_literal> + item . get <identifiersep> content <identifiersep> id ( ) + <string_literal> , <identifier> ) ; } } \n \t3 try { \n \t4 <identifier> <identifiersep> execution ( job ) ; \n \t3 } catch ( <identifier> <identifiersep> execution <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 model . set <identifiersep> <identifier> <identifiersep> <identifier> ( query . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t2 catch ( exception ex ) { \n <ect>
\t1 * <identifier> a message <identifier> error level . \n \t1 * < p > \n \t1 * <identifier> <identifier> : \n \t1 * < <identifier> > \n <ect>
\t2 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; } \n \t1 protected <identifier> <identifiersep> connection <identifiersep> factory create <identifiersep> <identifier> <identifiersep> connection <identifiersep> factory ( ) { \n \t2 <identifier> <identifiersep> connection <identifiersep> factory <identifier> = new <identifier> <identifiersep> connection <identifiersep> factory ( \n \t3 <string_literal> ) ; \n <ect>
\t5 . get <identifiersep> user <identifiersep> id ( ) ) ) ; \n \t3 return ( o <identifiersep> <identifier> <identifiersep> entry ) action <identifiersep> <identifier> . execute ( current <identifiersep> context , update <identifiersep> request <identifiersep> to <identifiersep> access <identifiersep> token <identifiersep> action ) ; } \n \t2 catch ( exception ex ) \n \t2 { \n <ect>
\t4 try { \n \t5 if ( ! <identifier> <identifiersep> model . <identifier> ( get <identifiersep> model <identifiersep> <identifier> ( ) ) ) { \n \t6 <identifier> <identifiersep> model . update ( get <identifiersep> model <identifiersep> <identifier> ( ) ) ; } \n \t4 } catch ( exception ex ) { \n <ect>
\t2 } else if ( client . get <identifiersep> <identifier> <identifiersep> mode ( ) . equals <identifiersep> ignore <identifiersep> case ( <identifier> <identifiersep> <identifier> <identifiersep> properties . <identifier> <identifiersep> mode <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 log . info ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> mode ( <identifier> <identifiersep> mode . <identifier> <identifiersep> <identifier> ) ; \n \t2 } else { \n <ect>
\t1 if ( ! <identifier> . is <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) ) { \n \t1 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> bean <identifiersep> name ( ) + <string_literal> ) ; } \n \t1 <identifier> . set <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> ( true ) ; \n \t1 if ( ! <identifier> <identifiersep> key <identifiersep> <identifier> . name ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t5 public void run ( ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> connection . this . exception <identifiersep> listener . on <identifiersep> exception ( e ) ; } \n \t4 } ) ; \n \t3 } else { \n <ect>
\t1 private boolean check <identifiersep> list <identifiersep> of <identifiersep> <identifier> ( string <identifiersep> builder <identifier> <identifiersep> list , string <identifiersep> builder <identifier> <identifiersep> <identifier> <identifiersep> list , configuration conf ) \n \t3 throws io <identifiersep> exception { \n \t2 string [ ] uri <identifiersep> list = <identifier> <identifiersep> <identifier> <identifiersep> list . to <identifiersep> string ( ) . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . instance <identifiersep> <identifier> ) ; \n \t2 if ( uri <identifiersep> list [ 0 ] != null ) { \n <ect>
\t1 try ( final transaction <identifiersep> resource <identifier> = <identifier> . transaction <identifiersep> for ( <identifier> <identifiersep> <identifier> . class ) ) { \n \t2 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> by <identifiersep> name ( null , <identifier> <identifiersep> <identifier> <identifiersep> id , <identifier> . < <identifier> <identifiersep> <identifier> > <identifier> ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> network <identifiersep> interface ( ) != null && \n \t3 <identifier> <identifiersep> <identifier> . get <identifiersep> public <identifiersep> ip <identifiersep> address ( ) == null ) try { <comment> \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 return value ; \n \t2 } else { \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> + element <identifiersep> name ) ; \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + element <identifiersep> name ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t5 <comment> \n \t5 return true ; } } \n \t2 } else { \n \t3 <comment> \n <ect>
\t4 if ( <identifier> . exists ( p ) == true ) { \n \t5 <identifier> . delete ( p , true ) ; \n \t5 logger . info ( <string_literal> + <identifier> <identifiersep> path ) ; \n \t4 } else { \n <ect>
\t6 throw new <identifier> <identifiersep> error <identifiersep> exception ( <string_literal> ) ; \n \t5 try { \n \t6 model model = model <identifiersep> factory . create <identifiersep> default <identifiersep> model ( ) ; \n \t6 <identifier> <identifiersep> load <identifiersep> utils . load <identifiersep> model ( model , uri , max <identifiersep> <identifier> ) ; \n <ect>
\t2 try { \n \t3 method method = web <identifiersep> <identifier> . get <identifiersep> class ( ) . get <identifiersep> method ( <string_literal> ) ; \n \t3 method . <identifier> ( web <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <comment> \n \t1 <comment> \n <ect>
\t2 try { <identifier> <identifiersep> context . job <identifiersep> queue ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . <identifier> <identifiersep> db ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n <ect>
\t2 <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> ticket ( attributes , <identifier> <identifiersep> attributes <identifiersep> to <identifiersep> <identifier> , <identifier> , registered <identifiersep> service ) ; \n \t2 <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> attribute <identifiersep> <identifier> ( attributes , registered <identifiersep> service ) ; } \n \t1 private static void <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> attribute <identifiersep> <identifier> ( final map < string , object > attributes , \n <number_literal> final registered <identifiersep> service registered <identifiersep> service ) { \n <ect>
private void start <identifiersep> <identifier> <identifiersep> <identifier> ( int <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> <identifier> , string job <identifiersep> id ) { \n \t1 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t1 <identifier> <identifiersep> <identifier> = get <identifiersep> context ( ) . <identifier> <identifiersep> of ( <identifier> . create ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class , <identifier> ( ) ) \n \t2 . with <identifiersep> <identifier> ( <string_literal> ) , <string_literal> + <identifier> . <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ) ; } \n <ect>
\t1 { \n \t1 @ <identifier> \n \t1 public void on <identifiersep> success ( <identifier> <identifier> ) \n \t1 { \n <ect>
\t6 i . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) , \n \t6 i . get <identifiersep> name ( ) ) ) ; } \n \t3 log . info ( <string_literal> + <identifier> . size ( ) + <string_literal> ) ; \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t3 for ( test <identifiersep> element config : <identifier> ) { \n \t4 if ( config != null ) { \n \t5 <identifier> . <identifier> <identifiersep> <identifier> ( config , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t8 <comment> \n \t8 if ( key instanceof property ) { \n \t9 <identifier> <identifiersep> property ( node , ( property ) key ) ; } } } } \n \t4 } ) ; \n <ect>
\t1 <identifier> <identifiersep> <identifier> . set <identifiersep> property ( <identifier> <identifiersep> <identifier> <identifiersep> cache , <string_literal> ) ; \n \t1 file <identifiersep> output <identifiersep> stream out = null ; \n \t1 try { \n \t2 out = new file <identifiersep> output <identifiersep> stream ( <identifier> <identifiersep> location ) ; \n <ect>
\t1 <identifier> <identifiersep> log . info ( <string_literal> + target <identifiersep> files ) ; } \n \t1 else \n \t1 { \n \t1 <identifier> <identifiersep> files = target <identifiersep> files ; \n <ect>
\t8 <identifier> = <identifier> . get <identifiersep> object ( 1 ) ; } } \n \t5 } catch ( sql <identifiersep> exception e ) { \n \t6 s <identifiersep> logger . warn ( <string_literal> + ( <identifier> <identifiersep> <identifier> != null ? <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) : <string_literal> ) , e ) ; } \n \t5 if ( <identifier> == null ) { \n <ect>
\t3 <identifier> . get <identifiersep> attributes ( ) . key <identifiersep> set ( ) . stream ( ) . for <identifiersep> <identifier> ( <identifier> <identifiersep> name - > { \n \t4 if ( authentication <identifiersep> attributes . contains <identifiersep> key ( <identifier> <identifiersep> name ) ) { \n \t5 logger . debug ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t5 final object <identifier> <identifiersep> value = authentication <identifiersep> attributes . remove ( <identifier> <identifiersep> name ) ; \n <ect>
\t2 try { \n \t3 this . query <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list == null ? null \n \t5 : <identifier> <identifiersep> utils . <identifier> ( ( <identifier> ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list ) ; \n \t2 } catch ( exception e ) { <comment> \n <ect>
\t2 return client . equals ( <identifier> <identifiersep> lock ( lock <identifiersep> path ) ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( string lock <identifiersep> path ) { \n \t2 lock <identifiersep> path = <identifier> ( lock <identifiersep> path ) ; \n <ect>
\t3 return new <identifier> <identifiersep> local <identifiersep> network ( this , <identifier> . <identifier> ( ) . next ( ) , null , null , null ) ; } \n \t2 if ( <identifier> . size ( ) == 0 ) { \n \t3 return null ; } \n <ect>
\t2 <comment> \n \t2 assert <identifiersep> that ( client ( <identifier> ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> <identifier> ( ) . get ( ) . get <identifiersep> state ( ) . get <identifiersep> routing <identifiersep> nodes ( ) . <identifier> ( ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; } \n \t1 public void test <identifiersep> do <identifiersep> not <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> be <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) throws exception { \n \t2 create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) \n \t3 <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t3 return <identifier> <identifiersep> manager . create ( ) . write ( ) \n \t2 } catch ( e : exception ) { \n <ect>
\t5 . create <identifiersep> <identifier> ( message ) \n \t4 ) \n \t3 . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ; \n \t2 client . transaction ( ) . for <identifiersep> <identifier> ( <identifier> ) . <identifier> ( e - > { \n <ect>
\t1 <identifier> <identifiersep> output <identifiersep> stream out = new <identifier> <identifiersep> output <identifiersep> stream ( connection . get <identifiersep> output <identifiersep> stream ( ) ) ; \n \t1 try { \n \t2 <identifier> . write <identifiersep> to ( out ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 byte [ ] <identifier> <identifiersep> bytes , byte [ ] <identifier> <identifiersep> bytes <identifiersep> <identifier> , job <identifiersep> conf job ) throws io <identifiersep> exception { \n \t1 application <identifiersep> id <identifier> <identifiersep> id = <identifier> <identifiersep> <identifier> <identifiersep> info . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t1 <comment> \n \t1 string user = system . <identifier> ( application <identifiersep> <identifier> . <identifier> . user . name ( ) ) ; \n <ect>
\t3 try { \n \t4 socket . <identifier> ( ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { } \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 m <identifiersep> <identifier> . shutdown ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> all <identifiersep> <identifier> ( ) ; } \n \t2 catch ( runtime <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time = \n \t5 <identifier> <identifiersep> collection <identifiersep> type . get ( <identifier> <identifiersep> store ) . <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> store , <identifier> ) ; \n <ect>
\t1 if ( state . is <identifiersep> first <identifiersep> <identifier> ( ) ) { \n \t1 log . info ( <string_literal> ) ; \n \t1 return true ; } \n \t1 <identifier> <identifier> <identifiersep> <identifier> = state . get <identifiersep> current <identifiersep> <identifier> ( ) ; \n <ect>
\t3 @ <identifier> \n \t3 public void set <identifiersep> attribute ( path path , string attribute , object value , <identifier> <identifiersep> <identifier> . . . options ) throws io <identifiersep> exception { \n \t4 logger . info ( <string_literal> ) ; ; } \n \t3 private abstract <identifiersep> file create ( final path path ) throws io <identifiersep> exception { \n <ect>
\t2 assert <identifier> != null ; \n \t2 try { \n \t3 <identifier> <identifiersep> m <identifiersep> bean = <identifier> . <identifier> <identifiersep> m <identifiersep> bean ( <identifier> , grid <identifiersep> name , <string_literal> , get <identifiersep> name ( ) , <identifier> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t1 { \n \t2 if ( <identifier> instanceof io <identifiersep> exception ) \n \t3 logger . trace ( <string_literal> , connection <identifiersep> id , <identifier> ) ; \n \t2 else \n <ect>
\t2 throw <identifier> ( e ) ; } \n \t1 map < <identifier> <identifiersep> and <identifiersep> name , ? extends <identifier> > <identifier> <identifiersep> map = <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> and <identifiersep> id <identifiersep> map . <identifier> <identifiersep> to <identifiersep> map ( <identifier> <identifiersep> <identifier> ) ; \n \t1 cache . get ( ) . <identifier> <identifiersep> all ( ) ; \n \t1 cache . get ( ) . put <identifiersep> all ( map . class . <identifier> ( <identifier> <identifiersep> map ) ) ; \n <ect>
\t4 for ( int length = <identifier> . length ; length >= 0 ; length -- ) { \n \t5 <identifier> <identifiersep> method method = abstract <identifiersep> method ( return <identifiersep> type , m . get <identifiersep> name ( ) , <identifier> . <identifier> <identifiersep> of ( <identifier> , length ) , empty , <identifier> ) ; \n \t5 if ( <identifier> . add ( method ) ) { \n \t6 <identifier> . add <identifiersep> method ( method ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; \n \t3 return null ; } \n \t2 return <identifier> <identifiersep> <identifier> ; } \n \t1 private boolean <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> ) { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> provider <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> element <identifiersep> cmd cmd ) { \n \t2 final <identifier> <identifiersep> provider <identifiersep> vo element = <identifier> <identifiersep> <identifier> <identifiersep> provider <identifiersep> dao . find <identifiersep> by <identifiersep> id ( cmd . get <identifiersep> id ( ) ) ; \n \t2 if ( element == null ) { \n <ect>
<comment> \n private void set <identifiersep> <identifier> ( string <identifier> ) { \n <ect>
<comment> \n <ect>
\t4 synchronized ( conn ) { \n \t5 try ( <identifier> <identifiersep> <identifier> <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; ) { \n \t6 <identifier> . execute <identifiersep> query ( ) ; \n \t5 } catch ( throwable <identifier> ) { \n <ect>
<number_literal> <identifier> . <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) , user . source . <identifier> ) ; \n \t7 response . set <identifiersep> <identifier> <identifiersep> id ( string . value <identifiersep> of ( user <identifiersep> account . get <identifiersep> account <identifiersep> id ( ) ) ) ; \n \t7 logger . info ( <string_literal> + <identifier> + <string_literal> + <identifier> <identifiersep> id ) ; \n \t6 } catch ( exception e ) { \n <ect>
\t3 for ( file <identifiersep> <identifier> <identifiersep> listener listener : <identifier> ( ) ) { \n \t4 try { \n \t5 listener . on <identifiersep> file <identifiersep> <identifier> ( file ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 action <identifiersep> <identifier> < <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> response > response <identifiersep> listener = builder . execute ( ) ; \n \t2 try { \n \t3 logger . info ( <string_literal> ) ; \n \t3 assert <identifiersep> <identifier> ( ( ) - > assert <identifiersep> that ( task <identifiersep> status ( action ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> ( <identifier> ) ) ) ; \n <ect>
\t3 throw new illegal <identifiersep> transaction <identifiersep> state <identifiersep> exception ( \n \t5 <string_literal> ) ; } \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == transaction <identifiersep> <identifier> . <identifier> <identifiersep> not <identifiersep> <identifier> ) { \n \t3 if ( debug <identifiersep> enabled ) { \n <ect>
\t2 <identifier> <identifier> = <identifier> . new <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 <identifier> . <identifier> ( new stream <identifiersep> source ( new string <identifiersep> <identifier> ( xml <identifiersep> content ) ) ) ; } \n \t2 catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 data <identifiersep> length = <identifier> . <identifier> ( end - start + 1 , data <identifiersep> length ) ; \n \t3 if ( data <identifiersep> length < = 0 ) return null ; \n \t3 <identifier> <identifiersep> data = <identifier> . <identifier> <identifiersep> of <identifiersep> <identifier> ( item . <identifier> , start , start + data <identifiersep> length ) ; \n \t3 <identifier> . add ( start , start + data <identifiersep> length - 1 ) ; \n <ect>
\t10 @ <identifier> \n \t10 public void failed ( final exception ex ) { \n <number_literal> if ( ex instanceof resource <identifiersep> io <identifiersep> exception ) { \n <ect>
\t2 <identifier> <identifiersep> class = null ; \n \t2 bean <identifiersep> info = null ; } \n \t1 public test <identifiersep> bean <identifiersep> <identifier> ( class < ? > test <identifiersep> bean <identifiersep> class ) { \n \t2 super ( ) ; \n <ect>
\t6 return to <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> class <identifiersep> <identifier> , <identifier> . < string , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type > empty <identifiersep> map ( ) ) ; } \n \t4 } finally { \n \t5 <identifier> <identifiersep> file . close ( ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t4 } catch ( <identifier> <identifiersep> url <identifiersep> exception <identifier> ) { } } \n \t3 if ( <identifier> ) { \n \t4 store <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } else if ( ! <identifier> ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 item item = null ; \n \t2 string item <identifiersep> name = filter . get <identifiersep> item <identifiersep> name ( ) ; \n <ect>
\t3 item item = null ; \n \t3 try { \n \t4 item = this . item <identifiersep> <identifier> . get <identifiersep> item ( filter . get <identifiersep> item <identifiersep> name ( ) ) ; \n \t3 } catch ( item <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t2 class <identifier> = new <identifier> <identifiersep> class <identifiersep> <identifier> ( ) . parse <identifiersep> class ( <string_literal> <string_literal> <ect>
\t2 return response . <identifier> ( ) . build ( ) ; } \n \t1 @ <identifier> \n \t1 @ timeout \n \t1 public void timeout ( <identifier> <identifier> ) { \n <ect>
\t2 int <identifier> = 0 ; \n \t2 while ( true ) { \n \t3 try { \n \t4 if ( <identifier> > 0 ) { \n <ect>
\t4 return ; } \n \t3 delete <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> vm . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> <identifiersep> log <identifiersep> <identifier> ) ; \n \t3 api . delete ( <identifier> <identifiersep> <identifier> . class , <identifier> <identifiersep> vm . get <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 if ( <identifier> . size ( ) == 0 ) { \n \t3 <comment> \n \t3 throw new <identifier> <identifiersep> index <identifiersep> exception ( <string_literal> + root ) ; } \n \t2 if ( <identifier> . size ( ) != 1 ) { \n <ect>
\t4 <identifier> . <identifier> ( cache ) ; \n \t4 cache . <identifier> <identifiersep> cache <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 cache <identifiersep> manager . add <identifiersep> cache ( cache ) ; \n <ect>
\t6 if ( <identifier> . get <identifiersep> property ( <identifier> <identifiersep> object . id ) == null ) { \n \t7 <identifier> . <identifier> <identifiersep> system <identifiersep> properties <identifiersep> <identifier> ( ) ; \n \t7 <identifier> . set <identifiersep> property ( <identifier> <identifiersep> object . id , node <identifiersep> service <identifiersep> command . get <identifiersep> next <identifiersep> <identifier> ( ) ) ; } \n \t5 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 } catch ( version <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 assert . <identifier> ( <string_literal> + e . get <identifiersep> message ( ) ) ; } \n \t2 <identifier> . check <identifiersep> error ( ) ; \n \t2 response <identifiersep> <identifier> . add ( <identifier> ) ; \n <ect>
\t5 log . debug ( <string_literal> ) ; \n \t5 on <identifiersep> exception ( illegal <identifiersep> argument <identifiersep> exception . class ) . set <identifiersep> body ( <identifier> ( <string_literal> ) ) . \n \t6 to ( <string_literal> ) ; \n \t4 } else if ( get <identifiersep> name ( ) . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
\t1 protected void do <identifiersep> start ( ) throws exception { \n \t2 if ( <identifier> <identifiersep> cache == null ) { \n \t3 if ( cache <identifiersep> size < 0 ) { \n \t4 <identifier> <identifiersep> cache = new empty <identifiersep> <identifier> <identifiersep> cache ( this , <identifier> <identifiersep> context ) ; \n <ect>
\t3 for ( int i = 0 ; i < num <identifiersep> nodes ; i ++ ) { \n \t4 <identifier> <identifiersep> builder . <identifier> ( <string_literal> + i ) ; } \n \t3 <identifier> . <identifier> ( <identifier> <identifiersep> builder , empty <identifiersep> <identifier> . instance , <identifier> <identifiersep> info . empty ) ; } \n \t2 <comment> \n <ect>
\t3 log . error ( <string_literal> , class <identifiersep> name , method <identifiersep> name , method <identifiersep> <identifier> <identifiersep> type . get <identifiersep> <identifier> <identifiersep> name ( ) , e ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> , class <identifiersep> name , method <identifiersep> name , method <identifiersep> <identifier> <identifiersep> type . get <identifiersep> <identifier> <identifiersep> name ( ) , e ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t6 log . info ( <string_literal> + consumer ) ; \n \t6 consumer . set <identifiersep> message <identifiersep> listener ( listener ) ; \n \t6 <identifier> . put ( consumer , listener ) ; } \n \t4 } catch ( exception e ) { \n <ect>
\t5 this . log . warn ( ex . get <identifiersep> message ( ) ) ; } } } \n \t2 if ( ! <identifier> <identifiersep> options . is <identifiersep> empty ( ) ) { \n <ect>
\t2 key <identifiersep> info <identifiersep> provider <identifiersep> list . add ( new <identifier> <identifiersep> <identifier> <identifiersep> provider ( ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> resource <identifiersep> location ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifier> = build <identifiersep> <identifier> <identifiersep> for <identifiersep> metadata <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> resource <identifiersep> location ) ; \n \t2 logger . info ( <string_literal> , <identifier> <identifiersep> resource <identifiersep> location ) ; \n <ect>
\t6 response . get <identifiersep> <identifier> <identifiersep> status <identifiersep> value ( ) ) ; \n \t4 <identifier> . add ( id . get <identifiersep> value ( ) ) ; \n \t4 <identifier> ++ ; \n \t4 continue ; } \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> < string , ? > config ) throws configuration <identifiersep> exception { \n \t2 logger . debug ( <string_literal> , config != null ? true : false ) ; \n \t2 if ( <identifier> <identifiersep> port != null ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> network <identifiersep> <identifier> . <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> <identifiersep> to <identifiersep> stop ) ; \n \t4 s <identifiersep> logger . debug ( <string_literal> + vm ) ; \n \t3 } catch ( final exception e ) { \n <ect>
\t3 return false ; \n \t2 int <identifier> = get <identifiersep> <identifier> <identifiersep> index ( <identifier> <identifiersep> <identifier> <identifiersep> unit ) ; \n \t2 if ( <identifier> != - 1 ) { \n \t3 logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> unit + <string_literal> + this + <string_literal> ) ; \n <ect>
\t2 log <identifiersep> log . warn ( \n \t3 <string_literal> + <identifier> <identifiersep> class . get <identifiersep> name ( ) \n \t3 + <string_literal> ) ; } \n \t1 } catch ( exception ex ) { \n <ect>
\t1 * \n \t1 * @ <identifier> <identifier> <identifiersep> cmd the e <identifiersep> <identifier> command to send . \n \t1 ** / \n \t1 public void send <identifiersep> command <identifiersep> and <identifiersep> close ( string <identifier> <identifiersep> cmd ) { \n <ect>
\t2 assert <identifier> <identifiersep> <identifier> != null ; \n \t2 assert <identifier> != null ; \n \t2 assert <identifier> <identifiersep> <identifier> != null ; \n \t2 assert <identifier> <identifiersep> <identifier> != null ; \n <ect>
\t2 <comment> \n \t2 while ( new <identifiersep> <identifier> <identifiersep> enum . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) \n \t2 { \n \t3 string group <identifiersep> name = new <identifiersep> <identifier> <identifiersep> enum . next <identifiersep> element ( ) ; \n <ect>
\t3 method <identifier> <identifiersep> <identifier> <identifiersep> method = <identifier> <identifiersep> bean <identifiersep> class . get <identifiersep> method ( <string_literal> ) ; \n \t3 object result = <identifier> <identifiersep> <identifier> <identifiersep> method . <identifier> ( <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> bean ( ) ) ; \n \t3 return ( long ) result ; } \n \t2 catch ( throwable t ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> uri = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> uri ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> . set ( true ) ; } } \n \t4 catch ( <identifier> <identifiersep> <identifier> <identifiersep> store <identifiersep> failure <identifiersep> exception e ) \n \t4 { \n <ect>
\t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t5 assert false ; \n \t5 e . add <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 } else if ( e instanceof node <identifiersep> <identifier> <identifiersep> exception ) { \n <ect>
\t2 <comment> \n \t2 <identifier> . add <identifiersep> first ( <string_literal> , new <identifier> <identifiersep> handler ( <identifier> <identifiersep> <identifier> ) ) ; } \n \t2 return super . new <identifiersep> channel ( <identifier> ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t4 try { \n \t5 <comment> \n \t5 <identifier> <identifiersep> <identifier> . service <identifiersep> failed ( event ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 } catch ( exception e ) { \n \t1 log . warn ( <string_literal> + snapshot <identifiersep> id + <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id , e ) ; \n \t1 try { \n \t2 if ( ! <identifier> . is <identifiersep> null <identifiersep> or <identifiersep> empty ( <identifier> <identifiersep> name ) ) { \n <ect>
\t1 @ <identifier> \n \t1 public void run ( ) { \n \t2 if ( max <identifiersep> time <identifiersep> <identifier> <identifiersep> last <identifiersep> <identifier> < 0 ) { \n \t3 <comment> \n <ect>
\t4 logger . debug ( <string_literal> , node . get <identifiersep> node <identifiersep> id ( ) ) ; \n \t4 return ; } \n \t3 file file = new file ( this . <identifier> <identifiersep> name , string . format ( <string_literal> , node . get <identifiersep> node <identifiersep> id ( ) ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> = null ; \n <ect>
\t1 @ <identifier> \n \t1 protected <identifier> <identifiersep> service create <identifiersep> <identifier> ( ) throws exception { \n \t2 return create <identifiersep> <identifier> ( <string_literal> ) ; } \n \t1 protected <identifier> <identifiersep> service create <identifiersep> <identifier> ( string uri ) throws exception { \n <ect>
\t1 public boolean is <identifiersep> <identifier> ( ) { \n \t2 long time <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - last <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> ; \n \t2 boolean <identifier> = time <identifiersep> <identifier> < max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> ; \n \t2 if ( ! <identifier> ) { \n <ect>
\t3 return value ; } \n \t2 try { \n \t3 return new url <identifiersep> <identifier> ( ) . <identifier> ( value ) . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public set < class < ? > > find <identifiersep> <identifier> ( class < ? extends <identifier> > <identifier> , string . . . package <identifiersep> <identifier> ) { \n \t2 if ( package <identifiersep> <identifier> == null ) { \n \t3 return <identifier> . empty <identifiersep> set ( ) ; } \n <ect>
\t5 s <identifiersep> logger . debug ( <string_literal> + host <identifiersep> id + <string_literal> + host <identifiersep> name + <string_literal> ) ; \n \t5 s <identifiersep> logger . trace ( <string_literal> + host <identifiersep> id + <string_literal> + request . get <identifiersep> <identifier> ( ) + <string_literal> + request ) ; \n \t4 } else if ( cmd instanceof <identifier> <identifiersep> command ) { \n \t5 log <identifiersep> <identifier> = false ; \n <ect>
\t2 final connection conn = <identifier> <identifiersep> resource <identifiersep> base . get <identifiersep> connection ( ) ; \n \t2 final string result = <identifier> <identifiersep> resource <identifiersep> base . <identifier> <identifiersep> host <identifiersep> <identifier> ( conn , <string_literal> , <string_literal> , <string_literal> , <identifier> <identifiersep> resource <identifiersep> base . get <identifiersep> vm <identifiersep> instance <identifiersep> name ( ) ) ; \n \t2 final int num <identifiersep> <identifier> = integer . parse <identifiersep> int ( result ) ; \n \t2 if ( result == null || result . is <identifiersep> empty ( ) || num <identifiersep> <identifier> < 0 ) { \n <ect>
\t1 logger . warn ( <string_literal> , <identifier> <identifiersep> command ) \n \t1 logger . warn ( <identifier> ( e ) ) \n \t1 <identifier> . <identifier> ( ) \n \t1 if result != 0 : \n <ect>
\t4 <identifier> <identifiersep> log . error ( e , e ) ; \n \t4 <identifier> <identifiersep> request <identifiersep> <identifier> = <identifier> <identifiersep> context . get <identifiersep> request <identifiersep> <identifier> ( \n \t5 <string_literal> ) ; \n \t4 if ( <identifier> <identifiersep> request <identifiersep> <identifier> == null ) { \n <ect>
\t1 protected list < string > <identifier> <identifiersep> event <identifiersep> from <identifiersep> http <identifiersep> request ( final http <identifiersep> <identifier> <identifiersep> request request ) { \n \t2 final http <identifiersep> session session = request . get <identifiersep> session ( ) ; \n \t2 object attribute <identifiersep> value = session != null ? session . get <identifiersep> attribute ( attribute <identifiersep> name ) : null ; \n \t2 if ( attribute <identifiersep> value == null ) { \n <ect>
\t2 assert <identifiersep> true ( <string_literal> + <identifier> , <identifier> . is <identifiersep> empty ( ) ) ; } \n \t1 @ test ( timeout = <number_literal> * <number_literal> * <number_literal> ) \n \t1 public void test <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n <ect>
\t4 <comment> \n \t4 long <identifier> <identifiersep> id = <identifier> <identifiersep> input . read <identifiersep> long ( true ) ; \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> cache . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , last <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . close ( ) ; } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t3 log . warn ( <string_literal> , <identifier> ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t4 logger . debug ( <string_literal> , mode ) ; \n \t4 set <identifiersep> mode ( mode ) ; } \n \t3 if ( <identifier> <identifiersep> config . e <identifiersep> is <identifiersep> set ( <identifier> <identifiersep> config . e <identifiersep> class ( ) . get <identifiersep> e <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ) ) { \n \t4 boolean <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ; \n <ect>
\t2 final password <identifiersep> <identifier> <identifiersep> properties <identifier> = <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ; \n \t2 final http <identifiersep> <identifier> <identifiersep> request request = web <identifiersep> utils . get <identifiersep> http <identifiersep> <identifier> <identifiersep> request <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( request <identifiersep> context ) ; \n \t2 final string <identifier> = request . get <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> ) ) { \n <ect>
\t3 } catch ( io <identifiersep> exception ex ) { \n \t5 s <identifiersep> logger . trace ( <string_literal> + ex ) ; } \n \t3 } catch ( http <identifiersep> exception ex ) { \n <ect>
\t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 case <identifier> : \n \t3 case <identifier> <identifiersep> table : \n \t4 break ; \n \t3 default : \n <ect>
\t3 <identifier> . <identifier> <identifiersep> <identifier> ( storage <identifiersep> service . <identifier> <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; \n \t3 <comment> \n \t3 endpoint <identifiersep> state new <identifiersep> state = endpoint <identifiersep> state <identifiersep> map . get ( endpoint ) ; \n \t3 if ( new <identifiersep> state == null ) \n <ect>
\t3 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t4 throw new configuration <identifiersep> exception ( <string_literal> + value ) ; } } \n \t2 string in <identifiersep> system <identifiersep> vm = ( string ) <identifier> . get ( <string_literal> ) ; \n \t2 if ( in <identifiersep> system <identifiersep> vm != null && <string_literal> . equals <identifiersep> ignore <identifiersep> case ( in <identifiersep> system <identifiersep> vm ) ) { \n <ect>
\t6 <comment> \n \t6 if ( job . should <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) { \n \t7 try { \n \t8 if ( <identifier> . <identifier> <identifiersep> job ( job , 0 ) ) { \n <ect>
\t3 <comment> \n \t3 if ( e instanceof <identifier> <identifiersep> exception && file <identifiersep> entry . get <identifiersep> file <identifiersep> type ( ) == file <identifiersep> type . dir ) { \n \t4 if ( <identifier> <identifiersep> error <identifiersep> code . <identifier> <identifiersep> <identifier> <identifiersep> exists . equals ( ( ( <identifier> <identifiersep> exception ) e ) . get <identifiersep> error <identifiersep> message ( ) . get <identifiersep> error <identifiersep> code ( ) ) ) { \n \t5 return ; } } \n <ect>
\t2 logger . info ( <string_literal> , this . service <identifiersep> <identifier> . get <identifiersep> name ( ) , this . <identifier> <identifiersep> manager . count ( ) ) ; } \n \t1 private boolean find <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> service ( final registered <identifiersep> service r ) { \n \t2 registered <identifiersep> service <identifier> = this . service <identifiersep> <identifier> . find <identifiersep> service <identifiersep> by <identifiersep> id ( r . get <identifiersep> service <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t9 throw new io <identifiersep> exception ( <string_literal> ) ; } \n \t8 if ( count > <number_literal> && context . is <identifiersep> in <identifiersep> transaction ( ) ) { \n \t9 count = 0 ; \n \t9 int size = context . get <identifiersep> transaction ( ) . size ( ) ; \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <number_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> base <identifiersep> path , build <identifiersep> path , <identifier> <identifiersep> <identifier> , system <identifiersep> <identifier> ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <number_literal> ) ; \n \t2 <comment> \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t3 <identifier> . set <identifiersep> attribute <identifiersep> <identifier> <identifiersep> policy ( policy ) ; } \n \t2 logger . debug ( <string_literal> , \n \t3 service . get <identifiersep> service <identifiersep> id ( ) , <identifier> . get <identifiersep> attribute <identifiersep> <identifier> <identifiersep> policy ( ) ) ; \n \t2 if ( ! <identifier> . equals ( service ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = client . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 return <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> path , false ) ; } \n \t1 } ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 int max <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 int num <identifiersep> to <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) - max <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t2 if ( num <identifiersep> to <identifiersep> <identifier> > 0 ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 final static <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new static <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 final <identifier> <identifiersep> provider <identifiersep> key <identifiersep> info <identifiersep> <identifier> <identifiersep> <identifier> key <identifiersep> info <identifiersep> <identifier> = new <identifier> <identifiersep> provider <identifiersep> key <identifiersep> info <identifiersep> <identifier> <identifiersep> <identifier> ( key <identifiersep> info <identifiersep> provider <identifiersep> list ) ; \n \t2 final <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , key <identifiersep> info <identifiersep> <identifier> ) ; \n <ect>
\t8 <comment> \n \t8 <comment> \n \t8 <comment> \n \t8 <comment> \n <ect>
\t2 <comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( message <identifiersep> context <identifier> ) \n \t1 { \n <ect>
\t3 out . write <identifiersep> object ( system <identifiersep> id ) ; \n \t3 out . write <identifiersep> object ( <identifier> ) ; \n \t3 out . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 log . debug ( <string_literal> , e ) ; \t5 \n \t5 <identifier> . get <identifiersep> channel ( ) . close ( ) ; \n \t4 } else { \n \t5 <comment> \n <ect>
\t3 else if ( default <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t4 log . debug ( <string_literal> , key <identifiersep> path ) ; \n \t4 <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> value <identifiersep> for <identifiersep> key <identifiersep> path ( value , key <identifiersep> path ) ; \n \t3 } else { \n <ect>
\t2 node = <identifier> . item ( 0 ) ; \n \t2 logger . info ( <string_literal> + node . get <identifiersep> node <identifiersep> name ( ) ) ; \n \t2 <identifier> = node . get <identifiersep> <identifier> <identifiersep> nodes ( ) ; \n \t2 node = <identifier> . item ( 0 ) ; \n <ect>
\t2 public void <identifier> <identifiersep> task <identifiersep> <identifier> ( string task <identifiersep> name ) { \n \t3 logger . info ( <string_literal> , task <identifiersep> name ) ; } \n \t2 @ <identifier> \n \t2 public void <identifier> <identifiersep> task <identifiersep> <identifier> ( ) { \n <ect>
\t4 if ( <identifier> . get <identifiersep> transaction ( ) . is <identifiersep> <identifier> ( ) ) { \n \t5 log . warn ( <string_literal> , <identifier> . get <identifiersep> name ( ) ) ; \n \t5 <identifier> . get <identifiersep> transaction ( ) . <identifier> ( ) ; } } \n \t3 catch ( exception ex ) { \n <ect>
\t2 <comment> \n \t2 <identifier> < ? > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> manager . instance . start <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> < stream <identifiersep> state > stream <identifiersep> success = stream <identifiersep> <identifier> ( <identifier> <identifiersep> to <identifiersep> stream ) ; \n \t2 <comment> \n <ect>
\t3 query <identifiersep> result = <identifier> . execute <identifiersep> query ( query ) ; \n \t3 <identifier> <identifiersep> info db <identifiersep> info = new <identifier> <identifiersep> info ( ) ; \n \t3 return db <identifiersep> info ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t3 } catch ( no <identifiersep> class <identifiersep> <identifier> <identifiersep> found <identifiersep> error e ) { \n \t4 logger . warn ( <string_literal> ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> error e ) { \n <ect>
\t2 interrupted <identifiersep> exception { \n \t1 output <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> map < string , <identifier> <identifiersep> output <identifiersep> format . base <identifiersep> output <identifiersep> <identifier> <identifiersep> <identifier> > ( ) ; \n \t1 string [ ] <identifier> = get <identifiersep> output <identifiersep> format <identifiersep> <identifier> ( context ) ; \n \t1 for ( string <identifier> : <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> get <identifiersep> put ( <identifier> , <identifier> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> get <identifiersep> put <identifiersep> <identifier> ( ) throws throwable { \n <ect>
\t2 while ( <identifier> . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 log . info ( <string_literal> + ( ( text <identifiersep> message ) <identifier> . next <identifiersep> element ( ) ) . get <identifiersep> text ( ) ) ; \n \t3 <identifier> <identifiersep> <identifier> = true ; } \n \t2 assert <identifiersep> false ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 grid <identifiersep> <identifier> < v , v > <identifier> <identifiersep> c , long <identifier> <identifiersep> <identifier> , long <identifier> <identifiersep> <identifier> <identifiersep> time , @ <identifier> grid <identifiersep> cache <identifiersep> version <identifier> <identifiersep> <identifier> , long <identifier> ) { \n \t2 long <identifier> <identifiersep> <identifier> = update <identifiersep> <identifier> . <identifier> <identifiersep> version ( ) ; \n \t2 collection < grid <identifiersep> node > <identifier> <identifiersep> nodes = <identifier> . <identifier> ( ) . <identifier> ( ) . nodes ( entry . <identifier> ( ) , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 try { \n \t3 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> key ) ; \n \t2 } catch ( <identifier> <identifiersep> security <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 } else if ( <identifier> <identifiersep> file . get <identifiersep> type ( ) == resource . type . directory ) { \n \t5 for ( resource file : files ) { \n \t6 if ( file . get <identifiersep> type ( ) == resource . type . resource ) { \n \t7 if ( ! file . delete ( ) ) { \n <ect>
\t3 <comment> \n \t3 consumer = new <identifier> <identifiersep> consumer ( <identifier> <identifiersep> location , <identifier> <identifiersep> <identifier> ) ; \n \t3 consumer . set <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <comment> \n <ect>
\t1 <identifier> <identifiersep> default . <identifier> ( connection , time <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 time <identifiersep> <identifier> . set <identifiersep> default ( time <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 log . info ( <string_literal> + time <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
import org . <identifier> . test ; \n public class <identifier> <identifiersep> write <identifiersep> test { \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> write ( ) throws exception { \n <ect>
\t2 if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> event && ! is <identifiersep> <identifier> ) { \n \t3 string <identifier> <identifiersep> service <identifiersep> <identifier> = url . get <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> event <identifiersep> <identifier> <identifiersep> key ) ; \n \t3 if ( <identifier> <identifiersep> service <identifiersep> <identifier> == null || <identifier> <identifiersep> service <identifiersep> <identifier> . length ( ) == 0 ) { \n <ect>
\t5 if ( command instanceof <identifier> <identifiersep> type ) { \n \t6 float <identifier> = ( ( <identifier> <identifiersep> type ) command ) . float <identifiersep> value ( ) ; \n \t6 int value = ( int ) ( <identifier> * <number_literal> . ) ; \n \t6 if ( send <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , value ) ) { \n <ect>
\t3 logger . warn ( <string_literal> , t ) ; \n \t3 try { \n \t4 <identifier> . close ( ) ; \n \t3 } catch ( throwable <identifier> ) { \n <ect>
\t4 <identifier> . <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> not <identifiersep> <identifier> <identifiersep> <identifier> ( 1 , <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t4 if ( <identifier> . is <identifiersep> empty ( ) ) { \n \t5 <comment> \n \t5 if ( log . should <identifiersep> log ( log . info ) ) \n <ect>
\t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> mode ( false ) ; \n \t3 <comment> \n \t3 request request <identifiersep> to <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> request <identifiersep> to <identifiersep> <identifier> ( ) ; \n \t3 while ( request <identifiersep> to <identifiersep> <identifier> != null ) { \n <ect>
\t1 return true ; } \n \t1 for ( final meta <identifiersep> class <identifier> : meta <identifiersep> class <identifiersep> factory . get <identifiersep> all <identifiersep> new <identifiersep> or <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t1 final boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . contains ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> || is <identifiersep> <identifier> <identifiersep> class ( <identifier> ) ) { \n <ect>
\t5 connection . close ( ) ; } } \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 this . <identifier> . <identifier> ( ) ; \n <ect>
\t5 <identifier> <identifiersep> update = false ; \n \t4 } else { \n \t5 <identifier> <identifiersep> update = <identifier> >= <identifier> <identifiersep> <identifier> ; } \n \t4 if ( <identifier> <identifiersep> update ) { \n <ect>
\t3 log . debug ( <string_literal> , <identifier> <identifiersep> time <identifiersep> format ) ; \n \t3 log . debug ( <string_literal> , <identifier> ) ; \n \t3 log . debug ( <string_literal> , <identifier> <identifiersep> values <identifiersep> <identifier> <identifiersep> type ) ; \n \t3 log . debug ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 input <identifiersep> stream input = device <identifiersep> type <identifiersep> <identifier> . class . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ; \n \t3 try { \n \t4 s <identifiersep> device <identifiersep> type <identifiersep> <identifier> . load <identifiersep> device <identifiersep> <identifier> <identifiersep> xml ( input ) ; \n \t3 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception e ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t3 return ; } \n \t2 final list < model <identifiersep> node > <identifier> = new array <identifiersep> list < model <identifiersep> node > ( ) ; \n \t2 for ( string <identifier> : <identifier> ) { \n \t3 if ( <identifier> == null || <identifier> . length ( ) == 0 ) { \n <ect>
\t1 @ <identifier> \n \t1 public void handle <identifiersep> event ( <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class <identifiersep> value <identifiersep> event event , item item , map < string , string > <identifier> ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> state <identifiersep> <identifier> < ? , ? > <identifier> = this . get <identifiersep> state <identifiersep> <identifier> ( item , event . get <identifiersep> value ( ) ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t5 public void on <identifiersep> response ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , response response ) throws io <identifiersep> exception { \n \t6 <comment> \n \t4 } ) ; } \n \t2 } catch ( throwable e ) { \n <ect>
\t4 ( system . <identifier> <identifiersep> time ( ) - <identifier> <identifiersep> <identifier> <identifiersep> start ) / 1 <identifiersep> 000 <identifiersep> 000 ) ; \n \t2 <comment> \n \t2 list < job <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = job <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> ( ) ; \n <ect>
\t3 logger . error ( null , <identifier> ) ; } \n \t2 return null ; } \n \t1 @ <identifier> \n \t1 public list < <identifier> <identifiersep> file > list <identifiersep> files ( ) { \n <ect>
\t1 { \n \t2 try { \n \t3 <identifier> ( template , <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 m <identifiersep> <identifier> . set <identifiersep> value ( \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> message <identifiersep> text ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> delete <identifiersep> <identifier> <identifiersep> not <identifiersep> <identifier> <identifiersep> 1 , <identifier> <identifiersep> name ) ) ; \n \t4 m <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> enabled ( false ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 assert . assert <identifiersep> equals ( <identifier> , <identifier> ) ; \n \t2 header <identifier> = new header ( ) ; \n \t2 header db = new header ( ) ; \n \t2 xml <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> test ( <string_literal> , <identifier> , <identifier> , db ) ; \n <ect>
\t2 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t2 assert <identifiersep> true ( get <identifiersep> <identifier> ( <identifier> , <string_literal> ) instanceof <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> . stop ( ) ; \n \t2 log . info ( <string_literal> ) ; \n <ect>
\t3 try { \n \t4 <identifier> . stop ( ) ; \n \t4 <identifier> . close ( ) ; } \n \t3 catch ( exception e ) { \n <ect>
\t4 if ( ! key . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t5 <identifier> <identifiersep> log . error ( <string_literal> + url + <identifier> ) ; \n \t5 return null ; } \n \t4 if ( key . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) . length ( ) != 0 ) { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 logger . warn ( <string_literal> + \n \t4 <string_literal> + \n \t4 <string_literal> ) ; \n <ect>
\t1 } else { \n \t2 log . debug ( <string_literal> ) ; } \n \t1 } catch ( exception e ) { \n \t1 <comment> \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 <identifier> . get <identifiersep> <identifier> <identifiersep> server ( ) . get <identifiersep> file <identifiersep> system ( ) . delete <identifiersep> <identifier> ( new <identifiersep> <identifier> . path ( ) ) ; } \n \t2 <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> server ( ) . get <identifiersep> file <identifiersep> system ( ) , <identifier> <identifiersep> <identifier> . path ( ) , new <identifiersep> <identifier> . path ( ) ) ; } \n \t2 break ; \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 } else { \n \t3 <identifier> = new <identifier> <identifiersep> host ( ) ; \n \t3 <identifier> . set <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; } \n \t2 <comment> \n <ect>
# the <identifier> server status . \n # \n @ <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . default ) \n <identifier> status ( <identifier> ) : \n <ect>
\t2 if ( data <identifiersep> <identifier> <identifiersep> config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( ) < = 0 && data <identifiersep> <identifier> <identifiersep> config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( ) < = 0 ) { \n \t3 logger . error ( <string_literal> ) ; \n \t3 return false ; } \n \t2 if ( data <identifiersep> <identifier> <identifiersep> config . is <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> ( ) && data <identifiersep> <identifier> <identifiersep> config . get <identifiersep> date <identifiersep> start <identifiersep> index ( ) < 0 ) { \n <ect>
\t1 protected final <identifier> <identifiersep> configuration <identifiersep> properties <identifier> <identifiersep> properties ; \n \t1 @ <identifier> \n \t1 public model <identifiersep> and <identifiersep> <identifier> <identifier> ( final <identifier> <identifiersep> context context , final o <identifiersep> <identifier> <identifiersep> registered <identifiersep> service service ) { \n \t2 final object <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = context . get <identifiersep> session <identifiersep> store ( ) . get ( context , o <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 if ( <identifier> instanceof service <identifiersep> <identifier> ) { \n \t3 run = ( ( service <identifiersep> <identifier> ) <identifier> ) . is <identifiersep> run <identifiersep> <identifier> ( ) ; } \n \t2 if ( ! run ) { \n \t3 <comment> \n <ect>
\t3 long stream <identifiersep> number = ++ file <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t3 file <identifiersep> <identifier> <identifiersep> output <identifiersep> stream <identifier> = \n \t4 new file <identifiersep> <identifier> <identifiersep> output <identifiersep> stream ( <identifier> , stream <identifiersep> number ) ; \n \t3 if ( log <identifiersep> debug ) \n <ect>
\t2 if ( <identifier> <identifiersep> in <identifiersep> <identifier> ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> in <identifiersep> <identifier> = true ; } \n \t2 if ( ! <identifier> <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t2 for ( key <identifiersep> listener listener : <identifier> ) { \n \t3 try { \n \t4 remove <identifiersep> <identifier> <identifiersep> <identifier> ( listener ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t3 try { \n \t4 <comment> \n \t4 create <identifiersep> connection ( ) . close ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 class <identifier> = class . for <identifiersep> name ( <identifier> . get <identifiersep> <identifier> <identifiersep> class <identifiersep> name ( ) ) ; \n \t3 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 return ( <identifier> <identifiersep> stream <identifiersep> <identifier> ) <identifier> . new <identifiersep> instance ( <identifier> <identifiersep> values ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 } else { \n \t4 <comment> \n \t4 result . set <identifiersep> <identifier> <identifiersep> <identifier> ( url <identifiersep> manager . get <identifiersep> base <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url ( ) ) ; } \n \t2 } catch ( sql <identifiersep> exception | <identifier> <identifiersep> exception | io <identifiersep> exception e ) { \n <ect>
\t4 long <identifier> <identifiersep> dir <identifiersep> <identifier> = update <identifiersep> client . do <identifiersep> update ( user <identifiersep> dir , <identifier> <identifiersep> <identifier> . <identifier> , <identifier> <identifiersep> <identifier> . <number_literal> , false , false ) ; \n \t4 <identifier> += system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t4 logger . info ( string . format ( <string_literal> , user <identifiersep> dir . get <identifiersep> <identifier> <identifiersep> path ( ) , <identifier> <identifiersep> dir <identifiersep> <identifier> , <identifier> ) ) ; \n \t3 } else { \n <ect>
\t4 } else { \n \t5 log . warn ( <string_literal> <string_literal> \\ <string_literal> ) ; } } } \n \t2 local <identifiersep> <identifier> = result . to <identifiersep> string ( ) ; \n <ect>
\t2 <identifier> <identifier> = <identifier> . get ( 0 ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , <identifier> ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <string_literal> , <identifier> . get <identifiersep> name ( ) ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t4 new <identifier> <identifiersep> transport <identifiersep> error ( http <identifiersep> <identifier> <identifiersep> handler . this , request , null , status <identifiersep> code , <identifier> <identifiersep> info ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( message <identifiersep> <identifier> . handle <identifiersep> transport <identifiersep> error ( transport <identifiersep> error ) ) { \n \t3 return ; } \n <ect>
\t2 ; } } \n \t1 final import <identifiersep> instance <identifiersep> <identifier> <identifiersep> task instance <identifiersep> task = ( import <identifiersep> instance <identifiersep> <identifier> <identifiersep> task ) task ; \n \t1 final <identifier> <identifiersep> task <identifier> <identifiersep> task = instance <identifiersep> task . get <identifiersep> task ( ) ; \n \t1 if ( <identifier> <identifiersep> task . get <identifiersep> import <identifiersep> instance ( ) == null ) { \n <ect>
\t6 if ( <identifier> . size ( ) > <identifier> <identifiersep> size ) { \n \t7 <identifier> = true ; \n \t7 logger . info ( <string_literal> , <identifier> ) ; } \n \t5 } else { \n <ect>
import <identifier> \n # <identifier> <identifier> is <identifier> <identifier> by root <identifier> <identifier> <identifier> to <identifier> <identifier> \n # on <identifier> such as <identifier> <identifiersep> <identifier> . <number_literal> . <identifier> : <comment> \n <identifier> <identifier> <identifiersep> <identifier> ( ) : \n <ect>
\t1 public string get <identifiersep> name ( ) { \n \t2 return <identifier> <identifiersep> name ; } \n \t1 protected boolean handle <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> , status . event event ) { \n \t2 long host <identifiersep> id = <identifier> . get <identifiersep> id ( ) ; \n <ect>
\t3 } catch ( x <identifiersep> path <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 logger . warn ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t4 logger . error ( e . get <identifiersep> message ( ) , e ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = null ; \n \t2 int <identifier> = 0 ; \n \t2 result <identifiersep> set <identifier> = null ; \n \t2 <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> no <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( c , id ) ; \n <ect>
\t1 log . info ( <string_literal> ) \n \t1 try { \n \t1 db <identifiersep> execute ( <string_literal> , <string_literal> $ { to } \\ <string_literal> $ { from } \\ <string_literal> $ { get <identifiersep> user <identifiersep> name ( ) } \\ <string_literal> ) \n \t1 } catch ( exception ex ) { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 load <identifiersep> values ( values ) ; \n \t2 <identifier> ( ) ; \n \t2 set < key <identifiersep> <identifier> > <identifier> = delete <identifiersep> values ( <number_literal> ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> status <identifiersep> <identifier> <identifiersep> to ( host , status . event . error , <identifier> <identifiersep> node <identifiersep> id ) ; \n \t3 try { \n \t4 resource <identifiersep> state <identifiersep> <identifier> <identifiersep> to ( host , resource <identifiersep> state . event . error , <identifier> <identifiersep> node <identifiersep> id ) ; \n \t3 } catch ( final no <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 string property <identifiersep> value = <string_literal> ; \n \t2 <identifier> . put ( property <identifiersep> name , property <identifiersep> value ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n <ect>
\t3 <identifier> <identifiersep> key <identifiersep> <identifier> key <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> function <identifiersep> class <identifiersep> key <identifiersep> value <identifiersep> <identifier> . default <identifiersep> <identifier> . key <identifiersep> get <identifiersep> <identifier> <identifiersep> for <identifiersep> key <identifiersep> path ( target <identifiersep> object . get <identifiersep> class ( ) , key <identifiersep> path ) ; \n \t3 if ( key <identifiersep> <identifier> != null ) { \n \t4 <identifier> <identifiersep> class = key <identifiersep> <identifier> . value <identifiersep> type ( ) ; } \n \t3 else { \n <ect>
\t2 int <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 int <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> length ( ) ; \n \t2 if ( <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> length ) \n \t2 { \n <ect>
\t1 if ( files . is <identifiersep> empty ( ) ) { \n \t1 throw new file <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> element + \n \t2 <string_literal> + configuration . timeout + <string_literal> + filter . get <identifiersep> <identifier> ( ) ) ; } \n \t1 log . info ( <string_literal> + files . get ( 0 ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n <ect>
\t3 in = <identifier> . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( name ) ; \n \t3 if ( in != null ) \n \t4 default <identifiersep> <identifier> = <identifier> <identifiersep> field <identifiersep> set . read <identifiersep> from ( in , false , false ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 } else { \n \t4 output <identifiersep> stream . write ( msg . get <identifiersep> bytes ( ) ) ; } \n \t3 output <identifiersep> stream . <identifier> ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 map < string , endpoint <identifiersep> <identifier> > endpoint <identifiersep> <identifier> = get <identifiersep> context ( ) . get <identifiersep> <identifier> ( ) . find <identifiersep> by <identifiersep> type <identifiersep> with <identifiersep> name ( endpoint <identifiersep> <identifier> . class ) ; \n \t2 if ( endpoint <identifiersep> <identifier> != null && ! endpoint <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t3 for ( entry < string , endpoint <identifiersep> <identifier> > entry : endpoint <identifiersep> <identifier> . entry <identifiersep> set ( ) ) { \n \t4 endpoint <identifiersep> <identifier> <identifier> = entry . get <identifiersep> value ( ) ; \n <ect>
\t5 public double get <identifiersep> <identifier> ( string <identifier> ) { \n \t6 return default <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t4 } ; \n \t3 } else { \n <ect>
\t4 for ( <identifier> <identifiersep> service <identifiersep> listener <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t5 <identifier> . entry <identifiersep> <identifier> ( this , <identifier> , <identifier> , options ) ; } } \n \t3 return success ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t5 continue ; } \n \t4 <identifier> <identifiersep> manager . create <identifiersep> file ( new file <identifiersep> <identifier> ( <identifier> <identifiersep> file ) ) ; \n \t4 continue ; } \n \t3 if ( event instanceof v <identifiersep> file <identifiersep> create <identifiersep> event ) { \n <ect>
<comment> \n \t1 protected event <identifier> <identifiersep> ticket <identifiersep> <identifier> <identifiersep> ticket <identifiersep> to <identifiersep> authentication <identifiersep> result ( final request <identifiersep> context context , \n <number_literal> final authentication <identifiersep> result <identifiersep> builder authentication <identifiersep> result <identifiersep> builder , \n <number_literal> final service service ) { \n <ect>
\t3 vm <identifiersep> <identifier> <identifiersep> log <identifiersep> vo log = <identifier> <identifiersep> <identifier> <identifiersep> log <identifiersep> dao . find <identifiersep> by <identifiersep> vm <identifiersep> id ( vm <identifiersep> id ) ; \n \t3 if ( log != null && log . get <identifiersep> <identifier> ( ) != <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> . add ( vm <identifiersep> id ) ; } } \n \t2 if ( <identifier> <identifiersep> <identifier> . size ( ) > 0 ) { \n <ect>
\t4 int new <identifiersep> id = entry . get <identifiersep> value ( ) ; \n \t4 int <identifier> <identifiersep> id = is <identifiersep> <identifier> ? get <identifiersep> <identifier> ( ) . i <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> id ( item <identifiersep> name ) : get <identifiersep> <identifier> ( ) . i <identifiersep> item <identifiersep> <identifier> . get <identifiersep> id ( item <identifiersep> name ) ; \n \t4 if ( <identifier> <identifiersep> id == - 1 ) \n \t4 { \n <ect>
\t2 logger . debug ( <string_literal> , ticket <identifiersep> to <identifiersep> add ) ; \n \t2 try { \n \t3 final ticket ticket = <identifier> <identifiersep> ticket ( ticket <identifiersep> to <identifiersep> add ) ; \n \t3 final <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . create ( ticket . get <identifiersep> id ( ) , get <identifiersep> time <identifiersep> to <identifiersep> <identifier> ( ticket <identifiersep> to <identifiersep> add ) , ticket ) ; \n <ect>
\t3 } else if ( name . <identifier> <identifiersep> with ( <string_literal> ) && <identifier> . length == 0 ) { \n \t4 class < ? > <identifier> = <identifier> [ <identifier> ] . get <identifiersep> return <identifiersep> type ( ) ; \n \t4 if ( boolean . type != <identifier> ) { \n <ect>
\t3 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> type ) ; \n \t3 int <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . parse <identifiersep> int ( <identifier> . get ( config . <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> vm <identifiersep> <identifier> <identifiersep> <identifier> . key ( ) ) , <number_literal> ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < <number_literal> ) \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <number_literal> ; \n <ect>
\t3 logger . debug ( string . format ( <string_literal> , property <identifiersep> name ) ) ; } \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 log . debug ( <string_literal> , port , <identifier> [ 0 ] ) ; \n \t5 client <identifiersep> socket = start <identifiersep> <identifier> ( client <identifiersep> socket , <identifier> [ 0 ] ) ; \n \t4 } else { \n \t5 <comment> \n <ect>
\t4 } catch ( exception e ) { \n \t5 try { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> cache . close ( ) ; \n \t5 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 super . <identifier> <identifiersep> <identifier> ( ) ; \n \t1 try { \n \t1 manager . close ( ) ; \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t1 string key <identifiersep> <identifier> = file <identifiersep> to <identifiersep> <identifier> . get <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> <identifier> ; \n \t1 string <identifier> = new <identifier> <identifiersep> path <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> path ( \n \t2 <identifier> <identifiersep> configuration . get <identifiersep> <identifier> ( ) + log <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> path <identifiersep> <identifier> + log <identifiersep> type , key <identifiersep> <identifier> , \n \t2 <identifier> <identifiersep> configuration . get <identifiersep> cluster ( ) ) ; \n <ect>
\t2 if ( ! x . is <identifiersep> <identifier> ( ) ) { \n \t3 log . warn ( <string_literal> + list ) ; \n \t3 return null ; } \n \t2 if ( ! <identifier> <identifiersep> value <identifiersep> <identifier> . is <identifiersep> <identifier> ( x ) ) { \n <ect>
\t6 if ( vm == null ) { \n \t7 s <identifiersep> logger . info ( <string_literal> + <identifier> . get <identifiersep> instance <identifiersep> id ( ) + <string_literal> ) ; \n \t7 <identifier> = true ; \n \t7 return ; } \n <ect>
\t1 <identifier> <identifiersep> count = native <identifiersep> result <identifiersep> set . get <identifiersep> meta <identifiersep> data ( ) . get <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t1 return <identifier> <identifiersep> count ; \n \t1 } catch ( sql <identifiersep> exception ex ) { \n \t1 <comment> \n <ect>
\t5 } ) ; } \n \t4 else \n \t5 <identifier> . send ( msg ) ; } } \n \t2 catch ( exception e ) { \n <ect>
\t3 log . debug ( <string_literal> + \n \t5 <identifier> ) ; \n \t2 <identifier> = <identifier> == null ? ( <identifier> <identifiersep> array ) current <identifiersep> <identifier> ( ) . <identifier> : <identifier> ; \n <ect>
\t4 object <identifier> = json <identifiersep> value . parse ( source <identifiersep> json ) ; \n \t4 json <identifiersep> object array = ( json <identifiersep> object ) <identifier> ; \n \t4 return array . get ( <string_literal> ) . to <identifiersep> string ( ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t1 try ( transaction <identifiersep> resource <identifier> = <identifier> . transaction <identifiersep> for ( snapshot <identifiersep> info . class ) ) { \n \t2 snapshot <identifiersep> <identifier> = <identifier> . query ( new snapshot <identifiersep> info ( ) , boolean . true , <identifier> <identifiersep> storage <identifiersep> <identifier> . get <identifiersep> failed <identifiersep> <identifier> ( ) , <identifier> . empty <identifiersep> map ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 version <identifiersep> manager version <identifiersep> manager = session . get <identifiersep> <identifier> ( ) . get <identifiersep> version <identifiersep> manager ( ) ; \n \t1 try { \n \t1 version = version <identifiersep> manager . get <identifiersep> base <identifiersep> version ( node . get <identifiersep> path ( ) ) ; \n \t1 } catch ( null <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 throw new runtime <identifiersep> exception ( e ) ; } } \n \t1 <comment> \n \t1 protected void end <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> m ) { \n <ect>
\t2 list < string > nodes <identifiersep> <identifier> = <identifier> <identifiersep> cluster ( ) . start <identifiersep> nodes ( <number_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 assert <identifiersep> <identifier> ( <identifier> <identifiersep> create ( <string_literal> ) . set <identifiersep> <identifier> ( <identifier> . builder ( ) . put ( <string_literal> , 1 ) . put ( <string_literal> , 0 ) ) ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t3 logger . debug ( <string_literal> + this . id ) ; } \n \t2 this . <identifier> . remove <identifiersep> <identifier> ( get <identifiersep> id ( ) ) ; } \n \t1 public void <identifier> ( ) { \n <ect>
\t6 string <identifier> <identifiersep> key = <identifier> <identifiersep> config . <identifier> <identifiersep> <identifier> <identifiersep> key ( <identifier> <identifiersep> id , <identifier> <identifiersep> name ) ; \n \t6 data . get <identifiersep> <identifier> <identifiersep> store ( ) . read <identifiersep> <identifier> <identifiersep> to ( <identifier> <identifiersep> key , \n \t8 new file <identifiersep> output <identifiersep> stream ( <identifier> <identifiersep> config . <identifier> <identifiersep> path ( <identifier> <identifiersep> code <identifiersep> location , <identifier> <identifiersep> name ) ) ) ; } } } \n \t2 } catch ( key <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . create ( \n \t8 self . <identifier> , \n \t8 self . <identifier> [ <string_literal> ] \n \t7 ) \n <ect>
\t1 if ( <identifier> == null || <identifier> . get <identifiersep> type ( ) == <identifier> <identifiersep> level <identifiersep> security . type . <identifier> ) { \n \t1 return null ; } \n \t1 i <identifiersep> <identifier> <identifiersep> session <identifier> = <identifier> <identifiersep> session <identifiersep> <identifier> . get <identifiersep> session ( ) ; \n \t1 if ( <identifier> == null ) { \n <ect>
\t2 for ( final <identifier> < ? > <identifier> : <identifier> ) { \n \t2 <identifier> . get ( ) ; } } \n \t1 } catch ( final exception e ) { \n \t1 log . debug ( <string_literal> , e ) ; } \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> map < destination , <identifier> <identifiersep> info > ( <number_literal> ) ; } \n \t1 public void handle <identifiersep> message ( <identifier> <identifiersep> message message , <identifier> <identifiersep> session <identifiersep> <identifier> session ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 name = <identifier> . get ( 0 ) . get <identifiersep> property ( abstract <identifiersep> node . name ) ; } } \n \t3 <identifier> . success ( ) ; \n \t3 return name ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 log . info ( <string_literal> , e ) ; \n \t1 throw new thrift <identifiersep> table <identifiersep> operation <identifiersep> exception ( <identifier> <identifiersep> id . <identifier> <identifiersep> id ( ) , <identifier> , <identifier> , \n \t2 table <identifiersep> operation <identifiersep> exception <identifiersep> type . <identifier> , <string_literal> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> . start ( ) ; \n \t2 <identifier> <identifiersep> vo <identifier> <identifiersep> to <identifiersep> remove = find <identifiersep> by <identifiersep> id ( <identifier> <identifiersep> id ) ; \n \t2 <identifier> <identifiersep> to <identifiersep> remove . set <identifiersep> name ( null ) ; \n \t2 if ( ! update ( <identifier> <identifiersep> id , <identifier> <identifiersep> to <identifiersep> remove ) ) { \n <ect>
\t4 <comment> \n \t4 send <identifiersep> status <identifiersep> message ( id , status ) ; \n \t4 boolean <identifier> = <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . add <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> . get <identifiersep> destination ( ) ) ; \n \t4 if ( ! <identifier> ) { \n <ect>
\t2 <identifier> += <identifier> <identifiersep> size ; \n \t2 <comment> \n \t2 system . <identifier> ( <identifier> <identifiersep> <identifier> , 0 , <identifier> , <identifier> , <number_literal> ) ; \n \t2 <identifier> += <number_literal> ; \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove <identifiersep> vm <identifiersep> from <identifiersep> load <identifiersep> <identifier> ( vm <identifiersep> id ) ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + vm <identifiersep> id + <string_literal> ) ; \n \t2 } else { \n \t3 success = false ; \n <ect>
\t2 if ( <identifier> != null ) { \n \t3 <identifier> . stop ( ) ; } } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> exception ( thread t , throwable e ) { \n <ect>
\t2 try { \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( static <identifiersep> <identifier> <identifiersep> <identifier> , continue <identifiersep> on <identifiersep> error , true ) ) { \n \t4 return false ; } \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> method <identifiersep> with <identifiersep> failure ( ) ; \n \t2 server . find ( <identifier> . class ) . find <identifiersep> count ( ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t1 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t2 status = <identifier> ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> socket <identifiersep> <identifier> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> socket <identifiersep> <identifier> ) s . get <identifiersep> handler ( ) ; \n \t2 if ( <identifier> . <identifier> != null && <identifier> . <identifier> . get <identifiersep> state ( ) == state . <identifier> ) { \n <ect>
\t3 result . <identifier> = ( table <identifiersep> not <identifiersep> found <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t2 <identifier> <identifiersep> failed ( e ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t2 <identifier> <identifiersep> failed ( e ) ; } } } } \n private void <identifier> <identifiersep> event ( event <identifiersep> type event <identifiersep> type ) { \n <ect>
\t2 resource resource = this . resource <identifiersep> <identifier> . get <identifiersep> resource ( get <identifiersep> resource <identifiersep> location ( path ) ) ; \n \t2 try { \n \t3 return resource . get <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ; } \n \t2 catch ( io <identifiersep> exception ex ) { \n <ect>
\t1 private void <identifier> <identifiersep> and <identifiersep> store <identifiersep> password ( user <identifiersep> vm <identifiersep> vo vm , string password ) { \n \t2 string <identifier> <identifiersep> public <identifiersep> key = vm . get <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> public <identifiersep> key != null && ! <identifier> <identifiersep> public <identifiersep> key . equals ( <string_literal> ) && password != null && ! password . equals ( <string_literal> ) ) { \n \t3 if ( ! <identifier> <identifiersep> public <identifiersep> key . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
<comment> \n <comment> \n <comment> \n \t3 list < <identifier> > <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> , test ) ; \n <ect>
\t1 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t1 logger . warn ( <string_literal> ) ; \n \t1 return ; } \n \t1 if ( ! is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( token <identifiersep> metadata <identifiersep> <identifier> , <identifier> , endpoint ) ; \n \t3 token <identifiersep> metadata <identifiersep> <identifier> . update <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , endpoint ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( token <identifiersep> metadata <identifiersep> <identifier> , <identifier> , endpoint ) ; \n \t3 logger . warn ( <string_literal> , <identifier> <identifiersep> to <identifiersep> string ( <identifier> ) ) ; \n <ect>
\t2 <identifier> <identifiersep> id , options ) ; \n \t1 <identifier> <identifiersep> create <identifiersep> response job = client . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> api ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( <identifier> <identifiersep> id , service <identifiersep> <identifier> <identifiersep> id , \n \t2 template <identifiersep> id , options ) ; \n \t1 <identifier> <identifiersep> <identifier> vm = <identifier> <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> <identifiersep> and <identifiersep> return <identifiersep> result . < <identifier> <identifiersep> <identifier> > <identifier> ( job ) ; \n <ect>
\t2 string <identifier> <identifiersep> id = get <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> name ) ; \n \t2 if ( <identifier> <identifiersep> id == null ) { \n \t3 throw new not <identifiersep> <identifier> <identifiersep> exception ( <identifier> <identifiersep> name ) ; } \n \t2 try { \n <ect>
\t3 list < <identifier> [ ] > <identifier> = <identifier> . get ( i ) ; \n \t3 result [ i ] = <identifier> . to <identifiersep> array ( new <identifier> [ <identifier> . size ( ) ] [ ] ) ; } \n \t2 if ( debug <identifiersep> enabled ( ) ) { \n \t3 for ( int i = 0 ; i < result . length ; i ++ ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 state <identifiersep> response = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> state ( ) . execute ( ) . action <identifiersep> get ( ) ; \n \t2 assert <identifiersep> that ( state <identifiersep> response . get <identifiersep> state ( ) . meta <identifiersep> data ( ) . index ( <string_literal> ) . get <identifiersep> state ( ) , equal <identifiersep> to ( index <identifiersep> meta <identifiersep> data . state . close ) ) ; \n \t2 assert <identifiersep> that ( state <identifiersep> response . get <identifiersep> state ( ) . routing <identifiersep> table ( ) . index ( <string_literal> ) , null <identifiersep> value ( ) ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> cluster <identifiersep> node <identifiersep> ip == null ) { \n \t3 <identifier> <identifiersep> cluster <identifiersep> node <identifiersep> ip = <string_literal> ; } \n \t2 <identifier> <identifiersep> cluster <identifiersep> node <identifiersep> ip = <identifier> <identifiersep> cluster <identifiersep> node <identifiersep> ip . <identifier> ( ) ; \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <comment> \n \t1 if ( ! has <identifiersep> <identifier> <identifiersep> a ) { \n <ect>
\t3 final object value = <identifier> <identifiersep> attributes . get ( <identifier> <identifiersep> <identifier> ) ; \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> , value , <identifier> ) ; \n \t3 return <identifier> . of ( <identifier> , value ) ; } \n \t2 final object value = <identifier> <identifiersep> attributes . get ( <identifier> ) ; \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + resource <identifiersep> name , e ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + resource <identifiersep> name , e ) ; \n \t2 } catch ( security <identifiersep> exception e ) { \n <ect>
\t4 log . trace ( <string_literal> + <identifier> + <string_literal> + \n \t7 msg . get <identifiersep> <identifier> ( ) + <string_literal> + msg . get <identifiersep> <identifier> ( ) ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( msg ) ; } \n \t2 catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> service . logger . error ( <string_literal> , e ) ; \n \t4 event . event ( event <identifiersep> type . <identifier> ) ; \n \t4 event . error ( <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t4 return error <identifiersep> <identifier> . error ( session , null , response . status . <identifier> <identifiersep> request , <identifier> . <identifier> <identifiersep> <identifier> ) ; } \n <ect>
\t5 log . trace ( <string_literal> + <identifier> ) ; } \n \t3 } catch ( throwable t ) { \n \t4 <comment> \n <ect>
\t1 @ <identifier> \n \t1 @ path ( <string_literal> ) \n \t1 @ <identifier> ( <string_literal> ) \n \t1 public char <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> root <identifiersep> element xml <identifiersep> <identifier> ( char <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> root <identifiersep> element <identifier> ) { \n <ect>
\t6 <identifier> <identifiersep> filter ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> = null ; \n <ect>
\t4 try { \n \t5 <identifier> . <identifier> ( conn ) ; \n \t5 <identifier> . <identifier> ( conn ) ; \n \t4 } catch ( final exception e ) { \n <ect>
\t3 s <identifiersep> logger . trace ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> state ( <identifier> <identifiersep> <identifier> . state . <identifier> ) ; } \n \t2 try { \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , true , false ) ) { \n <ect>
\t5 <identifier> = <identifier> , \n \t5 mode = <number_literal> , \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> files = <identifier> <identifiersep> <identifier> <identifiersep> files , \n ) \n <ect>
\t3 logger . info ( <string_literal> , <identifier> <identifiersep> port ) ; \n \t3 set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t2 } else { \n \t3 set <identifiersep> <identifier> <identifiersep> <identifier> ( false ) ; \n <ect>
\t6 } catch ( interrupted <identifiersep> exception e ) { \n \t7 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n \t7 throw new runtime <identifiersep> exception ( e ) ; } \n \t6 <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n <ect>
\t1 <comment> \n \t1 thread . <identifier> ( <identifier> <identifiersep> <identifier> * <number_literal> * <number_literal> ) ; \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> event <identifiersep> response <identifier> = <identifier> <identifiersep> client . get <identifiersep> next <identifiersep> <identifier> ( first <identifiersep> event <identifiersep> id , 0 , null ) ; \n <ect>
\t5 msg m = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> message ( ( byte ) <identifier> , ( byte ) <identifier> , ( byte ) <identifier> ) ; \n \t5 <identifier> . <identifier> <identifiersep> message ( m , m <identifiersep> <identifier> ) ; \n \t5 logger . info ( <string_literal> , <identifier> ( ) , <identifier> . get <identifiersep> address ( ) ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 test . load ( <identifier> ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 int <identifier> <identifiersep> list <identifiersep> <identifier> = 0 ; \n \t2 int next <identifiersep> <identifier> <identifiersep> id = 0 ; \n <ect>
\t2 try { \n \t3 answer <identifier> <identifiersep> test <identifiersep> answer = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send ( host <identifiersep> id , new <identifier> <identifiersep> test <identifiersep> command ( test <identifiersep> host <identifiersep> ip ) ) ; \n \t3 if ( <identifier> <identifiersep> test <identifiersep> answer == null ) { \n <ect>
\t1 source <identifiersep> <identifier> . <identifier> <identifiersep> event <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t1 try { \n \t2 get <identifiersep> channel <identifiersep> <identifier> ( ) . process <identifiersep> event ( <identifier> <identifiersep> event ) ; \n \t1 } catch ( channel <identifiersep> exception ex ) { \n <ect>
\t2 <identifier> . put ( string . format ( <string_literal> , <identifier> , false , <identifier> , false ) , null ) ; \n \t2 <identifier> . put ( string . format ( <string_literal> , <identifier> , false , <identifier> , true ) , null ) ; \n \t2 <identifier> . put ( string . format ( <string_literal> , <identifier> , true , <identifier> , false ) , null ) ; \n \t2 <identifier> . put ( string . format ( <string_literal> , <identifier> , true , <identifier> , true ) , null ) ; } } \n <ect>
\t2 <identifier> . <identifier> ( io <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 grid <identifiersep> <identifier> <identifier> = <identifier> ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t4 thread . <identifier> ( timeout . get <identifiersep> millis ( ) ) ; \n \t4 timeout . <identifier> ( ) ; } } \n \t2 catch ( interrupted <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 public void run ( ) { \n \t3 while ( current <identifiersep> <identifier> <identifiersep> index < <identifier> . size ( ) ) { \n \t4 final integer current <identifiersep> <identifier> = <identifier> . get ( current <identifiersep> <identifier> <identifiersep> index ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( current <identifiersep> <identifier> ) ) { \n <ect>
\t3 throws state <identifiersep> <identifier> <identifiersep> exception , <identifier> <identifiersep> exception { \n \t2 state <identifiersep> <identifier> <identifier> <identifiersep> state = context . get <identifiersep> session ( ) . get <identifiersep> <identifier> <identifiersep> state ( ) ; \n \t2 for ( <identifier> <identifier> : path ) { \n \t3 check <identifiersep> <identifier> <identifiersep> <identifier> ( target <identifiersep> state ) ; \n <ect>
\t5 <identifier> <identifiersep> log . info ( <string_literal> ) ; } \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> throwable = false ; } \n \t3 catch ( security <identifiersep> exception <identifier> ) { \n <ect>
\t3 return new set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> answer ( cmd , false , <identifier> ) ; } \n \t2 return new set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> answer ( cmd , true , <identifier> ) ; } \n \t1 protected answer execute ( final vm <identifiersep> data <identifiersep> command cmd ) { \n <ect>
\t4 byte <identifiersep> <identifier> <identifier> = s . <identifier> ( ) ; \n \t4 <identifier> <identifiersep> list . add ( from <identifiersep> byte <identifiersep> <identifier> ( <identifier> ) ) ; } \n \t3 catch ( <identifier> <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t1 @ <identifier> \n \t1 public boolean remove <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> network ( final <identifier> <identifiersep> <identifier> <identifier> , final network network ) throws <identifier> <identifiersep> operation <identifiersep> exception , \n \t1 resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( network . get <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> type . <identifier> ) { \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> meta <identifiersep> info . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , false ) ; \n \t1 log . info ( <string_literal> ) ; \n \t1 action <identifiersep> manager manager = <identifier> . get <identifiersep> instance ( action <identifiersep> manager . class ) ; \n <ect>
\t4 log . trace ( <string_literal> + size . get ( ) ) ; } \n \t3 if ( check <identifiersep> lock ) { \n \t4 if ( in <identifiersep> add ) \n <ect>
\t1 * <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( sql . to <identifiersep> string ( ) ) ; <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t1 * while ( <identifier> . next ( ) ) { final <identifier> < long , long > template <identifiersep> <identifier> <identifiersep> <identifier> = new \n \t1 * <identifier> < long , long > ( <identifier> . get <identifiersep> long ( 1 ) , - <identifier> ) ; \n \t1 * template <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list . add ( template <identifiersep> <identifier> <identifiersep> <identifier> ) ; } <identifier> . <identifier> ( ) ; } catch \n <ect>
\t2 connection . set <identifiersep> <identifier> <identifiersep> timeout ( <number_literal> ) ; <comment> \n \t2 connection . <identifier> ( ) ; \n \t2 return try <identifiersep> response <identifiersep> code ( connection ) ; } \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 string session <identifiersep> id = session . get <identifiersep> id ( ) ; \n \t4 synchronized ( session <identifiersep> id . <identifier> ( ) ) { \n \t5 <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> session ( ) . put ( attribute <identifiersep> name , <identifier> ) ; } \n \t3 } else { \n <ect>
\t3 int num <identifiersep> <identifier> = 0 ; \n \t3 while ( ( line = <identifier> . read <identifiersep> line ( ) ) != null ) { \n \t4 string [ ] <identifier> = line . <identifier> ( ) . <identifier> ( <string_literal> ) ; \n \t4 if ( <identifier> . length < <number_literal> ) { \n <ect>
public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> location <identifiersep> <identifier> ( list < url > class <identifiersep> path , file root <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t1 check <identifiersep> not <identifiersep> null ( class <identifiersep> path , <string_literal> ) ; \n \t1 check <identifiersep> not <identifiersep> null ( root <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <string_literal> ) ; \n \t1 file root <identifiersep> <identifier> <identifiersep> <identifier> = root <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> file ( ) ; \n <ect>
\t3 throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; \n \t2 try { \n \t3 port = integer . parse <identifiersep> int ( port <identifiersep> <identifier> ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t1 <comment> \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> service . stop ( ) \n \t1 } catch { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( output , data , <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , \n \t3 <identifier> <identifiersep> null <identifiersep> <identifier> , <identifier> <identifiersep> not <identifiersep> null <identifiersep> <identifier> ) ; \n \t1 has <identifiersep> <identifier> = ( output . get <identifiersep> length ( ) != <identifier> . get <identifiersep> length ( ) ) ; \n \t1 if ( has <identifiersep> <identifier> ) { \n <ect>
\t3 return ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> store <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 set < <identifier> <identifiersep> <identifier> > message <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> i <identifiersep> <identifier> ( ) ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifier> : message <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 ( <identifier> . get <identifiersep> send <identifiersep> stream <identifiersep> id ( ) > 0 ) ; } \n \t1 public void event <identifiersep> <identifier> ( connection <identifier> ) { \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) < = 0 ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 job . run ( ) ; \n \t2 } catch ( exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; \n \t3 system . <identifier> ( 1 ) ; } \n <ect>
\t1 public command <identifiersep> type get <identifiersep> command <identifiersep> type ( ) { \n \t2 return command <identifiersep> type . not <identifiersep> in <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public update <identifiersep> <identifier> do <identifiersep> it ( final <identifier> <identifier> ) throws command <identifiersep> exception { \n <ect>
\t5 <identifier> . <identifier> ( string . format ( <string_literal> , <identifier> . get <identifiersep> int ( 1 ) , check <identifiersep> case . item <identifiersep> name ) ) ; \n \t5 check <identifiersep> <identifier> = false ; } \n \t3 } catch ( exception e ) \n \t3 { \n <ect>
\t4 log . warn ( <string_literal> + <identifier> <identifiersep> class <identifiersep> name ) ; \n \t3 } catch ( illegal <identifiersep> access <identifiersep> exception <identifier> ) { \n \t4 log . warn ( <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; \n \t3 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n <ect>
\t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t5 logger . warn ( <string_literal> , event <identifiersep> header ) ; \n \t5 <identifier> = false ; } \n \t3 } else { \n <ect>
\t2 do <identifiersep> start <identifiersep> <identifier> ( false ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> store ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> pool ( ) . size ( ) ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , 1 , <identifier> . get <identifiersep> store ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> pool ( ) . size ( ) ) ; \n \t2 long <identifier> <identifiersep> <identifier> = total <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> count ( <identifier> ) ; \n <ect>
\t7 <string_literal> . format ( <identifier> <identifiersep> <identifier> . <identifier> , <identifier> <identifiersep> <identifier> . <identifier> ) , \n \t7 host <identifiersep> name = <identifier> . <identifier> <identifiersep> host ) \n <identifier> remove <identifiersep> <identifier> <identifiersep> <identifier> ( self , <identifier> ) : \n \t1 import <identifier> \n <ect>
\t7 = i <identifiersep> <identifier> <identifiersep> client <identifiersep> get <identifiersep> current <identifiersep> <identifier> ( i <identifiersep> <identifier> <identifiersep> client ) ; } \n \t5 catch ( <identifier> <identifiersep> result <identifiersep> exception <identifier> ) \n \t5 { \n \t6 num <identifiersep> <identifier> <identifiersep> <identifier> = num <identifiersep> <identifier> <identifiersep> <identifier> ; \n <ect>
\t2 <comment> \n \t2 string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t2 log log = new <identifiersep> <identifier> <identifiersep> log ( <identifier> , level . warn ) ; \n \t2 <comment> \n <ect>
\t3 @ <identifier> \n \t3 public string <identifier> ( @ <identifier> final string input ) { \n \t4 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( input ) ) { \n \t5 final string metadata <identifiersep> location = service . get <identifiersep> metadata <identifiersep> location ( ) . <identifier> ( <string_literal> , <identifier> <identifiersep> utils . url <identifiersep> <identifier> ( input ) ) ; \n <ect>
\t1 private entity <identifiersep> <identifier> <identifiersep> <identifier> < string > entity <identifiersep> <identifier> <identifiersep> <identifier> = utils \n \t2 . get <identifiersep> <identifier> ( entity <identifiersep> <identifier> <identifiersep> <identifier> . type <identifiersep> string ) ; \n \t1 protected void log <identifiersep> <identifier> ( string <identifier> , string <identifier> , string action , string info ) \n \t1 { \n <ect>
\t4 try { \n \t5 if ( <identifier> != null ) \n \t6 <identifier> . close ( ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \t3 last <identifiersep> event <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 this . context . set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> . <identifier> ( consumer <identifiersep> task ) ; } \n \t2 connection . start ( ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t5 <comment> \n \t5 io <identifiersep> utils . close <identifiersep> stream ( out ) ; } \n \t4 <comment> \n \t4 if ( ! <identifier> <identifiersep> file . delete ( ) ) { \n <ect>
\t3 json <identifiersep> import <identifier> = new json <identifiersep> import ( json , file <identifiersep> name , <identifier> , <string_literal> , - 1 ) ; \n \t3 <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 return <identifier> ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t4 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; } \n \t3 if ( thread . is <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> = false ; \n <ect>
\t1 <identifier> <identifiersep> logger . info ( <string_literal> ) ; \n \t1 if ( ! get <identifiersep> <identifier> <identifiersep> <identifier> ( request ) . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t1 <identifier> <identifiersep> logger . info ( <string_literal> ) ; \n \t1 return new <identifier> <identifiersep> response ( get <identifiersep> session <identifiersep> id ( request ) , status <identifiersep> code . no <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> error , <string_literal> ) ; } \n <ect>
\t2 if ( attribute <identifiersep> value == null ) { \n \t3 logger . debug ( <string_literal> , this . attribute <identifiersep> name ) ; \n \t3 return null ; } \n \t2 final set < object > values = collection <identifiersep> utils . to <identifiersep> collection ( attribute <identifiersep> value ) ; \n <ect>
\t2 int length = 0 ; \n \t2 while ( ( length = is . read ( <identifier> , 0 , <number_literal> ) ) != - 1 ) { \n \t2 logger . info ( <string_literal> + new string ( <identifier> , 0 , length ) ) ; } \n \t1 } catch ( exception ex ) { \n <ect>
\t2 final ticket <identifier> <identifiersep> ticket = <identifier> <identifiersep> ticket ( ticket ) ; \n \t2 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket ) ; \n \t2 final i <identifiersep> map < string , ticket > ticket <identifiersep> map = get <identifiersep> ticket <identifiersep> map <identifiersep> instance <identifiersep> by <identifiersep> metadata ( metadata ) ; \n \t2 ticket <identifiersep> map . set ( <identifier> <identifiersep> ticket . get <identifiersep> id ( ) , <identifier> <identifiersep> ticket , <identifier> , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t4 handle = meta <identifiersep> class <identifiersep> <identifier> <identifiersep> static <identifiersep> method . <identifier> <identifiersep> to ( <identifier> ) ; \n \t4 if ( log <identifiersep> enabled ) log . info ( <string_literal> ) ; \n \t3 } else { \n \t4 handle = <identifier> <identifiersep> <identifier> <identifiersep> method . <identifier> <identifiersep> to ( <identifier> ) ; \n <ect>
\t4 update <identifiersep> request delete <identifiersep> all = new <identifiersep> update <identifiersep> request ( ) ; \n \t4 delete <identifiersep> all . delete <identifiersep> by <identifiersep> query ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> client . request ( delete <identifiersep> all , collection ) ; } \n \t2 } catch ( <identifier> <identifiersep> server <identifiersep> exception e ) { \n <ect>
\t3 final long count = <identifier> . stream ( ) . filter ( e - > e . get <identifiersep> <identifier> <identifiersep> location ( ) . equals ( \n \t5 new <identifier> <identifiersep> location <identifiersep> request ( response . get <identifiersep> <identifier> ( ) , response . get <identifiersep> <identifier> ( ) ) ) ) . count ( ) ; \n \t3 logger . debug ( <string_literal> , remote <identifiersep> <identifier> , count ) ; \n \t3 if ( count == <identifier> . size ( ) ) { \n <ect>
\t2 this . start <identifiersep> time = system . <identifier> <identifiersep> time ( ) ; } \n \t1 <comment> \n \t1 public long get <identifiersep> start <identifiersep> time ( ) { \n \t2 if ( ! start <identifiersep> time <identifiersep> is <identifiersep> set ) \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> ) <identifier> <identifiersep> factory . get <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t2 <identifier> <identifiersep> <identifier> , new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) , <identifier> <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map ( <identifier> ) ; \n <ect>
\t3 xml <identifiersep> <identifier> = <identifier> . read ( <identifier> ) ; \n \t3 connection . <identifier> ( ) ; \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( final io <identifiersep> exception <identifier> ) { \n <ect>
\t4 . <identifier> ( <identifier> . to <identifiersep> set ( ) ) ; } \n \t1 @ <identifier> \n \t1 public boolean delete <identifiersep> <identifier> <identifiersep> ticket ( final string ticket <identifiersep> id <identifiersep> to <identifiersep> delete ) { \n \t2 final string ticket <identifiersep> id = <identifier> <identifiersep> ticket <identifiersep> id ( ticket <identifiersep> id <identifiersep> to <identifiersep> delete ) ; \n <ect>
\t3 element <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( server , input ) ; \n \t3 map < string , string > success = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( <identifier> , new string [ ] { <string_literal> } ) ; \n \t3 s <identifiersep> logger . info ( <string_literal> + success . get ( <string_literal> ) ) ; \n \t2 } else { \n <ect>
\t3 object object = <identifier> <identifiersep> count . value <identifiersep> in <identifiersep> <identifier> ( <identifier> ) ; \n \t3 if ( object != null ) { \n \t4 count = <identifier> <identifiersep> value <identifiersep> <identifier> . int <identifiersep> value ( object ) ; } \n \t3 else { \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> local <identifiersep> port ( ) != config . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> port ( ) ) { \n \t1 if ( is <identifiersep> request <identifiersep> <identifier> ( <identifier> <identifiersep> url ) ) { \n \t2 <identifier> <identifiersep> <identifier> . do <identifiersep> filter ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; } \n \t1 else { \n <ect>
\t2 if ( properties . get <identifiersep> max <identifiersep> <identifier> ( ) < properties . get <identifiersep> <identifier> <identifiersep> size ( ) ) { \n \t3 log . warn ( <string_literal> + properties . get <identifiersep> max <identifiersep> <identifier> ( ) ) ; \n \t3 properties . set <identifiersep> <identifier> <identifiersep> size ( properties . get <identifiersep> max <identifiersep> <identifier> ( ) ) ; } \n \t2 if ( properties . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) > properties . get <identifiersep> max <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 configuration <identifiersep> <identifier> . config <identifiersep> create <identifiersep> <identifier> , \n \t2 configuration <identifiersep> <identifier> . <identifier> <identifiersep> config <identifiersep> create <identifiersep> <identifier> , <string_literal> ) ; \n \t1 boolean create <identifiersep> index = boolean . value <identifiersep> of ( create <identifiersep> index <identifiersep> <identifier> ) ; \n \t1 if ( ! create <identifiersep> index ) { \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t3 <identifier> <identifiersep> id <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( new exception ( <string_literal> ) ) ; } \n \t2 @ <identifier> \n \t2 public void <identifier> <identifiersep> <identifier> <identifiersep> address ( string <identifier> <identifiersep> address , <identifier> <identifier> <identifiersep> session <identifiersep> id ) { \n \t3 if ( <identifier> ) { \n <ect>
\t2 if ( on <identifiersep> <identifier> ) { \n \t3 log . info ( <string_literal> , new object [ ] { config . get <identifiersep> host <identifiersep> name ( ) , config . get <identifiersep> port ( ) , <identifier> <identifiersep> path . to <identifiersep> string ( ) } ) ; \n \t2 } else { \n <ect>
\t3 connection <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( this : : <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> * <identifier> <identifiersep> <identifier> <identifiersep> count , time <identifiersep> unit . <identifier> ) ; } \n \t2 else \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> throwable ( <identifier> ) ; \n <ect>
\t4 event <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> event ( \n \t5 new <identifier> <identifiersep> event ( event . get <identifiersep> source ( ) , <identifier> <identifiersep> event . <identifier> <identifiersep> <identifier> ) ) ; } \n \t3 catch ( throwable t ) \n \t3 { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 for ( <identifier> < ? > <identifier> : <identifier> ) { \n \t3 log . debug ( <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) ) ; } } \n \t2 if ( <identifier> . size ( ) != 1 ) { \n <ect>
\t3 if ( update ) { \n \t4 item <identifiersep> service . update ( <identifier> . <identifier> <identifiersep> context ( ) , item ) ; } \n \t3 status = <identifier> . <identifier> <identifiersep> success ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> <identifiersep> e ) { \n <ect>
\t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n <ect>
\t2 } else if ( <identifier> instanceof empty <identifiersep> <identifier> <identifiersep> to <identifiersep> set ) { \n \t3 return add <identifiersep> all ( <identifier> , null ) ; } \n \t2 if ( ! <identifier> . v ( ) . <identifier> <identifiersep> to <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 logger . warn ( <string_literal> ) ; \n <ect>
\t5 log <identifiersep> file = new file ( config . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> test <identifiersep> log <identifiersep> directory ( test <identifiersep> id . <identifier> ( <string_literal> , <string_literal> ) ) , \n \t7 <identifier> <identifiersep> <identifier> . get <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) + <string_literal> ) ; \n \t5 file <identifiersep> utils . write <identifiersep> byte <identifiersep> array <identifiersep> to <identifiersep> file ( log <identifiersep> file , <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 { \n \t7 entry . service = new <identifiersep> instance ; } } } \n \t4 else \n \t4 { \n <ect>
\t3 if ( <identifier> <identifiersep> config . e <identifiersep> is <identifiersep> set ( <identifier> <identifiersep> config . e <identifiersep> class ( ) . get <identifiersep> e <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ) ) { \n \t4 set <identifiersep> <identifier> <identifiersep> code ( <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> code ( ) ) ; \n \t4 <identifier> <identifiersep> code <identifiersep> found = true ; \n \t3 } else { \n <ect>
\t3 while ( true ) { \n \t4 if ( ( <identifier> . <identifier> ( ) == 0 ) && ( <identifier> . <identifier> ( ) == 0 ) ) { \n \t5 int <identifier> = <identifier> . wait <identifiersep> for <identifiersep> <identifier> ( channel <identifiersep> <identifier> . <identifier> <identifiersep> data | channel <identifiersep> <identifier> . <identifier> <identifiersep> data | channel <identifiersep> <identifier> . <identifier> , <number_literal> ) ; \n \t5 if ( ( <identifier> & channel <identifiersep> <identifier> . timeout ) != 0 ) { \n <ect>
\t4 try { \n \t5 <comment> \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> file ( <identifier> <identifiersep> entry . get <identifiersep> path ( ) . <identifier> ( entry . get <identifiersep> <identifier> ( ) ) , result <identifiersep> <identifier> ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 if ( <identifier> <identifiersep> utils . <identifier> <identifiersep> message <identifiersep> <identifier> ( <identifier> <identifiersep> request , <identifier> , request <identifiersep> <identifier> , content <identifiersep> <identifier> ) ) { \n \t6 is <identifiersep> <identifier> = true ; } } \n \t4 request <identifiersep> content = request <identifiersep> xml <identifiersep> object . get <identifiersep> message <identifiersep> content ( ) ; \n \t3 } catch ( throwable e ) { \n <ect>
\t6 next . no <identifiersep> <identifier> <identifiersep> routing <identifiersep> to ( this <identifiersep> <identifier> , false ) ; \n \t6 return ; } \n \t5 if ( msg == null ) { \n \t6 <comment> \n <ect>
\t1 if ( <identifier> != null ) { \n \t1 try { \n \t2 <identifier> . close ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 protected function < <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> config > to <identifiersep> <identifier> <identifiersep> server <identifiersep> config ( ) { \n \t2 return new function < <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> config > ( ) { \n \t3 @ <identifier> \n \t3 public <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> config <identifier> ( <identifier> input ) { \n <ect>
\t2 return <identifier> ; } \n \t1 protected void log <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 log . info ( <string_literal> ) ; \n \t2 boolean <identifier> = <identifier> . is <identifiersep> <identifier> ( get <identifiersep> current <identifiersep> <identifier> <identifiersep> node ( ) . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 <comment> \n \t3 <comment> \n \t4 if ( <identifier> <identifiersep> value <identifiersep> set . is <identifiersep> empty ( ) ) \n <ect>
\t5 string <identifier> = system . get <identifiersep> property ( <identifier> <identifiersep> system <identifiersep> state . <identifier> <identifiersep> <identifier> ) ; \n \t5 if ( <identifier> != null ) { \n \t6 <identifier> = new file ( <identifier> ) ; \n \t6 if ( <identifier> . <identifier> <identifiersep> write ( ) == false ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> connection . start ( ) ; \n \t3 } catch ( final <identifier> <identifiersep> connection <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + e ) ; \n <ect>
\t4 throw new <identifier> <identifiersep> exception ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t1 if ( <identifier> . equals ( <string_literal> ) ) { \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> = <identifier> <identifiersep> process . <identifier> . http ; \n \t1 } else if ( <identifier> . equals ( <string_literal> ) ) { \n <ect>
\t7 remote <identifiersep> <identifier> . write ( password <identifiersep> bytes ) ; \n \t7 remote <identifiersep> <identifier> . <identifier> ( ) ; \n \t7 logger . debug ( <string_literal> ) ; \n \t6 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 <identifier> . <identifier> <identifiersep> message ( m , m <identifiersep> <identifier> ) ; \n \t4 logger . info ( <string_literal> , <identifier> ( ) , ( ( <identifier> <identifiersep> type ) cmd ) . int <identifiersep> value ( ) ) ; \n \t4 m = null ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 map < ? , ? > result = null ; \n \t1 try { \n \t1 result = <identifier> . read <identifiersep> value ( <identifier> <identifiersep> output , map . class ) ; \n \t1 } catch ( exception <identifier> ) { \n <ect>
\t2 set <identifiersep> <identifier> <identifiersep> status <identifiersep> request request = ( set <identifiersep> <identifier> <identifiersep> status <identifiersep> request ) in <identifiersep> action <identifiersep> context . get <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n \t2 if ( request . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) != null && request . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) . equals ( request . get <identifiersep> target <identifiersep> <identifier> <identifiersep> id ( ) ) ) \n \t2 { \n <ect>
\t5 <comment> \n \t3 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) != null ) { \n \t4 <identifier> <identifiersep> <identifier> . add ( <identifier> ) ; \n \t3 } else { \n <ect>
\t2 try ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = response . get <identifiersep> <identifier> ( ) ) { \n \t3 response . set <identifiersep> status ( status ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( text ) ; \n \t2 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t4 return null ; } \n \t3 <identifier> user <identifiersep> id = session . get ( ) . get <identifiersep> user <identifiersep> id ( ) ; \n \t3 <identifier> < user > <identifier> <identifiersep> user = user <identifiersep> manager . instance . get <identifiersep> user ( user <identifiersep> id ) ; \n \t3 if ( ! <identifier> <identifiersep> user . is <identifiersep> <identifier> ( ) ) { \n <ect>
import org . <identifier> . logger <identifiersep> factory ; \n public class <identifier> <identifiersep> <identifier> <identifiersep> exception <identifiersep> handler implements thread . <identifier> <identifiersep> exception <identifiersep> handler { \n protected transient logger logger = logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) ; \n public void <identifier> <identifiersep> exception ( thread thread , throwable throwable ) { \n <ect>
\t2 if ( map . contains <identifiersep> key ( <identifier> ) ) { \n \t3 <identifier> = map . get ( <identifier> ) ; \n \t2 } else { \n \t3 <identifier> = new <identifier> <identifiersep> set < > ( ) ; } \n <ect>
\t4 try { \n \t5 list < index <identifiersep> <identifier> > r = get <identifiersep> <identifier> ( ) ; \n \t5 <identifier> = <identifier> ( r ) ; \n \t5 <comment> \n <ect>
\t5 . get <identifiersep> <identifier> <identifiersep> field ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> field . set <identifiersep> <identifier> ( true ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = ( object [ ] ) <identifier> <identifiersep> <identifier> <identifiersep> field . get ( this ) ; \n \t2 } catch ( exception <identifier> ) { \n <ect>
\t2 if ( ( is <identifiersep> <identifier> ( ) ) && ( ! is <identifiersep> <identifier> <identifiersep> to <identifiersep> date ( ) ) ) { \n \t2 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( <identifier> . state . <identifier> . equals ( <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> . class ) . get <identifiersep> state ( ) ) ) { \n \t2 if ( ! is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> <identifier> <identifiersep> task ( ) , <identifier> <identifiersep> <identifier> . value ( ) , <identifier> <identifiersep> <identifier> . value ( ) , time <identifiersep> unit . <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( get <identifiersep> <identifier> <identifiersep> task ( ) ) ; \n <ect>
\t6 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t6 log . info ( <string_literal> + grid <identifiersep> name ) ; \n <ect>
\t4 while ( input <identifiersep> <identifier> . size ( ) > 0 ) { \n \t5 try { \n \t6 input <identifiersep> <identifier> . get ( 0 ) . close ( ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 final thread <identifier> <identifiersep> <identifier> = new thread ( new abstract <identifiersep> <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public void on <identifiersep> failure ( exception e ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> server <identifiersep> response e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + vm <identifiersep> name + <string_literal> + ip <identifiersep> <identifier> + <string_literal> , e ) ; \n \t3 return false ; \n \t2 } catch ( <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t2 final http <identifiersep> client <identifiersep> context context = <identifier> . client <identifiersep> context ; \n \t2 <identifier> <identifiersep> cache <identifiersep> <identifier> ( target , request ) ; \n \t2 final date <identifier> = get <identifiersep> current <identifiersep> date ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> response <identifiersep> be <identifiersep> <identifier> ( target , request , entry , <identifier> ) ) { \n <ect>
\t2 { \n \t3 <identifier> <identifiersep> user <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 log . warn ( <string_literal> , e ) ; \n \t1 return 1 ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 return false ; } \n \t2 final string client <identifiersep> id = context . get <identifiersep> request <identifiersep> <identifier> ( o <identifiersep> <identifier> . client <identifiersep> id ) ; \n \t2 final o <identifiersep> <identifier> <identifiersep> registered <identifiersep> service registered <identifiersep> service = get <identifiersep> registered <identifiersep> service <identifiersep> by <identifiersep> client <identifiersep> id ( client <identifiersep> id ) ; \n \t2 if ( ! <identifier> . check <identifiersep> service <identifiersep> <identifier> ( registered <identifiersep> service ) ) { \n <ect>
\t2 file file = <identifier> <identifiersep> <identifier> <identifiersep> request . get <identifiersep> file ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> log . info ( <string_literal> + action <identifiersep> request <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> request <identifiersep> <identifier> ) ; \n <ect>
\t2 if ( count > 0 ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + count + <string_literal> + account <identifiersep> id ) ; } \n \t2 count = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> policy <identifiersep> dao . remove <identifiersep> by <identifiersep> account <identifiersep> id ( account <identifiersep> id ) ; \n \t2 if ( count > 0 ) { \n <ect>
\t4 for ( <identifier> <identifiersep> context <identifiersep> handle handle : <identifier> <identifiersep> <identifier> ) { \n \t5 try { \n \t6 handle . <identifier> ( ) ; \n \t5 } catch ( throwable e ) { \n <ect>
\t3 response . set <identifiersep> status ( e . get <identifiersep> error <identifiersep> code ( ) ) ; \n \t3 if ( e . get <identifiersep> <identifier> ( ) != null && e . get <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> <identifier> ) \n \t4 <identifier> <identifiersep> response ( response , ( ( <identifier> <identifiersep> <identifier> ) e . get <identifiersep> <identifier> ( ) ) . get <identifiersep> <identifier> <identifiersep> code ( ) . get <identifiersep> local <identifiersep> <identifier> ( ) , e . get <identifiersep> message ( ) ) ; \n \t3 else { \n <ect>
\t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n <ect>
\t2 if ( node <identifiersep> <identifier> . has <identifiersep> next ( ) && ( node = node <identifiersep> <identifier> . next ( ) ) . is <identifiersep> resource ( ) ) { \n \t3 input <identifiersep> attributes = get <identifiersep> attributes ( model , node . as <identifiersep> resource ( ) , io <identifiersep> type . input ) ; \n \t3 input <identifiersep> model = get <identifiersep> <identifier> <identifiersep> model ( model , node . as <identifiersep> resource ( ) ) ; \n \t2 } else \n <ect>
\t2 string result = command . execute ( ) ; \n \t2 if ( result != null ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t1 public <identifier> <identifiersep> <identifier> read <identifiersep> from ( class < <identifier> <identifiersep> <identifier> > type , type <identifier> <identifiersep> type , \n \t7 <identifier> [ ] <identifier> , <identifier> <identifiersep> type <identifier> <identifiersep> type , \n \t7 <identifier> <identifiersep> map < string , string > http <identifiersep> <identifier> , input <identifiersep> stream entity <identifiersep> stream ) \n \t3 throws io <identifiersep> exception , web <identifiersep> application <identifiersep> exception { \n <ect>
\t3 if ( api . get <identifiersep> response <identifiersep> code ( ) != <number_literal> ) { \n \t4 error ++ ; \n \t4 s <identifiersep> logger . error ( <string_literal> + api . get <identifiersep> url ( ) + <string_literal> ) ; \n \t3 } else { \n <ect>
\t2 string <identifier> <identifiersep> <identifier> <identifiersep> string = ( string ) configuration . get ( <string_literal> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> <identifier> <identifiersep> string ) ) { \n \t3 <identifier> <identifiersep> <identifier> = integer . parse <identifiersep> int ( <identifier> <identifiersep> <identifier> <identifiersep> string ) ; } \n \t2 set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n <ect>
\t3 logger . info ( <string_literal> + url . get <identifiersep> service <identifiersep> key ( ) + <string_literal> + url ) ; } \n \t2 <identifier> ( url . get <identifiersep> service <identifiersep> key ( ) , url ) ; } \n \t1 public void <identifier> ( url url ) { \n <ect>
\t2 client . get <identifiersep> channel ( meta <identifiersep> <identifier> ) . remove <identifiersep> listener ( <identifier> <identifiersep> listener ) ; \n \t2 client . get <identifiersep> channel ( meta <identifiersep> <identifier> ) . remove <identifiersep> listener ( <identifier> <identifiersep> listener ) ; \n \t2 boolean <identifier> = client . <identifier> ( timeout ) ; \n \t2 if ( ! <identifier> ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 log . error ( <string_literal> + <identifier> <identifiersep> action <identifiersep> type + <string_literal> ) ; \n \t3 log . error ( <string_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 if ( configuration <identifiersep> service ( ) . get <identifiersep> boolean <identifiersep> property ( <string_literal> , <string_literal> , true ) ) { \n \t3 try { \n \t4 return new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cache <identifiersep> service ( <identifier> <identifiersep> manager <identifiersep> <identifier> ( ) . get <identifiersep> manager ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> manager <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> to <identifiersep> store ( key ) ; \n \t4 <comment> \n \t4 if ( max <identifiersep> file <identifiersep> store <identifiersep> size > 0 && file <identifiersep> store . length ( ) > max <identifiersep> file <identifiersep> store <identifiersep> size ) { \n <ect>
\t2 try { \n \t3 session . <identifier> <identifiersep> <identifier> ( get <identifiersep> test <identifiersep> name ( ) ) ; \n \t3 <identifier> ( <string_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 this . <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( new <identifier> ( system . current <identifiersep> time <identifiersep> millis ( ) ) ) ; \n \t4 this . <identifier> <identifiersep> provider . <identifier> <identifiersep> <identifier> ( this . <identifier> <identifiersep> <identifier> ) ; \n \t4 log . info ( <string_literal> + this . <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + this . <identifier> <identifiersep> <identifier> . get <identifiersep> remote <identifiersep> server <identifiersep> address ( ) ) ; \n \t3 } else { \n <ect>
\t5 + long . to <identifiersep> <identifier> <identifiersep> string ( session <identifiersep> id ) + <string_literal> ; \n \t4 log . warn ( warn <identifiersep> info ) ; \n \t4 throw new session <identifiersep> <identifier> <identifiersep> exception ( warn <identifiersep> info ) ; } \n \t3 if ( ! read <identifiersep> <identifier> && is <identifiersep> <identifier> ) { \n <ect>
\t1 if ( data <identifiersep> message == null ) { \n \t2 <identifier> . remove <identifiersep> queue ( key , <identifier> <identifiersep> key ) ; \n \t2 throw new <identifier> <identifiersep> error <identifiersep> exception ( <string_literal> + key + <string_literal> + <identifier> <identifiersep> key ) ; } \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> service answer = factory . get <identifiersep> <identifier> ( ) ; \n \t2 return answer ; } \n \t1 protected destination create <identifiersep> <identifier> <identifiersep> destination ( ) { \n \t2 string queue <identifiersep> name = <string_literal> + get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + get <identifiersep> name ( ) ; \n <ect>
\t7 log . warn ( <string_literal> , item <identifiersep> stream . get <identifiersep> name ( ) , max <identifiersep> size ) ; \n \t7 continue ; } \n \t6 process <identifiersep> file <identifiersep> item <identifiersep> stream <identifiersep> as <identifiersep> file <identifiersep> field ( item <identifiersep> stream , <identifier> <identifiersep> dir ) ; } \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 public <identifier> <identifiersep> message get <identifiersep> value <identifiersep> message ( ) { \n \t2 if ( is <identifiersep> get <identifiersep> <identifier> == false ) { \n \t3 logger . debug ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) ) ; \n \t3 return null ; } \n <ect>
\t5 if ( e . get <identifiersep> <identifier> ( ) instanceof cluster <identifiersep> <identifier> <identifiersep> session <identifiersep> exception ) { \n \t6 s <identifiersep> logger . error ( <string_literal> ) ; \n \t6 queue <identifiersep> <identifier> ( new cluster <identifiersep> manager <identifiersep> message ( cluster <identifiersep> manager <identifiersep> message . message <identifiersep> type . node <identifiersep> <identifier> ) ) ; } \n \t5 if ( is <identifiersep> root <identifiersep> <identifier> <identifiersep> connection <identifiersep> <identifier> ( e . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 string <identifier> = io <identifiersep> utils . to <identifiersep> string ( class <identifiersep> <identifier> . get <identifiersep> system <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ) ; \n \t2 logger . info ( <string_literal> , <identifier> ) ; \n \t2 <comment> \n \t2 string result = get <identifiersep> <identifier> ( <string_literal> , null ) . <identifier> ( <identifier> ) ; \n <ect>
\t4 <identifier> <identifiersep> service . execute ( <identifier> <identifiersep> task ) ; \n \t4 try { \n \t5 <identifier> <identifiersep> task . get ( delete <identifiersep> timeout , time <identifiersep> unit . <identifier> ) ; \n \t4 } catch ( timeout <identifiersep> exception e ) { \n <ect>
\t2 if ( last <identifiersep> <identifier> == <identifier> ) \n \t2 { \n \t3 last <identifiersep> <identifier> = <identifier> <identifiersep> state . get <identifiersep> last <identifiersep> <identifier> ( ) ; } \n \t2 <identifier> <identifiersep> state . last <identifiersep> <identifier> = last <identifiersep> <identifier> ; \n <ect>
\t4 get <identifiersep> <identifier> ( ) . start ( ) ; \n \t4 load <identifiersep> <identifier> <identifiersep> file ( ) ; \n \t4 log . info ( <string_literal> ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t9 <identifier> <identifiersep> request <identifier> <identifiersep> request ) throws throwable \n \t1 { \n \t2 try \n \t2 { \n <ect>
\t1 return <identifier> . empty <identifiersep> list ( ) ; } \n \t1 list < <identifier> > list = new array <identifiersep> list < > ( ) ; \n \t1 for ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t1 if ( null == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . key || null == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . find || null == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> with ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 try { \n \t4 string <identifier> <identifiersep> file <identifiersep> path = <string_literal> ; \n \t4 if ( path . <identifier> <identifiersep> with ( <identifier> <identifiersep> file <identifiersep> path ) ) { \n <ect>
\t3 <identifier> . get <identifiersep> principal ( ) . get <identifiersep> attributes ( ) . for <identifiersep> <identifier> ( ( <identifier> , v ) - > { \n \t4 try { \n \t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . contains ( <identifier> ) ) { \n \t6 final string uri = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . value <identifiersep> of ( <identifier> ) . get <identifiersep> uri ( ) ; \n <ect>
\t4 file <identifiersep> utils . delete <identifiersep> directory ( file ) ; \n \t3 } else { \n \t4 file <identifiersep> utils . delete <identifiersep> <identifier> ( file ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t1 out . <identifier> ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n \t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> , e ) ; } \n <ect>
\t3 response ) ; \n \t2 <identifier> . on <identifiersep> error ( new throwable ( <string_literal> ) ) ; } \n \t1 else \n \t1 { \n <ect>
\t2 <comment> \n \t2 target <identifiersep> nodes . add <identifiersep> action <identifiersep> listener ( this ) ; \n \t2 <comment> \n \t2 target <identifiersep> nodes <identifiersep> model . set <identifiersep> <identifier> <identifiersep> item ( <identifier> ) ; \n <ect>
\t5 log . debug ( <string_literal> ) ; \n \t5 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> config <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( self . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t4 string <identifier> = <identifier> <identifiersep> is . read <identifiersep> string ( <string_literal> ) ; \n \t4 if ( ! <identifier> . equals ( <string_literal> ) ) { \n <ect>
\t1 filter = <identifier> . get <identifiersep> content <identifiersep> filter ( ) ; \n \t1 if ( filter != null ) { \n \t2 break ; } } \n \t1 if ( filter != null ) { \n <ect>
\t5 <string_literal> + <identifier> + \n \t5 <string_literal> + <string_literal> + \n \t5 <string_literal> + <identifier> . null ; \n \t3 <identifier> <identifiersep> connection . send <identifiersep> <identifier> ( <identifier> ) ; } \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> from = new <identifier> <identifiersep> from ( <identifier> <identifiersep> host , user , <identifier> <identifiersep> password ) ; \n \t4 string remote <identifiersep> file = <identifier> <identifiersep> data <identifiersep> path + <identifier> <identifiersep> <identifier> <identifiersep> id + <string_literal> + instance <identifiersep> name + <string_literal> ; \n \t4 <identifier> <identifiersep> from . get <identifiersep> remote <identifiersep> file ( remote <identifiersep> file , data <identifiersep> path ) ; \n <ect>
\t2 count <identifiersep> and <identifiersep> <identifier> read <identifiersep> <identifier> = read <identifiersep> <identifier> <identifiersep> file ( <identifier> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> + <identifier> . get <identifiersep> base <identifiersep> name ( ) + <string_literal> + \n \t4 <identifier> . has <identifiersep> header ( ) ) ; \n \t2 if ( ! <identifier> . has <identifiersep> header ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> node <identifiersep> store <identifiersep> if <identifiersep> <identifier> ( ) ; } } \n \t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 protected void <identifier> <identifiersep> data <identifiersep> source ( data <identifiersep> source data <identifiersep> source ) { \n \t2 if ( this . data <identifiersep> source != data <identifiersep> source ) { \n <ect>
\t6 assert <identifier> != null ; \n \t6 <comment> \n \t6 assert method <identifiersep> resource <identifiersep> <identifier> <identifiersep> task . this . job <identifiersep> <identifier> == null ; \n \t6 assert job <identifiersep> <identifier> != null ; \n <ect>
\t3 add <identifiersep> <identifier> ( c , <identifier> , source <identifiersep> dir , map <identifiersep> file , template ) ; \n \t2 } catch ( exception add <identifiersep> exception ) { \n \t3 log . error ( <string_literal> + add <identifiersep> exception . get <identifiersep> message ( ) ) ; \n \t3 delete <identifiersep> <identifier> ( c , map <identifiersep> file ) ; \n <ect>
\t1 double <identifier> = <identifier> <identifiersep> <identifier> - ( <identifier> * <identifier> ) / data . size ( ) ; \n \t1 <comment> \n \t1 if ( double . <identifier> ( <identifier> <identifiersep> <identifier> , double . <identifier> <identifiersep> n ) == 0 ) { \n \t2 <identifier> <identifiersep> <identifier> = <identifier> / data . size ( ) * <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n <ect>
\t4 for ( final object <identifier> : ( collection ) <identifier> [ 0 ] ) { \n \t5 if ( <identifier> instanceof <identifier> <identifiersep> node ) { \n \t6 ( ( <identifier> <identifiersep> node ) <identifier> ) . <identifier> ( <identifier> <identifiersep> <identifier> , 0 ) ; } } \n \t3 } else { \n <ect>
\t2 if ( ! string <identifiersep> utils . is <identifiersep> blank ( <identifier> <identifiersep> query <identifiersep> client <identifiersep> class ) ) { \n \t3 log . info ( <string_literal> , <identifier> <identifiersep> query <identifiersep> client <identifiersep> class ) ; \n \t3 this . <identifier> <identifiersep> query <identifiersep> client = ( <identifier> <identifiersep> query <identifiersep> client ) utils . new <identifiersep> instance ( <identifier> <identifiersep> query <identifiersep> client <identifiersep> class ) ; \n \t2 } else { \n <ect>
\t2 int current <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 int current <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 log . info ( <string_literal> + last <identifiersep> <identifier> ) ; \n \t2 log . info ( <string_literal> + last <identifiersep> <identifier> ) ; \n <ect>
\t3 return <identifiersep> client <identifiersep> to <identifiersep> pool ( client <identifiersep> from <identifiersep> pool ) ; } \n \t2 return null ; } \n \t1 @ <identifier> \n \t1 public collection < ticket > get <identifiersep> <identifier> ( ) { \n <ect>
\t2 map < string , <identifier> <identifiersep> cluster <identifiersep> service > cluster <identifiersep> <identifier> = get <identifiersep> context ( ) . get <identifiersep> <identifier> ( ) . find <identifiersep> by <identifiersep> type <identifiersep> with <identifiersep> name ( <identifier> <identifiersep> cluster <identifiersep> service . class ) ; \n \t2 if ( cluster <identifiersep> <identifier> != null && ! cluster <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t3 for ( entry < string , <identifier> <identifiersep> cluster <identifiersep> service > entry : cluster <identifiersep> <identifier> . entry <identifiersep> set ( ) ) { \n \t4 <identifier> <identifiersep> cluster <identifiersep> service service = entry . get <identifiersep> value ( ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> source <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> source ( default <identifiersep> <identifier> <identifiersep> context ( ) , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> ( new <identifier> <identifiersep> array ( <string_literal> ) ) ; \n \t2 <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 out . write ( data <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> . to <identifiersep> string ( ) ) ) ; \n \t3 out . close ( ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> . length ; i ++ ) { \n \t3 <identifier> <identifiersep> class <identifier> <identifiersep> type = <identifier> <identifiersep> <identifier> [ i ] ; \n \t3 if ( <identifier> <identifiersep> class <identifiersep> name . equals ( <identifier> <identifiersep> type . get <identifiersep> name ( ) ) ) { \n \t4 string code = string . format ( <string_literal> , i + 1 , <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> name , i + 1 ) ; \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \t3 return true ; } \n \t2 final <identifier> <identifiersep> date <identifiersep> time <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = last <identifiersep> time <identifiersep> <identifier> . <identifier> ( this . time <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> , <identifier> <identifiersep> unit . <identifier> ) ; \n \t2 if ( current <identifiersep> time . is <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t6 for ( int i = 0 ; i < <identifier> <identifiersep> string . length ; i ++ ) { \n \t7 <identifier> <identifiersep> <identifier> [ i ] = float . parse <identifiersep> float ( <identifier> <identifiersep> string [ i ] ) ; } } } \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> path <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t5 <identifier> . <identifier> ( ) ; \n \t4 } catch ( exception e ) { \n \t5 s <identifiersep> logger . error ( <string_literal> + t <identifiersep> info . get <identifiersep> <identifier> <identifiersep> path ( ) + <string_literal> + e . get <identifiersep> message ( ) ) ; } } \n \t3 result . put ( t <identifiersep> info . get <identifiersep> template <identifiersep> name ( ) , t <identifiersep> info ) ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception ex ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , ex ) ; \n \t3 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . <identifier> <identifiersep> error , ex . get <identifiersep> message ( ) ) ; \n \t2 } catch ( resource <identifiersep> in <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 <comment> \n \t3 if ( ! <identifier> <identifiersep> or <identifiersep> <identifier> ) \n \t4 continue ; \n <ect>
\t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 0 ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 1 ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 0 ) . current <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 1 ) . current <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; } \n <ect>
\t2 if ( server != null ) { \n \t3 try { \n \t4 return ( ( <identifier> <identifiersep> socket <identifiersep> address ) server . local <identifiersep> address ( ) ) . get <identifiersep> port ( ) ; } \n \t3 catch ( exception e ) { \n <ect>
\t1 protected authentication <identifiersep> handler <identifiersep> execution <identifiersep> result do <identifiersep> authentication ( final <identifier> <identifier> ) throws <identifier> <identifiersep> security <identifiersep> exception { \n \t2 final <identifier> <identifiersep> key <identifiersep> <identifier> <identifier> <identifiersep> key <identifiersep> <identifier> = ( <identifier> <identifiersep> key <identifiersep> <identifier> ) <identifier> ; \n \t2 final string <identifier> = <identifier> <identifiersep> key <identifiersep> <identifier> . get <identifiersep> token ( ) ; \n \t2 if ( ! <identifier> <identifiersep> client . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> format ( <identifier> ) ) { \n <ect>
private resource <identifiersep> <identifier> <identifiersep> <identifier> create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t1 return new resource <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t1 public void process ( final resource resource , final <identifier> <identifier> , final <identifier> <identifier> ) \n \t2 throws io <identifiersep> exception { \n <ect>
\t2 if ( <identifier> <identifiersep> web <identifiersep> <identifier> . exists ( ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> . delete <identifiersep> directory ( <identifier> <identifiersep> web <identifiersep> <identifier> ) ; } \n \t3 catch ( io <identifiersep> exception io ) { \n <ect>
\t3 return input . get <identifiersep> id ( ) . equals ( location <identifiersep> id ) ; } \n \t2 } ) ; \n \t2 return location ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n <ect>
\t1 text first = key <identifiersep> <identifier> . get <identifiersep> metadata <identifiersep> entry ( table <identifiersep> id , start ) ; \n \t1 <identifier> <identifier> = new <identifier> ( first , false , null , true ) ; \n \t1 <identifier> . set <identifiersep> <identifier> ( <identifier> . <identifier> ( metadata <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ) ; \n \t1 key <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = null ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider ( <identifier> <identifiersep> context ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list <identifiersep> metadata ( \n \t6 <identifier> <identifiersep> context , \n \t6 info ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 if ( i == 0 ) { \n \t3 log . warn ( <string_literal> + name , e ) ; \n \t2 } else { \n \t3 log . debug ( <string_literal> + name + <string_literal> , e ) ; \n <ect>
\t2 <identifier> . <identifier> ( task ) ; } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> stop ( ) throws exception { \n \t2 super . do <identifiersep> stop ( ) ; \n <ect>
\t2 final <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 final int <identifier> <identifiersep> length = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . length ( ) ; \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> length > <number_literal> && <identifier> <identifiersep> length > <identifier> <identifiersep> <identifier> <identifiersep> stop ) { \n <ect>
\t6 log . info ( <string_literal> + node <identifiersep> id ) ; \n \t6 log . info ( <string_literal> + <identifier> <identifiersep> host ) ; \n \t6 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t3 for ( string item <identifiersep> name : item <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> config <identifier> <identifiersep> config = provider . get <identifiersep> item <identifiersep> config ( item <identifiersep> name ) ; \n \t4 if ( <identifier> <identifiersep> config . get <identifiersep> address ( ) . equals ( address . to <identifiersep> string ( ) ) ) { \n \t5 return <identifier> <identifiersep> config . get <identifiersep> item <identifiersep> name ( ) ; } } } \n <ect>
\t2 host . set <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> url ) ; \n \t2 return <identifier> <identifiersep> host <identifiersep> dao . <identifier> ( host ) ; } \n \t1 @ <identifier> \n \t1 public boolean delete <identifiersep> <identifier> <identifiersep> host ( delete <identifiersep> <identifier> <identifiersep> cmd cmd ) { \n <ect>
\t3 { \n \t3 if ( <identifier> ) \n \t3 { \n \t4 <identifier> <identifiersep> event <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( property , value ) ; \n <ect>
\t5 <string_literal> ) ; \n \t3 if ( ! result <identifiersep> <identifier> [ 0 ] . equals ( result <identifiersep> <identifier> [ 1 ] ) ) { \n \t4 <identifier> <identifiersep> logger . debug ( handler <identifiersep> <identifier> [ 0 ] + <string_literal> + handler <identifiersep> <identifier> [ 1 ] + <string_literal> + \n \t6 result <identifiersep> <identifier> [ 0 ] . size ( ) + <string_literal> + result <identifiersep> <identifier> [ 1 ] . size ( ) + <string_literal> ) ; \n <ect>
<number_literal> <string_literal> , \n <number_literal> xml <identifiersep> <identifier> <identifiersep> service . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n \t3 ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 if ( if <identifiersep> <identifier> == true ) { \n \t3 for ( string <identifier> <identifiersep> <identifier> <identifiersep> name : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 string [ ] <identifier> <identifiersep> name <identifiersep> list = <identifier> <identifiersep> <identifier> <identifiersep> name . <identifier> ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> table <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> table <identifiersep> <identifier> ( table <identifiersep> name . value <identifiersep> of ( <identifier> <identifiersep> name <identifiersep> list [ 0 ] ) ) ; \n <ect>
\t6 system . set <identifiersep> property ( key , <string_literal> ) ; \n \t6 return null ; } \n \t4 } ) ; \n \t3 } catch ( final security <identifiersep> exception e ) { \n <ect>
\t2 list < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 int num <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . size ( ) ; \n \t2 int num <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 if ( local <identifiersep> map . get ( <identifier> ) != <identifier> ) { \n \t5 if ( <identifier> <identifiersep> <identifier> ) { \n \t6 if ( log <identifiersep> <identifier> ) logger . <identifier> ( this , <string_literal> + <identifier> + <string_literal> + local <identifiersep> map . get ( <identifier> ) + <string_literal> + <identifier> ) ; \n \t5 } else { \n <ect>
\t2 try { \n \t3 enabled <identifiersep> <identifier> <identifiersep> <identifier> = null ; \n \t3 <identifier> <identifiersep> context . get <identifiersep> instance ( <string_literal> ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <comment> \n \t4 <identifier> . set <identifiersep> <identifier> ( true ) ; } } \n \t2 catch ( throwable t ) \n \t2 { \n <ect>
\t6 break ; } } } \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 set < <identifier> > <identifier> = new <identifier> <identifiersep> set < <identifier> > ( 1 ) ; \n \t4 if ( log . should <identifiersep> log ( log . info ) ) \n <ect>
\t1 try { \n \t1 for ( string table : table <identifiersep> <identifier> ) { \n \t2 <identifier> <identifiersep> table <identifiersep> if <identifiersep> exists ( table ) ; } \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . <identifier> ( <identifier> ) ; \n \t3 <identifier> <identifiersep> output <identifiersep> stream <identifier> = new <identifier> <identifiersep> cache <identifiersep> <identifier> <identifiersep> output <identifiersep> stream ( out ) ; \n \t3 <identifier> <identifiersep> io . write ( <identifier> , <string_literal> , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t4 <comment> \n \t4 string line = data <identifiersep> <identifier> . read <identifiersep> line ( ) ; \n \t4 data <identifiersep> <identifier> . close ( ) ; \n \t4 if ( line == null ) { \n <ect>
\t4 string the <identifiersep> token = next . next <identifiersep> token ( ) . <identifier> ( ) ; \n \t4 if ( the <identifiersep> token . index <identifiersep> of ( ' @ ' ) > 0 ) { <comment> \n \t5 address <identifiersep> list . add ( the <identifiersep> token ) ; \n \t4 } else { \n <ect>
\t3 if ( <identifier> == null ) { \n \t4 logger . warn ( <string_literal> + item <identifiersep> name + <string_literal> ) ; \n \t4 continue ; } \n \t3 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) == <identifier> <identifiersep> <identifier> <identifiersep> config . <identifier> <identifiersep> type . in ) { \n <ect>
\t4 <identifier> = \n \t5 conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t4 <identifier> . execute <identifiersep> update ( ) ; } \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t6 if ( api . set <identifiersep> <identifier> ( this . get <identifiersep> <identifier> ( ) ) == false ) { \n \t7 s <identifiersep> logger . error ( <string_literal> + api . get <identifiersep> name ( ) + <string_literal> + api . get <identifiersep> url ( ) ) ; \n \t7 return false ; } \n \t6 else if ( api . get <identifiersep> test <identifiersep> case <identifiersep> info ( ) != null ) { \n <ect>
\t4 <identifier> <identifiersep> class <identifiersep> <identifier> <identifier> <identifiersep> class <identifiersep> <identifier> = new <identifier> <identifiersep> class <identifiersep> <identifier> ( <identifier> <identifiersep> file ) ; \n \t4 class < ? > <identifier> <identifiersep> <identifier> <identifiersep> class = <identifier> <identifiersep> class <identifiersep> <identifier> . load <identifiersep> class ( <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> name ) ; \n \t4 object object = <identifier> <identifiersep> <identifier> <identifiersep> class . new <identifiersep> instance ( ) ; \n \t4 if ( ! ( object instanceof <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t1 if ( from != null ) { \n \t2 msg . set <identifiersep> from ( new <identifier> <identifiersep> address ( from , from <identifiersep> name ) ) ; \n \t1 } else { \n \t2 <comment> \n <ect>
\t5 string value = ( string ) <identifier> . get <identifiersep> value ( ) ; \n \t5 try { \n \t6 <identifier> = <identifier> + <string_literal> + key + <string_literal> + url <identifiersep> <identifier> . <identifier> ( value , <string_literal> ) ; \n \t5 } catch ( exception ex ) { \n <ect>
\t2 if ( num <identifiersep> write > 0 && num <identifiersep> write != num <identifiersep> <identifier> ) { \n \t3 log . warn ( <string_literal> + num <identifiersep> <identifier> + <string_literal> + num <identifiersep> write ) ; } \n \t2 int num <identifiersep> read = read <identifiersep> <identifier> . length ; \n \t2 if ( num <identifiersep> read > 0 && num <identifiersep> read != num <identifiersep> <identifier> ) { \n <ect>
\t4 { \n \t5 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t4 catch ( operation <identifiersep> failed <identifiersep> exception <identifier> ) \n \t4 { \n <ect>
\t3 <identifier> <identifiersep> service . <identifier> <identifiersep> metadata ( context , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> element , <identifier> <identifiersep> <identifier> , null ) ; \n \t3 <identifier> <identifiersep> service . add <identifiersep> metadata ( context , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> element , <identifier> <identifiersep> <identifier> , null , <identifier> ) ; \n \t3 <identifier> <identifiersep> service . update ( context , <identifier> ) ; \n \t2 } catch ( sql <identifiersep> exception | <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> host <identifiersep> <identifier> , \n \t4 <identifier> <identifiersep> timeout ) ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 throw new runtime <identifiersep> exception ( e ) ; } \n <ect>
\t6 if ( m != null ) { \n \t7 <identifier> . <identifier> <identifiersep> message ( m , m <identifiersep> <identifier> ) ; } } \n \t4 } , <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 if ( key . equals ( <string_literal> ) ) { \n \t6 config . set <identifiersep> property ( value ) ; } } } \n \t3 boolean is <identifiersep> value <identifiersep> item = item . get <identifiersep> class ( ) . equals ( number <identifiersep> item . class ) || item . get <identifiersep> class ( ) . equals ( string <identifiersep> item . class ) ; \n \t3 if ( is <identifiersep> value <identifiersep> item && string <identifiersep> utils . is <identifiersep> empty ( config . get <identifiersep> property ( ) ) ) { \n <ect>
import org . apache . <identifier> . logger ; \n public class <identifier> { \n \t1 private static final logger logger = logger . get <identifiersep> logger ( <identifier> . class ) ; \n \t1 public static void <identifier> ( string <identifier> [ ] ) { \n <ect>
\t4 return null ; } \n \t3 final object <identifiersep> <identifier> <identifier> = new object <identifiersep> <identifier> ( ) ; \n \t3 return <identifier> . read <identifiersep> value ( response . get <identifiersep> entity ( ) . get <identifiersep> content ( ) , <identifier> <identifiersep> user . class ) ; \n \t2 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t2 is <identifiersep> run <identifiersep> <identifier> . set ( false ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> thread . <identifier> ( ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { } \n <ect>
\t5 s <identifiersep> logger \n \t7 . error ( <string_literal> + <string_literal> + url ) ; \n \t5 return - 1 ; } } \n \t2 } else { \n <ect>
\t2 if ( entry . get <identifiersep> value ( ) . get <identifiersep> <identifier> <identifiersep> time ( ) > max <identifiersep> wait ) { \n \t3 instance = entry . get <identifiersep> key ( ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> time ++ ; } } } \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> time == 1 && <identifier> <identifiersep> <identifier> <identifiersep> time == 1 && <identifier> <identifiersep> status . size ( ) > 1 ) { \n <ect>
\t2 log . debug ( <string_literal> , <identifier> ) ; \n \t2 return ; } \n \t2 string message = string . value <identifiersep> of ( <identifier> . get <identifiersep> message ( ) ) ; \n \t2 if ( <identifier> <identifiersep> error <identifiersep> message . <identifier> ( message ) . <identifier> ( ) ) { \n <ect>
\t4 result = <identifier> . get ( ) ; \n \t3 } else { \n \t4 result = <identifier> . get ( timeout , time <identifiersep> unit . <identifier> ) ; } \n \t2 } catch ( interrupted <identifiersep> exception | execution <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> <identifier> ( x <identifiersep> stream <identifier> ) { \n \t2 for ( <identifier> <identifier> : <identifier> ) { \n \t3 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t6 break ; } } \n \t3 if ( config != null ) { \n \t4 add <identifiersep> <identifier> <identifiersep> config ( item , config ) ; } \n \t2 } else { \n <ect>
\t1 public collection < metadata <identifiersep> <identifier> > <identifier> ( final <identifier> <identifiersep> registered <identifiersep> service service ) { \n \t2 final string metadata <identifiersep> location = service . get <identifiersep> metadata <identifiersep> location ( ) ; \n \t2 logger . info ( <string_literal> , metadata <identifiersep> location ) ; \n \t2 try ( input <identifiersep> stream in = resource <identifiersep> utils . get <identifiersep> resource <identifiersep> from ( metadata <identifiersep> location ) . get <identifiersep> input <identifiersep> stream ( ) ) { \n <ect>
\t5 <identifier> <identifiersep> for <identifiersep> final <identifiersep> files ( <identifier> <identifiersep> path <identifiersep> info , path ) ; \n \t4 } else { \n \t5 log . warn ( <string_literal> + path ) ; } } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 } finally { \n \t4 io <identifiersep> utils . close <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t3 break ; } \n \t2 case <identifier> <identifiersep> and <identifiersep> <identifier> : { \n <ect>
\t4 if ( <identifier> <identifiersep> properties <identifiersep> file . exists ( ) ) { \n \t5 log . info ( <string_literal> , <identifier> <identifiersep> properties <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t5 <identifier> <identifiersep> properties <identifiersep> file . delete ( ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t10 string file <identifiersep> path , <identifier> <identifiersep> map < string , string > query <identifiersep> <identifier> , \n \t10 job <identifiersep> type job <identifiersep> type ) { \n \t1 string name <identifiersep> node = <identifier> <identifiersep> context . get <identifiersep> properties ( ) . get ( <string_literal> ) ; \n \t1 if ( name <identifiersep> node == null ) { \n <ect>
\t5 try { \n \t6 <identifier> . run ( ) ; } \n \t5 <comment> \n \t5 catch ( throwable t ) { \n <ect>
\t1 try { \n \t1 conn = db <identifiersep> conf . get <identifiersep> connection ( ) ; \n \t1 <identifier> = ( ( <identifier> <identifiersep> connection ) conn ) . get <identifiersep> <identifier> <identifiersep> api ( ) ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
\t5 <identifier> <identifiersep> to = <identifier> <identifiersep> or <identifiersep> create <identifiersep> destination ( <identifier> <identifiersep> to <identifiersep> <identifier> , session ) ; \n \t4 } else if ( <identifier> <identifiersep> <identifier> <identifiersep> to instanceof destination ) { \n \t5 <identifier> <identifiersep> to = ( destination ) <identifier> <identifiersep> <identifier> <identifiersep> to ; } \n \t4 if ( <identifier> <identifiersep> to != null ) { \n <ect>
\t6 <comment> \n \t6 <comment> \n \t6 <identifier> = true ; \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
<comment> \n \t1 private void <identifier> ( ) throws <identifier> <identifiersep> exception { \n <ect>
\t1 <comment> \n \t1 private <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message <identifiersep> listener message <identifiersep> listener = null ; \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t2 remove <identifiersep> <identifier> ( client . get <identifiersep> endpoint ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> in <identifiersep> <identifier> ( ) , \n \t6 <identifier> <identifiersep> header <identifiersep> <identifier> . class ) ; \n \t2 client . get <identifiersep> endpoint ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> in <identifiersep> <identifier> ( ) . add ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( client . get <identifiersep> endpoint ( ) . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 logger . info ( <string_literal> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> name ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 logger . warn ( <string_literal> , e ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t9 vm <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t9 vm <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> <identifier> ( ) ; \n \t9 vm <identifiersep> <identifier> . <identifier> ( ) ; } } } } } \n \t3 } else { \n <ect>
\t3 in <identifiersep> <identifier> = true ; \n \t2 } catch ( exception e ) { \n \t3 in <identifiersep> <identifier> = false ; } \n \t1 if ( ! in <identifiersep> <identifier> ) { \n <ect>
\t2 if ( thread <identifiersep> pool == null || ( thread <identifiersep> pool instanceof <identifier> <identifiersep> service && ( ( <identifier> <identifiersep> service ) thread <identifiersep> pool ) . is <identifiersep> shutdown ( ) ) ) { \n \t3 if ( thread <identifiersep> pool <identifiersep> enabled ) { \n \t4 int num <identifiersep> <identifier> = runtime . get <identifiersep> runtime ( ) . <identifier> <identifiersep> <identifier> ( ) ; \n \t4 int max <identifiersep> <identifier> <identifiersep> size = <identifier> . max ( <number_literal> , num <identifiersep> <identifier> ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void thread <identifiersep> <identifier> ( ) { \n <ect>
\t3 send <identifiersep> message ( from , new status <identifiersep> response ( session <identifiersep> id , failed ) ) ; } \n \t2 else \n \t2 { \n \t3 send <identifiersep> message ( from , new status <identifiersep> response ( session <identifiersep> id , session . get <identifiersep> state ( ) ) ) ; \n <ect>
\t3 byte <identifiersep> array <identifiersep> output <identifiersep> stream <identifier> = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( <number_literal> ) ; \n \t3 <identifier> <identifiersep> message . write <identifiersep> to ( <identifier> ) ; \n \t3 result = <identifier> . to <identifiersep> string ( ) ; } \n \t2 catch ( exception x ) { \n <ect>
\t3 } catch ( exception e ) { \n \t4 s <identifiersep> logger . error ( string . format ( <string_literal> , <identifier> , body , account . get <identifiersep> account <identifiersep> name ( ) , \n \t6 account . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> , e ) ) ; \n <ect>
\t2 exception <identifiersep> config config ; \n \t2 while ( true ) { \n \t3 <comment> \n \t3 string name = type . get <identifiersep> name ( ) ; \n <ect>
\t1 string host <identifiersep> name = <identifier> <identifiersep> utils . get <identifiersep> host <identifiersep> name ( ) ; \n \t1 if ( string <identifiersep> utils . is <identifiersep> empty ( host <identifiersep> name ) ) { \n \t2 log . warn ( <string_literal> ) ; \n \t1 } else { \n <ect>
\t8 s <identifiersep> logger . debug ( <string_literal> + <identifier> . to <identifiersep> string ( ) + <string_literal> + \n \t10 <identifier> <identifiersep> <identifier> <identifiersep> update . to <identifiersep> string ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ) ; } } } \n \t4 } catch ( final <identifier> <identifiersep> runtime <identifiersep> exception e ) { \n <ect>
\t3 } ) ; } \n \t2 } catch ( throwable t ) { \n \t3 log . debug ( <string_literal> + pool , t ) ; } } \n \t1 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 <identifier> . <identifier> ( ) ; \n \t3 return <identifier> ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 if ( <identifier> < 0 ) \n \t5 { \n \t6 <comment> \n \t6 continue ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> + <identifier> <identifiersep> id , e . get <identifiersep> message ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> failed <identifiersep> exception e ) { \n \t3 root . <identifier> ( ) ; \n <ect>
\t3 } finally { \n \t4 <identifier> . stop <identifiersep> <identifier> ( ) ; \n \t4 <identifier> <identifiersep> <identifier> . close ( ) ; } \n <ect>
\t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t4 <identifier> . <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> set ( <identifier> <identifiersep> <identifier> <identifiersep> <number_literal> ) ; \n \t3 } catch ( io <identifiersep> exception ex ) { \n \t4 <identifier> . <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> set ( null ) ; \n <ect>
\t2 if ( <identifier> != null ) { \n \t3 logger . trace ( <string_literal> , <identifier> . name ( ) ) ; \n \t3 return <identifier> ; } \n \t1 } catch ( exception ex ) { \n <ect>
\t1 private static class <identifier> <identifiersep> <identifier> extends abstract <identifiersep> byte <identifiersep> array <identifiersep> <identifier> { \n \t2 @ <identifier> \n \t2 public byte [ ] <identifier> ( input <identifiersep> stream input <identifiersep> stream ) throws io <identifiersep> exception { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> + vm . get <identifiersep> instance <identifiersep> name ( ) ) ; \n \t4 <identifier> <identifiersep> it <identifiersep> <identifier> . <identifier> ( vm . get <identifiersep> <identifier> ( ) , null ) ; } \n \t3 return <identifier> <identifiersep> vm <identifiersep> dao . find <identifiersep> by <identifiersep> id ( vm <identifiersep> id ) ; \n \t2 } else { \n <ect>
\t1 private void add <identifiersep> <identifier> <identifiersep> provider ( connection conn , long <identifier> <identifiersep> network <identifiersep> id , long <identifier> <identifiersep> id ) { \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> update = null ; \n \t2 try { \n \t3 <comment> \n <ect>
\t7 <identifier> = false ; \n \t5 if ( <identifier> ) \n \t6 continue ; \n \t5 log . error ( <string_literal> + <identifier> . <identifier> <identifiersep> name ) ; \n <ect>
<identifier> <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> start ( <identifier> <identifiersep> manager : local <identifiersep> <identifier> <identifiersep> manager ) { \n \t1 log . info ( <identifier> , <string_literal> ) \n \t1 <identifier> <identifiersep> manager . send <identifiersep> <identifier> ( <identifier> ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> start ) ) } \n <identifier> <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> manager : local <identifiersep> <identifier> <identifiersep> manager ) { \n <ect>
\t1 <identifier> = <identifier> <identifiersep> metadata <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( request . get <identifiersep> <identifier> ( ) ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> entity <identifiersep> exception e ) { \n \t1 throw new no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception ( request . get <identifiersep> <identifier> ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 final <identifier> <identifiersep> context <identifier> <identifiersep> context = <identifier> <identifiersep> context <identifiersep> builder . build ( ) ; \n \t1 default <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> context ) ; \n \t1 return <identifier> <identifiersep> context ; } \n private string <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> source ( final <identifier> <identifiersep> context <identifier> <identifiersep> context ) { \n <ect>
\t2 if ( ! <identifier> <identifiersep> file <identifiersep> path . exists ( ) && <identifier> != null ) { \n \t3 try { \n \t4 new object <identifiersep> <identifier> ( ) . write <identifiersep> value ( <identifier> <identifiersep> file <identifiersep> path . create ( ) , <identifier> ) ; \n \t3 } catch ( json <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> config <identifiersep> <identifier> . set <identifiersep> operation ( operation . to <identifiersep> string ( ) ) ; \n \t2 return <identifier> <identifiersep> config <identifiersep> <identifier> ; } \n \t1 public static <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> switch <identifiersep> <identifier> <identifiersep> <identifier> create <identifiersep> <identifier> <identifiersep> port <identifiersep> <identifier> <identifiersep> <identifier> ( integer <identifier> <identifiersep> id , string <identifier> <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> id == null && <identifier> <identifiersep> <identifier> != null && ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t4 try { \n \t5 if ( response <identifiersep> <identifier> != null ) { \n \t6 response <identifiersep> <identifier> . close ( ) ; } \n \t4 } catch ( throwable <identifier> ) { \n <ect>
\t2 <identifier> ( <identifier> ) { \n \t3 <identifier> <identifiersep> message <identifiersep> <identifier> . error , \n \t3 <identifier> <identifiersep> message <identifiersep> <identifier> . exception - > { \n \t4 has <identifiersep> <identifier> = true \n <ect>
\t3 return new <identifier> <identifiersep> file <identifiersep> import ( header <identifiersep> <identifier> <identifiersep> index , data <identifiersep> start <identifiersep> <identifier> <identifiersep> index , \n \t5 <identifier> , <identifier> <identifiersep> <identifier> , <identifier> , max <identifiersep> num <identifiersep> <identifier> , \n \t5 get <identifiersep> file ( ) , <identifier> , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 } catch ( exception e ) { \n \t2 log . error ( <string_literal> , e ) ; \n \t2 throw new <identifier> <identifiersep> exception ( e . get <identifiersep> message ( ) , e ) ; } } } } \n public void execute <identifiersep> <identifier> <identifiersep> <identifier> ( list < <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> , string <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> <identifier> <identifiersep> file <identifiersep> name ) throws <identifier> <identifiersep> exception { \n <ect>
\t2 try { \n \t3 <identifier> . put ( <string_literal> , <number_literal> ) ; \n \t3 assert . <identifier> ( <string_literal> ) ; \n \t2 } catch ( exception e ) { } <comment> \n <ect>
\t2 try ( output <identifiersep> stream out = new <identifier> <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( <identifier> ) ) ) { \n \t3 <identifier> ( location , out ) ; } \n \t2 catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) \n \t2 { \n <ect>
<comment> \n \t1 class <identifier> <identifiersep> <identifier> <identifiersep> state <identifiersep> listener implements <identifier> <identifiersep> state <identifiersep> listener { \n \t2 public void on <identifiersep> all <identifiersep> session <identifiersep> <identifier> ( <identifier> <identifier> ) { } \n \t2 public void on <identifiersep> exception ( <identifier> <identifier> , throwable t ) { \n <ect>
\t5 { \n \t6 <identifier> <identifiersep> result <identifier> = token <identifiersep> <identifier> . <identifier> ( ) ; \n \t6 token start <identifiersep> token = factory . from <identifiersep> string ( <identifier> . group ( 1 ) ) ; \n \t6 token end <identifiersep> token = factory . from <identifiersep> string ( <identifier> . group ( <number_literal> ) ) ; \n <ect>
\t2 if ( key . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t3 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) != null ) { \n \t3 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) . to <identifiersep> <identifier> <identifiersep> case ( ) ) ; } } } } \n \t1 } catch ( exception e ) { \n <ect>
\t2 set <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> password ( false ) ; \n \t2 set <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> ticket ( false ) ; } \n \t1 @ <identifier> \n \t1 public map < string , object > get <identifiersep> attributes <identifiersep> <identifier> ( final principal principal , final map < string , object > attributes , final registered <identifiersep> service service ) { \n <ect>
\t2 <identifier> = <identifier> <identifiersep> <identifier> ( template , <identifier> ) ; \n \t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> . size ( ) + <string_literal> + <identifier> ) ; } \n <ect>
<comment> \n public void add <identifiersep> user ( user <identifiersep> <identifier> user ) throws illegal <identifiersep> argument <identifiersep> exception { \n \t1 assert . not <identifiersep> null ( user , <string_literal> ) ; \n <ect>
\t4 <identifier> <identifiersep> cache = new timeout <identifiersep> <identifier> <identifiersep> cache ( ) ; \n \t4 <identifier> <identifiersep> cache . <identifier> ( conf ) ; } \n \t2 } catch ( java . <identifier> . <identifier> <identifiersep> class <identifiersep> version <identifiersep> error e ) { \n \t3 if ( e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { \n <ect>
\t1 * \n \t1 * @ <identifier> ip <identifiersep> cmd the command to send . \n \t1 ** / \n \t1 public void send <identifiersep> command ( string ip <identifiersep> cmd ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 int <identifier> = lock <identifiersep> update <identifiersep> <identifier> . execute <identifiersep> update ( ) ; \n \t3 if ( <identifier> == 1 ) { \n \t4 result = true ; } \n \t2 } catch ( exception e ) { \n <ect>
\t4 break ; \n \t3 case <identifier> : \n \t4 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 try { \n \t4 try { \n \t5 success = ( success && <identifier> <identifiersep> it <identifiersep> <identifier> . <identifier> <identifiersep> stop ( vm , false , get <identifiersep> system <identifiersep> user ( ) , get <identifiersep> system <identifiersep> account ( ) ) ) ; \n \t4 } catch ( operation <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t6 <comment> \n \t6 channel . write ( byte <identifiersep> <identifier> . <identifier> ( data ) , <identifier> . get <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t5 catch ( io <identifiersep> exception e ) \n \t5 { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> connection <identifiersep> <identifier> <identifiersep> thread <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 log . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> server <identifiersep> url ( <identifier> . get <identifiersep> transport <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> ( <string_literal> ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( ) ) ; \n <ect>
\t2 <comment> \n \t2 try { \n \t3 <identifier> ( result , <identifier> , <identifier> , <identifier> , default <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception | io <identifiersep> exception e ) { \n <ect>
\t6 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t7 s <identifiersep> logger . error ( <string_literal> ) ; \n \t7 system . <identifier> ( <identifier> <identifiersep> status . error . value ( ) ) ; \n \t6 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
\t3 assert <identifiersep> no <identifiersep> timeout ( client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( <identifier> . <identifier> ) . set <identifiersep> timeout ( <string_literal> ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> <identifiersep> status ( ) ) ; \n \t3 logger . info ( <string_literal> , total <identifiersep> num <identifiersep> <identifier> ) ; \n \t3 wait <identifiersep> for <identifiersep> <identifier> ( total <identifiersep> num <identifiersep> <identifier> , <identifier> ) ; \n \t3 <identifier> . assert <identifiersep> no <identifiersep> <identifier> ( ) ; \n <ect>
\t6 . get <identifiersep> command <identifiersep> class ( command <identifiersep> class . no <identifiersep> operation ) ; \n \t4 if ( <identifier> <identifiersep> command <identifiersep> class != null ) { \n \t5 <identifier> <identifiersep> <identifier> . send <identifiersep> data ( <identifier> <identifiersep> command <identifiersep> class . get <identifiersep> no <identifiersep> operation <identifiersep> message ( ) ) ; } \n \t3 } else { \n <ect>
\t8 return new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < void > ( <identifier> <identifiersep> id , <identifier> , \n \t9 path <identifiersep> info . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , path <identifiersep> info . <identifier> ) ; } \n \t7 catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) \n \t7 { \n <ect>
\t4 log . info ( url ) ; } \n \t3 int code = client . execute <identifiersep> method ( method ) ; \n \t3 if ( code != <number_literal> ) \n \t3 { \n <ect>
\t4 field <identifiersep> info = <identifier> <identifiersep> metadata . get <identifiersep> field ( field . get <identifiersep> name ( ) ) ; } \n \t3 if ( field <identifiersep> info != null ) { \n \t4 data <identifiersep> map . put ( field <identifiersep> info , new <identifier> <identifiersep> <identifier> <identifiersep> data ( field . get <identifiersep> value ( ) ) ) ; \n \t3 } else if ( field . has <identifiersep> name ( ) ) { \n <ect>
<comment> \n @ <identifier> \n @ <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n public void on <identifiersep> <identifier> <identifiersep> event ( service <identifiersep> <identifier> <identifiersep> event event ) { \n <ect>
\t3 if ( log <identifiersep> enabled ) log . info ( <string_literal> ) ; \n \t3 handle = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to ( <identifier> ) ; \n \t3 handle = handle . as <identifiersep> <identifier> ( object [ ] . class , target <identifiersep> type . <identifier> <identifiersep> count ( ) - 1 ) ; \n \t3 handle = method <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( handle , 0 , class . class ) ; \n <ect>
\t2 final int default <identifiersep> <identifier> = <identifier> . get <identifiersep> default <identifiersep> <identifier> ( ) > 0 ? \n \t3 <identifier> . get <identifiersep> default <identifiersep> <identifier> ( ) : this . default <identifiersep> <identifier> ; \n \t2 <comment> \n \t2 log . debug ( <string_literal> , default <identifiersep> <identifier> ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . do <identifiersep> filter ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; } \n \t1 else { \n \t2 log . warn ( <string_literal> + <identifier> <identifiersep> url ) ; } } \n \t1 else { \n <ect>
\t5 this . <identifier> <identifiersep> <identifier> . set <identifiersep> read <identifiersep> <identifier> ( <identifier> ) ; \n \t5 this . <identifier> . <identifier> ( this . <identifier> <identifiersep> <identifier> , output ) ; } \n \t4 else { \n <ect>
\t6 <identifier> <identifiersep> nodes . add ( n ) ; } \n \t4 } else { \n \t5 <identifier> <identifiersep> nodes . add ( ( t ) target ) ; } } \n \t2 } catch ( throwable t ) { \n <ect>
\t1 cluster . start ( ) ; \n \t1 } else { \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 if ( client <identifiersep> socket != null && ! client <identifiersep> socket . is <identifiersep> <identifier> ( ) ) { \n \t4 try { \n \t5 client <identifiersep> socket . set <identifiersep> <identifier> <identifiersep> <identifier> ( true , 0 ) ; \n \t4 } catch ( socket <identifiersep> exception socket <identifiersep> ex ) { \n <ect>
\t3 } catch ( interrupted <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t4 return false ; } } \n \t2 if ( host <identifiersep> <identifier> == null ) { \n <ect>
\t6 <identifier> <identifiersep> log . debug ( <string_literal> + <identifier> . to <identifiersep> string ( ) ) ; } \n \t4 <identifier> . set <identifiersep> length ( 0 ) ; } \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 host <identifiersep> name = server <identifiersep> address instanceof <identifier> \n \t5 ? ' [ ' + server <identifiersep> address . get <identifiersep> host <identifiersep> address ( ) + ' ] ' \n \t5 : server <identifiersep> address . get <identifiersep> host <identifiersep> address ( ) ; } \n \t2 string url = string . format ( url <identifiersep> template , host <identifiersep> name , port ) ; \n <ect>
\t1 public map get <identifiersep> configuration ( final http <identifiersep> <identifier> <identifiersep> request request , final http <identifiersep> <identifier> <identifiersep> response response ) { \n \t2 final map <identifier> = new <identifier> <identifiersep> map ( ) ; \n \t2 <identifier> <identifiersep> endpoint <identifiersep> access <identifiersep> is <identifiersep> <identifier> ( request , response ) ; \n \t2 if ( <identifier> <identifiersep> endpoint == null || ! <identifier> <identifiersep> endpoint . is <identifiersep> enabled ( ) ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> handle handler = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> handle ( <identifier> ) ; \n \t3 <identifier> <identifiersep> db . remove ( handler , <identifier> . <identifier> ( key ) ) ; \n \t2 } catch ( <identifier> <identifiersep> db <identifiersep> exception e ) { \n <ect>
\t1 transaction transaction = null ; \n \t1 try { \n \t2 transaction = transaction <identifiersep> manager . get <identifiersep> transaction ( ) ; } \n \t1 catch ( system <identifiersep> exception e ) { \n <ect>
\t4 + <string_literal> + service . get <identifiersep> metadata <identifiersep> location ( ) ) ; } \n \t2 metadata <identifiersep> <identifier> . set <identifiersep> id ( <identifier> <identifiersep> metadata <identifiersep> <identifier> . class . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 metadata <identifiersep> <identifier> . set <identifiersep> <identifier> ( metadata <identifiersep> <identifier> ) ; \n \t2 metadata <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t4 for ( file file : files ) { \n \t5 log . info ( <string_literal> + file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t5 <identifier> <identifiersep> client <identifiersep> context . conf . add <identifiersep> resource ( file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; } \n \t3 } catch ( exception ex ) { \n <ect>
\t5 if ( handler != null ) { \n \t6 try { \n \t7 handler . on <identifiersep> response ( this , new response ( ) ) ; \n \t6 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 final static <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new static <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 final <identifier> <identifiersep> provider <identifiersep> key <identifiersep> info <identifiersep> <identifier> <identifiersep> <identifier> key <identifiersep> info <identifiersep> <identifier> = new <identifier> <identifiersep> provider <identifiersep> key <identifiersep> info <identifiersep> <identifier> <identifiersep> <identifier> ( key <identifiersep> info <identifiersep> provider <identifiersep> list ) ; \n \t2 final <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , key <identifiersep> info <identifiersep> <identifier> ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 <identifier> = <identifier> . get <identifiersep> <identifier> ( ) [ 0 ] ; \n \t5 this . <identifier> = ( <identifier> <identifiersep> context <identifiersep> manager ) <identifier> . new <identifiersep> instance ( this . <identifier> ) ; \n \t4 } catch ( exception e ) { \n \t5 <comment> \n <ect>
\t2 if ( ! <identifier> <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> a ) ) { \n \t3 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> a ) ; \n \t3 return false ; } \n \t2 if ( ! <identifier> <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t2 if ( event != null ) { \n \t3 api <identifiersep> message = event . get <identifiersep> api <identifiersep> message ( ) ; \n \t3 api <identifiersep> code = integer . parse <identifiersep> int ( api <identifiersep> message . get <identifiersep> api <identifiersep> code ( ) ) ; \n \t3 <identifier> = api <identifiersep> message . get <identifiersep> api <identifiersep> name ( ) ; \n <ect>
\t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } \n \t3 if ( policy . get <identifiersep> <identifier> ( ) < vm <identifiersep> group <identifiersep> vo . get <identifiersep> <identifier> ( ) ) { \n \t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } } \n \t2 policy = check <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( policy , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 if ( task . get <identifiersep> state ( ) . is <identifiersep> <identifier> <identifiersep> state ( ) ) { \n \t4 remove <identifiersep> from <identifiersep> queue ( task ) ; \n \t4 log . warn ( <string_literal> , task . get <identifiersep> job <identifiersep> key ( ) ) ; \n \t3 } else if ( task . get <identifiersep> state ( ) == job <identifiersep> task <identifiersep> state . <identifier> ) { \n <ect>
\t7 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n \t8 log . info ( log . <identifier> <identifiersep> <identifier> , <string_literal> , i , to <identifiersep> delete ) ; \n \t8 log . info ( log . <identifier> <identifiersep> <identifier> , <string_literal> ) ; \n \t8 for ( <identifier> p : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n <ect>
\t3 log <identifiersep> log . warn ( <string_literal> , e ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n \t3 log <identifiersep> log . warn ( <string_literal> , e ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 current <identifiersep> content . set <identifiersep> node <identifiersep> value ( node <identifiersep> field <identifiersep> value . to <identifiersep> string ( ) ) ; } } } \n \t3 text . <identifier> ( output . get <identifiersep> file <identifiersep> on <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 text . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 assert <identifiersep> equals ( <identifier> , <identifier> . size ( ) ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> p = <identifier> <identifiersep> server . query <identifiersep> <identifier> ( on <identifiersep> p , null ) ; \n \t2 assert <identifiersep> equals ( <number_literal> , <identifier> <identifiersep> p . size ( ) ) ; \n <ect>
\t7 try { \n \t8 last <identifiersep> failed = ! query <identifiersep> time ( <identifier> . to <identifiersep> array ( new string [ <identifier> . size ( ) ] ) , short <identifiersep> timeout , <identifier> <identifiersep> i <identifiersep> <identifier> ) ; \n \t7 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n \t8 if ( ! last <identifiersep> failed && <identifier> <identifiersep> log != null && <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t3 @ <identifier> \n \t3 public void <identifier> ( ) { \n \t4 try { \n \t5 if ( ! <identifier> <identifiersep> directory . exists ( ) ) { \n <ect>
\t5 <comment> \n \t5 synchronized ( <identifier> <identifiersep> <identifier> ) { \n \t6 <identifier> = <identifier> <identifiersep> <identifier> ( dir ) ; } \n \t4 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t6 <identifier> ++ ; \n \t6 if ( entry . key ( ) instanceof grid <identifiersep> cache <identifiersep> set <identifiersep> item <identifiersep> key ) { \n \t7 grid <identifiersep> cache <identifiersep> set <identifiersep> item <identifiersep> key set <identifiersep> item = ( grid <identifiersep> cache <identifiersep> set <identifiersep> item <identifiersep> key ) entry . key ( ) ; \n \t7 if ( set <identifiersep> <identifier> . add ( set <identifiersep> item . set <identifiersep> id ( ) ) ) \n <ect>
\t8 <identifier> = self . <identifier> . id , \n \t8 <identifier> = <identifier> , \n \t8 <identifier> = <identifier> . id \n \t8 ) \n <ect>
\t3 for ( class < ? > <identifier> <identifiersep> type : get <identifiersep> <identifier> ( ) ) \n \t3 { \n \t4 if ( <identifier> <identifiersep> type . is <identifiersep> <identifier> <identifiersep> from ( object <identifiersep> type ) ) \n \t4 { \n <ect>
\t2 if ( command == on <identifiersep> <identifier> <identifiersep> type . on ) { \n \t3 <identifier> <identifiersep> map < integer , integer > <identifier> = new <identifier> <identifiersep> map < integer , integer > ( ) ; \n \t3 <identifier> . put ( <identifier> , <identifier> <identifiersep> on ) ; \n \t3 <identifier> . put ( item . get <identifiersep> name ( ) , <identifier> ) ; \n <ect>
\t4 response . set <identifiersep> status <identifiersep> code ( http <identifiersep> status ) ; } } \n \t2 return response . set <identifiersep> <identifier> ( ) ; } \n \t1 private <identifier> < void > service <identifiersep> <identifier> <identifiersep> response ( server <identifiersep> web <identifiersep> exchange exchange ) { \n <ect>
\t2 <identifier> <identifiersep> network <identifiersep> model <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> network <identifiersep> model ( network , <identifier> . <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) , <string_literal> , <identifier> <identifiersep> type . <identifier> ) ; \n \t2 db . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . add ( <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> network <identifiersep> model <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> network <identifiersep> model ( network , <identifier> . <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) , <string_literal> , <identifier> <identifiersep> type . <identifier> ) ; \n \t2 db . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . add ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 <comment> \n \t3 throw new io <identifiersep> exception ( <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> from ( <identifier> ) ; \n \t3 long end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { \n \t4 if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { \n <ect>
\t1 @ <identifier> \n \t1 protected string get <identifiersep> <identifier> <identifiersep> type <identifiersep> key ( native <identifiersep> web <identifiersep> request web <identifiersep> request ) { \n \t2 http <identifiersep> <identifier> <identifiersep> request request = web <identifiersep> request . get <identifiersep> native <identifiersep> request ( http <identifiersep> <identifier> <identifiersep> request . class ) ; \n \t2 if ( request == null ) { \n <ect>
\t2 <identifier> <identifiersep> vm <identifiersep> dao . load <identifiersep> <identifier> ( user <identifiersep> vm ) ; \n \t2 vm <identifiersep> template <identifiersep> vo template = <identifier> <identifiersep> template <identifiersep> dao . find <identifiersep> by <identifiersep> id <identifiersep> <identifier> <identifiersep> <identifier> ( user <identifiersep> vm . get <identifiersep> template <identifiersep> id ( ) ) ; \n \t2 <comment> \n \t2 if ( user <identifiersep> vm . get <identifiersep> state ( ) == state . error || user <identifiersep> vm . get <identifiersep> state ( ) == state . <identifier> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n \t4 <identifier> <identifiersep> log . warn ( <string_literal> + ( <identifier> - <identifier> ) + <string_literal> ) ; \n \t2 } else { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 template = builder . to <identifiersep> template ( ) ; \n \t3 assert . assert <identifiersep> equals ( error <identifiersep> msg , template , <string_literal> ) ; } \n \t2 <comment> \n \t2 { \n <ect>
\t4 <comment> \n \t4 string <identifier> = <identifier> . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; \n \t4 if ( <identifier> == null && type == <identifier> <identifiersep> type . <identifier> ) { \n \t5 <comment> \n <ect>
\t2 if ( ( <identifier> <identifiersep> vm <identifiersep> map <identifiersep> <identifier> != null ) && ( <identifier> <identifiersep> vm <identifiersep> map <identifiersep> <identifier> . size ( ) > 0 ) ) { \n \t3 for ( load <identifiersep> <identifier> <identifiersep> vm <identifiersep> map <identifiersep> vo <identifier> <identifiersep> vm <identifiersep> map <identifiersep> vo : <identifier> <identifiersep> vm <identifiersep> map <identifiersep> <identifier> ) { \n \t4 long instance <identifiersep> id = <identifier> <identifiersep> vm <identifiersep> map <identifiersep> vo . get <identifiersep> instance <identifiersep> id ( ) ; \n \t4 if ( instance <identifiersep> id == vm <identifiersep> id ) { \n <ect>
\t2 return <identifier> <identifiersep> dir ( get <identifiersep> file ( <string_literal> ) ) ; } \n \t1 public file <identifier> <identifiersep> dir ( file file ) { \n \t2 if ( ! file . exists ( ) ) { \n \t3 if ( file . <identifier> ( ) ) { \n <ect>
\t6 return ; } \n \t5 <identifier> . <identifier> ( ) ; } \n \t4 catch ( throwable t ) \n \t4 { \n <ect>
\t2 if ( <identifier> <identifiersep> id ) { \n \t3 try { \n \t4 <identifier> . set <identifiersep> bytes ( <identifier> , id . get <identifiersep> bytes ( <string_literal> ) ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t1 public void log <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t3 try { \n \t4 <identifier> <identifiersep> socket <identifiersep> manager <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . write ( this ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 private list < i <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao > attribute <identifiersep> <identifier> = new array <identifiersep> list < > ( ) ; \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> attribute <identifiersep> <identifier> ( final i <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao <identifier> ) { \n \t2 final string name = <identifier> <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ? <identifier> <identifiersep> utils . get <identifiersep> target <identifiersep> class ( <identifier> ) . get <identifiersep> <identifier> <identifiersep> name ( ) : <identifier> . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ; \n <ect>
\t5 int <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> next <identifiersep> <identifier> [ 0 ] ) ; \n \t5 if ( <identifier> . log . should <identifiersep> log ( log . debug ) ) \n \t6 <identifier> . log . debug ( <string_literal> + <identifier> + <string_literal> ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> = <identifier> <identifiersep> utils . new <identifiersep> instance ( <identifier> <identifiersep> class , conf ) ; } \n \t2 metadata metadata = null ; \n \t2 string <identifier> = conf . get ( <identifier> <identifiersep> <identifier> <identifiersep> conf , default <identifiersep> <identifier> ) ; \n \t2 path file = get <identifiersep> default <identifiersep> <identifier> <identifiersep> file ( job , <identifier> . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ? null : <identifier> ) ; \n <ect>
\t1 try { \n \t1 final string json <identifiersep> <identifier> = <identifier> . write <identifiersep> value <identifiersep> as <identifiersep> string ( event ) ; \n \t1 return new string ( <identifier> . get <identifiersep> <identifier> ( ) . <identifier> ( json <identifiersep> <identifier> . get <identifiersep> bytes ( ) ) ) ; \n \t1 } catch ( final io <identifiersep> exception ex ) { \n <ect>
\t4 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; } } \n \t2 file <identifier> <identifiersep> <identifier> = new file ( <identifier> <identifiersep> <identifier> , id + <string_literal> ) ; \n \t2 boolean <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . delete ( ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 } catch ( throwable e ) { \n \t5 if ( e instanceof <identifier> <identifiersep> <identifier> <identifiersep> exception ) \n \t6 e = ( ( <identifier> <identifiersep> <identifier> <identifiersep> exception ) e ) . <identifier> <identifiersep> exception ( ) ; \n \t5 log . warn ( <string_literal> , e ) ; \n <ect>
\t2 set < network > all <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> = <identifier> <identifiersep> client . get <identifiersep> network <identifiersep> api ( ) . list <identifiersep> <identifier> ( \n \t3 list <identifiersep> <identifier> <identifiersep> options . builder . <identifier> <identifiersep> id ( template . get <identifiersep> <identifier> <identifiersep> id ( ) ) . is <identifiersep> system ( false ) ) ; \n \t2 for ( network <identifier> : all <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ) { \n \t3 if ( <identifier> . get <identifiersep> name ( ) . equals ( <identifier> + <string_literal> ) ) { \n <ect>
\t1 private list < metadata <identifiersep> <identifier> > load <identifiersep> metadata <identifiersep> from <identifiersep> resource ( final metadata <identifiersep> filter metadata <identifiersep> filter , final resource resource , final string entity <identifiersep> id ) { \n \t2 logger . debug ( <string_literal> , resource . get <identifiersep> <identifier> ( ) ) ; \n \t2 try ( input <identifiersep> stream in = get <identifiersep> resource <identifiersep> input <identifiersep> stream ( resource , entity <identifiersep> id ) ) { \n \t3 if ( in . <identifier> ( ) > 0 && in . <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 final property <identifiersep> map properties = property <identifiersep> map . <identifier> <identifiersep> type <identifiersep> to <identifiersep> java <identifiersep> type ( security <identifiersep> context , <identifier> <identifiersep> type , <identifier> <identifiersep> <identifier> <identifiersep> data . get <identifiersep> properties ( ) ) ; \n \t5 return <identifier> . create ( target <identifiersep> start <identifiersep> node , target <identifiersep> end <identifiersep> node , <identifier> <identifiersep> type , properties ) ; } \n \t3 } else { \n \t4 logger . warn ( <string_literal> , new object [ ] { target <identifiersep> start <identifiersep> node , target <identifiersep> end <identifiersep> node } ) ; } } \n <ect>
\t1 while ( client <identifiersep> service . is <identifiersep> <identifier> ( ) ) { \n \t1 <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; } \n \t1 log . info ( <string_literal> ) ; \n \t1 <identifier> . shutdown ( ) ; \n <ect>
\t4 logger . warn ( \n \t6 <string_literal> + <identifier> <identifiersep> type \n \t8 + <string_literal> + <identifier> <identifiersep> function + <string_literal> + data + <string_literal> , \n \t6 <identifier> ) ; } \n <ect>
\t3 if ( should <identifiersep> ignore <identifiersep> bean ( a <identifiersep> class ) ) { \n \t4 logger . debug ( <string_literal> , a <identifiersep> class ) ; \n \t4 continue ; } \n \t3 if ( ! is <identifiersep> <identifier> <identifiersep> class ( a <identifiersep> class ) ) { \n <ect>
<number_literal> final <identifier> <identifiersep> name default <identifiersep> element <identifiersep> name ) { \n \t2 if ( attribute <identifiersep> value == null ) { \n \t3 logger . debug ( <string_literal> , attribute <identifiersep> name ) ; \n \t3 return ; } \n <ect>
\t3 string type <identifiersep> list = <identifier> <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> property ( <identifier> + <string_literal> ) ; <comment> \n \t3 if ( type <identifiersep> list != null ) { \n \t4 string [ ] <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> utils . <identifier> ( type <identifiersep> list , <string_literal> , true ) ; \n \t4 for ( final string type : <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> context . message <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( message <identifiersep> id ) ; } \n \t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> failure ( long message <identifiersep> id , string status ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t6 <identifier> <identifiersep> vm <identifiersep> data <identifiersep> server . handle <identifiersep> vm <identifiersep> <identifier> ( cmd . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } } \n \t3 state = state . <identifier> ; \n \t3 return new start <identifiersep> answer ( cmd ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 <identifier> . close ( ) ; \n \t4 } catch ( runtime <identifiersep> exception e ) { \n \t5 <comment> \n \t5 <comment> \n <ect>
\t3 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> . get <identifiersep> <identifier> <identifiersep> element ( ) . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 return <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception e ) { \n <ect>
\t7 <identifier> . state = <identifier> . state . <identifier> ; } \n \t6 if ( <identifier> . state == <identifier> . state . <identifier> ) { \n \t7 s <identifiersep> logger . info ( <string_literal> + info . get <identifiersep> name ( ) ) ; \n \t7 if ( ! info . instance . <identifier> ( info . name , info . <identifier> ) ) { \n <ect>
\t2 version <identifiersep> dao <identifiersep> <identifier> dao = <identifier> <identifiersep> <identifier> . <identifier> ( version <identifiersep> dao <identifiersep> <identifier> . class ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n \t2 string version = dao . get <identifiersep> current <identifiersep> version ( ) ; \n \t2 if ( ! version . equals ( <string_literal> ) ) { \n <ect>
\t2 log . info ( <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id + <string_literal> ) ; \n \t2 storage <identifiersep> resource = connection <identifiersep> manager . <identifier> <identifiersep> target ( <identifier> , <identifier> ) ; \n \t2 storage <identifiersep> resource . set <identifiersep> id ( snapshot <identifiersep> id ) ; \n \t2 } catch ( exception conn <identifiersep> ex ) { \n <ect>
\t2 return c ; } \n \t1 @ <identifier> \n \t1 public void do <identifiersep> shutdown ( ) { \n \t2 if ( ! <identifier> <identifiersep> file <identifiersep> find <identifiersep> map . is <identifiersep> empty ( ) ) { \n <ect>
\t5 value = <identifier> <identifiersep> properties . get <identifiersep> property ( key ) ; \n \t5 out . write ( string . format ( <string_literal> <identifier> \\ <string_literal> , key , value ) ) ; out . new <identifiersep> line ( ) ; } } \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 assert ( false ) ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 private final void log <identifiersep> update ( int <identifier> <identifiersep> index , object x ) throws sql <identifiersep> exception { \n <ect>
\t3 if ( <identifier> <identifiersep> v <identifiersep> <identifier> . size ( ) > 1 ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + user <identifiersep> id + <string_literal> + event . get <identifiersep> account <identifiersep> id ( ) + <string_literal> ) ; } \n \t3 for ( <identifier> <identifiersep> <identifier> <identifiersep> user <identifiersep> vo <identifier> <identifiersep> vo : <identifier> <identifiersep> v <identifiersep> <identifier> ) { \n <ect>
<comment> \n <ect>
\t3 string <identifiersep> builder s <identifiersep> <identifier> = new string <identifiersep> builder ( ) ; \n \t3 s <identifiersep> <identifier> . <identifier> ( <identifier> ) . <identifier> ( <string_literal> ) . <identifier> ( <identifier> ) . <identifier> ( <string_literal> ) . <identifier> ( <identifier> ) . <identifier> ( <string_literal> ) . <identifier> ( <identifier> <identifiersep> <identifier> ) . <identifier> ( <string_literal> ) . <identifier> ( <identifier> ) . <identifier> ( <string_literal> ) . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 return s <identifiersep> <identifier> . to <identifiersep> string ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 node . set <identifiersep> text <identifiersep> content ( node . get <identifiersep> text <identifiersep> content ( ) . <identifier> ( <identifier> , <identifier> ) ) ; } \n \t1 public static void remove <identifiersep> node <identifiersep> by <identifiersep> attribute <identifiersep> value ( <identifier> <identifier> , string <identifier> <identifiersep> <identifier> , string <identifier> <identifiersep> name , string attribute <identifiersep> name , string value ) { \n \t2 node <identifiersep> list <identifier> <identifiersep> nodes = <identifier> . get <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> nodes . get <identifiersep> length ( ) != 1 ) { \n <ect>
\t4 <identifier> <identifiersep> vm <identifiersep> instance <identifiersep> vo <identifier> <identifiersep> instance = \n \t5 new <identifier> <identifiersep> vm <identifiersep> instance <identifiersep> vo ( r <identifiersep> <identifier> <identifiersep> type , r <identifiersep> <identifier> <identifiersep> id , r <identifiersep> account <identifiersep> id , r <identifiersep> vm <identifiersep> id , r <identifiersep> vm <identifiersep> name , r <identifiersep> <identifier> <identifiersep> id , r <identifiersep> t <identifiersep> id , r <identifiersep> <identifier> <identifiersep> <identifier> , r <identifiersep> <identifier> <identifiersep> <identifier> , r <identifiersep> <identifier> , <identifier> <identifiersep> type , instance <identifiersep> start <identifiersep> date , instance <identifiersep> end <identifiersep> date ) ; \n \t4 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> instance ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t2 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> . value ( ) ) ; \n \t2 field <identifiersep> <identifier> . add ( field , field . get <identifiersep> type ( ) , <identifier> <identifiersep> <identifier> . value ( ) ) ; } \n \t2 else \n \t2 { \n <ect>
\t3 <identifier> . get <identifiersep> attributes ( ) . key <identifiersep> set ( ) . stream ( ) . for <identifiersep> <identifier> ( <identifier> <identifiersep> name - > { \n \t4 if ( authentication <identifiersep> attributes . contains <identifiersep> key ( <identifier> <identifiersep> name ) ) { \n \t5 logger . debug ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t5 final object <identifier> <identifiersep> value = authentication <identifiersep> attributes . remove ( <identifier> <identifiersep> name ) ; \n <ect>
\t3 log . debug ( <string_literal> + <identifier> . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) ) ; \n \t3 for ( int i = 0 ; i < <identifier> . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) ; i ++ ) { \n \t4 log . debug ( <string_literal> + i + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) . get ( i ) . get <identifiersep> <identifier> <identifiersep> location ( ) ) ; \n \t4 log . debug ( <string_literal> + i + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) . get ( i ) . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
<number_literal> <comment> \n <number_literal> <comment> \n <number_literal> <comment> \n \t3 } else { \n <ect>
\t2 <identifier> <identifiersep> value <identifiersep> <identifier> <identifier> <identifiersep> value <identifiersep> enum = <identifier> <identifiersep> value <identifiersep> <identifier> . value <identifiersep> of ( class <identifiersep> <identifier> ) ; \n \t2 return <identifier> . to <identifiersep> java <identifiersep> object ( <identifier> <identifiersep> value . to <identifiersep> string ( ) , <identifier> <identifiersep> value <identifiersep> enum . get <identifiersep> value <identifiersep> class ( ) ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n \t2 value <identifiersep> factory <identifiersep> logger . warn ( <string_literal> , class <identifiersep> <identifier> ) ; \n <ect>
\t4 if ( base != null ) { \n \t5 boolean new <identifiersep> <identifier> <identifiersep> <identifier> = base . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t5 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get ( ) ; \n \t5 if ( new <identifiersep> <identifier> <identifiersep> <identifier> != <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 try { \n \t3 logger . debug ( <string_literal> , <identifier> ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t3 final set < java . security . principal > <identifier> = <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ; \n <ect>
\t3 string <identifier> <identifiersep> path = ( string ) <identifier> . <identifier> [ 1 ] ; \n \t3 string <identifier> <identifiersep> path = ( string ) <identifier> . <identifier> [ 0 ] ; \n \t3 if ( <identifier> <identifiersep> <identifier> . exists ( new path ( <identifier> <identifiersep> path ) ) && ! <identifier> <identifiersep> <identifier> . exists ( new path ( <identifier> <identifiersep> path ) ) ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> path ( <identifier> <identifiersep> path , <identifier> <identifiersep> path ) ; \n <ect>
\t2 <identifier> <identifiersep> type <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> type <identifiersep> <identifier> ( <identifier> <identifiersep> type , <identifier> <identifiersep> type , new attribute <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> type , <identifier> <identifiersep> type , found <identifiersep> type ) ; \n \t2 add ( <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifier> = format . get <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> <identifiersep> data <identifier> <identifiersep> data = <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> data ( ) ; \n \t3 <identifier> <identifier> = <identifier> . read ( <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> data ( ) ) ; \n \t3 session . set <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> data ) ) ; \n <ect>
\t3 if ( message <identifiersep> format != null ) { \n \t4 message . set <identifiersep> string <identifiersep> property ( <string_literal> , message <identifiersep> format ) ; } \n \t3 message <identifiersep> <identifier> = session . create <identifiersep> <identifier> ( destination ) ; \n \t3 message <identifiersep> <identifier> . send ( message ) ; \n <ect>
\t2 long time <identifiersep> find <identifiersep> <identifier> <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 float <identifier> <identifiersep> time <identifiersep> <identifier> = ( time <identifiersep> find <identifiersep> <identifier> <identifiersep> <identifier> - start ) / <identifier> ; \n \t2 logger . info ( <string_literal> + <identifier> <identifiersep> time <identifiersep> <identifier> + <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 } else { \n \t3 s <identifiersep> logger . info ( <string_literal> ) ; } \n \t2 if ( <identifier> <identifiersep> list . size ( ) > 0 ) { \n <ect>
\t3 string target <identifiersep> result <identifiersep> string = <identifier> <identifiersep> json ( source <identifiersep> string , target <identifiersep> string , \n \t5 path <identifiersep> string , <identifier> <identifiersep> id ) ; \n \t3 return new text ( target <identifiersep> result <identifiersep> string ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 <comment> \n \t1 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> size = try <identifiersep> <identifier> ( max <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) , ( num <identifiersep> <identifier> ) ) ; \n \t1 if ( <identifier> <identifiersep> size . <identifier> <identifiersep> to ( <identifier> <identifiersep> <identifier> ) < 0 ) { \n \t1 <identifier> <identifiersep> size = <identifier> <identifiersep> <identifier> ; \n <ect>
\t4 if ( <identifier> . equals ( <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> ( ) ) ) \n \t5 continue ; \n \t4 int <identifier> = <identifier> . index <identifiersep> of ( integer . value <identifiersep> of ( i ) ) ; \n \t4 if ( <identifier> < 0 ) { \n <ect>
\t4 . set <identifiersep> <identifier> <identifiersep> type ( <identifier> <identifiersep> type . query <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t4 . execute ( ) . action <identifiersep> get ( ) ; \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . length > 0 ) { \n \t3 for ( <identifier> <identifiersep> <identifier> <identifiersep> failure <identifier> : <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 throw new <identifier> <identifiersep> operation <identifiersep> exception ( <string_literal> + operation <identifiersep> mode + <string_literal> ) ; } \n \t2 if ( ! is <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> set ( false , true ) ) \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; \n <ect>
\t2 if ( is <identifiersep> <identifier> ) { \n \t3 <identifier> <identifier> = <identifier> . get ( <identifier> . size ( ) - 1 ) ; \n \t3 if ( ! <identifier> <identifiersep> as <identifiersep> <identifier> ( <identifier> ) ) { \n \t4 if ( log . should <identifiersep> warn ( ) ) \n <ect>
\t1 @ <identifier> \n \t1 protected event do <identifiersep> execute ( final request <identifiersep> context request <identifiersep> context ) { \n \t2 final string token = request <identifiersep> context . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> string ( <string_literal> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( token ) ) { \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> <identifiersep> <identifier> ) ) { \n \t3 throw new account <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( user <identifiersep> <identifier> . get <identifiersep> password ( ) ) ) { \n \t3 throw new failed <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t2 assert . assert <identifiersep> true ( <identifier> <identifiersep> <identifier> . is <identifiersep> first <identifiersep> <identifier> ( <identifier> <identifiersep> data <identifiersep> target . name ( ) ) ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> target ( ) throws exception { \n <ect>
\t6 if ( <identifier> <identifiersep> resource != null ) { \n \t7 send <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t5 } catch ( throwable <identifier> ) { \n \t6 <comment> \n <ect>
\t2 <comment> \n \t2 <identifier> . <identifier> ( <string_literal> ) ; \n \t2 <comment> \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n <ect>
\t1 destination <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> object <identifiersep> <identifier> ( \n \t2 <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , null , ( byte ) 0 , null ) ; \n \t1 destination <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> info ( source <identifiersep> <identifier> . size ( ) , 0 ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void close ( ) throws io <identifiersep> exception { \n \t1 <comment> \n \t1 public void <identifier> <identifiersep> data ( ) { \n <ect>
\t4 logger . error ( <string_literal> , e ) ; } } \n \t1 } ; \n \t1 @ <identifier> \n \t1 public void run ( ) { \n <ect>
\t4 } , null ) ; \n \t3 synchronized ( result ) { \n \t4 if ( result [ 0 ] == integer . max <identifiersep> value ) { \n \t5 result . wait ( <number_literal> ) ; } } \n <ect>
\t1 logger . info ( <string_literal> , file <identifiersep> path ) ; \n \t1 <identifier> <identifiersep> data <identifiersep> input <identifiersep> stream stream = <identifier> . <identifier> ( file <identifiersep> path ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( stream ) ) ; \n \t1 string line = <identifier> . read <identifiersep> line ( ) ; \n <ect>
\t9 } ) ; \n \t6 } else { \n \t7 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> error <identifiersep> <identifier> ( user <identifiersep> <identifier> <identifiersep> context . get <identifiersep> message ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> msg <identifiersep> for <identifiersep> user ) ) ; } \n \t5 } else { \n <ect>
\t1 try { \n \t1 if ( ! <identifier> <identifiersep> file <identifiersep> <identifier> ( file <identifiersep> path , target ) ) { \n \t2 return ; } \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . get <identifiersep> in ( ) . set <identifiersep> <identifier> ( false ) ; } \n \t3 if ( <identifier> <identifiersep> service != null ) { \n \t4 <identifier> <identifiersep> service . <identifier> ( new <identifier> < exchange > ( ) { \n \t5 public exchange <identifier> ( ) throws exception { \n <ect>
\t2 catch ( empty <identifiersep> result <identifiersep> data <identifiersep> access <identifiersep> exception e ) { \n \t4 log . info ( <string_literal> + token ) ; } } \n \t2 catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t2 } catch ( key <identifiersep> store <identifiersep> exception e ) { \n <ect>
\t3 break ; } } } } \n \t1 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t1 <identifier> <identifiersep> <identifier> = num <identifiersep> <identifier> <identifiersep> value <identifiersep> <identifier> <identifiersep> factory \n \t2 . get <identifiersep> empty <identifiersep> num <identifiersep> <identifier> <identifiersep> value <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n <ect>
\t2 <comment> \n \t2 for ( string dir : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 string <identifier> = dir + file . <identifier> + default <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t3 if ( new file ( <identifier> ) . exists ( ) ) { \n <ect>
\t1 list < volume <identifiersep> info > <identifier> <identifiersep> to <identifiersep> be <identifiersep> <identifier> = null ; \n \t1 try { \n \t2 <identifier> <identifiersep> to <identifiersep> be <identifiersep> <identifier> = <identifier> . find <identifiersep> all ( <identifier> <identifiersep> volume ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> config != null ) { \n \t3 http <identifiersep> <identifier> <identifiersep> config config = parse <identifiersep> <identifier> <identifiersep> config ( item , <identifier> <identifiersep> config ) ; \n \t3 add <identifiersep> <identifier> <identifiersep> config ( item , config ) ; \n \t2 } else { \n <ect>
\t7 <identifier> <identifiersep> lock . <identifier> ( ) ; } } \n \t4 } finally { \n \t5 <identifier> <identifiersep> lock . <identifier> <identifiersep> <identifier> ( ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t6 <identifier> <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> service ( ) \n \t6 , <number_literal> , <identifier> <identifiersep> text ) ; } \n \t3 catch ( <identifier> <identifiersep> argument <identifiersep> exception | parse <identifiersep> exception e ) \n \t3 { \n <ect>
\t4 if ( <identifier> != null ) { \n \t5 <identifier> <identifiersep> message . set <identifiersep> header ( exchange . content <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . java <identifiersep> <identifier> ( <identifier> ) ) ; } } \n \t2 } else { \n \t3 <comment> \n <ect>
\t1 if ( bytes == null || bytes . length == 0 || bytes . length > max <identifiersep> <identifier> <identifiersep> size ) { \n \t2 throw new io <identifiersep> exception ( <string_literal> + <identifier> ) ; } \n \t1 <identifier> <identifiersep> queue . add ( bytes ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void on <identifiersep> message ( message message ) { \n \t2 if ( ! queue . <identifier> ( message ) ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void start ( <identifier> <identifiersep> context <identifier> ) throws exception { \n <ect>
\t4 <identifier> = <identifier> . find ( <identifier> <identifiersep> id , <identifier> <identifiersep> id , cluster <identifiersep> id , uri , <identifier> , password , host <identifiersep> <identifier> ) ; \n \t3 } catch ( final <identifier> <identifiersep> exception e ) { \n \t4 throw e ; \n \t3 } catch ( final exception e ) { \n <ect>
\t6 this . logger . debug ( message <identifiersep> format . format ( <string_literal> , \n \t8 header <identifiersep> name , <identifier> ) ) ; } \n \t5 return true ; } } } \n <ect>
\t4 + <string_literal> + service . get <identifiersep> metadata <identifiersep> location ( ) ) ; } \n \t2 metadata <identifiersep> <identifier> . set <identifiersep> id ( <identifier> <identifiersep> metadata <identifiersep> <identifier> . class . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 metadata <identifiersep> <identifier> . set <identifiersep> <identifier> ( metadata <identifiersep> <identifier> ) ; \n \t2 metadata <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t10 abstract <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> request <identifiersep> <identifier> ) { \n \t2 <comment> \n \t2 synchronized ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> request <identifiersep> <identifier> ) { \n \t3 time <identifiersep> value <identifier> = <identifier> <identifiersep> wait <identifiersep> time ( last <identifiersep> <identifier> <identifiersep> start <identifiersep> time , time <identifiersep> value <identifiersep> <identifier> ( system . <identifier> <identifiersep> time ( ) ) , last <identifiersep> <identifier> <identifiersep> size ) ; \n <ect>
\t8 string msg = <string_literal> + volume . get <identifiersep> <identifier> ( ) + <string_literal> ; \n \t8 volume <identifiersep> store . set <identifiersep> error <identifiersep> string ( msg ) ; \n \t8 s <identifiersep> logger . info ( msg ) ; \n \t8 if ( volume . get <identifiersep> state ( ) == state . not <identifiersep> <identifier> || volume . get <identifiersep> state ( ) == state . <identifier> <identifiersep> in <identifiersep> <identifier> ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> max <identifiersep> <identifier> ( 1 ) ; \n \t3 <identifier> = <identifier> <identifiersep> <identifier> . run <identifiersep> query ( object <identifiersep> cache ) ; \n \t3 if ( <identifier> . first ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> != null && <identifier> . is <identifiersep> <identifier> ( ) ) \n \t4 process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 else \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <comment> \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> != null ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t3 return true ; } \n \t2 return false ; } \n \t1 public boolean add <identifiersep> <identifier> ( node source , node target , default <identifiersep> <identifier> <identifier> ) { \n <ect>
\t2 if ( ! property <identifiersep> type . equals ( max . get <identifiersep> class ( ) ) ) { \n \t3 throw new <identifier> <identifiersep> property <identifiersep> exception ( max <identifiersep> <identifier> , property <identifiersep> type ) ; } \n \t2 <identifier> r = get <identifiersep> <identifier> ( ) ; \n \t2 if ( r != null ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t2 list < snapshot <identifiersep> info > snapshot <identifiersep> <identifier> = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> get <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> <identifier> ( <string_literal> ) . get ( ) . get <identifiersep> <identifier> ( ) ; \n \t2 assert <identifiersep> that ( snapshot <identifiersep> <identifier> . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( snapshot <identifiersep> <identifier> . get ( 0 ) . state ( ) , equal <identifiersep> to ( snapshot <identifiersep> state . success ) ) ; \n \t2 assert <identifiersep> that ( snapshot <identifiersep> <identifier> . get ( 0 ) . <identifier> <identifiersep> <identifier> ( ) . size ( ) , equal <identifiersep> to ( 0 ) ) ; \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t4 break ; } \n \t3 else \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> entry = <identifier> <identifiersep> <identifier> <identifiersep> entry ; } \n \t2 if ( <identifier> <identifiersep> entry == null ) { \n <ect>
\t1 @ <identifier> <identifiersep> read ( context = <string_literal> ) \n \t1 event < string > read <identifiersep> event ; \n \t1 private array <identifiersep> list < object > event <identifiersep> list = new array <identifiersep> list < object > ( ) ; \n \t1 static { \n <ect>
\t2 <comment> \n \t2 try ( output <identifiersep> stream <identifier> <identifiersep> out = new <identifier> <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( <identifier> ) ) ) { \n \t3 write ( <identifier> <identifiersep> out , <identifier> <identifiersep> <identifier> , type <identifiersep> <identifier> , <identifier> <identifiersep> total ) ; \n \t2 } catch ( io <identifiersep> exception ex ) \n <ect>
\t3 log . warn ( <string_literal> + file <identifiersep> status . get <identifiersep> path ( ) + <string_literal> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> + e . get <identifiersep> message ( ) ) ; } \n \t2 } else { \n <ect>
\t7 + <string_literal> \n \t7 + error <identifiersep> command + <string_literal> ) ; \n \t2 } else { \n \t3 <comment> \n <ect>
\t5 logger . info ( <string_literal> ) ; \n \t5 <identifier> . <identifier> ( <identifier> . system <identifiersep> <identifier> ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> store ( system <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) . <identifier> <identifiersep> <identifier> ( ) ; } \n \t4 catch ( exception e ) \n \t4 { \n <ect>
\t8 result [ i ] . <identifier> = integer . parse <identifiersep> int ( <identifier> [ <number_literal> ] ) ; } } \n \t6 <identifier> <identifiersep> <identifier> . add ( result ) ; \n \t6 break ; } \n \t5 default : \n <ect>
\t1 public void <identifier> <identifiersep> m <identifiersep> bean ( final object m <identifiersep> bean , final string m <identifiersep> bean <identifiersep> name ) { \n \t2 try { \n \t3 server . <identifier> <identifiersep> m <identifiersep> bean ( m <identifiersep> bean , new object <identifiersep> name ( m <identifiersep> bean <identifiersep> name ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 <string_literal> , new class [ ] { object . class } ) ; \n \t3 <identifier> <identifiersep> write <identifiersep> <identifier> <identifiersep> method . set <identifiersep> <identifier> ( true ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t4 if ( host . <identifier> <identifiersep> with ( <string_literal> ) && host . char <identifiersep> <identifier> ( host . length ( ) - 1 ) == ' ] ' ) { \n \t5 host = host . <identifier> ( 1 , host . length ( ) - 1 ) ; } \n \t4 url <identifiersep> port = url . get <identifiersep> port ( ) ; } \n \t2 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( p . name ) ) { \n \t5 http <identifiersep> <identifier> <identifiersep> client . send <identifiersep> <identifier> ( get <identifiersep> <identifier> <identifiersep> name ( ) , \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ( p . name ) , <string_literal> , string . value <identifiersep> of ( p . value ) ) ; } } \n \t3 catch ( exception e ) { \n <ect>
\t2 for ( thread t : <identifier> ) { \n \t3 try { \n \t4 t . <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 if ( msg <identifiersep> <identifier> . has <identifiersep> <identifier> ( ) ) { \n \t3 logger . error ( <string_literal> ) ; \n \t3 for ( <identifier> it = msg <identifiersep> <identifier> . get <identifiersep> error <identifiersep> <identifier> ( ) ; it . has <identifiersep> next ( ) ; ) { \n \t4 list <identifiersep> <identifier> . entry e = ( list <identifiersep> <identifier> . entry ) it . next ( ) ; \n <ect>
\t3 if ( remove <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 try { \n \t5 security . remove <identifiersep> provider ( <identifier> <identifiersep> <identifier> <identifiersep> provider . provider <identifiersep> name ) ; \n \t4 } catch ( security <identifiersep> exception ex ) { \n <ect>
\t7 <identifier> . add ( entry ) ; } \n \t5 } else { \n \t6 <comment> \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 <identifier> . remove <identifiersep> meta <identifiersep> class ( from <identifiersep> class ) ; } } \n \t2 else { \n \t3 <identifier> = ( <identifier> <identifiersep> meta <identifiersep> class ) <identifier> <identifiersep> meta <identifiersep> class ; \n <ect>
\t3 user user = ( user ) session . get <identifiersep> attribute ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> user <identifiersep> session <identifiersep> key ) ; \n \t3 if ( user != null ) { \n \t4 <identifier> <identifiersep> service service = ( <identifier> <identifiersep> service ) context . get <identifiersep> bean ( <string_literal> ) ; \n \t4 service . <identifier> ( user . get <identifiersep> name ( ) ) ; \n <ect>
\t2 <identifier> . write ( <identifier> ) ; \n \t2 <identifier> . write <identifiersep> bytes ( e . is <identifiersep> set <identifiersep> <identifier> <identifiersep> job <identifiersep> id ( ) ? e . get <identifiersep> <identifier> <identifiersep> job <identifiersep> id ( ) : no <identifiersep> <identifier> ) ; \n \t2 <identifier> . write ( <identifier> ) ; } } \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <identifier> ( ) ; \n \t2 assert <identifiersep> that ( client . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> size ( 0 ) . get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 client . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> close ( <string_literal> ) . get ( ) ; \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t5 end <identifiersep> result = false ; \n \t4 } else { \n \t5 <identifier> [ i ++ ] = null ; } \n \t3 } catch ( throwable e ) { \n <ect>
\t1 assert <identifiersep> not <identifiersep> null ( <string_literal> , <identifier> . get ( <string_literal> ) ) ; \n \t1 <comment> \n \t1 int num <identifiersep> <identifier> = <number_literal> ; \n \t1 logger . debug ( <string_literal> ) ; \n <ect>
\t3 self . command = command \n \t2 else : \n \t3 self . command = <identifier> ( <string_literal> ) \n \t2 if not self . command : \n <ect>
\t2 } else { \n \t3 try { \n \t4 this . volume = new <identifier> <identifiersep> <identifier> ( volume ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t1 if ( field <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) == <identifier> <identifiersep> type . <identifier> || \n \t2 field <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) == <identifier> <identifiersep> type . <identifier> ) { \n \t2 string value = get <identifiersep> <identifier> <identifiersep> value ( field <identifiersep> <identifier> ) ; \n \t2 if ( entity <identifiersep> <identifier> . contains ( value ) ) { \n <ect>
\t2 final index <identifiersep> routing <identifiersep> table index <identifiersep> <identifier> <identifiersep> routing <identifiersep> table = cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( index ) ; \n \t2 set < integer > <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> = new <identifier> <identifiersep> set < > ( ) ; \n \t2 for ( int i = 1 + <identifier> <identifiersep> int ( number <identifiersep> of <identifiersep> shards - 1 ) ; i > 0 ; i -- ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> . add ( <identifier> <identifiersep> int ( number <identifiersep> of <identifiersep> shards - 1 ) ) ; } \n <ect>
\t3 assert <identifiersep> that ( <identifier> <identifiersep> event ) . is <identifiersep> equal <identifiersep> to ( <identifier> <identifiersep> event ) ; } \n \t2 private void <identifier> <identifiersep> <identifier> <identifiersep> event ( event event ) { \n \t3 if ( <identifier> . get <identifiersep> count ( ) == 0 ) { \n \t4 <comment> \n <ect>
\t1 return filter . filter ( name , values ) ; } \n private void <identifier> <identifiersep> to <identifiersep> registered ( final <identifier> <identifiersep> <identifier> <identifiersep> group <identifiersep> metadata group , final list < string > instance <identifiersep> <identifier> ) { \n \t1 try { \n <ect>
\t6 <identifier> . add ( <identifier> <identifiersep> <identifier> + it . next ( ) ) ; } \n \t4 } catch ( exception e ) { \n \t5 logger . error ( <string_literal> , <identifier> , e ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t2 log . info ( <string_literal> ) ; } \n \t1 if ( ( http <identifiersep> server != null ) && http <identifiersep> server . is <identifiersep> <identifier> ( ) ) { \n \t2 try { \n \t2 http <identifiersep> server . stop ( ) ; \n <ect>
\t1 if ( stop <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> == null ) { \n \t2 log . warn ( <string_literal> ) } \n \t1 case job <identifiersep> status : current <identifiersep> job <identifiersep> status = > \n \t1 if ( stop <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> == null ) { \n <ect>
\t4 do { \n \t5 device <identifiersep> token = <identifier> <identifiersep> request . execute ( ) . parse <identifiersep> as ( device <identifiersep> token . class ) ; \n \t5 if ( device <identifiersep> token . access <identifiersep> token != null ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , \n \t5 <string_literal> , <identifier> <identifiersep> to <identifiersep> <identifier> ) ; \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 } catch ( interrupted <identifiersep> exception e ) { \n \t5 <comment> \n \t2 private void start <identifiersep> <identifier> ( ) { \n \t3 if ( this . thread != null && this . thread . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 logger . error ( this , <string_literal> + this + <string_literal> ) ; \n \t4 return false ; \n \t3 } else return false ; \n \t2 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 if ( get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . is <identifiersep> <identifier> ( <identifier> , null ) ) { \n \t4 <identifier> <identifiersep> object ( <identifier> ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 <identifier> <identifiersep> test = false ; \n \t4 string name = system . get <identifiersep> property ( <string_literal> ) ; \n \t4 string message = <identifier> . get <identifiersep> message ( ) ; \n <ect>
\t2 <identifier> . close ( ) ; \n \t2 <comment> \n \t2 remove <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 <identifier> <identifiersep> error <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> exception <identifiersep> handler ( ) ; \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> session <identifiersep> info session <identifiersep> info = m <identifiersep> session <identifiersep> manager . get <identifiersep> session <identifiersep> info ( <identifier> ) ; \n \t2 if ( session <identifiersep> info == null ) { \n <ect>
\t6 log . debug ( <string_literal> , <identifier> <identifiersep> class <identifiersep> name ) ; } \n \t5 class < ? > command <identifiersep> class = class . for <identifiersep> name ( <identifier> <identifiersep> class <identifiersep> name ) ; \n \t5 if ( ! <identifier> . is <identifiersep> abstract ( command <identifiersep> class . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 <comment> \n \t2 channel <identifiersep> <identifier> <identifier> = <identifier> . <identifier> ( ) ; \n \t2 <identifier> <identifiersep> handler <identifier> <identifiersep> handler = <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> handler != null ) { \n <ect>
{ \n \t1 if ( resource <identifiersep> model == null ) \n \t1 { \n \t1 return ; } \n <ect>
\t4 try { \n \t5 if ( in != null ) { \n \t6 in . close ( ) ; } \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 if ( url != null ) { \n \t3 try { \n \t4 <identifier> = <identifier> <identifiersep> io . read ( <identifier> <identifiersep> <identifier> . class . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( url ) ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n \t5 throw new user <identifiersep> exception . <identifier> <identifiersep> file ( <string_literal> + line ) ; } } \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> . size ( ) > 0 ) { \n <ect>
\t1 <identifier> <identifier> <identifiersep> <identifier> = new input <identifiersep> stream <identifiersep> <identifier> ( class <identifiersep> of [ log <identifiersep> <identifier> ] . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ) \n \t1 <identifier> <identifier> <identifiersep> text = <identifier> <identifiersep> <identifier> . <identifier> ( io <identifiersep> utils to <identifiersep> string <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) \n \t1 <identifier> <identifiersep> text . set <identifiersep> text ( <identifier> <identifiersep> text ) \n \t1 } catch { \n <ect>
\t5 logger . <identifier> ( <string_literal> , m . get <identifiersep> version ( ) ) ; } \n \t4 try { \n \t5 m . <identifier> <identifiersep> import ( session , <identifier> , <identifier> , <identifier> <identifiersep> user <identifiersep> <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 update . set <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> . <identifier> ( update ) ; \n \t2 db . <identifier> ( ) ; \n \t2 } catch ( final no <identifiersep> such <identifiersep> element <identifiersep> exception ex ) { \n <ect>
\t3 for ( <identifier> <identifiersep> manager <identifiersep> listener listener : <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> manager <identifiersep> listener . class ) ) { \n \t4 listener . start ( <identifier> <identifiersep> <identifier> <identifiersep> manager ) ; } \n \t3 context <identifiersep> class <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager <identifiersep> provider . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> manager ) ; \n \t3 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> manager . get <identifiersep> name ( ) ) ; } \n <ect>
\t3 url = server + <string_literal> + user <identifiersep> id + <string_literal> ; \n \t3 client = new http <identifiersep> client ( ) ; \n \t3 method = new get <identifiersep> method ( url ) ; \n \t3 response <identifiersep> code = client . execute <identifiersep> method ( method ) ; \n <ect>
\t4 if ( application <identifiersep> context . contains <identifiersep> bean ( <string_literal> ) ) { \n \t5 logger . debug ( <string_literal> ) ; \n \t5 <identifier> = application <identifiersep> context . get <identifiersep> bean ( <string_literal> , principal <identifiersep> attributes <identifiersep> <identifier> . class ) ; \n \t4 } else { \n <ect>
\t6 task . get <identifiersep> failure <identifiersep> <identifier> ( ) , \n \t6 <identifier> <identifiersep> snapshot , \n \t6 task . get <identifiersep> <identifier> <identifiersep> group ( ) . get <identifiersep> io <identifiersep> <identifier> <identifiersep> group ( ) . create <identifiersep> snapshot ( ) ) ) ; \n \t2 } else { \n <ect>
\t2 metadata <identifiersep> table <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( metadata <identifiersep> entry , key <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> end <identifiersep> <identifier> ( <identifier> ) , context , \n \t3 lock ) ; \n \t2 return new key <identifiersep> <identifier> ( metadata <identifiersep> entry , key <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> end <identifiersep> <identifier> ( <identifier> ) ) ; \n \t1 } else { \n <ect>
\t1 return ; \n \t1 } catch ( m <identifiersep> bean <identifiersep> exception e ) { \n \t1 <comment> \n \t1 <comment> \n <ect>
\t4 if ( target <identifiersep> source != null ) { \n \t5 try { \n \t6 target = target <identifiersep> source . get <identifiersep> target ( ) ; } \n \t5 catch ( exception e ) { \n <ect>
\t2 } catch ( exception from ) { \n \t3 try { \n \t3 <identifier> ( ) ; \n \t3 } catch ( exception <identifier> ) { \n <ect>
\t5 get <identifiersep> web <identifiersep> socket ( ) . send ( message <identifiersep> builder . status ( ) . code ( <number_literal> ) . message ( <string_literal> + name ) . data ( result <identifiersep> data ) . build ( ) , true ) ; \n \t4 } else { \n \t5 get <identifiersep> web <identifiersep> socket ( ) . send ( message <identifiersep> builder . status ( ) . code ( <number_literal> ) . message ( <string_literal> + name ) . data ( result <identifiersep> data ) . build ( ) , true ) ; } } \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t4 case <identifier> : \n \t5 logger . debug ( <string_literal> ) ; \n \t5 return null ; \n \t4 case throw <identifiersep> exception : \n <ect>
\t2 <comment> \n \t2 log . info ( <string_literal> ) ; \n \t2 file <identifier> <identifiersep> file = create <identifiersep> <identifier> ( item , null , false ) ; \n \t2 <comment> \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t3 <comment> \n \t3 return <identifier> ; } \n \t2 catch ( no <identifiersep> result <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 this . <identifier> = <identifier> . get <identifiersep> text ( ) ; \n \t2 this . <identifier> = <identifier> <identifiersep> utils . <identifier> ( this . <identifier> ) ; } \n \t1 public void write ( ) { \n \t2 if ( ! is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> <identifiersep> mode ( <identifier> ? <identifier> <identifiersep> mode . <identifier> : <identifier> <identifiersep> mode . <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . set <identifiersep> time <identifiersep> to <identifiersep> <identifier> ( msg <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> load ( ) ; \n \t3 <identifier> = true ; \n <ect>
\t2 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> file ( <identifier> <identifiersep> i <identifiersep> stream , <identifier> <identifiersep> o <identifiersep> stream , <identifier> , <identifier> <identifiersep> files ) ; \n \t2 file <identifiersep> input <identifiersep> stream <identifier> <identifiersep> result <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( <identifier> + <string_literal> ) ; \n \t2 <identifier> <identifiersep> ex <identifiersep> result <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( <identifier> + <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> ex <identifiersep> result <identifiersep> stream , <identifier> <identifiersep> result <identifiersep> stream ) ; \n <ect>
\t2 nodes = <identifier> <identifiersep> cluster ( ) . start <identifiersep> nodes ( num <identifiersep> nodes , \n \t3 <identifier> . builder ( ) . put ( index <identifiersep> <identifier> . <identifier> <identifiersep> max <identifiersep> <identifier> . get <identifiersep> key ( ) , <identifier> <identifiersep> int <identifiersep> <identifier> ( <number_literal> , <number_literal> ) ) . build ( ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 create <identifiersep> index ( index <identifiersep> name ) ; \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> state state = <identifier> . next ( ) ; \n \t4 if ( state . get <identifiersep> <identifier> ( ) > <number_literal> * max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time ) { \n \t5 <identifier> . remove ( ) ; \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t6 log . error ( \n \t7 <string_literal> <string_literal> \\ <string_literal> + \n \t8 <string_literal> ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t5 if ( <identifier> . get <identifiersep> name ( ) . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t6 template <identifiersep> <identifier> = <identifier> ; \n \t6 break ; } } \n \t4 if ( template <identifiersep> <identifier> == null ) { \n <ect>
\t2 log . info ( <string_literal> , get <identifiersep> number <identifiersep> of <identifiersep> <identifier> <identifiersep> files ( ) ) ; \n \t2 assert <identifiersep> true ( get <identifiersep> number <identifiersep> of <identifiersep> <identifier> <identifiersep> files ( ) > 1 ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t1 @ <identifier> \n \t1 final public void <identifier> ( <identifier> <identifier> ) \n \t1 { \n \t2 if ( <identifier> . get <identifiersep> id ( ) != id ) \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 if ( value instanceof function \n \t6 && ! name . equals ( <string_literal> ) <comment> \n \t6 && ! name . equals ( <string_literal> ) ) { \n \t5 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> function . class . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + name + <string_literal> ) ; \n <ect>
\t2 try { \n \t3 server <identifiersep> count = <identifier> . get <identifiersep> cluster <identifiersep> status ( ) . get <identifiersep> <identifier> ( ) . size ( ) ; \n \t3 log . debug ( <string_literal> , server <identifiersep> count ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 if ( <string_literal> . equals ( get <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ) ) { \n \t5 logger . info ( <string_literal> ) ; \n \t5 <identifier> <identifiersep> web <identifiersep> <identifier> = true ; \n \t4 } else { \n <ect>
\t2 <identifier> <identifier> = <identifier> . parse <identifiersep> <identifier> ( stream , out ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 if ( <identifier> . get <identifiersep> parse <identifiersep> <identifier> ( ) > 0 ) { \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 <comment> \n \t1 <identifier> . size ( conn <identifiersep> <identifier> . create <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> . empty ) . <identifier> ( ) ) ; \n \t1 while ( ! <identifier> <identifiersep> table . is <identifiersep> <identifier> ( conn <identifiersep> <identifier> ) ) { \n <ect>
\t2 try { \n \t3 list < <identifier> <identifiersep> resource > <identifier> <identifiersep> files = m <identifiersep> <identifier> <identifiersep> <identifier> . read <identifiersep> <identifier> ( m <identifiersep> <identifier> <identifiersep> root , filter , true ) ; \n \t3 result . add <identifiersep> all ( <identifier> <identifiersep> files ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 throw new io <identifiersep> exception ( message . to <identifiersep> string ( ) ) ; } \n \t1 if ( ! has <identifiersep> <identifier> ( uri ) ) { \n \t1 throw new io <identifiersep> exception ( <string_literal> + uri ) ; } \n \t1 log . debug ( <string_literal> , uri ) ; \n <ect>
\t1 public void test <identifiersep> create <identifiersep> <identifier> <identifiersep> queue <identifiersep> <identifier> <identifiersep> create <identifiersep> a <identifiersep> queue <identifiersep> from <identifiersep> <identifier> <identifiersep> name ( ) throws exception { \n \t2 session session = connection . create <identifiersep> session ( false , session . <identifier> <identifiersep> <identifier> ) ; \n \t2 queue <identifier> <identifiersep> queue = session . create <identifiersep> <identifier> <identifiersep> queue ( ) ; \n \t2 string name = <identifier> <identifiersep> queue . get <identifiersep> queue <identifiersep> name ( ) ; \n <ect>
\t3 string path = <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> path ( <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 if ( path != null ) { \n \t4 <identifier> . <identifier> ( new file ( path ) ) . <identifier> ( ) ; \n \t3 } else { \n <ect>
\t4 <identifier> . start ( ) ; \n \t3 } else { \n \t4 logger . debug ( <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) ) ; } } \n \t2 void stop <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 message <identifiersep> <identifier> <identifier> = message <identifiersep> <identifier> . get <identifiersep> instance ( <string_literal> ) ; \n \t3 byte [ ] <identifier> = <identifier> . <identifier> ( <identifier> <identifiersep> address ) ; \n \t3 user <identifiersep> id = <identifier> . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> to <identifiersep> string ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 { \n \t4 return ( value / num <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t3 else \n \t3 { \n <ect>
\t1 } catch ( <identifier> <identifiersep> resource <identifiersep> exception e ) { \n \t1 throw new resource <identifiersep> <identifier> <identifiersep> exists <identifiersep> exception ( e . get <identifiersep> message ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 if ( log . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t2 assert . assert <identifiersep> true ( <identifier> . <identifier> ( <identifier> , <identifier> ) > 0 ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
<number_literal> <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <string_literal> , <string_literal> ) , \n <number_literal> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . find <identifiersep> <identifier> <identifiersep> <identifier> ( log , <identifier> . has <identifiersep> <identifier> ( <string_literal> ) ) ) ; } \n \t1 catch ( throwable e ) \n \t1 { \n <ect>
\t2 if ( input == null ) { \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> input <identifiersep> key + <string_literal> ) ; } \n \t2 try { \n \t3 key <identifiersep> value <identifiersep> <identifier> <identifier> = ( key <identifiersep> value <identifiersep> <identifier> ) input . get <identifiersep> <identifier> ( ) ; \n <ect>
\t1 queue <identifiersep> consumer ( log , <identifier> <identifiersep> properties . <identifier> <identifiersep> queue <identifiersep> name ) . <identifier> ( \n \t2 <identifier> . and <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . event <identifiersep> to <identifiersep> message ) . <identifier> ( event ) \n \t1 ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t1 @ db \n \t1 public void create <identifiersep> volume <identifiersep> on <identifiersep> <identifier> ( string ip <identifiersep> address , string <identifier> <identifiersep> name , string pool <identifiersep> name , string <identifier> <identifiersep> name , string <identifier> <identifiersep> size , string snapshot <identifiersep> policy , integer snapshot <identifiersep> <identifier> , string <identifier> , string password ) throws <identifier> <identifiersep> host <identifiersep> exception , server <identifiersep> exception , <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception \n \t1 { \n <ect>
\t5 ) ; \n \t5 if ( trace ) { \n \t6 logger . trace ( <string_literal> { } \\ <string_literal> , file . get <identifiersep> file ( ) . get <identifiersep> name ( ) , <identifier> <identifiersep> info ) ; } \n \t4 } catch ( parse <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifier> <identifiersep> <identifier> = null ; \n \t4 for ( <identifier> <identifier> : <identifier> <identifiersep> empty <identifiersep> <identifier> <identifiersep> with <identifiersep> id ) { \n \t5 long this <identifiersep> time = <identifier> . time <identifiersep> last <identifiersep> <identifier> ; \n \t5 if ( this <identifiersep> time < <identifier> ) \n <ect>
\t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> , boolean <identifier> <identifiersep> method , boolean <identifier> <identifiersep> time <identifiersep> format , string <identifier> , string <identifier> <identifiersep> values <identifiersep> <identifier> <identifiersep> type , boolean <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> array <identifier> <identifiersep> values ) { \n \t3 log . debug ( <string_literal> , <identifier> ) ; \n \t3 log . debug ( <string_literal> , <identifier> <identifiersep> method ) ; \n <ect>
\t1 this . <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t2 metadata <identifiersep> cache , data <identifiersep> cache , <identifier> <identifiersep> manager <identifiersep> <identifier> , conf , cache <identifiersep> <identifier> , io <identifiersep> <identifier> , trace <identifiersep> pool ) ; \n \t1 this . <identifier> <identifiersep> <identifier> = is <identifiersep> <identifier> <identifiersep> enabled ? new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t2 <identifier> <identifiersep> cache , <identifier> <identifiersep> manager <identifiersep> <identifier> , conf , cache <identifiersep> <identifier> , io <identifiersep> <identifier> , trace <identifiersep> pool ) : null ; \n <ect>
\t1 try { \n \t2 if ( null != <identifier> ) { \n \t2 <identifier> . close ( ) ; } \n \t1 } catch ( exception ex ) { \n <ect>
\t1 for ( final <identifier> <identifiersep> task task : <identifier> ) { \n \t1 try { \n \t2 task . <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 result . <identifier> = ( table <identifiersep> not <identifiersep> found <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t5 return super . <identifier> <identifiersep> class ( <identifier> ) ; } \n \t3 } ; \n \t3 result = ( t ) <identifier> . read <identifiersep> object ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 <identifier> <identifiersep> group ) ) ; \n \t3 <identifier> <identifiersep> group <identifiersep> map . <identifier> ( new <identifier> <identifiersep> and <identifiersep> name ( <identifier> , <identifier> <identifiersep> group ) ) ; \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> group ) ; \n \t3 } catch ( illegal <identifiersep> state <identifiersep> exception e ) { \n <ect>
\t4 runtime . get <identifiersep> runtime ( ) . add <identifiersep> shutdown <identifiersep> <identifier> ( shutdown <identifiersep> <identifier> ) ; } \n \t3 catch ( illegal <identifiersep> state <identifiersep> exception <identifier> ) { \n \t4 <comment> \n \t3 catch ( throwable t ) { \n <ect>
\t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> update ( string item <identifiersep> name , state new <identifiersep> state ) { \n \t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t4 result = result && <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t3 } else if ( <identifier> . get <identifiersep> state ( ) == state . <identifier> || <identifier> . get <identifiersep> state ( ) == state . <identifier> ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> instance <identifiersep> name ( ) + <string_literal> + <identifier> . get <identifiersep> state ( ) + <string_literal> ) ; \n \t3 } else { \n <ect>
\t2 int max <identifiersep> <identifier> = <number_literal> ; <comment> \n \t2 try { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . length ( ) != 0 ) { \n \t4 <identifier> <identifiersep> <identifier> = double . parse <identifiersep> double ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t8 <identifier> <identifiersep> to . get <identifiersep> <identifier> ( ) , i + 1 , true , true ) ; \n \t6 if ( <identifier> <identifiersep> to . get <identifiersep> <identifier> ( ) != null ) { \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> switch <identifiersep> <identifier> . put ( <identifier> <identifiersep> to . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> switch <identifiersep> <identifier> ) ; } \n \t5 } else { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t4 <comment> \n <ect>
\t3 return ; } \n \t2 long <identifier> <identifiersep> id = <identifier> . get <identifiersep> id ( ) ; \n \t2 <identifier> <identifiersep> routing <identifiersep> command <identifier> = ( <identifier> <identifiersep> routing <identifiersep> command ) cmd ; \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> type . <identifier> <identifiersep> server ) { \n <ect>
\t2 if ( last <identifiersep> <identifier> <identifiersep> <identifier> != <identifier> . get <identifiersep> <identifier> <identifiersep> num ( ) ) { \n \t3 last <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> num ( ) ; \n \t3 logger . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> num ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ) . get <identifiersep> name ( ) + <string_literal> ) ; } \n \t2 log <identifiersep> state ( <identifier> ) ; \n <ect>
\t2 thread . set <identifiersep> default <identifiersep> <identifier> <identifiersep> exception <identifiersep> handler ( new thread . <identifier> <identifiersep> exception <identifiersep> handler ( ) \n \t2 { \n \t3 public void <identifier> <identifiersep> exception ( thread t , throwable e ) \n \t3 { \n <ect>
\t7 try { \n \t8 synchronized ( <identifier> <identifiersep> value ) { \n \t9 <identifier> <identifiersep> value [ 0 ] = integer . parse <identifiersep> int ( <identifier> <identifiersep> string ) ; } \n \t7 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 log . info ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> . close <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t2 if ( ! super . <identifier> <identifiersep> <identifier> ( shutdown <identifiersep> wait <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ) { \n \t2 logger . info ( <string_literal> ) ; \n \t2 super . shutdown <identifiersep> <identifier> ( ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t4 integer key = null ; \n \t4 try { \n \t5 key = integer . parse <identifiersep> int ( <identifier> . get ( <string_literal> ) ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> log . debug ( <string_literal> ) ; \n \t4 string destination = <identifier> <identifiersep> event <identifiersep> handler . wait <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> log . debug ( <string_literal> + destination ) ; \n \t4 if ( destination == null ) { \n <ect>
\t2 } finally { \n \t3 remove <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t3 string url = in <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> base <identifiersep> object <identifiersep> properties ( ) . get ( <string_literal> ) ; \n \t3 if ( url != null ) \n \t3 { \n \t4 <comment> \n <ect>
\t1 public boolean <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> start ( final <identifier> <identifier> , final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 final <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> . get <identifiersep> id ( ) ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t2 put <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> property ( <identifier> . <identifier> . <identifier> . default . <identifier> , self . <identifier> <identifiersep> root <identifiersep> default <identifiersep> queue <identifiersep> name ) \n \t1 else : \n \t2 self . logger . debug ( <string_literal> . format ( <identifier> <identifiersep> queue <identifiersep> name , list ( <identifier> <identifiersep> queue <identifiersep> <identifier> ) ) ) \n \t1 else : \n <ect>
\t5 input <identifiersep> stream state <identifiersep> file <identifiersep> input <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( file ) ; \n \t5 <identifier> = <identifier> <identifiersep> builder ( ) . put ( <identifier> <identifiersep> <identifier> ) . load <identifiersep> from <identifiersep> stream ( <string_literal> , state <identifiersep> file <identifiersep> input <identifiersep> stream ) . build ( ) ; \n \t5 logger . info ( <string_literal> , <identifier> , <identifier> . get <identifiersep> as <identifiersep> map ( ) ) ; \n \t4 } else { \n <ect>
\t3 m <identifiersep> <identifier> = <identifier> . empty <identifiersep> list ( ) ; \n \t3 <identifier> ( false ) ; \n \t3 m <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> = node <identifiersep> id <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 list < map <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 <identifier> = <identifier> . get ( 0 ) . get <identifiersep> <identifier> <identifiersep> key ( ) . get <identifiersep> <identifier> ( ) ; \n \t2 this . in <identifiersep> <identifier> = in <identifiersep> <identifier> ; \n <ect>
\t4 <identifier> <identifiersep> count . put ( c . get <identifiersep> as <identifiersep> filter <identifiersep> query ( ) , ( int ) c . get <identifiersep> count ( ) ) ; } \n \t3 for ( <identifier> <identifiersep> result c : <identifier> <identifiersep> count ) { \n \t4 <identifier> <identifiersep> count . put ( c . get <identifiersep> as <identifiersep> filter <identifiersep> query ( ) , ( int ) c . get <identifiersep> count ( ) ) ; } \n \t2 } catch ( <identifier> <identifiersep> service <identifiersep> exception e ) { \n <ect>
\t2 else \n \t2 { \n \t3 <comment> \n \t3 if ( logger . is <identifiersep> <identifier> ( m <identifiersep> level . info ) ) \n <ect>
\t1 <identifier> <identifiersep> server <identifier> ; \n \t1 string file <identifiersep> name , <identifier> <identifiersep> <identifier> ; \n \t1 @ <identifier> \n \t1 public void set <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t2 s <identifiersep> logger . debug ( <string_literal> + <identifier> <identifiersep> private <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = network <identifiersep> model . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , private <identifiersep> network . get <identifiersep> id ( ) , null ) ; \n \t2 boolean result = <identifier> . <identifier> ( this ) ; \n \t2 if ( ! result ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> ( this , \n <number_literal> new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> method , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> class <identifiersep> array ) , \n <number_literal> path ) ; \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) { \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> utils . get <identifiersep> property ( <string_literal> , null ) == null ) { \n <ect>
\t2 <comment> \n \t2 <identifier> = <identifier> <identifiersep> for ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> from <identifiersep> <identifier> . path ) ; \n \t2 security <identifiersep> context . get <identifiersep> <identifier> <identifiersep> context ( <identifier> ) . <identifier> ( ) ; \n \t2 } catch ( exception <identifier> ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> not <identifiersep> found <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t1 string s = value . <identifier> ( ) ; \n \t1 try { \n \t1 return integer . value <identifiersep> of ( s ) . int <identifiersep> value ( ) ; } \n \t1 catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 final registered <identifiersep> service registered <identifiersep> service = this . <identifier> <identifiersep> manager . find <identifiersep> service <identifiersep> by ( service ) ; \n \t4 <identifier> <identifiersep> registered <identifiersep> service <identifiersep> properties ( registered <identifiersep> service , service ) ; \n \t4 return new http <identifiersep> <identifier> <identifiersep> service <identifiersep> <identifier> ( new url ( <identifier> <identifiersep> url ) , registered <identifiersep> service ) ; \n \t3 } catch ( final exception e ) { \n <ect>
\t7 return cluster <identifiersep> state . builder ( current <identifiersep> state ) . put <identifiersep> <identifier> ( <identifier> <identifiersep> in <identifiersep> <identifier> . type , <identifier> ) . build ( ) ; } } \n \t5 return current <identifiersep> state ; } \n \t4 @ <identifier> \n \t4 public void on <identifiersep> failure ( string source , exception e ) { \n <ect>
\t2 final <identifier> < <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo > it = <identifier> <identifiersep> node <identifiersep> list . <identifier> ( ) ; \n \t2 while ( it . has <identifiersep> next ( ) ) { \n \t3 final <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo <identifier> = it . next ( ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> node ( <identifier> ) ) { \n <ect>
\t2 string file <identifiersep> id = test <identifiersep> file . get <identifiersep> id ( ) ; \n \t2 <comment> \n \t2 final <identifier> . <identifier> . api . <identifier> . <identifier> . model . property <identifiersep> list result = request <identifiersep> body ( <string_literal> , file <identifiersep> id ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , result ) ; \n <ect>
\t3 ? <string_literal> : <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> output <identifiersep> path . to <identifiersep> string ( ) + ' \\ <identifier> ; \n \t1 log . info ( info <identifiersep> string ) ; \n \t1 file <identifiersep> system <identifier> = file <identifiersep> system . get ( <identifier> <identifiersep> model <identifiersep> state <identifiersep> <identifier> <identifiersep> path . to <identifiersep> uri ( ) , conf ) ; \n \t1 int <identifier> <identifiersep> number = get <identifiersep> current <identifiersep> <identifier> <identifiersep> number ( conf , <identifier> <identifiersep> model <identifiersep> state <identifiersep> <identifier> <identifiersep> path , max <identifiersep> <identifier> ) ; \n <ect>
\t4 <identifier> = self . <identifier> . id , \n \t4 <identifier> = <identifier> , \n \t4 <identifier> = <identifier> . id \n \t3 ) \n <ect>
\t2 if ( ( ! <identifier> ) && ( context . get <identifiersep> <identifier> ( ) != null ) \n \t3 && ( <string_literal> . equals ( context . get <identifiersep> <identifier> ( ) . <identifier> ( <string_literal> ) ) ) ) { \n \t3 logger . debug ( <string_literal> , context . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t3 return ; } \n <ect>
\t4 add <identifiersep> <identifier> <identifiersep> config ( item , config ) ; \n \t3 } else { \n \t4 logger . warn ( <string_literal> + item + <string_literal> ) ; } \n \t2 } catch ( array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
public object <identifier> <identifiersep> with <identifiersep> timeout ( final <identifier> <identifier> , final long <identifier> <identifiersep> <identifier> ) { \n \t1 string command <identifiersep> name = config . get <identifiersep> command <identifiersep> name ( <identifier> ) ; \n \t1 http <identifiersep> command command = to <identifiersep> command ( command <identifiersep> name , <identifier> ) ; \n \t1 org . <identifier> . <identifier> < ? > <identifier> = get <identifiersep> <identifier> ( command <identifiersep> name , <identifier> , command ) ; \n <ect>
\t1 public static void write <identifiersep> <identifier> <identifiersep> server <identifiersep> error ( final http <identifiersep> <identifier> <identifiersep> response response ) { \n \t2 try { \n \t3 response . send <identifiersep> error ( http <identifiersep> <identifier> <identifiersep> response . <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> error ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 } catch ( io <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> , e ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> , e ) ; } \n <ect>
\t2 assert <identifiersep> equals ( password , <identifier> . get <identifiersep> password ( ) ) ; } \n \t1 @ test \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> ticket <identifiersep> as <identifiersep> authentication <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 final map < ? , ? > attributes = <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t1 <identifier> <identifiersep> meta <identifiersep> data meta <identifiersep> data = this . get <identifiersep> connection ( ) . get <identifiersep> meta <identifiersep> data ( ) ; \n \t1 result <identifiersep> set <identifier> = meta <identifiersep> data . get <identifiersep> <identifier> <identifiersep> <identifier> ( null , null , \n \t2 <identifier> <identifiersep> name , null ) ; \n \t1 if ( null == <identifier> ) { \n <ect>
\t4 <identifier> . <identifier> <identifiersep> list ( \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> info ( \n \t6 <identifier> <identifiersep> <identifier> . get <identifiersep> org <identifiersep> unit <identifiersep> manager ( ) . read <identifiersep> <identifier> <identifiersep> unit ( a <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> object ( ) , m <identifiersep> <identifier> <identifiersep> name ) ) ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> metadata <identifiersep> <identifier> result = null ; \n \t2 try { \n \t3 result = this . <identifier> <identifiersep> manager . get <identifiersep> instance ( <identifier> <identifiersep> metadata <identifiersep> <identifier> . class , entity <identifiersep> type . name ( ) . to <identifiersep> <identifier> <identifiersep> case ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> ( ) ; \n \t2 query <identifiersep> builder <identifier> = query <identifiersep> <identifier> . <identifier> <identifiersep> query ( query <identifiersep> <identifier> . <identifier> <identifiersep> query ( <string_literal> , <string_literal> ) , query <identifiersep> <identifier> . <identifier> <identifiersep> query ( <string_literal> , <string_literal> ) ) \n \t4 . <identifier> ( <identifier> <identifiersep> float ( ) ) \n \t4 . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> float ( ) ) ; \n <ect>
\t5 <string_literal> + new <identifiersep> handler <identifiersep> method + <string_literal> + <identifier> + <string_literal> + \n \t5 <identifier> <identifiersep> handler <identifiersep> method . get <identifiersep> bean ( ) + <string_literal> + <identifier> <identifiersep> handler <identifiersep> method + <string_literal> ) ; } \n \t2 this . handler <identifiersep> <identifier> . put ( <identifier> , new <identifiersep> handler <identifiersep> method ) ; \n <ect>
\t1 public void <identifier> <identifiersep> with <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> <identifiersep> store = new data <identifiersep> store <identifiersep> <identifier> <identifiersep> store ( data <identifiersep> store <identifiersep> utils . create <identifiersep> <identifier> ( new file ( get <identifiersep> <identifier> <identifiersep> dir ( ) , <string_literal> ) , <number_literal> ) ) ; \n \t2 data <identifiersep> store <identifiersep> state state = set <identifiersep> <identifier> ( ) ; \n \t2 add <identifiersep> <identifier> ( ) ; \n <ect>
\t1 status = url <identifiersep> response . <identifier> ( ) \n \t1 response = url <identifiersep> response . read ( ) \n \t1 if status != <number_literal> : \n \t2 logger . <identifier> ( <string_literal> . format ( status ) ) \n <ect>
\t4 ( cluster instanceof <identifier> ) ) { \n \t4 try { \n \t5 ( ( <identifier> ) cluster ) . start ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 return new <identifier> [ 0 ] ; } \n @ <identifier> \n public void <identifier> ( <identifier> <identifier> ) throws <identifier> <identifiersep> exception { \n \t1 this . <identifier> <identifiersep> <identifier> = true ; \n <ect>
\t7 <identifier> . set <identifiersep> is <identifiersep> <identifier> ( true ) ; \n \t7 logger . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> object <identifiersep> map <identifiersep> <identifier> ( ) ) ; } } \n \t5 if ( <identifier> . is <identifiersep> empty ( ) ) \n \t5 { \n <ect>
\t2 web <identifiersep> target target = client . target ( <identifier> <identifiersep> url ( context ) ) ; \n \t2 web <identifiersep> target new <identifiersep> target = null ; \n \t2 if ( <identifier> != null ) { \n \t3 for ( map . entry < string , string > entry : <identifier> . entry <identifiersep> set ( ) ) { \n <ect>
\t5 + <string_literal> + <identifier> + <string_literal> + <identifier> ; \n \t3 if ( <identifier> ) { \n \t4 logger . info ( <string_literal> + status ) ; \n \t3 } else { \n <ect>
\t1 try { \n \t1 if ( ! execution <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t2 execution <identifiersep> <identifier> . start <identifiersep> <identifier> ( null ) ; } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
public void <identifier> { <identifier> . <identifier> <identifiersep> name } ( <identifier> . <identifier> <identifiersep> destination . class <identifiersep> name <identifiersep> with <identifiersep> default value ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( value , $ { entity . <identifier> <identifiersep> class <identifiersep> name <identifiersep> <identifier> <identifiersep> package } . $ { <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> name } <identifier> <identifiersep> key ) ; } \n public void <identifier> { <identifier> . <identifier> <identifiersep> name } <identifier> ( <identifier> . <identifier> <identifiersep> destination . class <identifiersep> name <identifiersep> with <identifiersep> default value ) { \n <ect>
\t2 default : \n \t3 log . warn ( <string_literal> + to <identifiersep> string ( event ) ) ; } \n \t2 break ; \n \t1 default : \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 if ( connection <identifiersep> <identifier> ) { \n \t4 close <identifiersep> connection ( ) ; } \n \t2 } finally { \n <ect>
\t5 . <identifier> ( entity . entity ( <identifier> <identifiersep> map , <string_literal> ) ) ; \n \t3 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , response . get <identifiersep> status ( ) ) ; \n \t3 string entity = response . read <identifiersep> entity ( string . class ) ; \n \t3 int <identifier> = <identifier> . <identifier> ( entity . length ( ) , <number_literal> ) ; \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t4 if ( values . get ( <string_literal> ) == null ) { \n \t5 s <identifiersep> logger . info ( <string_literal> ) ; \n \t5 return <number_literal> ; } \n \t4 else { \n <ect>
\t6 continue ; } \n \t5 dir <identifiersep> queue . add ( new input <identifiersep> <identifier> ( <identifier> , context <identifiersep> path + <identifier> . get <identifiersep> name ( ) + file . <identifier> ) ) ; \n \t4 } else { \n \t5 if ( ! <identifier> . <identifier> <identifiersep> read ( ) ) { \n <ect>
\t2 properties <identifiersep> configuration <identifier> = new properties <identifiersep> configuration ( ) ; \n \t2 <identifier> . set <identifiersep> list <identifiersep> <identifier> ( ' \\ <identifier> ) ; \n \t2 try { \n \t2 <identifier> . load ( conf ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t6 response . get <identifiersep> <identifier> <identifiersep> status <identifiersep> value ( ) ) ; \n \t4 <identifier> . add ( id . get <identifiersep> value ( ) ) ; \n \t4 <identifier> ++ ; \n \t4 continue ; } \n <ect>
\t1 <identifier> <identifiersep> output [ <string_literal> ] = { <string_literal> : code , <string_literal> : <string_literal> . format ( <identifier> ( output ) ) } \n \t1 self . put <identifiersep> <identifier> <identifiersep> out ( <identifier> <identifiersep> output ) \n <identifier> get <identifiersep> <identifier> <identifiersep> cmd ( self ) : \n \t1 if <identifier> <identifiersep> check . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) : \n <ect>
\t2 content <identifiersep> name name = <identifier> <identifiersep> <identifier> . add <identifiersep> version ( <identifier> <identifiersep> name ) ; \n \t2 thread . <identifier> ( <number_literal> ) ; \n \t2 if ( name == <identifier> <identifiersep> <identifier> . add <identifiersep> version ( <identifier> <identifiersep> <identifier> <identifiersep> name ) ) \n \t3 <identifier> ( <string_literal> ) ; \n <ect>
@ <identifier> \n public void <identifier> <identifiersep> <identifier> <identifiersep> resource ( <identifier> <identifiersep> context <identifier> <identifiersep> context , \n \t9 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) \n { \n <ect>
\t3 try { \n \t4 org . apache . <identifier> . api . security . user . group <identifier> = get <identifiersep> group ( ) ; \n \t4 return ( <identifier> == null ) ? null : <identifier> . get <identifiersep> path ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t10 <string_literal> + \n \t10 <string_literal> , \n \t8 <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> state . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t6 throw new illegal <identifiersep> state <identifiersep> exception ( msg ) ; } } \n <ect>
\t4 lock <identifiersep> resource . try <identifiersep> lock ( cluster . get <identifiersep> <identifier> <identifiersep> lock ( ) . read <identifiersep> lock ( ) , <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t2 if ( lock . is <identifiersep> <identifier> ( ) ) { \n \t3 cluster . <identifier> <identifiersep> <identifier> ( ) ; } } \n \t1 } catch ( exception ex ) { \n <ect>
\t3 <comment> \n \t3 input <identifiersep> stream error <identifiersep> stream = conn . get <identifiersep> error <identifiersep> stream ( ) ; \n \t3 if ( error <identifiersep> stream == null ) { \n <ect>
\t2 system . out . <identifier> ( <string_literal> + user <identifiersep> key <identifiersep> store <identifiersep> <identifier> ) ; \n \t2 system . out . <identifier> ( <string_literal> + user <identifiersep> <identifier> ) ; } \n @ test \n \t1 public void test <identifiersep> user <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < > ( ) ; } \n @ <identifier> \n public void start ( <identifier> < <identifier> > <identifier> ) \n { \n <ect>
\t3 <identifier> . set <identifiersep> long ( <number_literal> , ( long ) <identifier> <identifiersep> ip [ 0 ] ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . close ( ) ; } } \n \t1 protected void <identifier> <identifiersep> public <identifiersep> user <identifiersep> ip <identifiersep> address ( connection conn , long <identifier> <identifiersep> id , long network <identifiersep> id , string <identifier> <identifiersep> type ) throws sql <identifiersep> exception { \n <ect>
\t3 if ( is <identifiersep> <identifier> ( ) ) \n \t4 return ; \n \t3 boolean <identifier> = host . <identifier> <identifiersep> lock . try <identifiersep> lock ( <identifier> <identifiersep> lock <identifiersep> timeout <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; \n \t3 if ( ! <identifier> ) { \n <ect>
\t3 try { \n \t4 this . event <identifiersep> <identifier> . <identifier> <identifiersep> update ( <identifier> . get <identifiersep> name ( ) , new <identifier> <identifiersep> type ( value ) ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception exception ) { \n \t4 logger . warn ( <string_literal> , string . value <identifiersep> of ( value ) , <identifier> . get <identifiersep> name ( ) ) ; } \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> pool != null ) { \n \t3 <identifier> <identifiersep> pool . stop ( ) ; } } \n \t1 public void shutdown ( ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> list . add ( <identifier> <identifiersep> <identifier> <identifiersep> list . resource <identifiersep> <identifier> ) ; \n \t2 int id = <identifier> . get <identifiersep> and <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> id ( id ) ; \n \t2 collection . put ( id , <identifier> ) ; \n <ect>
\t3 field default <identifiersep> policy = class . for <identifiersep> name ( <string_literal> ) . get <identifiersep> <identifier> <identifiersep> field ( <string_literal> ) ; \n \t3 default <identifiersep> policy . set <identifiersep> <identifier> ( true ) ; \n \t3 default <identifiersep> policy . set ( null , <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 else \n \t5 this . run ( ) ; } \n \t3 catch ( throwable t ) \n \t3 { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n \t1 { \n \t2 collection < operation <identifiersep> and <identifiersep> data < ? > > <identifier> = new array <identifiersep> list < > ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to ( <identifier> ) ; \n <ect>
\t3 thread . current <identifiersep> thread ( ) . set <identifiersep> name ( new <identifiersep> thread <identifiersep> name ) ; \n \t3 logger . info ( <string_literal> + port ) ; \n \t3 server <identifiersep> socket = get <identifiersep> server <identifiersep> socket <identifiersep> factory ( ) . create <identifiersep> server <identifiersep> socket ( port ) ; \n \t3 while ( ! <identifier> ) { \n <ect>
\t2 list < <identifier> <identifiersep> vo > <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> ( <identifier> , null ) ; \n \t2 if ( <identifier> . size ( ) > 0 ) { \n \t3 if ( <identifier> . get ( 0 ) . get <identifiersep> total <identifiersep> <identifier> ( ) < <identifier> <identifiersep> <identifier> + ( <identifier> != null ? <identifier> . get <identifiersep> <identifier> <identifiersep> size ( ) * <identifier> * <identifier> : 0 ) ) { \n <ect>
\t1 for ( <identifier> <identifiersep> info <identifier> : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t2 <identifier> <identifiersep> node <identifiersep> <identifier> <identifier> = <identifier> . get ( <identifier> ) ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t3 } else { \n \t4 log . warn ( string . format ( <string_literal> , <identifier> <identifiersep> task . get <identifiersep> <identifier> <identifiersep> name ( ) ) ) ; \n \t4 <identifier> <identifiersep> <identifier> . set <identifiersep> state ( <identifier> <identifiersep> task , import <identifiersep> task <identifiersep> state . failed , import <identifiersep> task <identifiersep> state . state <identifiersep> msg <identifiersep> <identifier> <identifiersep> timeout ) ; } \n \t3 } catch ( final exception ex ) { \n <ect>
<comment> \n @ <identifier> \n public void write <identifiersep> <identifier> <identifiersep> end ( ) throws t <identifiersep> exception { \n <ect>
\t1 void <identifier> ( ) throws exception { \n \t2 final <identifier> < object > <identifier> = new <identifier> < object > ( ) ; \n \t2 connection . <identifier> ( new <identifier> < void > ( ) { \n \t3 public void on <identifiersep> success ( void value ) { \n <ect>
\t1 private void update <identifiersep> key <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( string <identifier> <identifiersep> dir ) { \n \t2 file key <identifiersep> dir = new file ( <identifier> <identifiersep> dir + <string_literal> ) ; \n \t2 boolean <identifier> = boolean . value <identifiersep> of ( <identifier> <identifiersep> config <identifiersep> dao . get <identifiersep> value ( <string_literal> ) ) ; \n \t2 if ( ! key <identifiersep> dir . is <identifiersep> directory ( ) ) { \n <ect>
<comment> \n \t1 public void start <identifiersep> <identifier> ( <identifier> <identifiersep> properties <identifier> <identifiersep> properties , <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> value return <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> value ( return <identifiersep> <identifier> ) ; \n \t2 if ( ! info <identifiersep> <identifier> <identifiersep> <identifier> . contains <identifiersep> node ( return <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) \n \t3 info <identifiersep> <identifier> <identifiersep> <identifier> . add <identifiersep> node ( return <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> ) \n <ect>
\t4 for ( remote <identifiersep> input <identifiersep> channel input <identifiersep> channel : input <identifiersep> <identifier> . values ( ) ) { \n \t5 input <identifiersep> channel . on <identifiersep> error ( <identifier> ) ; } \n \t3 } catch ( throwable t ) { \n \t4 <comment> \n <ect>
\t2 boolean result = false ; \n \t2 try { \n \t3 result = <identifier> . resource <identifiersep> update ( value ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> e ) { \n <ect>
\t5 } else if ( <string_literal> . equals ( <identifier> . get <identifiersep> local <identifiersep> name ( ) ) ) { \n \t6 try { \n \t7 handler . handle <identifiersep> msg ( level , <identifier> . get <identifiersep> element <identifiersep> text ( ) ) ; \n \t6 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 { \n \t5 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; } \n \t4 catch ( exception e ) \n \t4 { \n <ect>
\t2 load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> <identifier> . read ( stream ) ) ; \n \t1 } else { \n \t2 logger . warn ( <string_literal> , <identifier> <identifiersep> file ) ; } } } \n private void load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) { \n <ect>
\t2 <identifier> = <identifier> ( <identifier> , <identifier> , true ) ; \n \t2 assert <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( ) , <number_literal> , <number_literal> , user . get <identifiersep> id ( ) , user . get <identifiersep> id ( ) + <string_literal> , <string_literal> ) ; \n \t2 assert <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( ) , <number_literal> , <number_literal> , user . get <identifiersep> id ( ) , user . get <identifiersep> id ( ) + <string_literal> ) ; \n \t2 cache <identifiersep> <identifier> ( ) ; \n <ect>
\t5 return false ; } } } \n \t2 return true ; } \n \t1 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> , <identifier> <identifiersep> event event , object object ) { } \n \t1 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> , <identifier> <identifiersep> event event , object object ) { \n <ect>
\t2 else { \n \t3 <identifier> <identifiersep> connection <identifiersep> handler handler = this . connection <identifiersep> <identifier> . get ( session <identifiersep> id ) ; \n \t3 if ( handler == null ) { \n <ect>
\t2 task <identifiersep> <identifier> . add ( <identifier> <identifiersep> event ) ; } \n \t2 num <identifiersep> <identifier> <identifiersep> for <identifiersep> task [ task ] = count ; } } \n \t1 input <identifiersep> name <identifiersep> input <identifiersep> <identifier> <identifiersep> map . put ( input <identifiersep> name , \n \t2 input <identifiersep> <identifier> <identifiersep> update . create <identifiersep> <identifier> <identifiersep> task <identifiersep> input <identifiersep> <identifier> <identifiersep> update ( <identifier> . as <identifiersep> list ( num <identifiersep> <identifier> <identifiersep> for <identifiersep> task ) ) ) ; \n <ect>
\t5 log . error ( <string_literal> , <identifier> <identifiersep> file ) ; \n \t4 throw e ; } \n \t3 catch ( io <identifiersep> exception e ) { \n \t4 if ( ! <identifier> <identifiersep> file . delete ( ) ) \n <ect>
\t3 final <identifier> <identifiersep> password <identifiersep> <identifier> c = ( <identifier> <identifiersep> password <identifiersep> <identifier> ) <identifier> ; \n \t3 final <identifier> <identifiersep> filter filter = <identifier> <identifiersep> utils . new <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> filter ( <identifier> . get <identifiersep> <identifier> <identifiersep> filter ( ) , \n \t4 <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> filter <identifiersep> default <identifiersep> <identifier> <identifiersep> name , \n \t4 collection <identifiersep> utils . <identifier> ( c . get <identifiersep> id ( ) ) ) ; \n <ect>
\t4 <identifier> . set <identifiersep> result ( result . get <identifiersep> result ( ) ) ; \n \t3 } else { \n \t4 <identifier> = new snapshot <identifiersep> result ( context . snapshot , null ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 process <identifiersep> <identifier> <identifiersep> <identifier> ( message . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> ) ; } } \n \t1 private void process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> data . <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , channel <identifiersep> handler <identifiersep> context <identifier> ) { \n \t2 logger . info ( <string_literal> ) ; \n \t2 if ( server <identifiersep> <identifier> == null || client <identifiersep> <identifier> == null ) { \n <ect>
\t2 long <identifier> <identifiersep> <identifier> = total <identifiersep> <identifier> - <identifier> <identifiersep> <identifier> ; \n \t2 function < long , string > <identifier> = <identifier> <identifiersep> info : : <identifier> <identifiersep> <identifier> ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> log . info ( log , <string_literal> , <identifier> . version ) ; \n <ect>
\t4 if ( item . is <identifiersep> <identifier> ( ) ) \n \t5 <identifier> . remove <identifiersep> entry ( item . get <identifiersep> source <identifiersep> entry ( ) ) ; } } \n \t2 catch ( <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t6 return ; <comment> \n \t4 catch ( io <identifiersep> exception e ) \n \t4 { \n \t5 if ( ! ( e instanceof <identifier> <identifiersep> exception ) ) \n <ect>
<comment> \n \t1 public < t extends <identifier> > void add <identifiersep> <identifier> <identifiersep> type ( string type <identifiersep> name , class < t > <identifier> <identifiersep> class ) { \n <ect>
\t2 private void run <identifiersep> action ( <identifier> action ) { \n \t3 try { \n \t4 action . run ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception ex ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + bytes <identifiersep> <identifier> + <string_literal> + user <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> ( ) + \n \t5 <string_literal> + current <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> ) ; \n \t3 bytes <identifiersep> <identifier> = 0 ; } \n \t2 if ( bytes <identifiersep> <identifier> < 0 ) { \n <ect>
\t1 log . info ( s <string_literal> ) \n \t1 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) \n \t1 case <identifier> <identifiersep> <identifier> - > <identifier> <identifiersep> <identifier> = > \n \t1 <comment> \n <ect>
\t3 files . delete ( to ) ; } } \n \t1 protected void <identifier> <identifiersep> response ( http <identifiersep> response response ) throws io <identifiersep> exception { \n \t2 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( response . get <identifiersep> entity ( ) . get <identifiersep> content ( ) ) ) ; \n \t2 string line = <identifier> . read <identifiersep> line ( ) ; \n <ect>
\t4 with self . <identifier> <identifiersep> <identifier> <identifiersep> socket <identifiersep> <identifier> : \n \t5 self . socket . <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t3 <identifier> exception : \n \t4 <identifier> <identifiersep> <identifier> , e , <identifier> <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> info ( ) \n <ect>
\t4 . get ( ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> out ( ) , equal <identifiersep> to ( false ) ) ; \n \t2 logger . info ( <string_literal> , cluster <identifiersep> <identifier> . get <identifiersep> status ( ) ) ; \n \t2 assert <identifiersep> that ( files . exists ( <identifier> ) , equal <identifiersep> to ( true ) ) ; \n <ect>
\t2 client . <identifier> ( ) ; } \n \t1 private void process <identifiersep> new <identifiersep> client ( <identifier> <identifiersep> client client ) { \n \t2 client . <identifier> ( entity <identifiersep> manager , entity <identifiersep> <identifier> , event <identifiersep> <identifier> , event <identifiersep> <identifier> ) ; \n \t2 <comment> \n <ect>
\t3 try { \n \t4 count = id <identifiersep> pool . next <identifiersep> id ( ) ; \n \t4 <identifier> <identifiersep> pool . <identifier> ( ) ; \n \t3 } catch ( id <identifiersep> pool <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } else { \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> list . size ( ) ; i ++ ) { \n \t4 if ( ! <identifier> <identifiersep> list . get ( i ) . equals ( <identifier> <identifiersep> list . get ( i ) ) ) { \n \t5 status = false ; \n <ect>
\t3 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 <identifier> <identifiersep> thread = null ; \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t2 assert <identifiersep> equals ( <number_literal> , <identifier> . get <identifiersep> total <identifiersep> time ( ) ) ; \n \t2 thread . <identifier> ( <number_literal> ) ; \n \t2 <identifier> . add <identifiersep> time ( <number_literal> ) ; \n \t2 assert <identifiersep> last <identifiersep> time <identifiersep> not <identifiersep> start <identifiersep> time ( <identifier> ) ; \n <ect>
\t5 <comment> \n \t4 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n \t5 <comment> \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 <identifier> <identifiersep> name = name ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> current <identifiersep> <identifier> ( ) ; \n \t2 configuration <identifiersep> dao config <identifiersep> dao = <identifier> . get <identifiersep> dao ( configuration <identifiersep> dao . class ) ; \n \t2 if ( config <identifiersep> dao == null ) { \n <ect>
\t2 { \n \t3 native . <identifier> ( <string_literal> ) ; } \n \t2 catch ( no <identifiersep> class <identifiersep> <identifier> <identifiersep> found <identifiersep> error e ) \n \t2 { \n <ect>
\t6 <string_literal> ) ; \n \t4 return new <identifier> < host , map < volume , storage <identifiersep> pool > > ( <identifier> <identifiersep> host , storage ) ; \n \t3 } else { \n \t4 <identifier> . add <identifiersep> host ( <identifier> <identifiersep> host . get <identifiersep> id ( ) ) ; } } \n <ect>
\t5 this . <identifier> <identifiersep> metadata <identifiersep> value <identifiersep> info ( abstract <identifiersep> field , <identifier> ) ; \n \t4 try { \n \t5 this . add <identifiersep> <identifier> <identifiersep> metadata ( context , info , item ) ; \n \t4 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 if ( this . <identifier> <identifiersep> <identifier> != null ) { \n \t4 this . <identifier> <identifiersep> <identifier> . close ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 list < string > <identifier> <identifiersep> <identifier> <identifiersep> list = ( <identifier> <identifiersep> <identifier> <identifiersep> check <identifiersep> values == null ? new <identifier> <identifiersep> list < string > ( ) : <identifier> . as <identifiersep> list ( <identifier> <identifiersep> <identifier> <identifiersep> check <identifiersep> values . <identifier> ( <string_literal> ) ) ) ; \n \t3 if ( null != <identifier> && <identifier> <identifiersep> <identifier> <identifiersep> list . contains ( <identifier> ) ) { \n \t4 return boolean . false ; } \n \t2 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 if ( client . get <identifiersep> input <identifiersep> stream ( ) . <identifier> ( ) == 0 ) { \n \t5 break ; } } \n \t3 return <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 { \n \t2 try { \n \t3 if ( <identifier> . is <identifiersep> <identifier> ( ) ) \n \t3 { \n <ect>
\t7 <identifier> . count <identifiersep> <identifier> ( ) ; \n \t7 service <identifiersep> lock . write <identifiersep> lock ( ) . <identifier> ( ) ; } } \n \t4 } ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t3 <comment> \n \t3 if ( ! string <identifiersep> utils . is <identifiersep> empty ( api <identifiersep> key ) ) { \n \t4 add <identifiersep> <identifier> <identifiersep> <identifier> ( data , message <identifiersep> key <identifiersep> api <identifiersep> key , api <identifiersep> key ) ; \n \t3 } else { \n <ect>
\t9 item <identifiersep> type . get <identifiersep> class ( ) ) ; \n \t7 return null ; } \n \t6 return state ; } \n \t4 case <string_literal> : <comment> \n <ect>
\t1 { \n \t2 shutdown <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> cluster <identifiersep> <identifier> ) ; } \n \t1 catch ( exception e ) \n \t1 { \n <ect>
\t3 service <identifiersep> handler = new service <identifiersep> handler ( data ) ; \n \t3 <identifier> <identifiersep> thrift ( conf ) ; \n \t2 } catch ( throwable e ) { \n \t3 if ( e instanceof out <identifiersep> of <identifiersep> <identifier> <identifiersep> error ) { \n <ect>
\t1 <identifier> message . name == <identifier> : \n \t2 self . log . info ( <string_literal> ) \n \t2 self . task . input ( request [ <string_literal> ] , request [ <string_literal> ] ) \n \t1 <identifier> message . name == <identifier> : \n <ect>
\t3 new <identifier> <identifiersep> <identifier> <identifiersep> request ( ) . with <identifiersep> <identifier> <identifiersep> name ( <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) . with <identifiersep> key ( <identifier> . get <identifiersep> key <identifiersep> name ( ) ) . with <identifiersep> <identifier> <identifiersep> id ( <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ) \n \t4 . with <identifiersep> <identifier> <identifiersep> number ( <identifier> . get <identifiersep> <identifier> <identifiersep> number ( ) ) . with <identifiersep> <identifier> <identifiersep> size ( <identifier> . get <identifiersep> size ( ) ) . with <identifiersep> file ( new file ( <identifier> . get <identifiersep> file <identifiersep> name ( ) ) ) , <identifier> <identifiersep> token <identifiersep> <identifier> ) ; \n \t1 return <identifier> <identifiersep> <identifier> <identifiersep> result . get <identifiersep> <identifier> <identifiersep> e <identifiersep> <identifier> ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <comment> \n \t2 integer current <identifiersep> vm = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> vm <identifiersep> group <identifiersep> vm <identifiersep> map <identifiersep> dao . count <identifiersep> by <identifiersep> group ( as <identifiersep> group . get <identifiersep> id ( ) ) ; \n \t2 integer max <identifiersep> vm = as <identifiersep> group . get <identifiersep> max <identifiersep> <identifier> ( ) ; \n \t2 if ( current <identifiersep> vm + num <identifiersep> vm > max <identifiersep> vm ) { \n <ect>
\t3 return ; } \n \t2 final string device <identifiersep> id = map . key <identifiersep> set ( ) . <identifier> ( ) . next ( ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifiersep> thread <identifier> <identifiersep> thread = <identifier> <identifiersep> <identifier> . get ( device <identifiersep> id ) ; \n \t2 if ( <identifier> <identifiersep> thread == null ) { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> + <identifier> + <string_literal> + <identifier> + <string_literal> ) ; \n \t4 <comment> \n \t3 } catch ( exception e ) { \n \t4 <comment> \n <ect>
\t2 default : \n \t3 throw new runtime <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> type ) ; } \n \t2 { \n <ect>
\t4 string <identifier> = t . get ( 1 ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t4 string uri = t . get ( <number_literal> ) . get <identifiersep> uri ( ) ; \n \t4 map . put ( <identifier> , uri ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 table <identifiersep> name , \n \t2 job . get <identifiersep> configuration ( ) ) ; \n \t1 return ; \n \t1 } else if ( file <identifiersep> type == file <identifiersep> type . <identifier> <identifiersep> data <identifiersep> file ) { \n <ect>
\t3 <identifier> = <identifier> . max ( line <identifiersep> number / <identifier> <identifiersep> count , 1 ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t3 logger . info ( <string_literal> , <identifier> <identifiersep> data <identifiersep> file ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t7 <string_literal> + id + <string_literal> + <identifier> \n \t8 . get <identifiersep> <identifier> <identifiersep> source ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> set <identifiersep> id ( ) + <string_literal> ) ; \n \t6 <identifier> <identifiersep> collection <identifiersep> service . delete ( context , <identifier> ) ; \n \t5 } else { \n <ect>
\t4 int <identifier> <identifiersep> code = file . to <identifiersep> <identifier> <identifiersep> path ( ) . to <identifiersep> string ( ) . <identifier> <identifiersep> code ( ) ; \n \t4 if ( <identifier> . <identifier> ( <identifier> <identifiersep> code <identifier> total <identifiersep> <identifier> ) != thread <identifiersep> num ) { \n \t5 return file <identifiersep> <identifier> <identifiersep> result . continue ; } } \n \t3 if ( ! file . <identifier> <identifiersep> with ( input <identifiersep> root ) ) { \n <ect>
\t5 <string_literal> + <identifier> <identifiersep> wait <identifiersep> timeout <identifiersep> <identifier> + <string_literal> + \n \t5 <string_literal> ; \n \t3 throw new <identifier> <identifiersep> store <identifiersep> exception ( msg ) ; } } \n \t1 public void <identifier> ( ) { \n <ect>
\t2 get <identifiersep> <identifier> ( <identifier> <identifiersep> c <identifiersep> name ) . stop ( ) ; \n \t2 get <identifiersep> <identifier> ( <identifier> <identifiersep> c <identifiersep> name ) . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 remove <identifiersep> <identifier> ( <identifier> <identifiersep> c <identifiersep> name ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 try { \n \t4 data . get <identifiersep> <identifier> <identifiersep> cluster <identifiersep> state ( ) . <identifier> <identifiersep> <identifier> ( key , <identifier> <identifiersep> info , version <identifiersep> for <identifiersep> key ) ; \n \t3 } catch ( exception e ) { \n \t4 throw new t <identifiersep> exception ( <string_literal> , e ) ; } } \n <ect>
\t3 try { \n \t4 <identifier> . <identifier> ( context ) ; \n \t4 <identifier> . stop ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 <identifier> . put ( exchange . to <identifiersep> string ( ) , 1 ) ; \n \t3 } else { \n \t4 integer ++ ; \n \t4 <identifier> . put ( exchange . to <identifiersep> string ( ) , integer ) ; } \n <ect>
\t4 if ( unit . equals ( <identifier> <identifiersep> <identifier> [ <identifier> ] ) ) { \n \t5 <identifier> = <identifier> <identifiersep> <identifier> [ <identifier> ] ; \n \t5 break ; } } \n \t3 if ( <identifier> == 0 ) { \n <ect>
\t3 set <identifiersep> table <identifiersep> property <identifiersep> result result = new set <identifiersep> table <identifiersep> property <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t2 try ( final <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( <identifier> . get <identifiersep> security <identifiersep> context ( ) ) . <identifier> ( ) ) { \n \t3 node . set <identifiersep> property ( key , null ) ; \n \t3 <identifier> . success ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> end ( root \n \t4 . get <identifiersep> element ( root . get <identifiersep> element <identifiersep> count ( ) - 1 ) , text ) ; } \n \t2 catch ( <identifier> <identifiersep> location <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 set < string > <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( cluster <identifiersep> state , <identifier> <identifiersep> <identifier> ) ; \n \t2 for ( string <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> . remove ( <identifier> <identifiersep> <identifier> ) ; } \n \t2 for ( string <identifier> <identifiersep> id : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> ( url url ) throws <identifier> <identifiersep> exception { \n \t2 string class <identifiersep> name = url . get <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> key , <string_literal> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> empty ( class <identifiersep> name ) || <identifier> . contains ( class <identifiersep> name ) ) { \n \t3 return ; } \n <ect>
\t2 file <identifier> = create <identifiersep> <identifier> <identifiersep> dir ( <string_literal> , <string_literal> ) ; \n \t2 if ( <identifier> . delete ( ) || <identifier> . delete ( ) ) \n \t3 log . debug ( <string_literal> , <identifier> ) ; \n \t2 if ( ! <identifier> . <identifier> ( ) ) \n <ect>
\t5 delete <identifiersep> <identifier> <identifiersep> server <identifiersep> and <identifiersep> default <identifiersep> pool ( <identifier> <identifiersep> server <identifiersep> name ) ; \t3 } } \n \t3 <identifier> <identifiersep> configuration ( ) ; \t4 \n \t3 return new answer ( cmd ) ; \t2 \n \t2 } catch ( execution <identifiersep> exception e ) { \n <ect>
\t1 case <identifier> : \n \t1 { \n \t2 if ( <identifier> <identifiersep> properties . get ( property <identifiersep> <identifier> . <identifier> <identifiersep> key <identifiersep> <identifier> ) == null ) \n \t2 { \n <ect>
\t3 if ( <identifier> <identifiersep> boolean ( ) && i > 0 ) { <comment> \n \t4 int <identifier> <identifiersep> count = <identifier> <identifiersep> <identifier> [ i - 1 ] ; \n \t4 if ( <identifier> <identifiersep> count > 0 ) { \n \t5 int delete <identifiersep> count = <identifier> <identifiersep> int <identifiersep> <identifier> ( 1 , <identifier> <identifiersep> count ) ; \n <ect>
\t2 for ( host <identifiersep> vo host : <identifier> ) { \n \t3 try { \n \t4 <identifier> <identifiersep> storage <identifiersep> <identifier> . <identifier> <identifiersep> host <identifiersep> to <identifiersep> <identifier> <identifiersep> pool ( host . get <identifiersep> id ( ) , data <identifiersep> store . get <identifiersep> id ( ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 public builder ( <identifier> <identifier> ) { \n \t2 super ( <identifier> ) ; } \n \t1 public builder ( ) { } \n \t1 public <identifier> build ( ) throws exception { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> <identifiersep> action , log ) ; } \n \t3 if ( <identifier> . get <identifiersep> status ( ) != <identifier> <identifiersep> job . status . <identifier> \n \t5 && <identifier> . get <identifiersep> status ( ) != <identifier> <identifiersep> job . status . <identifier> ) { \n \t4 queue ( new <identifier> <identifiersep> action <identifiersep> <identifier> <identifiersep> x <identifiersep> command ( <identifier> <identifiersep> action . get <identifiersep> job <identifiersep> id ( ) ) ) ; } \n <ect>
\t4 <identifier> . send ( new test <identifiersep> job ( ) , node ) ; \n \t4 assert false ; } \n \t3 catch ( grid <identifiersep> exception e ) { \n <ect>
\t6 new t <identifiersep> file ( file <identifiersep> <identifier> <identifiersep> <identifier> ) . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> file ) ; \n \t6 try { \n \t7 t <identifiersep> file . <identifier> ( file <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t6 } catch ( exception e ) { \n <ect>
\t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 log . error ( e , <string_literal> ) ; \n \t3 throw new runtime <identifiersep> exception ( e ) ; \n \t2 } catch ( execution <identifiersep> exception e ) { \n <ect>
\t1 <identifier> = <identifier> . <identifier> <identifiersep> user , \n \t1 group = <identifier> . user <identifiersep> group , \n \t1 content = <identifier> <identifiersep> template ( <identifier> . <identifier> <identifiersep> <identifier> ) \n \t1 ) \n <ect>
\t2 <comment> \n \t2 service . stop ( ) ; \n \t2 context . close ( ) ; \n \t2 super . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t1 public void context <identifiersep> <identifier> ( <identifier> <identifiersep> context <identifiersep> event <identifier> ) { \n \t2 try { \n \t3 <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( next == null ) { \n \t4 p <identifiersep> <identifier> . set ( this ) ; \n \t4 return ; } \n \t3 if ( this . is <identifiersep> value <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 public void <identifier> <identifiersep> node <identifiersep> <identifier> ( list < <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo > node <identifiersep> list ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t3 for ( <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo <identifier> : node <identifiersep> list ) { \n <ect>
\t1 public void close ( ) { \n \t2 this . <identifier> <identifiersep> pool . <identifier> ( this ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifier> ( final class type , final <identifier> <identifier> ) { \n <ect>
\t10 throw <identifier> ; } \n \t8 } else { \n \t9 log . error ( <string_literal> , principal , <identifier> ) ; } } } \n \t5 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 try { \n \t4 file <identifiersep> status data <identifiersep> status = <identifier> \n \t5 . get <identifiersep> file <identifiersep> status ( new path ( file <identifiersep> status . get <identifiersep> path ( ) , map <identifiersep> file . data <identifiersep> file <identifiersep> name ) ) ; \n \t4 if ( data <identifiersep> status . is <identifiersep> directory ( ) ) { \n <ect>
\t3 <identifier> = result . get <identifiersep> json <identifiersep> array ( <string_literal> ) ; \n \t3 assert . assert <identifiersep> equals ( <identifier> . length ( ) , <number_literal> ) ; \n \t3 logger . info ( <string_literal> ) ; \n \t3 failure ( <identifier> , request , response , <identifier> <identifiersep> lock , <string_literal> , <identifier> , <string_literal> , user , <string_literal> , integer . to <identifiersep> string ( all ) , <string_literal> , <string_literal> ) ; \n <ect>
\t5 properties <identifier> = new properties ( ) ; \n \t5 for ( properties <identifier> : properties ) { \n \t6 <identifier> . put <identifiersep> all ( <identifier> ) ; } \n \t5 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t5 this . logger . error ( <string_literal> , e ) ; } \n \t4 catch ( listener <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t5 this . logger . error ( <string_literal> , e ) ; } \n \t4 catch ( io <identifiersep> exception e ) { \n <ect>
\t2 if ( ! this . metadata <identifiersep> location . exists ( ) ) { \n \t3 logger . debug ( <string_literal> , this . metadata <identifiersep> location ) ; \n \t3 if ( ! this . metadata <identifiersep> location . <identifier> ( ) ) { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + this . metadata <identifiersep> location + <string_literal> ) ; } } \n <ect>
\t4 <identifier> = <identifier> <identifiersep> <identifier> . next ( ) ; \n \t4 try { \n \t5 logger . info ( <string_literal> + <identifier> . to <identifiersep> string ( ) ) ; \n \t5 <identifier> <identifiersep> is <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> with <identifiersep> it ( store <identifiersep> name , <identifier> <identifiersep> version , <identifier> <identifiersep> response <identifiersep> map ) ; \n <ect>
\t3 { \n \t4 <identifier> . load <identifiersep> server <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 catch ( exception | <identifier> <identifiersep> error ex ) \n \t3 { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = null ; \n \t2 try { \n \t3 <identifier> = <identifier> . read <identifiersep> value ( <identifier> <identifiersep> file , <identifier> <identifiersep> <identifier> . class ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 if ( get <identifiersep> <identifier> ( ) != null ) { \n \t3 base <identifiersep> <identifier> . add <identifiersep> all ( get <identifiersep> <identifier> ( ) ) ; \n \t3 total <identifiersep> <identifier> . add <identifiersep> all ( get <identifiersep> <identifier> ( ) ) ; } \n <ect>
\t3 storage . on <identifiersep> <identifier> ( context ) ; \n \t3 this . <identifier> = new <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> ( this , storage ) ; \n \t3 <identifier> ( context ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t1 <comment> \n \t1 object <identifiersep> entity = object <identifiersep> entity . new <identifiersep> <identifier> <identifiersep> for <identifiersep> create ( <identifier> , request . get <identifiersep> key ( ) , 0 , request <identifiersep> user ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> client ( this ) ; \n \t2 <identifier> <identifiersep> path = request . get <identifiersep> query <identifiersep> string ( ) ; } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> web <identifiersep> socket <identifiersep> close ( final int close <identifiersep> code , final string message ) { \n <ect>
\t3 throw new xml <identifiersep> <identifier> <identifiersep> exception ( - <number_literal> , e . get <identifiersep> message ( ) ) ; \n \t2 } finally { \n \t3 long end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 float <identifier> = ( end <identifiersep> time - start <identifiersep> time ) / <number_literal> ; <comment> \n <ect>
\t4 throw new <identifier> <identifiersep> configuration <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> file + <string_literal> , e ) ; } } \n \t2 <identifier> = null ; \n \t2 string <identifier> <identifiersep> file = <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( header + <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> file != null ) { \n <ect>
\t1 public void <identifier> <identifiersep> remove <identifiersep> <identifier> ( ) \n \t1 { \n \t2 if ( ! <identifier> <identifiersep> nodes . is <identifiersep> empty ( ) || token <identifiersep> metadata . get <identifiersep> size <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> ( ) > 0 ) \n \t2 { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t1 string [ ] <identifier> = <identifier> <identifiersep> and <identifiersep> <identifier> . <identifier> ( <string_literal> ) ; \n \t1 if ( <identifier> . length == <number_literal> ) { \n \t2 <comment> \n \t2 try { \n <ect>
\t2 factory <identifiersep> configuration <identifier> <identifiersep> provider <identifiersep> config = new factory <identifiersep> configuration ( ) ; \n \t2 <identifier> <identifiersep> provider <identifiersep> config . set <identifiersep> class ( <identifier> <identifiersep> cache <identifiersep> manager <identifiersep> <identifier> <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) ) ; \n \t2 <identifier> < network <identifiersep> utils . ip <identifiersep> port <identifiersep> <identifier> , string > properties ; \n \t2 if ( string <identifiersep> utils . equals ( get <identifiersep> cluster <identifiersep> mode ( ) , <string_literal> ) ) { \n <ect>
\t3 throw new runtime <identifiersep> exception ( <string_literal> ) ; } \n \t2 catch ( execution <identifiersep> exception e ) \n \t2 { \n \t3 <comment> \n <ect>
\t1 private void set <identifiersep> <identifier> <identifiersep> name ( content <identifiersep> name n ) { \n \t2 <comment> \n \t2 <identifier> <identifiersep> base <identifiersep> <identifier> <identifiersep> name = n ; \n \t2 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) \n <ect>
\t6 break ; } \n \t5 event <identifiersep> <identifier> . wait <identifiersep> no <identifiersep> <identifier> <identifiersep> exception ( <identifier> ) ; } } \n \t2 } catch ( exception e ) { \n \t3 logger . error ( <string_literal> , <identifier> , e . get <identifiersep> message ( ) ) ; \n <ect>
\t2 <identifier> <identifiersep> host <identifiersep> server <identifiersep> resource resource = new <identifier> <identifiersep> host <identifiersep> server <identifiersep> resource ( ) ; \n \t2 try { \n \t3 resource . <identifier> ( <string_literal> , <identifier> ) ; \n \t2 } catch ( configuration <identifiersep> exception e ) { \n <ect>
\t1 web <identifiersep> socket <identifiersep> url = <identifier> <identifiersep> message . get ( string . class , message <identifiersep> <identifier> . web <identifiersep> socket <identifiersep> url ) ; \n \t1 web <identifiersep> socket <identifiersep> token = <identifier> <identifiersep> message . get ( string . class , message <identifiersep> <identifier> . web <identifiersep> socket <identifiersep> token ) ; \n \t1 <identifier> = ( web <identifiersep> socket <identifiersep> url == null || web <identifiersep> socket <identifiersep> token == null ) ; \n \t1 if ( <identifier> ) { \n <ect>
\t5 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this . m <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get ( i ) , this . m <identifiersep> <identifier> <identifiersep> count ) ; } \n \t4 <comment> \n \t2 catch ( runtime <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 array <identifiersep> list < <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = new array <identifiersep> list < <identifier> <identifiersep> <identifier> > ( ) ; \n \t2 for ( class < ? extends <identifier> > <identifier> : <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . create ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t3 if ( ! <identifier> . get <identifiersep> <identifier> ( ) . is <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> ( ) ) { \n <ect>
\t9 new <identifiersep> files . remove ( <identifier> <identifiersep> file ) } \n \t8 <identifier> <identifiersep> manager . <identifier> <identifiersep> of <identifiersep> file <identifiersep> <identifier> ( <identifier> <identifiersep> file ) } } \n \t6 new <identifiersep> files . <identifier> ( ) \n \t5 } catch ( <identifier> <identifiersep> failed <identifiersep> exception <identifier> ) { \n <ect>
\t6 <comment> \n \t5 } else { \n \t6 logger . error ( <string_literal> , item <identifiersep> name , command <identifiersep> as <identifiersep> string ) ; } \n \t4 } else { \n <ect>
\t3 return new <identifier> <identifiersep> ticket <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t4 <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> key ( ) , \n \t4 <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> key ( ) , \n \t4 <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> <identifiersep> data <identifiersep> response ) ; \n \t2 if ( <identifier> <identifiersep> data <identifiersep> response . is <identifiersep> error ( ) ) { \n \t3 final <identifier> <identifiersep> error error = <identifier> <identifiersep> data <identifiersep> response . get <identifiersep> error ( ) ; \n \t3 if ( error . is <identifiersep> access <identifiersep> token <identifiersep> <identifier> ( ) || error . is <identifiersep> token <identifiersep> not <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t5 <identifier> <identifiersep> object <identifiersep> delete <identifiersep> request . set <identifiersep> <identifier> ( <identifier> ) ; \n \t5 client . delete <identifiersep> <identifier> ( <identifier> <identifiersep> object <identifiersep> delete <identifiersep> request ) ; } \n \t3 } catch ( exception ex ) { \n <ect>
\t4 logger . debug ( <string_literal> , current <identifiersep> <identifier> , <identifier> <identifiersep> class ) ; \n \t4 <identifier> . remove ( current <identifiersep> <identifier> ) ; \n \t4 <identifier> . add ( <identifier> <identifiersep> class ) ; \n \t3 } else { \n <ect>
\t8 if ( has <identifiersep> <identifier> ( <identifier> <identifiersep> config , <identifier> . get ( <identifier> <identifiersep> config ) , <identifier> ) ) { \n \t9 <identifier> . put ( <identifier> <identifiersep> config , <identifier> ) ; \n \t9 <identifier> ( <identifier> <identifiersep> config , <identifier> ) ; } } \n \t6 } ) ; \n <ect>
\t5 count ++ ; \n \t5 try { \n \t6 thread . <identifier> ( <number_literal> ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 send <identifiersep> <identifier> ( <identifier> , 1 ) ; \n \t2 <comment> \n \t2 send <identifiersep> <identifier> ( queue ) ; \n <ect>
\t5 string key = e . next <identifiersep> element ( ) ; \n \t5 object <identifier> = <identifier> . get ( key ) ; \n \t5 config <identifiersep> <identifier> <identifiersep> <identifier> . put ( key , <identifier> ) ; } } \n \t3 if ( should <identifiersep> update ( config <identifiersep> <identifier> <identifiersep> <identifier> , config <identifiersep> map <identifiersep> <identifier> ) ) { \n <ect>
\t4 ( integer ) <identifier> . <identifier> <identifiersep> from <identifiersep> command <identifiersep> to <identifiersep> value ( item , command ) , db <identifiersep> <identifier> . size ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> message <identifier> <identifiersep> message = command <identifiersep> class . set <identifiersep> config <identifiersep> message ( configuration <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> message == null ) { \n <ect>
\t5 <comment> \n \t5 <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> context <identifiersep> map ( ) . put ( <string_literal> , <identifier> ) ; } } \n \t3 <comment> \n \t3 if ( <identifier> == null ) { \n <ect>
\t4 final <identifier> <identifiersep> address <identifier> <identifiersep> address = <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> name ( c . get <identifiersep> remote <identifiersep> address ( ) . <identifier> ( ) ) ; \n \t4 if ( contains <identifiersep> address ( this . <identifier> <identifiersep> network <identifiersep> <identifier> , this . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> address ) ) { \n \t5 return new default <identifiersep> authentication <identifiersep> handler <identifiersep> execution <identifiersep> result ( this , c , this . principal <identifiersep> factory . create <identifiersep> principal ( c . get <identifiersep> id ( ) ) ) ; } \n \t3 } catch ( final <identifier> <identifiersep> host <identifiersep> exception e ) { \n <ect>
\t4 int i = m . get <identifiersep> int <identifiersep> property ( <string_literal> ) ; \n \t4 <comment> \n \t4 if ( i < max <identifiersep> <identifier> ) { \n \t5 if ( <identifier> <identifiersep> <identifier> [ i ] == 1 ) { \n <ect>
\t1 write <identifiersep> <identifier> . <identifier> read <identifiersep> <identifier> ) { \n \t1 int <identifier> <identifiersep> key <identifiersep> length <identifiersep> length = \n \t2 ( int ) ( ( key <identifiersep> <identifier> <identifiersep> <identifier> & <identifier> <identifiersep> key <identifiersep> length . <identifier> <identifiersep> <identifier> ) > > <identifier> <identifiersep> key <identifiersep> length . <identifier> <identifiersep> <identifier> ) ; \n \t1 boolean is <identifiersep> key <identifiersep> length <identifiersep> <identifier> = ( <identifier> <identifiersep> key <identifiersep> length <identifiersep> length != <identifier> <identifiersep> key <identifiersep> length . all <identifiersep> <identifier> <identifiersep> on ) ; \n <ect>
\t3 <identifier> <identifiersep> execution <identifiersep> <identifier> ( \n \t4 job <identifiersep> id , \n \t4 <identifier> <identifiersep> execution <identifiersep> <identifier> . create <identifiersep> from ( <identifier> ) ) ) \n \t2 } catch { \n <ect>
\t1 this . <identifier> = true ; \n \t1 this . client <identifiersep> <identifier> . add <identifiersep> listener ( new <identifier> . listener ( ) { \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) { \n <ect>
\t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> dir . exists ( ) ) { \n \t3 logger . error ( this , <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> dir . get <identifiersep> path ( ) ) ; \n \t3 return false ; } \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> dir . is <identifiersep> directory ( ) ) { \n <ect>
\t2 i ++ ; \n \t2 thread . <identifier> ( <number_literal> ) ; \n \t2 if ( 0 == i <identifier> <number_literal> ) { \n \t2 log . info ( <string_literal> , i ) ; } } \n <ect>
\t4 <comment> \n \t4 if ( count >= max <identifiersep> lock <identifiersep> <identifier> ) { \n \t5 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + lock <identifiersep> key + <string_literal> + count + <string_literal> ) ; } \n <ect>
\t1 @ <identifier> \n \t1 public void handle <identifiersep> <identifier> <identifiersep> <identifier> ( long <identifier> <identifiersep> id ) { \n \t2 host <identifiersep> vo storage <identifiersep> host = <identifier> <identifiersep> server <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> <identifiersep> id ) ; \n \t2 if ( storage <identifiersep> host == null ) { \n <ect>
\t3 request . get <identifiersep> <identifier> ( ) . put <identifiersep> all ( this . <identifier> ) ; \n \t3 request . get <identifiersep> <identifier> ( ) . set <identifiersep> <identifier> ( \n \t5 <identifier> . as <identifiersep> list ( <identifier> <identifiersep> type . application <identifiersep> json , <identifier> <identifiersep> type . application <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; \n <ect>
\t2 file <identifier> <identifiersep> file = new file ( <identifier> , <identifier> + <string_literal> ) ; \n \t2 file source <identifiersep> file = new file ( <identifier> , <identifier> + <string_literal> ) ; \n \t2 file <identifier> <identifiersep> file = new file ( <identifier> , <identifier> + <string_literal> ) ; \n \t2 file <identifier> <identifiersep> file = new file ( <identifier> , <string_literal> ) . get <identifiersep> <identifier> <identifiersep> file ( ) ; \n <ect>
\t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 logger . warn ( <string_literal> , <identifier> ) ; \n \t3 return null ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
\t4 start <identifiersep> <identifier> ( ) ; } } } \n \t1 protected void start <identifiersep> <identifier> ( ) { \n \t2 synchronized ( this . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name = ( string ) <identifier> . get ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name == null ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name = <string_literal> ; } \n <ect>
\t3 log . warn ( <identifier> <identifiersep> <identifier> <identifiersep> utils . class , <string_literal> ) ; \n \t3 return 0 ; } \n \t2 if ( <identifier> == null ) \n \t2 { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> command ( string item <identifiersep> name , command command ) { \n \t2 if ( item <identifiersep> name == null ) { \n <ect>
private <identifier> function : map <identifiersep> function [ in , out ] = <identifier> <identifiersep> <identifier> \n <identifier> <identifier> <identifier> ( <identifier> : configuration ) : unit = { \n \t1 log . debug ( s <string_literal> ) \n \t1 <identifier> <identifier> = <identifier> ( get <identifiersep> runtime <identifiersep> context . get <identifiersep> user <identifiersep> code <identifiersep> class <identifiersep> <identifier> , name , code ) \n <ect>
\t9 object [ ] <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> map < string , long > meta <identifiersep> <identifier> <identifiersep> time <identifiersep> map , \n \t9 class < ? extends i <identifiersep> meta <identifiersep> store <identifiersep> client > <identifier> <identifiersep> client <identifiersep> class ) throws meta <identifiersep> exception { \n \t1 this . <identifier> = get <identifiersep> <identifier> ( ) ; \n \t1 if ( this . <identifier> == null ) { \n <ect>
\t2 logger . debug ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void stop ( <identifier> <identifiersep> context context ) throws exception { \n \t2 context = null ; \n <ect>
\t3 { \n \t4 log . error ( <string_literal> , e ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) \n \t3 { \n <ect>
\t3 <identifier> <identifier> = <identifier> . <identifier> ( <identifier> ) ; \n \t3 system . add <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 list < string > <identifier> = options . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 file index = get <identifiersep> file ( <identifier> . remove ( 0 ) ) ; \n <ect>
\t3 if ( max <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t4 try { \n \t5 i <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> = integer . parse <identifiersep> int ( max <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t4 end <identifiersep> key = null ; \n \t4 logger . trace ( <string_literal> ) ; } \n \t3 if ( null == start <identifiersep> key && null == end <identifiersep> key ) { \n \t4 <identifier> . check <identifiersep> state ( 1 == <identifier> . size ( ) ) ; \n <ect>
\t2 server <identifiersep> factory . set <identifiersep> file <identifiersep> system ( new <identifier> <identifiersep> file <identifiersep> system <identifiersep> factory ( ) ) ; \n \t2 listener <identifiersep> factory factory = new listener <identifiersep> factory ( ) ; \n \t2 factory . set <identifiersep> port ( port ) ; \n \t2 server <identifiersep> factory . add <identifiersep> listener ( <string_literal> , factory . create <identifiersep> listener ( ) ) ; \n <ect>
\t4 <identifier> <identifiersep> method . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t3 } catch ( throwable e ) { \n \t4 logger . error ( <identifier> . get <identifiersep> method <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> method + <string_literal> + <identifier> . get <identifiersep> url ( ) , e ) ; } \n \t2 } else { \n <ect>
\t2 } catch ( json <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> , e ) ; \n \t3 <identifier> . write ( error <identifiersep> response ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 byte <identifiersep> <identifier> <identifier> = entry . get <identifiersep> key ( ) . <identifier> ( ) ; \n \t4 <identifier> <identifiersep> map . put ( from <identifiersep> byte <identifiersep> <identifier> ( <identifier> ) , entry . get <identifiersep> value ( ) ) ; } \n \t3 catch ( <identifier> <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t3 <identifier> <identifiersep> log . info ( <string_literal> + to <identifiersep> string ( ) , new exception ( <string_literal> ) ) ; \n \t2 <identifier> <identifiersep> connection to <identifiersep> close = <identifier> <identifiersep> close ( <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( to <identifiersep> close != null && to <identifiersep> close != this ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> ) { \n \t5 <identifier> . add ( <identifier> ) ; } } \n \t3 return <identifier> ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 final load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> instance update = <identifier> . <identifier> <identifiersep> result ( instance ) ; \n \t3 update . set <identifiersep> <identifier> <identifiersep> state ( load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> instance . <identifier> <identifiersep> state . <identifier> ) ; \n \t3 db . <identifier> ( ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception ex ) { \n <ect>
\t6 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t7 this . store <identifiersep> entry <identifiersep> as <identifiersep> file ( <identifier> , <identifier> <identifiersep> <identifier> , \n <number_literal> config ) ; } \n \t5 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> store ( ) ; \n \t2 <identifier> = null ; } \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> store ( ) { \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> store == null && <identifier> <identifiersep> <identifier> <identifiersep> store <identifiersep> type == <identifier> <identifiersep> store <identifiersep> type . <identifier> ) { \n <ect>
\t1 <identifier> . set <identifiersep> object <identifiersep> <identifier> <identifiersep> <identifier> ( response . get <identifiersep> last <identifiersep> <identifier> ( ) ) ; \n \t1 <identifier> . set <identifiersep> <identifier> <identifiersep> id ( response . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t1 log . trace ( <string_literal> + response . get <identifiersep> status <identifiersep> message ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t7 <comment> \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> . add <identifiersep> all ( not <identifiersep> <identifier> ) ; \n \t6 } catch ( runtime <identifiersep> exception e ) { } \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 string [ ] <identifier> = <identifier> . <identifier> ( <string_literal> ) ; \n \t3 int count = <identifier> . length ; \n \t3 assert <identifiersep> equals ( <number_literal> , count ) ; \n \t2 } catch ( exception e ) { \n <ect>
public class <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> log <identifiersep> <identifier> { \n \t1 public static void log <identifiersep> <identifier> <identifiersep> failure ( logger logger , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , throwable t ) { \n \t2 logger . error ( <string_literal> + <identifier> . get <identifiersep> connection <identifiersep> string ( ) , t ) ; } \n \t1 public static void log <identifiersep> <identifier> <identifiersep> failure ( logger logger , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , string device , throwable t ) { \n <ect>
\t3 if ( ! <identifier> . get <identifiersep> <identifier> ( ) . equals ( <identifier> ) ) { \n \t4 logger . error ( <string_literal> ) ; \n \t4 return null ; } \n \t3 if ( <identifier> . get <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) || ! <identifier> . get <identifiersep> <identifier> ( ) . get ( 0 ) . equals ( <identifier> ) ) { \n <ect>
\t3 try { \n \t4 if ( <identifier> != null ) \n \t5 <identifier> . close ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public boolean is <identifiersep> <identifier> <identifiersep> in ( ) { \n \t2 session session = request . get <identifiersep> session <identifiersep> <identifier> ( false ) ; \n \t2 if ( session == null ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( int <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 if ( default <identifiersep> group . is <identifiersep> <identifier> ( ) ) \n \t5 update <identifiersep> default <identifiersep> security <identifiersep> group ( default <identifiersep> group . get ( ) ) ; } \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( final exception ex ) { \n <ect>
\t6 final <identifier> <identifiersep> password <identifiersep> policy <identifiersep> configuration <identifier> = create <identifiersep> <identifier> <identifiersep> password <identifiersep> policy <identifiersep> configuration ( <identifier> , <identifier> , <identifier> <identifiersep> map <identifiersep> attributes ) ; \n \t6 handler . set <identifiersep> password <identifiersep> policy <identifiersep> configuration ( <identifier> ) ; } \n \t5 final map < string , object > attributes = collection <identifiersep> utils . <identifier> ( <identifier> <identifiersep> map <identifiersep> attributes ) ; \n \t5 handler . set <identifiersep> principal <identifiersep> attribute <identifiersep> map ( attributes ) ; \n <ect>
\t3 if ( ! result . first ( ) ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> ip + <string_literal> + result . <identifier> ( ) ) ; \n \t4 return new answer ( cmd , false , <string_literal> + result . <identifier> ( ) ) ; } \n <ect>
\t2 config . <identifier> ( ) ; \n \t2 if ( ! config . is <identifiersep> <identifier> ( ) \n \t4 || config . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null ) { \n \t3 if ( <identifier> == null ) { \n <ect>
\t1 is <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n \t1 connection <identifiersep> <identifier> . <identifier> ( ) ; \n \t1 log . info ( <string_literal> + job <identifiersep> id ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t1 public synchronized void on <identifiersep> message ( message m ) { \n \t2 try { \n \t3 object <identifiersep> message = ( object <identifiersep> message ) m ; \n \t3 <identifier> <identifiersep> message ( object <identifiersep> message , <identifier> ) ; \n <ect>
\t7 <identifier> . element , <identifier> . <identifier> , item . <identifier> ) ; \n \t3 item <identifiersep> service . add <identifiersep> metadata ( <identifier> <identifiersep> service . get <identifiersep> context ( ) , item , <identifier> . <identifier> , \n \t9 <identifier> . element , <identifier> . <identifier> , null , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void stop ( <identifier> <identifiersep> context <identifier> ) throws exception { \n <ect>
\t2 if ( <identifier> <identifiersep> token != token ) { \n \t3 log . info ( <string_literal> ) ; \n \t3 <identifier> = instance . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> user <identifiersep> name ( ) , <identifier> <identifiersep> token ) ; \n \t2 } else { \n <ect>
\t2 try { \n \t2 c . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 boolean <identifier> <identifiersep> <identifier> ; \n \t2 boolean <identifier> <identifiersep> <identifier> ; \n \t2 @ <identifier> \n \t2 public void on <identifiersep> <identifier> ( ) { \n <ect>
\t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n \t6 <identifier> <identifiersep> log . debug ( <string_literal> + entry ) ; \n \t5 <identifier> . add ( entry ) ; } } } \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t6 get <identifiersep> channel ( ) . send ( <identifier> , msg , get <identifiersep> channel <identifiersep> send <identifiersep> options ( ) ) ; } \n \t5 entry . set <identifiersep> <identifier> <identifiersep> nodes ( <identifier> ) ; \n \t5 entry . set <identifiersep> <identifier> ( channel . get <identifiersep> local <identifiersep> <identifier> ( false ) ) ; \n \t4 } catch ( channel <identifiersep> exception x ) { \n <ect>
\t2 throws no <identifiersep> such <identifiersep> object <identifiersep> exception , meta <identifiersep> exception , t <identifiersep> exception { \n \t1 try { \n \t2 return get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> resource <identifiersep> <identifier> ( request . get <identifiersep> resource <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t1 } catch ( meta <identifiersep> exception e ) { \n <ect>
\t1 public void <identifier> <identifiersep> authentication <identifiersep> service <identifiersep> <identifier> <identifiersep> <identifier> ( final authentication <identifiersep> service <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> server <identifiersep> url ( ) ) ) { \n \t3 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id <identifiersep> p <identifiersep> entity <identifiersep> id <identifiersep> authentication <identifiersep> service <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 } else { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> . get <identifiersep> id ( ) ) ; \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } else if ( <identifier> . get <identifiersep> <identifier> ( ) == <number_literal> ) { <comment> \n <ect>
\t1 text <identifiersep> <identifier> <identifier> ; \n \t1 if ( command <identifiersep> state . get <identifiersep> instance ( <identifier> ) . get <identifiersep> mode ( ) == command <identifiersep> state . mode . <identifier> ) { \n \t1 <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t3 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n \t4 <identifier> <identifiersep> log . warn ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) + <string_literal> , <identifier> ) ; \n \t4 <identifier> = true ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 if ( local <identifiersep> dir <identifiersep> list != null && ! local <identifiersep> dir <identifiersep> list . is <identifiersep> empty ( ) ) { \n \t1 log . info ( <string_literal> , local <identifiersep> dir <identifiersep> list ) ; \n \t1 if ( ! local <identifiersep> dir <identifiersep> list . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) && \n \t2 ! string <identifiersep> utils . is <identifiersep> blank ( local <identifiersep> dir <identifiersep> list ) ) { \n <ect>
\t3 <identifier> <identifier> = new <identifier> ( ) ; \n \t3 for ( <identifier> <identifiersep> <identifier> <identifier> : out <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 key <identifiersep> <identifier> <identifier> = new key <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t4 if ( <identifier> . contains ( <identifier> ) ) { \n <ect>
\t5 <identifier> . get ( ) . get <identifiersep> root <identifiersep> <identifier> ( null ) . stop <identifiersep> <identifier> ( ) ; \n \t5 configuration . set <identifiersep> <identifier> <identifiersep> cache ( false ) ; \n \t5 return ; } \n \t3 } else { \n <ect>
\t3 final file properties <identifiersep> file = new file ( <identifier> <identifiersep> path + <string_literal> ) ; \n \t3 try ( final <identifier> <identifier> = new file <identifiersep> <identifier> ( properties <identifiersep> file ) ) { \n \t4 properties . store ( <identifier> , <string_literal> + new date ( ) ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 string <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t1 file <identifier> <identifiersep> file <identifiersep> <identifier> = new file ( <identifier> <identifiersep> <identifier> ) ; \n \t1 if ( <identifier> <identifiersep> file <identifiersep> <identifier> . exists ( ) ) { \n <ect>
\t2 <identifier> . <identifier> ( ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void <identifier> <identifiersep> <identifier> ( ) throws io <identifiersep> exception , no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception { \n <ect>
\t1 public boolean delete <identifiersep> vm <identifiersep> snapshot <identifiersep> from <identifiersep> db ( vm <identifiersep> snapshot vm <identifiersep> snapshot ) { \n \t2 try { \n \t3 vm <identifiersep> snapshot <identifiersep> <identifier> . vm <identifiersep> snapshot <identifiersep> state <identifiersep> <identifier> <identifiersep> to ( vm <identifiersep> snapshot , vm <identifiersep> snapshot . event . <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( no <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } catch ( exception e ) { \n \t3 <comment> \n \t3 <comment> \n \t3 <identifier> = false ; \n <ect>
\t2 <identifier> ( exchange ) ; \n \t2 byte [ ] bytes = <identifier> <identifiersep> as <identifiersep> bytes ( exchange ) ; \n \t2 return new bytes <identifiersep> source ( bytes ) ; } \n \t1 public node <identifier> <identifiersep> as <identifiersep> <identifier> ( exchange exchange ) throws exception { \n <ect>
\t5 vm <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> <identifier> ( ) ; \n \t5 vm <identifiersep> <identifier> . <identifier> ( ) ; } } \n \t2 } catch ( throwable e ) { \n \t3 if ( e instanceof remote <identifiersep> exception ) { \n <ect>
\t1 map < string , service <identifiersep> info > service <identifiersep> info <identifiersep> map = null ; \n \t1 try { \n \t1 service <identifiersep> info <identifiersep> map = <identifier> <identifiersep> meta <identifiersep> info . get <identifiersep> <identifier> ( <identifier> <identifiersep> stack <identifiersep> version . get <identifiersep> stack <identifiersep> name ( ) , <identifier> <identifiersep> stack <identifiersep> version . get <identifiersep> stack <identifiersep> version ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> object <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t1 <identifier> < string > <identifier> = new <identifier> <identifiersep> <identifier> < string > ( ) ; \n \t1 <identifier> < string > <identifier> = <identifier> <identifiersep> map . put <identifiersep> if <identifiersep> <identifier> ( key , <identifier> ) ; \n \t1 return <identifier> == null ? <identifier> : <identifier> ; } \n public void set <identifiersep> <identifier> ( string key , string value ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void all <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> provider provider ) { \n <ect>
\t3 self . <identifier> , \n \t3 self . <identifier> [ <string_literal> ] ) \n \t2 self . logger . debug ( <string_literal> ) \n \t2 self . <identifier> <identifiersep> <identifier> . update ( self . <identifier> , state = <identifier> ) \n <ect>
\t2 finally { \n \t3 <identifier> . <identifier> ( ) ; } } \n \t1 protected void handle <identifiersep> <identifier> <identifiersep> message ( final <identifier> <identifier> <identifiersep> <identifier> , final address <identifier> , final <identifier> <identifiersep> id <identifier> <identifiersep> id ) { \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t1 protected set < event > <identifier> <identifiersep> event <identifiersep> for <identifiersep> provider <identifiersep> in <identifiersep> context ( final principal principal , \n <number_literal> final registered <identifiersep> service service , \n <number_literal> final request <identifiersep> context context , \n <number_literal> final <identifier> <identifiersep> authentication <identifiersep> provider provider ) { \n <ect>
\t3 if ( <identifier> != null && network . get <identifiersep> network <identifiersep> <identifier> <identifiersep> id ( ) != null ) { \n \t4 s <identifiersep> logger . error ( <string_literal> ) ; \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t3 if ( <identifier> != null && ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager . check <identifiersep> if <identifiersep> <identifier> <identifiersep> template <identifiersep> <identifier> ( network . get <identifiersep> <identifier> <identifiersep> id ( ) , <identifier> . get <identifiersep> value ( ) , network . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) , null ) ) { \n <ect>
\t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> context <identifier> <identifiersep> context , url <identifiersep> class <identifiersep> <identifier> <identifier> ) \n \t3 throws <identifier> <identifiersep> url <identifiersep> exception , uri <identifiersep> <identifier> <identifiersep> exception { \n \t2 <comment> \n \t2 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) return ; \n <ect>
\t1 remote <identifiersep> <identifier> < <identifier> <identifiersep> file <identifiersep> status > it = file <identifiersep> system . list <identifiersep> files ( new path ( <string_literal> ) , true ) ; \n \t1 while ( it . has <identifiersep> next ( ) ) { \n \t2 log . info ( <string_literal> , it . next ( ) . get <identifiersep> path ( ) . get <identifiersep> name ( ) ) ; \n \t2 ++ count ; } \n <ect>
\t3 if ( local <identifiersep> address == null ) { \n \t4 try { \n \t5 local <identifiersep> address = local <identifiersep> address <identifiersep> <identifier> . get ( timeout . to <identifiersep> <identifier> ( ) , time <identifiersep> unit . <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void do <identifiersep> start ( ) throws exception { \n \t2 super . do <identifiersep> start ( ) ; \n \t2 log . debug ( <string_literal> ) ; \n <ect>
\t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( context , <identifier> <identifiersep> cluster , <identifier> <identifiersep> <identifier> ) ) { \n \t4 if ( <identifier> <identifiersep> cluster == null ) \n \t5 s <identifiersep> logger . warn ( <string_literal> ) ; \n \t4 else \n <ect>
\t1 request . <identifier> ( application <identifiersep> xml <identifiersep> <identifier> <identifiersep> type ) ; \n \t1 string <identifier> = <string_literal> 1 . 0 \\ <string_literal> \n \t3 + <string_literal> ; \n \t1 log . info ( <identifier> ) ; \n <ect>
<comment> \n \t3 cache <identifiersep> <identifier> . start ( ) ; \n \t2 } catch ( final store <identifiersep> exception e ) { \n <ect>
\t2 final class < ? > c = <identifier> <identifiersep> server . class ; \n \t2 <identifier> <identifiersep> version = c . get <identifiersep> package ( ) . get <identifiersep> <identifier> <identifiersep> version ( ) ; \n \t2 if ( <identifier> <identifiersep> version == null ) <identifier> <identifiersep> version = <string_literal> ; \n <ect>
<comment> \n public function < collection < file > , void > create <identifiersep> <identifier> <identifiersep> handler ( final group group , final resource resource , \n \t1 final string base <identifiersep> name <identifiersep> <identifier> ) { \n <ect>
\t3 final resource resource = resource <identifiersep> utils . get <identifiersep> resource <identifiersep> from ( this . <identifier> <identifiersep> <identifier> ) ; \n \t3 return <identifier> <identifiersep> utils . execute <identifiersep> <identifier> <identifiersep> <identifier> ( resource , <identifier> , map . class ) ; \n \t2 } catch ( final exception e ) { \n \t3 logger . error ( e . get <identifiersep> message ( ) , e ) ; } \n <ect>
\t1 <identifier> . <identifier> <identifiersep> map <identifiersep> local <identifiersep> path = file . to <identifiersep> path ( ) ; \n \t1 <identifier> . <identifier> <identifiersep> map <identifiersep> on <identifiersep> <identifier> = true ; \n \t1 log . info ( <string_literal> + <identifier> <identifiersep> id + <string_literal> + in <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> count + \n \t2 <string_literal> + <identifier> . <identifier> <identifiersep> map . <identifier> <identifiersep> size ( ) + <string_literal> + file ) ; \n <ect>
\t3 logger . debug ( <string_literal> , item ) ; \n \t3 if ( item instanceof switch <identifiersep> item && ! ( item instanceof <identifier> <identifiersep> item ) ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> switch <identifiersep> item <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> switch <identifiersep> item = ( <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> switch <identifiersep> item ) provider \n \t6 . get <identifiersep> <identifier> <identifiersep> config ( item <identifiersep> name ) ; \n <ect>
\t3 for ( entry < string , thread <identifiersep> pool <identifiersep> <identifier> > entry : <identifier> . entry <identifiersep> set ( ) ) { \n \t4 thread <identifiersep> pool <identifiersep> <identifier> <identifier> = entry . get <identifiersep> value ( ) ; \n \t4 <comment> \n \t4 if ( <identifier> . is <identifiersep> default <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 return ; } } \n \t3 send <identifiersep> empty <identifiersep> <identifier> <identifiersep> <identifier> ( queue ) ; \n \t3 <identifier> . response ( response ) ; \n \t2 } catch ( final interrupted <identifiersep> exception e ) { \n <ect>
\t4 object <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get ( 1 ) ; \n \t4 object <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get ( 1 ) ; \n \t4 <identifier> = <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t8 . end <identifiersep> object ( ) \n \t7 . end <identifiersep> object ( ) \n \t6 . end <identifiersep> object ( ) ) . execute ( ) . action <identifiersep> get ( ) ; \n \t2 final int num <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> int <identifiersep> <identifier> ( <number_literal> , <number_literal> ) ; \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> state ( ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 wait <identifiersep> state <identifiersep> <identifier> ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n \t5 logger . error ( <string_literal> , e ) ; \n \t4 } catch ( socket <identifiersep> timeout <identifiersep> exception e ) { \n <ect>
\t8 total <identifiersep> <identifier> <identifiersep> bytes , <identifier> . size ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t5 long total <identifiersep> bytes = total <identifiersep> <identifier> <identifiersep> bytes + ( <number_literal> * <identifier> . size ( ) ) + ( <number_literal> * <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t5 return total <identifiersep> bytes ; } \n \t3 } catch ( exception e ) { \n <ect>
\t2 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 catch ( exception e ) { \n <ect>
\t5 log . debug ( <string_literal> ) ; \n \t5 return ; } \n \t4 if ( e instanceof file <identifiersep> system <identifiersep> exception && e . get <identifiersep> message ( ) != null && e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { \n \t5 <comment> \n <ect>
\t5 @ <identifier> \n \t5 public void <identifier> <identifiersep> end ( ) throws exception { \n \t6 <comment> \n \t6 if ( ! <identifier> <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n <ect>
\t3 string type = <identifier> . next ( ) . to <identifiersep> string ( ) ; \n \t3 <identifier> = <identifier> <identifiersep> <identifier> . get ( type ) ; \n \t3 <identifier> = <identifier> <identifiersep> <identifier> . get ( type ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t1 job <identifiersep> <identifier> = <identifier> <identifiersep> session . <identifier> ( <identifier> <identifiersep> context , <identifier> <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifiersep> logger . <identifier> <identifiersep> log <identifiersep> end ( class <identifiersep> name , <identifier> <identifiersep> logger . <identifier> <identifiersep> <identifier> <identifiersep> job ) ; \n \t1 <comment> \n \t1 if ( <identifier> <identifiersep> context . is <identifiersep> shutdown ( ) ) { \n <ect>
\t4 long local <identifiersep> file <identifiersep> length = local . file <identifiersep> length ( name ) ; \n \t4 long remote <identifiersep> file <identifiersep> length = remote . file <identifiersep> length ( name ) ; \n \t4 <identifier> <identifiersep> local <identifiersep> <identifier> <identifiersep> <identifier> = local <identifiersep> file <identifiersep> length == remote <identifiersep> file <identifiersep> length ; \n \t4 if ( ! <identifier> <identifiersep> local <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t7 <string_literal> , name , <identifier> <identifiersep> time <identifiersep> out <identifiersep> <identifier> ) ; \n \t5 <identifier> <identifiersep> stop <identifiersep> <identifier> . set ( true ) ; \n \t5 if ( ! run <identifiersep> <identifier> . try <identifiersep> <identifier> ( <identifier> <identifiersep> time <identifiersep> out , time <identifiersep> unit . <identifier> ) ) { \n \t6 <comment> \n <ect>
\t3 default : \n \t4 throw new runtime <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> type ) ; } \n \t2 } finally { \n \t3 if ( ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t6 + ( end <identifiersep> time - start <identifiersep> time ) \n \t6 + <string_literal> ) ; \n \t5 return true ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t6 <identifier> ( this . <identifier> , null ) ; \n \t6 if ( has <identifiersep> <identifier> ) { \n \t7 start <identifiersep> <identifier> ( ) ; } \n \t5 } catch ( exception e ) { \n <ect>
\t1 } else { \n \t2 result result = new result ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> ( ) . <identifier> ( result , self ( ) ) ; } \n \t1 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t4 <comment> \n \t4 for ( int i = 0 ; ! <identifier> <identifiersep> request && ! <identifier> <identifiersep> <identifier> . contains ( next <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ; i ++ ) { \n \t5 int <identifier> <identifiersep> time = 1 ; \n \t5 if ( i <identifier> <number_literal> / <identifier> <identifiersep> time == <number_literal> / <identifier> <identifiersep> time - 1 ) \n <ect>
\t8 <identifier> . stop ( ) ; \n \t8 <identifier> = address . get <identifiersep> port ( ) ; \n \t8 break ; \n \t7 } catch ( exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t7 <string_literal> + result ) ; } } \n \t3 return new <identifier> <identifiersep> snapshot <identifiersep> answer ( cmd , cmd . get <identifiersep> snapshot <identifiersep> id ( ) , \n \t5 <identifier> . get <identifiersep> path ( ) + file . <identifier> + snapshot <identifiersep> name , true , null ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 - <identifier> . get <identifiersep> start <identifiersep> time ( ) ) ) ; \n \t2 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . execute <identifiersep> update ( ) ; \n \t2 } catch ( sql <identifiersep> exception sql ) { \n <ect>
\t2 try { \n \t3 registered <identifiersep> service <identifiersep> access <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> service <identifiersep> access <identifiersep> is <identifiersep> <identifier> ( service , registered <identifiersep> service ) ; \n \t3 return true ; \n \t2 } catch ( final <identifier> <identifiersep> service <identifiersep> exception e ) { \n <ect>
\t1 public string get <identifiersep> <identifier> ( ) { \n \t2 return <string_literal> ; } \n \t1 @ path ( <string_literal> ) \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> get <identifiersep> <identifier> ( ) { \n <ect>
\t3 log . error ( <string_literal> + <identifier> ) ; \n \t3 return false ; } \n \t2 <identifier> <identifiersep> type type = <identifier> <identifiersep> type . parse <identifiersep> <identifier> <identifiersep> type ( <identifier> [ 0 ] ) ; \n \t2 if ( type == null ) { \n <ect>
\t1 try { \n \t1 path = <identifier> ( path ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . put <identifiersep> <identifier> <identifiersep> data ( path , <identifier> , node <identifiersep> exists <identifiersep> policy . <identifier> ) ; \n \t1 cache . <identifier> ( ) ; \n <ect>
\t1 public void <identifier> <identifiersep> operation ( cache cache ) { \n \t2 try { \n \t3 cache . put ( <identifier> <identifiersep> key , <string_literal> ) ; \n \t2 } catch ( cache <identifiersep> exception e ) { \n <ect>
\t3 logger . info ( <string_literal> , endpoint ) ; \n \t3 return ; } \n \t2 if ( ! failure <identifiersep> <identifier> . instance . is <identifiersep> <identifier> ( endpoint ) ) \n \t2 { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void end <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> ) throws <identifier> <identifiersep> exception { \n <ect>
\t2 final <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 final <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 final account <identifiersep> <identifier> <identifiersep> name account <identifiersep> <identifier> <identifiersep> name = account <identifiersep> <identifier> <identifiersep> name . get <identifiersep> instance ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> account <identifiersep> number ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> network <identifiersep> interface ( ) == null ) try { <comment> \n <ect>
\t10 set <identifiersep> item <identifiersep> value ( <identifier> <identifiersep> config . item , <identifier> . get <identifiersep> name ( ) ) ; \n \t10 break ; } } } \n \t6 last <identifiersep> <identifier> <identifiersep> check = <identifier> <identifiersep> end <identifiersep> time ; } } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 public class <identifier> <identifiersep> <identifier> { } \n \t1 static { \n \t2 <identifier> <identifiersep> provider <identifiersep> factory factory = <identifier> <identifiersep> provider <identifiersep> factory . get <identifiersep> instance ( ) ; \n \t2 <identifier> = factory . get <identifiersep> message <identifiersep> body <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . class , null , null , <identifier> <identifiersep> type . application <identifiersep> xml <identifiersep> type ) ; \n <ect>
\t1 } else if ( <identifier> == <number_literal> ) { <comment> \n \t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t1 <identifier> <identifiersep> access <identifiersep> <identifier> <identifiersep> <identifier> out = new <identifier> <identifiersep> access <identifiersep> <identifier> <identifiersep> <identifier> ( size , <number_literal> ) ; \n \t1 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> entry <identifiersep> <identifier> element : values ) { \n \t1 out . set <identifiersep> <identifier> ( element . get <identifiersep> <identifier> ( ) , element . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t4 if ( key . <identifier> <identifiersep> with ( <identifier> + <string_literal> ) ) <comment> \n \t5 key = key . <identifier> ( <identifier> . length ( ) + 1 ) ; \n \t4 key = key . <identifier> ( 0 , <identifier> <identifiersep> size ) ; <comment> \n \t4 if ( ! key . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> + <identifier> , e ) ; \n \t4 if ( e . get <identifiersep> status <identifiersep> code ( ) == http <identifiersep> status . <identifier> <identifiersep> <identifier> && <identifier> ( ) ) { \n \t5 <identifier> . <identifier> ( ) ; \n \t5 content = get <identifiersep> http <identifiersep> client ( ) . execute ( <identifier> , new <identifier> <identifiersep> response <identifiersep> handler ( ) ) ; \n <ect>
\t2 client ( ) . <identifier> <identifiersep> index ( <string_literal> , <string_literal> , <string_literal> ) . set <identifiersep> source ( json <identifiersep> builder ( ) . start <identifiersep> object ( ) . field ( <string_literal> , <string_literal> ) . end <identifiersep> object ( ) ) . execute ( ) . action <identifiersep> get ( ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t5 if ( session != null && session . get <identifiersep> <identifier> ( ) ) { \n \t6 session . <identifier> ( ) ; } \n \t5 ( ( <identifier> <identifiersep> transaction <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> <identifiersep> <identifier> ) . <identifier> ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
try { \n \t1 <identifier> . start ( ) ; \n \t1 log . info ( <string_literal> ) \n } catch ( exception e ) { \n <ect>
\t2 result . set <identifiersep> message <identifiersep> <identifier> ( new <identifiersep> <identifier> ) ; \n \t2 return result ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> message set <identifiersep> value <identifiersep> message ( int value ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> key <identifiersep> <identifier> ) ; } \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final string <identifier> <identifiersep> key <identifiersep> <identifier> ) { \n \t2 string <identifier> <identifiersep> key <identifiersep> to <identifiersep> <identifier> = <identifier> <identifiersep> key <identifiersep> <identifier> ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> <identifiersep> key <identifiersep> to <identifiersep> <identifier> ) ) { \n <ect>
\t2 <comment> \n \t2 storage <identifiersep> pool <identifiersep> vo lock = <identifier> <identifiersep> storage <identifiersep> pool <identifiersep> dao . <identifier> <identifiersep> in <identifiersep> lock <identifiersep> table ( s <identifiersep> pool . get <identifiersep> id ( ) ) ; \n \t2 if ( lock == null ) { \n <ect>
\t2 <identifier> < t > <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( new <identifier> < t > ( <identifier> , <identifier> , key , is <identifiersep> <identifier> ) ) ; \n \t2 try { \n \t3 return <identifier> . get ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> context != null ) { \n \t3 try { \n \t4 <identifier> <identifiersep> context . stop ( ) ; \n \t3 } catch ( final exception e ) { \n <ect>
\t7 log . trace ( string . format ( <string_literal> , s . as . s ) , new exception ( <string_literal> ) ) ; \n \t6 } else { \n <ect>
\t1 public <identifier> <identifiersep> <identifier> get <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 return <identifier> <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t1 @ task <identifiersep> action \n \t1 void <identifier> ( ) { \n \t2 <identifier> root = <identifier> <identifiersep> root . get ( ) \n \t2 for ( e in <identifier> <identifiersep> <identifier> <identifiersep> files ( false ) . as <identifiersep> map ( ) . entry <identifiersep> set ( ) ) { \n <ect>
\t3 log . debug ( <string_literal> , \n \t5 <identifier> . length ( ) - <identifier> <identifiersep> size , <identifier> . length ( ) , name ) ; \n \t3 return this ; } \n \t2 if ( ! has <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 public void test <identifiersep> <identifier> ( ) throws exception { \n \t2 string path = <string_literal> ; \n \t2 string <identifier> = system . get <identifiersep> property ( <string_literal> ) ; \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( path ) ; \n <ect>
\t1 if ( data <identifiersep> output != null ) { \n \t2 try { \n \t2 data <identifiersep> output . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 break ; } \n \t3 default : \n \t4 assert false : <string_literal> + <identifier> ; } \n <ect>
\t2 cluster <identifiersep> state = <identifier> . <identifier> ( cluster <identifiersep> state , <string_literal> ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n <ect>
\t3 return grid <identifiersep> <identifier> <identifiersep> job <identifiersep> result <identifiersep> policy . <identifier> ; } \n \t2 <comment> \n \t2 @ <identifier> public <identifier> <identifier> ( list < grid <identifiersep> <identifier> <identifiersep> job <identifiersep> result > <identifier> ) throws grid <identifiersep> exception { \n <ect>
\t3 { \n \t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( \n \t6 <string_literal> + <identifier> + <string_literal> ) ; } \n \t3 user <identifiersep> manager . remove <identifiersep> <identifier> <identifiersep> from <identifiersep> user ( <identifier> <identifiersep> name , <identifier> ) ; \n <ect>
\t6 throw new <identifier> <identifiersep> exception ( msg , <identifier> <identifiersep> code , <identifier> <identifiersep> exception . input ) ; } \n \t4 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t5 throw <identifier> ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> property item = <identifier> . next ( ) ; \n \t4 new <identifiersep> <identifier> . put ( item . get <identifiersep> name ( ) , item . <identifier> ( ) ) ; } \n \t3 return new <identifiersep> <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> session <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> log . error ( <string_literal> , e ) ; \n \t3 return write <identifiersep> string ( session <identifiersep> error , e . get <identifiersep> message ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 <identifier> . get <identifiersep> class ( ) . get <identifiersep> name ( ) , <identifier> <identifiersep> <identifier> . class . get <identifiersep> name ( ) , <identifier> <identifiersep> <identifier> . class . get <identifiersep> name ( ) ) ; } \n \t2 return null ; } \n \t1 private execution <identifiersep> context get <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> , execution <identifiersep> context <identifier> <identifiersep> context ) { \n <ect>
\t3 return ( <identifier> ) value ; } \n \t2 if ( value == null ) { \n \t3 logger . warn ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> configuration <identifier> <identifiersep> <identifier> <identifiersep> configuration = new <identifier> <identifiersep> <identifier> <identifiersep> configuration ( ) ; \n \t2 if ( element == null ) { \n \t3 log . error ( <string_literal> ) ; \n \t2 } else \t1 if ( element . get <identifiersep> <identifier> <identifiersep> name ( ) == null ) { \n <ect>
\t3 object result = <identifier> . <identifier> ( <identifier> ) ; \n \t3 if ( result instanceof boolean ) { \n \t4 return ( ( boolean ) result ) . boolean <identifiersep> value ( ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . add ( new <identifier> <identifiersep> attribute ( <identifier> . get <identifiersep> service <identifiersep> <identifier> <identifiersep> attribute ( ) , <identifier> . to <identifiersep> string ( ) ) ) ; \n \t3 <identifier> . add ( new <identifier> <identifiersep> attribute ( <identifier> <identifiersep> utils . object <identifiersep> class <identifiersep> attribute , <string_literal> , <identifier> . get <identifiersep> object <identifiersep> class ( ) ) ) ; } \n \t2 logger . debug ( <string_literal> , new <identifiersep> <identifier> , <identifier> ) ; \n \t2 final <identifier> <identifiersep> entry entry = new <identifier> <identifiersep> entry ( new <identifiersep> <identifier> , <identifier> ) ; \n <ect>
\t2 <string_literal> <string_literal> <ect>
\t3 logger . error ( \n \t4 <string_literal> + <identifier> , ex ) ; \n \t3 throw ex ; \n \t2 } catch ( exception ex ) { \n <ect>
\t5 try { \n \t6 <comment> \n \t6 <identifier> <identifiersep> socket = new <identifier> <identifiersep> socket ( configuration . get <identifiersep> <identifier> <identifiersep> port ( ) ) ; \n \t6 if ( <identifier> <identifiersep> error <identifiersep> <identifier> ) { \n <ect>
\t4 network <identifiersep> destination <identifiersep> <identifier> = new network <identifiersep> destination <identifiersep> <identifier> ( network <identifiersep> destination <identifiersep> <identifier> , object <identifiersep> name ) ; \n \t4 <identifier> <identifiersep> destination <identifiersep> <identifier> <identifiersep> map . put ( destination , network <identifiersep> destination <identifiersep> <identifier> ) ; \n \t4 network <identifiersep> destination <identifiersep> <identifier> . message <identifiersep> <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 } catch ( sql <identifiersep> exception ex ) { \n \t4 this . handle <identifiersep> exception ( ex , null ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> connection ( ) . is <identifiersep> <identifier> ( ) ) { \n \t5 return ; } \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 this . update <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> ( ) ; \n \t2 logger . debug ( <string_literal> ) ; \n \t2 if ( this . get <identifiersep> <identifier> <identifiersep> by <identifiersep> status ( <identifier> <identifiersep> status . <identifier> <identifiersep> by <identifiersep> user ) != null ) { \n \t3 for ( <identifier> <identifiersep> <identifier> <identifier> : this . get <identifiersep> <identifier> <identifiersep> by <identifiersep> status ( <identifier> <identifiersep> status . <identifier> <identifiersep> by <identifiersep> user ) ) \n <ect>
\t1 public <identifiersep> ip <identifiersep> address ip = null ; \n \t1 try { \n \t2 ip = client . <identifier> <identifiersep> public <identifiersep> ip <identifiersep> in <identifiersep> <identifier> ( v <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifier> = user <identifiersep> password <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> . find ( ) ) { \n \t3 return <identifier> <identifiersep> <identifier> . builder ( ) . user ( <identifier> . group ( 1 ) ) . password ( <identifier> . group ( <number_literal> ) ) . <identifier> <identifiersep> <identifier> ( true ) . build ( ) ; \n \t2 } else { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> queue <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> queue ) send <identifiersep> session . create <identifiersep> <identifier> <identifiersep> queue ( ) ; \n \t2 text <identifiersep> message message = send <identifiersep> session . create <identifiersep> text <identifiersep> message ( <string_literal> ) ; \n \t2 message . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> . send ( message ) ; \n <ect>
\t3 if ( <identifier> . length ( ) == 0 ) { \n \t4 continue ; } \n \t3 <comment> \n \t3 if ( <identifier> . length ( ) > max <identifiersep> <identifier> <identifiersep> length ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . add ( ( byte ) <identifier> ) ; <comment> \n \t2 <identifier> <identifiersep> <identifier> . add ( ( byte ) <identifier> ) ; <comment> \n \t2 <identifier> <identifiersep> <identifier> . add ( ( byte ) <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . add ( ( byte ) i <identifiersep> nodes ) ; \n <ect>
\t4 try { \n \t5 node . set <identifiersep> <identifier> <identifiersep> password ( <identifier> <identifiersep> password , false ) ; \n \t4 } catch ( <identifier> <identifiersep> set <identifiersep> password <identifiersep> exception e ) { \n \t5 system . <identifier> . <identifier> ( <string_literal> ) ; \n <ect>
\t4 p . execute ( sql ) ; \n \t4 p . close ( ) ; \n \t3 } catch ( sql <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t3 for ( final resource <identifiersep> access access : <identifier> . node <identifiersep> query ( resource <identifiersep> access . class ) . get <identifiersep> as <identifiersep> list ( ) ) { \n \t4 <identifier> . delete ( access ) ; } \n \t3 <identifier> . success ( ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t2 path <identifier> <identifiersep> path = <identifier> . <identifier> <identifiersep> data <identifiersep> file ( ) . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> length ( <number_literal> ) ) ; \n \t2 final string index = <string_literal> ; \n \t2 path start <identifiersep> dir = <identifier> <identifiersep> path . <identifier> ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> length ( <number_literal> ) ) ; \n \t2 path end <identifiersep> dir = <identifier> <identifiersep> path . <identifier> ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> length ( <number_literal> ) ) ; \n <ect>
\t4 while ( message . length ( ) >= <number_literal> ) { \n \t5 <identifier> . send <identifiersep> message ( message . <identifier> ( 0 , <number_literal> ) ) ; \n \t5 message = message . <identifier> ( <number_literal> ) ; } \n \t4 <identifier> . send <identifiersep> message ( message ) ; \n <ect>
\t1 public string get <identifiersep> properties <identifiersep> file ( ) { \n \t2 return properties <identifiersep> file ; } \n \t1 public <identifier> <identifiersep> endpoint find <identifiersep> or <identifiersep> create <identifiersep> endpoint ( string uri , string new <identifiersep> resource <identifiersep> uri ) { \n \t2 string new <identifiersep> uri = uri . <identifier> ( get <identifiersep> resource <identifiersep> uri ( ) , new <identifiersep> resource <identifiersep> uri ) ; \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> context . get <identifiersep> service <identifiersep> <identifier> ( \n \t5 <identifier> <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , null ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 case switch <identifiersep> <identifier> <identifiersep> set : \n \t3 case switch <identifiersep> <identifier> <identifiersep> get : \n \t3 case switch <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> get : \n \t3 case switch <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : \n <ect>
\t5 <identifier> <identifiersep> count . <identifier> ( ) ; } \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 ! <identifier> . is <identifiersep> abstract ( <identifier> . get <identifiersep> <identifier> ( ) ) && \n \t2 <identifier> . is <identifiersep> public ( <identifier> . get <identifiersep> <identifier> ( ) ) ) { \n \t1 try { \n \t2 final policy <identifiersep> <identifier> policy <identifiersep> <identifier> = ( policy <identifiersep> <identifier> ) <identifier> . new <identifiersep> instance ( ) ; \n <ect>
\t3 return false ; } } \n \t1 @ <identifier> \n \t1 public boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> , string num , string <identifier> , string <identifier> , string <identifier> ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + pool . get <identifiersep> id ( ) + <string_literal> + total <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> + total <identifiersep> <identifier> <identifiersep> size + <string_literal> + <identifier> <identifiersep> size + <string_literal> + <identifier> <identifiersep> storage <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t2 double <identifier> <identifiersep> <identifier> = ( total <identifiersep> <identifier> <identifiersep> size + <identifier> <identifiersep> size ) / ( double ) ( total <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> storage <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( table , out ) ; \n \t2 close <identifiersep> java <identifiersep> <identifier> ( out ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 java <identifiersep> <identifier> out = new <identifiersep> java <identifiersep> <identifier> ( get <identifiersep> file ( <identifier> , mode . <identifier> ) ) ; \n <ect>
\t3 input <identifiersep> stream in = entity . get <identifiersep> content ( ) ; \n \t3 output <identifiersep> stream out = new file <identifiersep> output <identifiersep> stream ( get <identifiersep> <identifier> <identifiersep> file <identifiersep> path ( ) ) ; \n \t3 io <identifiersep> utils . <identifier> ( in , out ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 . get <identifiersep> command <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n \t2 . execute ( new <identifier> <identifiersep> command ( <identifier> <identifiersep> thread , cmd ) ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t2 this . exception = e ; } \n <ect>
\t1 values <identifiersep> <identifier> <identifier> = type . get <identifiersep> <identifier> ( <identifier> ) ; \n \t1 for ( int i : <identifier> ) { \n \t2 <identifier> . write <identifiersep> integer ( i ) ; } \n \t1 byte [ ] bytes = <identifier> . get <identifiersep> bytes ( ) . to <identifiersep> byte <identifiersep> array ( ) ; \n <ect>
\t3 for ( integer i : entry . get <identifiersep> value ( ) ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> files . add ( i ) ; } } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> files . remove <identifiersep> all ( <identifier> . get <identifiersep> file <identifiersep> map ( ) . key <identifiersep> set ( ) ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> files . is <identifiersep> empty ( ) ) { \n <ect>
\t1 if ( field == null ) return ; \n \t1 try { \n \t1 ( ( <identifier> ) field . get ( <identifier> ) ) . <identifier> ( ) ; \n \t1 } catch ( throwable t ) { \n <ect>
\t2 <identifier> . add <identifiersep> to <identifiersep> event <identifiersep> <identifier> <identifiersep> success <identifiersep> count ( long . value <identifiersep> of ( <identifier> <identifiersep> <identifier> . size ( ) ) ) ; } \n \t1 transaction . <identifier> ( ) ; \n \t1 } catch ( exception ex ) { \n \t1 string error <identifiersep> msg = <string_literal> ; \n <ect>
\t3 return null ; } \n \t2 } else { \n \t3 return resource . with <identifiersep> <identifier> ( pool <identifiersep> <identifier> . get ( 1 ) ) ; } \n \t2 } else { \n <ect>
\t4 <identifier> <identifiersep> all <identifiersep> <identifier> = true ; \n \t4 log . error ( <string_literal> , t ) ; \n \t4 throw new exception ( t ) ; } \n \t3 finally { \n <ect>
\t3 server <identifiersep> a = remote <identifiersep> <identifier> ; } \n \t2 assert <identifiersep> not <identifiersep> null ( <identifier> <identifiersep> message ( connection <identifiersep> a ) ) ; \n \t2 assert <identifiersep> no <identifiersep> <identifier> <identifiersep> <identifier> ( connection <identifiersep> <identifier> ) ; \n \t2 <comment> \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> , e ) ; } } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( network network , network <identifiersep> <identifier> <identifier> ) { \n \t2 <comment> \n <ect>
\t2 logger logger = logger <identifiersep> factory . get <identifiersep> logger ( <identifier> <identifiersep> e <identifiersep> <identifier> . class ) ; \n \t2 int run <identifiersep> length = <number_literal> ; \n \t2 for ( int i = 1 ; i < = run <identifiersep> length ; i ++ ) { \n \t3 if ( ( i <identifier> <number_literal> ) < <number_literal> ) { \n <ect>
\t5 try { \n \t6 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> queue ( system . current <identifiersep> time <identifiersep> millis ( ) , true ) ) return ; \n \t5 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t6 if ( ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 { \n \t3 <identifier> . set <identifiersep> content ( content , c <identifiersep> type <identifiersep> header ) ; } \n \t2 catch ( parse <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 return exception <identifiersep> handler ; } \n \t1 public void set <identifiersep> exception <identifiersep> handler ( exception <identifiersep> handler exception <identifiersep> handler ) { \n \t2 this . exception <identifiersep> handler = exception <identifiersep> handler ; } \n \t1 protected void do <identifiersep> stop ( ) throws exception { \n <ect>
\t3 . <identifier> ( <identifier> . to <identifiersep> set ( ) ) ; \n \t2 logger . info ( <string_literal> , <identifier> . size ( ) ) ; \n \t2 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t3 <identifier> . for <identifiersep> <identifier> ( entry - > storage . remove ( entry . get <identifiersep> <identifier> <identifiersep> key ( ) ) ) ; \n <ect>
\t4 return out . to <identifiersep> string ( ) ; \n \t3 } catch ( io <identifiersep> exception ex ) { \n \t4 logger . info ( <string_literal> + ex . get <identifiersep> message ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 if ( <identifier> ) { \n \t4 is <identifiersep> <identifier> <identifiersep> or <identifiersep> throw ( ) ; \n \t4 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t4 object <identifier> = <identifier> . from <identifiersep> json ( content , <identifier> ) ; \n \t4 return <identifier> ; } \n \t3 return null ; \n \t2 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . <identifier> ( vm ) ; } \n \t2 db . <identifier> ( ) ; \n \t2 return true ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 if ( key == null ) { \n \t3 log . warn ( <string_literal> , e ) ; \n \t3 return null ; } \n \t2 if ( value == null ) { \n <ect>
\t2 if ( <identifier> == null ) return ; <comment> \n \t2 try { \n \t3 if ( this . data <identifiersep> <identifier> . get <identifiersep> node ( <identifier> <identifiersep> <identifier> . config <identifiersep> node ) == null ) { \n \t4 <comment> \n <ect>
\t2 } ; \n \t2 return get <identifiersep> <identifier> <identifiersep> list ( builder ) ; } \n \t1 public void test <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( ) throws exception { \n \t2 list < <identifier> > <identifier> = build <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( ) ; \n <ect>
\t1 private final <identifier> <identifiersep> map < string , string > cache = new <identifier> <identifiersep> <identifier> <identifiersep> map < > ( cache <identifiersep> size ) ; \n \t1 private <identifier> <identifiersep> node <identifiersep> store <identifiersep> <identifier> <identifier> ; \n \t1 public string get ( string path ) { \n \t2 if ( cache . size ( ) >= cache <identifiersep> size && ! cache . contains <identifiersep> key ( path ) ) { \n <ect>
\t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( ! <identifier> <identifiersep> node <identifiersep> name . is <identifiersep> <identifier> <identifiersep> of ( node <identifiersep> name ) ) { \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( <identifier> <identifiersep> node <identifiersep> name . equals ( node <identifiersep> name ) ) { \n <ect>
\t3 int i <identifiersep> size ; \n \t3 while ( - 1 != ( i <identifiersep> size = input <identifiersep> stream . read ( o <identifiersep> <identifier> ) ) ) { \n \t4 log . debug ( <string_literal> , i <identifiersep> size ) ; \n \t4 o <identifiersep> output . write ( o <identifiersep> <identifier> , 0 , i <identifiersep> size ) ; } \n <ect>
\t1 <identifier> <identifiersep> key = new <identifier> <identifiersep> <identifier> <identifiersep> key ( 0 , 0 , 0 ) ; \n \t1 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> metadata ( <identifier> <identifiersep> key , <identifier> , <identifier> , null , null , null , null ) ; \n \t1 log . info ( <string_literal> + root . <identifier> ( <identifier> , map ) + <string_literal> ) ; \n \t1 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> index ( ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> device <identifiersep> vo <identifier> <identifiersep> device <identifiersep> vo = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> network ( network ) ; \n \t2 host <identifiersep> vo <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> host <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> <identifiersep> device <identifiersep> vo . get <identifiersep> host <identifiersep> id ( ) ) ; \n \t2 assert ( <identifier> <identifiersep> <identifier> != null ) ; \n \t2 if ( network . get <identifiersep> state ( ) == network . state . <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> job <identifier> = job . get <identifiersep> <identifier> ( ) ; \n \t2 if ( job . get <identifiersep> type ( ) . equals ( <identifier> <identifiersep> job . job <identifiersep> type ) ) { \n \t3 logger . info ( <string_literal> , <identifier> ) ; \n \t2 } else if ( <identifier> != null && <identifier> . get <identifiersep> type ( ) . equals ( <identifier> <identifiersep> job . job <identifiersep> type ) ) { \n <ect>
\t5 source <identifiersep> name = value <identifiersep> factory . create ( source <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ) ; } } } \n \t2 current <identifiersep> source = source <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public <identifier> next ( ) { \n <ect>
\t2 { \n \t3 <identifier> <identifiersep> stream = <identifier> <identifiersep> system . get <identifiersep> <identifier> <identifiersep> input <identifiersep> stream ( uri ) ; } \n \t2 catch ( io <identifiersep> exception <identifier> ) \n \t2 { \n <ect>
\t1 private synchronized void check <identifiersep> for <identifiersep> endpoint <identifiersep> <identifier> ( <identifier> local <identifiersep> host <identifiersep> id ) throws configuration <identifiersep> exception \n \t1 { \n \t2 if ( boolean . get <identifiersep> boolean ( <string_literal> ) ) \n \t2 { \n <ect>
\t1 if ( ! command <identifiersep> <identifier> . contains <identifiersep> key ( user <identifiersep> <identifier> <identifiersep> <identifier> . cmd <identifiersep> input <identifiersep> file . <identifier> ( ) ) ) { \n \t1 logger . error ( <string_literal> , user <identifiersep> <identifier> <identifiersep> <identifier> . cmd <identifiersep> input <identifiersep> file . <identifier> ( ) ) ; \n \t1 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + user <identifiersep> <identifier> <identifiersep> <identifier> . cmd <identifiersep> input <identifiersep> file . <identifier> ( ) + <string_literal> ) ; } \n \t1 if ( ! command <identifiersep> <identifier> . contains <identifiersep> key ( user <identifiersep> <identifier> <identifiersep> <identifier> . cluster <identifiersep> security <identifiersep> type . <identifier> ( ) ) ) { \n <ect>
\t3 resource resource = new class <identifiersep> path <identifiersep> resource ( <identifier> <identifiersep> resource ) ; \n \t3 file resource <identifiersep> file = resource . get <identifiersep> file ( ) ; \n \t3 return resource <identifiersep> file ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 } else { \n \t3 <comment> \n \t3 input <identifiersep> stream <identifier> <identifiersep> stream = context . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> \n \t5 + default <identifiersep> template <identifiersep> name ) ; \n <ect>
\t5 if ( ( ip <identifiersep> address <identifiersep> values != null ) && ! ip <identifiersep> address <identifiersep> values . is <identifiersep> empty ( ) ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> ip <identifiersep> id . set ( ip <identifiersep> address <identifiersep> values . get ( 0 ) ) ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> ip . set ( ip <identifiersep> address <identifiersep> values . get ( 1 ) ) ; \n \t6 s <identifiersep> logger . info ( <string_literal> + ip <identifiersep> address <identifiersep> values . get ( 0 ) ) ; \n <ect>
\t1 @ db \n \t1 protected boolean <identifier> <identifiersep> static <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( final long <identifier> <identifiersep> id , final account <identifier> ) throws resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 <comment> \n \t2 final list < static <identifiersep> <identifier> <identifiersep> vo > <identifier> = <identifier> <identifiersep> static <identifiersep> <identifier> <identifiersep> dao . list <identifiersep> by <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> id ) ; \n <ect>
public integer <identifier> <identifiersep> entity <identifiersep> id ( ) { \n \t1 return ( integer ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <string_literal> ) ; } \n public void set <identifiersep> <identifier> <identifiersep> entity <identifiersep> id ( integer value ) { \n <ect>
\t4 if ( index >= 0 ) { \n \t5 <identifier> . remove ( index ) ; } \n \t4 else { \n \t5 log . error ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> name ( ) , <identifier> , <identifier> ) ; } } \n <ect>
@ <identifier> \n public void <identifier> ( collection < <identifier> > <identifier> <identifiersep> <identifier> ) { \n \t1 if ( data <identifiersep> file . last <identifiersep> <identifier> ( ) > last <identifiersep> <identifier> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n \t2 || read <identifiersep> last <identifiersep> update <identifiersep> file <identifiersep> <identifier> ( ) > last <identifiersep> update <identifiersep> file <identifiersep> <identifier> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( public <identifiersep> id ) ) { \n \t4 string <identifier> <identifiersep> file = <identifier> <identifiersep> <identifier> . get ( public <identifiersep> id ) ; \n \t4 return new input <identifiersep> source ( class <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <identifier> <identifiersep> file , <identifier> <identifiersep> <identifier> . class ) ) ; \n \t3 } else { \n <ect>
\t4 break ; \n \t3 default : \n \t4 name <identifiersep> id <identifiersep> value = <identifier> . get <identifiersep> principal ( ) . get <identifiersep> name ( ) ; } \n \t2 final id <identifiersep> p <identifiersep> attribute <identifiersep> value < string > value = new string <identifiersep> attribute <identifiersep> value ( name <identifiersep> id <identifiersep> value ) ; \n <ect>
\t1 if ( current <identifiersep> response <identifiersep> id == null ) { \n \t1 <comment> \n \t1 log . error ( <string_literal> + <identifier> + <string_literal> ) ; \n \t1 return create <identifiersep> <identifier> <identifiersep> command ( ) ; } \n <ect>
\t4 log . error ( <string_literal> , e ) ; \n \t4 delete <identifiersep> test <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t4 wait <identifiersep> <identifier> <identifiersep> no <identifiersep> job <identifiersep> is <identifiersep> <identifier> ( client ) ; \n \t4 continue ; } \n <ect>
\t2 <comment> \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> data . set <identifiersep> string <identifiersep> <identifier> ( <identifier> <identifiersep> data ) ; \n \t1 } else { \n \t1 <comment> \n <ect>
\t3 success = false ; \n \t3 s <identifiersep> logger . warn ( <string_literal> + vm <identifiersep> id + <string_literal> ) ; } \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> port <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> vm ( vm <identifiersep> id ) ) { \n <ect>
\t1 final security <identifiersep> group test <identifiersep> group = security . create <identifiersep> security <identifiersep> group ( <identifier> <identifiersep> <identifier> <identifiersep> name , get <identifiersep> node <identifiersep> template ( ) . get <identifiersep> location ( ) ) ; \n \t1 try { \n \t2 <identifier> <identifiersep> and <identifiersep> delete <identifiersep> security <identifiersep> group ( security , count <identifiersep> <identifier> <identifiersep> add , test <identifiersep> group ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( key , <identifier> , key <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> key ( ) , key <identifiersep> <identifier> . get <identifiersep> max <identifiersep> key ( ) , \n \t3 event <identifiersep> options ) ; } } \n \t1 <identifier> <identifiersep> key = <identifier> . get <identifiersep> <identifier> <identifiersep> key ( ) ; \n \t1 max <identifiersep> key = <identifier> . get <identifiersep> max <identifiersep> key ( ) ; \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 this . <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> service . <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n \t2 this . <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> service . <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n \t2 this . <identifier> = <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n <ect>
\t3 string line ; \n \t3 while ( ( line = r . read <identifiersep> line ( ) ) != null ) { \n \t4 log . info ( <string_literal> , <identifier> , line ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> resource <identifier> = <identifier> . read <identifiersep> resource ( m <identifiersep> <identifier> <identifiersep> id ) ; \n \t4 <identifier> . <identifier> <identifiersep> resource ( <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 system . set <identifiersep> <identifier> ( new system <identifiersep> log <identifiersep> handler ( system . <identifier> ) ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> ( ) { \n \t2 <comment> \n \t2 if ( ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 . build ( ) ; } \n \t1 log <identifiersep> <identifier> <identifiersep> config <identifiersep> <identifier> . get <identifiersep> config ( ) . set <identifiersep> input <identifiersep> config ( cluster <identifiersep> name , service <identifiersep> name , new object <identifiersep> <identifier> ( ) . write <identifiersep> value <identifiersep> as <identifiersep> string ( input <identifiersep> config ) ) ; \n \t1 return response . <identifier> ( ) . build ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) throws <identifier> <identifiersep> exception { \n \t1 for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> object ( configuration <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , new key <identifiersep> <identifier> < <identifier> <identifiersep> <identifier> > ( ) { \n \t1 @ <identifier> public void <identifier> ( string key , class < <identifier> <identifiersep> <identifier> > <identifier> ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add <identifiersep> <identifier> <identifiersep> <identifier> ( key , <identifier> <identifiersep> factory . create <identifiersep> <identifier> ( <identifier> ) ) ; \n <ect>
\t3 status <identifiersep> server . start ( ) ; \n \t3 <identifier> <identifiersep> manager . <identifier> <identifiersep> start ( ) ; \n \t3 input <identifiersep> manager . <identifier> <identifiersep> start ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 try { \n \t3 service <identifiersep> <identifier> . <identifier> <identifiersep> by <identifiersep> name ( <identifier> , <identifier> <identifiersep> service <identifiersep> name ) \n \t3 logger . warn ( <string_literal> + <identifier> <identifiersep> service <identifiersep> name ) \n \t3 } catch ( final no <identifiersep> such <identifiersep> element <identifiersep> exception <identifier> ) { \n <ect>
\t2 account account = null ; \n \t2 if ( user != null ) { \n \t3 account = <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> account ( user . get <identifiersep> account <identifiersep> id ( ) ) ; } \n \t2 if ( ( user == null ) || ( user . get <identifiersep> <identifier> ( ) != null ) || ! user . get <identifiersep> state ( ) . equals ( account . state . enabled ) || ( account == null ) || ! account . get <identifiersep> state ( ) . equals ( account . state . enabled ) ) { \n <ect>
\t2 stack <identifiersep> event <identifiersep> entity <identifiersep> manager . add <identifiersep> stack <identifiersep> event ( stack <identifiersep> resource <identifiersep> entity ) ; } } \n \t1 return <string_literal> ; } \n @ <identifier> \n public string get <identifiersep> <identifier> <identifiersep> execution <identifiersep> close <identifiersep> status ( string stack <identifiersep> id , string <identifier> <identifiersep> type ) { \n <ect>
public security <identifiersep> configuration load <identifiersep> security <identifiersep> configuration <identifiersep> by <identifiersep> <identifier> ( string <identifier> ) { \n \t1 security <identifiersep> configuration security <identifiersep> configuration = null ; \n \t1 logger . debug ( <string_literal> , <identifier> ) ; \n \t1 if ( <identifier> == null ) { \n <ect>
\t1 string model <identifiersep> <identifier> <identifiersep> name = get <identifiersep> item <identifiersep> property <identifiersep> name ( model , id ) ; \n \t1 log . debug ( string . format ( <string_literal> , model <identifiersep> <identifier> <identifiersep> name ) ) ; \n \t1 if ( get <identifiersep> config ( ) . contains <identifiersep> key ( model <identifiersep> <identifier> <identifiersep> name ) ) { \n \t1 string json = read ( model <identifiersep> <identifier> <identifiersep> name ) ; \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t3 logger . debug ( <string_literal> , <identifier> ) ; \n \t3 <identifier> . get ( ) ; <comment> \n <ect>
\t1 server . find ( <identifier> . class ) . find <identifiersep> count ( ) ; \n \t1 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> method <identifiersep> with <identifiersep> failure ( ) ; \n \t1 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t2 private grid <identifiersep> <identifier> <identifiersep> task <identifiersep> session task <identifiersep> <identifier> ; \n \t2 <comment> \n \t2 @ <identifier> protected collection < ? extends grid <identifiersep> <identifier> <identifiersep> job > <identifier> ( int grid <identifiersep> size , <identifier> <identifier> ) throws grid <identifiersep> exception { \n <ect>
\t3 <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t3 <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t3 while ( <identifier> . next ( ) ) { \n \t4 if ( <identifier> . get <identifiersep> int ( 1 ) != default <identifiersep> <identifier> <identifiersep> network <identifiersep> id ) { \n <ect>
\t5 map < object , object > map = ( map < object , object > ) value ; \n \t5 for ( entry < object , object > entry : map . entry <identifiersep> set ( ) ) { \n \t6 properties . put ( new <identifiersep> <identifier> + entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) . to <identifiersep> string ( ) ) ; } } \n \t4 else { \n <ect>
\t1 <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( final <identifier> <identifiersep> resource <identifiersep> exception ex ) { \n \t1 ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t2 try { \n \t3 store = new <identifier> <identifiersep> string <identifiersep> key <identifiersep> value <identifiersep> store <identifiersep> level <identifiersep> db ( file . to <identifiersep> string ( ) , options , false ) ; \n \t2 } catch ( exception ex ) { \n \t3 store = string <identifiersep> key <identifiersep> value <identifiersep> store <identifiersep> no <identifiersep> <identifier> . <identifier> ; \n <ect>
\t1 final long start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 <identifier> . <identifier> ( <identifier> ) ; \n \t1 final long end = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 final long <identifier> = end - start ; \n <ect>
\t3 template . <identifier> <identifiersep> and <identifiersep> send ( queue . get <identifiersep> name ( ) , i + <string_literal> ) ; \n \t3 <comment> \n \t3 thread . <identifier> ( <number_literal> ) ; } \n \t2 int timeout = get <identifiersep> timeout ( ) ; \n <ect>
<identifier> create <identifiersep> command <identifiersep> file ( <identifier> , <identifier> <identifiersep> dir , <identifier> <identifiersep> file <identifiersep> path , <identifier> <identifiersep> url , collection , filter <identifiersep> field , id <identifiersep> field , <identifier> <identifiersep> <identifier> <identifiersep> end <identifiersep> value , \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> end <identifiersep> id , <identifier> <identifiersep> user , <identifier> <identifiersep> path , key <identifiersep> file <identifiersep> path , <identifier> , key <identifiersep> <identifier> , local <identifiersep> path ) : \n <identifier> = { } \n if <identifier> : \n <ect>
\t5 <identifier> <identifiersep> state = <number_literal> ; \n \t5 <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> ) ; \n \t4 } else { \n \t5 <comment> \n <ect>
\t2 for ( filter <identifier> <identifiersep> filter : <identifier> <identifiersep> <identifier> <identifiersep> filter <identifiersep> <identifier> ) { \n \t3 <identifier> <identifiersep> load <identifier> <identifiersep> load = <identifier> <identifiersep> filter . get <identifiersep> class ( ) . get <identifiersep> <identifier> ( <identifier> <identifiersep> load . class ) ; \n \t3 if ( <identifier> <identifiersep> load != null && <identifier> <identifiersep> load . value ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <number_literal> ) ; } } \n \t1 public void <identifier> ( ) { \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 set <identifiersep> <identifier> <identifiersep> <identifier> ( action . response ) ; \n \t2 try { \n \t3 target target = <identifier> <identifiersep> target ( action ) ; \n <ect>
\t2 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> <identifier> . get <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 logger . info ( <string_literal> + <identifier> ) ; \n \t3 list < <identifier> <identifiersep> info > <identifier> <identifiersep> <identifier> = new array <identifiersep> list < <identifier> <identifiersep> info > ( ) ; \n \t3 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 return <identifier> ; } \n \t2 @ <identifier> \n \t2 public <identifier> handle ( <identifier> <identifiersep> <identifier> . timeout . <identifier> <identifier> ) throws io <identifiersep> exception \n \t2 { \n <ect>
\t2 while ( property <identifiersep> <identifier> . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t2 object object = property <identifiersep> <identifier> . next <identifiersep> element ( ) ; } } \n \t1 message <identifiersep> <identifier> <identifiersep> token . count <identifiersep> <identifier> ( ) ; } \n \t1 catch ( <identifier> <identifiersep> exception e ) { \n <ect>
private void index <identifiersep> file ( path source <identifiersep> file , input <identifiersep> file . type type , <identifier> <identifier> ) throws io <identifiersep> exception { \n \t1 <comment> \n \t1 path <identifier> <identifiersep> <identifier> <identifiersep> file = source <identifiersep> file . to <identifiersep> <identifier> <identifiersep> path ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) . to <identifiersep> <identifier> <identifiersep> path ( ) . <identifier> ( ) ; \n \t1 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> file . <identifier> <identifiersep> with ( <identifier> . get <identifiersep> base <identifiersep> dir ( ) ) ) { \n <ect>
\t7 result = false ; } } \n \t5 if ( is <identifiersep> <identifier> ) { \n \t6 job <identifiersep> <identifier> = new file ( job <identifiersep> dir , <string_literal> ) ; \n \t6 if ( ! job <identifiersep> <identifier> . create <identifiersep> new <identifiersep> file ( ) ) { \n <ect>
\t4 if ( ! <identifier> . is <identifiersep> answer <identifiersep> <identifier> ( <identifier> . get <identifiersep> user <identifiersep> id ( request ) , request . get ( <string_literal> ) ) ) { \n \t5 logger . warn ( <string_literal> ) ; \n \t5 return false ; } \n \t3 } catch ( exception e ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> log , <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> , \n \t6 <identifier> <identifiersep> set . < name > builder ( ) . add <identifiersep> all ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) . add ( <identifier> <identifiersep> <identifier> . <identifier> . get <identifiersep> name ( ) ) . build ( ) \n \t4 ) ; } } } \n \t1 private < t > <identifier> < <identifier> <identifiersep> <identifier> < t > > build <identifiersep> and <identifiersep> store ( name < t > name , <identifier> <identifiersep> <identifier> < t > <identifier> , <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 try { \n \t4 message = stream <identifiersep> <identifier> . read <identifiersep> string ( is , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 throw new runtime <identifiersep> exception ( e ) ; } \n <ect>
<comment> \n \t1 protected void <identifier> <identifiersep> <identifier> ( model <identifiersep> <identifier> <identifiersep> client model <identifiersep> <identifier> <identifiersep> client ) throws exception { \n \t2 if ( <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> . length == 0 ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> not <identifiersep> empty <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t3 <identifier> <identifiersep> to <identifiersep> <identifier> . size ( ) \n \t1 ) , e ) ; \n \t1 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n \t1 } catch ( io <identifiersep> exception | execution <identifiersep> exception e ) { \n <ect>
\t1 return new <identifier> <identifiersep> data <identifiersep> source ( object <identifiersep> pool ) ; \n \t1 } else if ( <string_literal> . equals ( connection <identifiersep> <identifier> ) ) { \n \t1 return new <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> source <identifiersep> provider ( ) . create ( conf ) ; \n \t1 } else if ( <string_literal> . equals ( connection <identifiersep> <identifier> ) ) { \n <ect>
\t3 logger . info ( <string_literal> , response ) ; \n \t3 assert <identifiersep> not <identifiersep> equals ( <string_literal> , 0 , response . get <identifiersep> failed <identifiersep> shards ( ) ) ; \n \t3 return response ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> execution <identifiersep> exception ex ) { \n <ect>
\t1 <comment> \n \t1 file <identifiersep> <identifier> <identifier> = new file <identifiersep> <identifier> ( <identifier> <identifiersep> properties <identifiersep> file ) ; \n \t1 <identifier> <identifiersep> properties . store ( <identifier> , <string_literal> ) ; \n \t1 <identifier> . close ( ) ; \n <ect>
\t3 s <identifiersep> logger . debug ( string . format ( <string_literal> + \n \t5 <string_literal> , <identifier> <identifiersep> ip , <identifier> , <string_literal> , <identifier> <identifiersep> num , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ) ; \n \t3 return <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> send <identifiersep> error ( response , <identifier> <identifiersep> not <identifiersep> found ) ; } \n \t1 } catch ( client <identifiersep> <identifier> <identifiersep> exception e ) { \n \t1 log . trace ( <string_literal> , resource , <identifier> <identifiersep> key , e ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> log . error ( <string_literal> + msg , new exception ( ) ) ; \n \t3 return false ; } \n \t2 if ( msg . get <identifiersep> <identifier> ( ) < = <identifier> <identifiersep> context . <identifier> ( ) . <identifier> ( ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t6 s <identifiersep> logger . debug ( <string_literal> + vm + <string_literal> ) ; \n \t5 } else if ( <identifier> <identifiersep> state == state . <identifier> ) { \n \t6 <identifier> <identifiersep> <identifier> . remove ( vm ) ; \n \t5 } else if ( <identifier> <identifiersep> state == state . <identifier> ) { \n <ect>
<comment> \n protected void cache <identifiersep> <identifier> ( job job , conn <identifiersep> manager <identifier> ) \n \t1 throws io <identifiersep> exception { \n \t1 if ( options . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cache ( ) ) { \n <ect>
\t3 <comment> \n \t3 try { \n \t4 model <identifiersep> <identifier> <identifiersep> client . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> date = date <identifiersep> <identifier> . parse <identifiersep> date <identifiersep> string ( s <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; } \n \t4 <identifier> <identifiersep> <identifier> . add ( new <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> policy <identifiersep> vo ( <identifier> <identifiersep> id , <identifier> <identifiersep> id , <identifier> <identifiersep> id , <identifier> <identifiersep> id , <identifier> <identifiersep> date , <identifier> <identifiersep> date ) ) ; } \n \t2 } catch ( exception e ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t2 try ( <identifier> <identifiersep> <identifier> <identifier> = connection . <identifier> <identifiersep> <identifier> ( delete <identifiersep> <identifier> <identifiersep> sql ) ) { \n \t3 <identifier> . set <identifiersep> string ( 1 , address <identifiersep> to <identifiersep> delete ) ; \n \t3 <identifier> . set <identifiersep> string ( <number_literal> , <identifier> ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n <ect>
\t2 final string entity <identifiersep> id = <identifier> . get <identifiersep> value ( ) . get <identifiersep> entity <identifiersep> id ( ) ; \n \t2 logger . debug ( <string_literal> , entity <identifiersep> id ) ; \n \t2 final <identifier> <identifiersep> request <identifier> <identifiersep> request = authentication <identifiersep> context . get <identifiersep> key ( ) ; \n \t2 this . response <identifiersep> builder . build ( <identifier> <identifiersep> request , request , response , <identifier> <identifiersep> <identifier> , <identifier> . get <identifiersep> key ( ) , <identifier> . get <identifiersep> value ( ) , <identifier> ) ; \n <ect>
\t6 <identifier> <identifiersep> message msg = <identifier> <identifiersep> message <identifiersep> handler . read <identifiersep> message ( <identifier> <identifiersep> stream ) ; \n \t6 if ( msg != null ) { \n \t7 <comment> \n \t7 <identifier> <identifiersep> listener . message <identifiersep> <identifier> ( <identifier> <identifiersep> message <identifiersep> <identifier> . this , msg ) ; \n <ect>
\t2 <identifier> <identifiersep> if <identifiersep> <identifier> ( ) ; \n \t2 if ( debug ) logger . info ( <string_literal> , values ) ; \n \t2 put <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> ( values ) ; } \n \t1 public map < string , t > load <identifiersep> all <identifiersep> by <identifiersep> <identifier> ( collection < string > <identifier> ) { \n <ect>
\t1 try { \n \t1 final string file <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ; \n \t1 file <identifier> = file . create <identifiersep> <identifier> <identifiersep> file ( <string_literal> , <string_literal> ) ; \n \t1 file <identifiersep> utils . write ( <identifier> , file <identifiersep> <identifier> ) ; \n <ect>
\t2 <identifier> : \n \t2 <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) \n \t2 <identifier> : \n \t2 <identifier> == [ : ] \n <ect>
\t4 log . warn ( <identifier> <identifiersep> query <identifiersep> <identifier> . class . get <identifiersep> name ( ) + <string_literal> ) ; } \n \t2 } catch ( <identifier> <identifiersep> object <identifiersep> name <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> , e ) ; \n \t2 } catch ( runtime <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 if ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> ( ) . length < <identifier> + 1 ) { \n \t5 logger . error ( <string_literal> ) ; \n \t5 return ; } \n \t4 <identifier> <identifiersep> level = <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <identifier> + 1 ) ; \n <ect>
\t5 int start <identifiersep> index = <identifier> . last <identifiersep> index <identifiersep> of ( <string_literal> , end <identifiersep> index ) ; \n \t5 <identifier> = <identifier> . <identifier> ( start <identifiersep> index + 1 , end <identifiersep> index ) ; \n \t5 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> name = <identifier> ; } \n \t4 catch ( exception e ) { \n <ect>
\t3 exception <identifiersep> <identifier> = true ; \n \t2 } finally { \n \t3 <comment> \n \t3 if ( exception <identifiersep> <identifier> ) { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception { \n \t2 string <identifier> <identifiersep> key = <string_literal> ; \n \t2 <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t2 <identifier> . put ( <identifier> <identifiersep> key , <string_literal> ) ; \n <ect>
\t3 try { \n \t4 thread . <identifier> ( <number_literal> ) ; \n \t3 } catch ( final interrupted <identifiersep> exception ex ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> ) ; } } \n <ect>
<comment> \n \t1 public list < request > parse <identifiersep> config ( string file <identifiersep> name ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> ( this <identifiersep> client ) ; } \n \t2 } catch ( json <identifiersep> <identifier> <identifiersep> exception | <identifier> <identifiersep> exception ex ) { \n \t3 set <identifiersep> consumer ( this <identifiersep> client , null ) ; \n \t3 set <identifiersep> consumer ( this <identifiersep> client , null ) ; \n <ect>
\t4 case <identifier> <identifiersep> <identifier> = > \n \t4 log . error ( s <string_literal> ) \n \t4 null } \n \t3 case <identifier> <identifiersep> <identifier> = > \n <ect>
\t2 return get <identifiersep> http <identifiersep> connection ( url <identifiersep> string , <string_literal> ) ; } \n \t1 public http <identifiersep> url <identifiersep> connection get <identifiersep> http <identifiersep> connection ( string url <identifiersep> string , string http <identifiersep> method ) throws exception { \n \t2 string <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> client . get <identifiersep> service <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 <identifier> . put <identifiersep> element ( port . interface <identifiersep> type , new xml <identifiersep> object ( port . interface <identifiersep> type ) \n \t5 . put <identifiersep> element ( <string_literal> , new xml <identifiersep> object ( <string_literal> ) . set <identifiersep> text ( port . port ) ) ) ; \n \t3 request = new http <identifiersep> entity < > ( xml . <identifier> ( ) , <identifier> ) ; \n \t3 <identifier> = build <identifiersep> <identifier> ( <identifier> . get <identifiersep> switch <identifiersep> ip ( ) , string . format ( <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) ) ) ; \n <ect>
\t4 log . info ( <string_literal> + key ) ; \n \t4 log . info ( <string_literal> + queue <identifiersep> <identifier> . get <identifiersep> name ( ) ) ; \n \t4 log . info ( <string_literal> + queue <identifiersep> <identifier> . <identifier> <identifiersep> size ( ) ) ; \n \t4 log . info ( <string_literal> + queue <identifiersep> <identifier> . get <identifiersep> queue <identifiersep> size ( ) ) ; \n <ect>
\t1 } ) ; \n \t1 <identifier> . <identifier> ( ) ; } \n \t1 catch ( <identifier> e ) \n \t1 { \n <ect>
\t3 output <identifiersep> stream <identifier> = t . get <identifiersep> response <identifiersep> body ( ) ; \n \t3 <identifier> . write ( <identifier> ) ; \n \t3 <identifier> . close ( ) ; \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> config <identifiersep> dao . update ( <string_literal> , <string_literal> ) ; \n \t3 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> config <identifiersep> dao . update ( <string_literal> , <string_literal> ) ; \n <ect>
\t1 private static boolean check <identifiersep> task <identifiersep> message ( @ <identifier> job <identifiersep> task task , string message <identifiersep> source <identifiersep> <identifier> ) { \n \t2 if ( task == null ) { \n \t3 return false ; } \n \t2 if ( ( message <identifiersep> source <identifiersep> <identifier> == null ) || ! message <identifiersep> source <identifiersep> <identifier> . equals ( task . get <identifiersep> host <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> out <identifiersep> <identifier> != null ) { \n \t3 <identifier> <identifiersep> out <identifiersep> <identifier> . close ( ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n \t2 if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ( e ) && <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 i <identifiersep> connection <identifier> <identifiersep> connection = null ; \n \t2 try { \n \t3 <identifier> <identifiersep> connection = new <identifier> <identifiersep> server ( <identifier> <identifiersep> conf , port , <identifier> <identifiersep> queue , <identifier> <identifiersep> <identifier> <identifiersep> queue , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( count ) ; \n \t2 stop <identifiersep> <identifier> <identifier> = new stop <identifiersep> <identifier> ( ) ; \n \t2 execute ( count ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t8 <identifier> <identifiersep> <identifier> = info ; } } } \n \t5 <comment> \n \t5 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 public void run ( ) { \n \t3 synchronized ( <identifier> ) { \n \t4 if ( current != null ) { \n \t5 if ( current . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t4 m <identifiersep> device = factory . create <identifiersep> m <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( ) ; \n \t4 m <identifiersep> device . set <identifiersep> device <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> . device <identifiersep> <identifier> ) ; \n \t3 } else if ( device <identifiersep> <identifier> == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . device <identifiersep> <identifier> ) { \n <ect>
\t3 } catch ( value <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t4 if ( <identifier> <identifiersep> on <identifiersep> parse <identifiersep> exception ) { \n \t5 throw <identifier> ; \n \t4 } else { \n <ect>
\t2 } catch ( exception e ) { \n \t3 if ( <identifier> <identifiersep> port <identifiersep> name != null ) { \n \t4 logger . error ( <string_literal> , <identifier> <identifiersep> port <identifiersep> name , e ) ; \n \t3 } else { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> host <identifiersep> id ) ; \n \t4 <identifier> <identifiersep> resource <identifiersep> <identifier> . <identifier> <identifiersep> failed ( <identifier> <identifiersep> host <identifiersep> id ) ; } \n \t3 return null ; \n \t2 } catch ( <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 } else { \n \t2 try { \n \t2 do <identifiersep> <identifier> <identifiersep> files ( user <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> path , <identifier> ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t5 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> node <identifiersep> id ) ; } \n \t4 s <identifiersep> logger . info ( <string_literal> + <identifier> . get <identifiersep> name ( ) ) ; \n \t4 success = true ; \n \t4 return result ; } \n <ect>
\t2 if ( attribute <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t3 logger . debug ( <string_literal> , get <identifiersep> name ( ) ) ; \n \t3 return null ; } \n \t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t1 public final void shutdown ( ) { \n \t2 try { \n \t3 if ( <identifier> <identifiersep> server != null && <identifier> <identifiersep> server . is <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> <identifiersep> server . stop ( ) ; \n <ect>
\t3 try { \n \t4 <identifier> . load <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( is ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 if ( log . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . set <identifiersep> table <identifiersep> name ( new <identifiersep> table <identifiersep> name ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( new <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> . update <identifiersep> table <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t1 } catch ( no <identifiersep> such <identifiersep> object <identifiersep> exception <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> service , <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( final exception e ) { \n \t4 <comment> \n \t4 <comment> \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t3 if ( value == null ) { \n \t4 boolean <identifier> <identifiersep> value = name . <identifier> <identifiersep> with ( password <identifiersep> property <identifiersep> end ) ; \n \t4 value = default <identifiersep> value ; \n \t4 string log <identifiersep> value = ( <identifier> <identifiersep> value ) ? <string_literal> : default <identifiersep> value ; \n <ect>
\t2 string data <identifiersep> string = base <identifiersep> string + request <identifiersep> number ; \n \t2 <comment> \n \t2 int <identifier> = <identifier> . next <identifiersep> int ( number <identifiersep> of <identifiersep> nodes ) ; \n \t2 node <identifier> <identifiersep> node = nodes [ <identifier> ] ; \n <ect>
\t4 integer . parse <identifiersep> int ( path . <identifier> ( local <identifiersep> port <identifiersep> index + 1 , path . length ( ) ) ) ; \n \t4 string local <identifiersep> string = location . get <identifiersep> <identifier> ( ) + <string_literal> + path ; \n \t4 local <identifiersep> location = new uri ( local <identifiersep> string ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t5 <comment> \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> application . <identifier> . local <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager ) } \n \t3 } catch ( e : exception ) { \n <ect>
<comment> \n \t2 try { \n \t3 if ( ! version . current . to <identifiersep> string ( ) . equals ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> version <identifiersep> <identifier> ) ) { \n <ect>
\t1 try { \n \t1 super . <identifier> <identifiersep> <identifier> ( o ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> map . put ( <identifier> <identifiersep> uri , <identifier> ) ; \n \t2 <identifier> <identifiersep> map . put ( <identifier> <identifiersep> uri , 1 ) ; \n \t2 <identifier> <identifiersep> map . put ( <identifier> , <identifier> <identifiersep> uri ) ; \n \t2 <identifier> . start ( ) ; \n <ect>
<number_literal> + current <identifiersep> state ) ; } \n \t3 } else { \n \t4 <comment> \n \t4 if ( current <identifiersep> state . equals ( <identifier> <identifiersep> state . <identifier> <identifiersep> server . to <identifiersep> string ( ) ) ) { \n <ect>
\t3 return null ; } \n \t2 array <identifiersep> list < <identifier> > <identifier> = new array <identifiersep> list < <identifier> > ( files . length ) ; \n \t2 for ( file <identifier> <identifiersep> file : files ) { \n \t3 if ( ! <identifier> <identifiersep> file . <identifier> <identifiersep> read ( ) ) { \n <ect>
\t4 field . set ( null , null ) ; } \n \t2 } catch ( no <identifiersep> such <identifiersep> field <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> + field <identifiersep> name + <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> + e , e ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t4 success = false ; \n \t4 s <identifiersep> logger . warn ( <string_literal> + network <identifiersep> id + <string_literal> ) ; } \n \t2 } catch ( final resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t3 success = false ; \n <ect>
\t2 <comment> <ect>
\t4 <identifier> = <identifier> [ 0 ] ; \n \t4 <identifier> = <identifier> [ 1 ] ; \n \t3 } catch ( throwable t ) { \n \t4 system . <identifier> . <identifier> ( <string_literal> + t ) ; \n <ect>
\t3 if ( <identifier> >= public <identifiersep> <identifier> <identifiersep> count ) { \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> <identifier> > <number_literal> * <number_literal> * <number_literal> ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> mode = db <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> mode <identifiersep> check ; \n \t3 } catch ( exception ex ) { \n \t4 s <identifiersep> logger . debug ( ex ) ; \n <ect>
\t3 log . error ( <string_literal> , e ) ; \n \t3 <identifier> <identifiersep> connection <identifiersep> exception <identifier> <identifiersep> exception = new <identifier> <identifiersep> connection <identifiersep> exception ( <string_literal> , e ) ; \n \t3 get <identifiersep> <identifier> ( ) . <identifier> ( new status . failure ( <identifier> <identifiersep> exception ) , get <identifiersep> self ( ) ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 . set <identifiersep> source ( json <identifiersep> builder ( ) . start <identifiersep> object ( ) . field ( <string_literal> , <identifier> <identifiersep> all <identifiersep> query ( ) ) . end <identifiersep> object ( ) ) \n \t3 . get ( ) ; \n \t2 client ( ) . <identifier> <identifiersep> index ( <string_literal> , <string_literal> , <string_literal> ) . set <identifiersep> source ( <string_literal> , x <identifiersep> content <identifiersep> type . json ) . get ( ) ; \n \t2 client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> <identifier> ( ) . get ( ) ; \n <ect>
\t1 <identifier> = update <identifiersep> from <identifiersep> xml ( config <identifiersep> file ) \n \t1 <identifier> <identifier> == <string_literal> : \n \t1 <identifier> = update <identifiersep> from <identifiersep> file ( config <identifiersep> file ) \n \t1 else : \n <ect>
\t7 this . pool . put <identifiersep> connection <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( connection ) ; } \n \t6 thread . <identifier> ( <identifier> ) ; <comment> \n \t4 } <comment> \n \t4 <comment> \n <ect>
\t2 <comment> \n \t2 if ( t instanceof <identifier> <identifiersep> task <identifiersep> thread ) { \n \t3 ( ( <identifier> <identifiersep> task <identifiersep> thread ) t ) . set <identifiersep> task ( r ) ; \n \t3 ( ( <identifier> <identifiersep> task <identifiersep> thread ) t ) . start <identifiersep> stop <identifiersep> <identifier> ( ) ; \n <ect>
\t2 } catch ( <identifier> <identifiersep> <identifier> . resource <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t2 <comment> \n \t2 log . warn ( <string_literal> + volume <identifiersep> id + <string_literal> , e ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 return <identifier> <identifiersep> id . <identifier> <identifiersep> code ( ) ; } \n \t1 void handle <identifiersep> session <identifiersep> <identifier> ( stream <identifiersep> session session ) \n \t1 { \n \t2 session <identifiersep> info session <identifiersep> info = session . get <identifiersep> session <identifiersep> info ( ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void check ( ) { \n \t2 <identifier> <identifiersep> lock lock = <identifier> <identifiersep> lock . get <identifiersep> <identifier> <identifiersep> lock ( <string_literal> ) ; \n \t2 try { \n <ect>
\t7 if ( property <identifiersep> key != null ) { \n \t8 try { \n \t9 <identifier> . set <identifiersep> property ( property <identifiersep> key , <identifier> ) ; \n \t8 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 if ( status <identifiersep> code >= http <identifiersep> status . <identifier> <identifiersep> <identifier> <identifiersep> request ) { \n \t4 logger . debug ( <string_literal> + method . get <identifiersep> status <identifiersep> line ( ) ) ; } \n \t3 string response <identifiersep> body = io <identifiersep> utils . to <identifiersep> string ( method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) ) ; \n \t3 if ( ! response <identifiersep> body . is <identifiersep> empty ( ) ) { \n <ect>
\t1 } catch ( exception ex ) { \n \t2 log . warn ( <string_literal> + volume <identifiersep> id ) ; \n \t2 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + volume <identifiersep> id , ex ) ; } \n \t1 } else { \n <ect>
\t2 store . stop ( ) ; \n \t2 message <identifiersep> store = create <identifiersep> store ( <number_literal> * <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( message <identifiersep> store , <number_literal> ) ; \n \t2 long size <identifiersep> <identifier> <identifiersep> <identifier> = store . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> size ( ) ; \n <ect>
@ <identifier> \n public void check <identifiersep> connection ( ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> info info = <identifier> <identifiersep> <identifier> <identifiersep> info . get <identifiersep> storage <identifiersep> info ( ) ; \n \t1 if ( info != null && ! <identifier> <identifiersep> config . is <identifiersep> <identifier> ( info ) ) { \n <ect>
\t4 <identifier> . add ( new read <identifiersep> write <identifiersep> end <identifiersep> <identifier> ( info . <identifier> ( ) , <identifier> , <identifier> <identifiersep> id . get <identifiersep> <identifier> ( ) , \n \t6 as <identifiersep> list ( info . <identifier> ( ) ) , info . get <identifiersep> <identifier> <identifiersep> name ( ) ) ) ; } \n \t3 else \n \t3 { \n <ect>
\t3 throw <identifier> ; } \n \t2 catch ( exception ex ) \n \t2 { \n \t3 on <identifiersep> exception ( <identifier> <identifiersep> status ) ; \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 try { \n \t2 test ( 0 , 0 ) ; \n \t1 } finally { \n <ect>
\t5 time <identifiersep> unit . <identifier> ) ; } } \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> id ) ; \n \t2 <identifier> <identifiersep> nodes . add ( node . get ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \t3 return null ; } \n \t2 if ( key == null ) \n \t2 { \n <ect>
\t3 } else { \n \t4 log . warn ( <string_literal> , new object [ ] { \n \t6 local <identifiersep> <identifier> , remote <identifiersep> <identifier> , error \n \t4 } ) ; } \n <ect>
\t3 <identifier> <identifiersep> first <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 return <identifier> ; \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t9 storage <identifiersep> service . remove <identifiersep> <identifier> ( store <identifiersep> <identifier> . get <identifiersep> storage <identifiersep> <identifier> ( store <identifiersep> <identifier> . get <identifiersep> name ( ) ) , \n <number_literal> is <identifiersep> read <identifiersep> <identifier> , \n <number_literal> store <identifiersep> <identifier> . get <identifiersep> type ( ) , \n <number_literal> true ) ; \n <ect>
\t6 size . <identifier> <identifiersep> and <identifiersep> get ( ) ; } } } \n \t3 if ( first == null ) { \n \t4 log . error ( <string_literal> + size . get ( ) + <string_literal> ) ; } \n \t3 if ( last == null ) { \n <ect>
\t2 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> service . get <identifiersep> <identifier> <identifiersep> <identifier> ( not <identifiersep> <identifier> , null , null , null , null , null , false ) ) { \n \t3 if ( ! <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . <identifier> ( ) ; \n \t4 <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t2 factory . shutdown ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> db . close ( ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t5 return false ; } } \n \t2 } finally { \n \t3 try { \n \t4 <identifier> <identifiersep> network <identifiersep> <identifier> . <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> <identifiersep> to <identifiersep> stop ) ; \n <ect>
\t3 if ( vm == null || vm . get <identifiersep> host <identifiersep> id ( ) == null || vm . get <identifiersep> host <identifiersep> id ( ) != <identifier> <identifiersep> host <identifiersep> id || ! <identifier> <identifiersep> state ( vm , event . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> host <identifiersep> id , <identifier> , <identifier> . <identifier> ) ) { \n \t4 s <identifiersep> logger . info ( <string_literal> + vm ) ; \n \t4 throw new <identifier> <identifiersep> operation <identifiersep> exception ( <string_literal> + vm ) ; } \n \t2 } catch ( final no <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 if ( c != null ) { \n \t3 try { \n \t4 c . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> + name ) ; } \n \t5 if ( <identifier> > <number_literal> ) { \n \t6 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> + name ) ; } } \n \t3 } catch ( final number <identifiersep> format <identifiersep> exception e ) { \n <ect>
<number_literal> . get <identifiersep> key ( ) , \n <number_literal> <identifier> <identifiersep> current <identifiersep> <identifier> <identifiersep> map . get ( <identifier> <identifiersep> version ) \n <number_literal> . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 return ; } \n \t2 list < string > <identifier> <identifiersep> <identifier> = new java <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> builder ( <identifier> ) . <identifier> <identifiersep> <identifier> <identifiersep> options ( true ) . <identifier> <identifiersep> source <identifiersep> files ( true ) . build ( ) ; \n \t2 string <identifier> <identifiersep> <identifier> = <identifier> . on ( ' ' ) . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 return <identifier> <identifiersep> <identifier> . <identifier> ( msg ) ; } \n \t1 public object <identifier> ( message msg ) { \n \t2 <identifier> <identifiersep> header <identifier> = msg . get <identifiersep> header ( id ) ; \n \t2 if ( <identifier> == null ) \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t1 try { \n \t1 log . debug ( <string_literal> + current <identifiersep> <identifier> <identifiersep> id + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id + <string_literal> + base <identifiersep> <identifier> ) ; \n \t1 connection <identifiersep> manager . <identifier> <identifiersep> snapshot <identifiersep> <identifier> ( base <identifiersep> <identifier> , <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 current <identifiersep> input <identifiersep> format <identifiersep> class , current <identifiersep> <identifier> . size ( ) * ( num <identifiersep> <identifier> / <identifier> . length ) , \n \t2 current <identifiersep> table , result ) ; } \n \t1 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> for <identifiersep> conf ( job ) ; \n <ect>
\t3 return ; } \n \t2 list < string > <identifier> <identifiersep> <identifier> = new java <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> builder ( <identifier> ) . <identifier> <identifiersep> <identifier> <identifiersep> options ( true ) . <identifier> <identifiersep> source <identifiersep> files ( true ) . build ( ) ; \n \t2 string <identifier> <identifiersep> <identifier> = <identifier> . on ( ' ' ) . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t6 log . debug ( <string_literal> , query , total <identifiersep> <identifier> ) ; \n \t6 return total <identifiersep> <identifier> ; } \n \t5 log . debug ( <string_literal> , <identifier> <identifiersep> request <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> request ( ) ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 private registered <identifiersep> service process <identifiersep> <identifier> <identifiersep> registered <identifiersep> service ( final registered <identifiersep> service registered <identifiersep> service ) { \n \t2 final registered <identifiersep> service <identifiersep> <identifier> <identifiersep> policy policy = registered <identifiersep> service . get <identifiersep> <identifier> <identifiersep> policy ( ) ; \n \t2 logger . warn ( <string_literal> , registered <identifiersep> service . get <identifiersep> service <identifiersep> id ( ) , policy . get <identifiersep> <identifier> <identifiersep> date ( ) ) ; \n \t2 if ( policy . is <identifiersep> delete <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 set <identifiersep> request ( request ) ; \n \t3 boolean <identifier> = false ; \n \t3 process <identifiersep> request ( false ) ; <comment> \n \t3 long stop = system . current <identifiersep> time <identifiersep> millis ( ) ; \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t2 file <identifier> <identifiersep> file = new file ( dir , <identifier> <identifiersep> config <identifiersep> file ) ; \n \t2 try { \n \t3 data <identifiersep> <identifier> . load <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> file ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 file <identifiersep> utils . create <identifiersep> directory ( dir ) ; } \n \t3 catch ( <identifier> <identifiersep> error e ) \n \t3 { \n \t4 <comment> \n <ect>
\t2 try { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . close ( ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t1 try { \n \t1 handle = <identifier> <identifiersep> handler . get <identifiersep> <identifier> <identifiersep> api ( ) . <identifier> <identifiersep> lock ( <identifier> <identifiersep> store . <identifier> <identifiersep> key . <identifier> <identifiersep> <identifier> . name ( ) ) ; \n \t1 long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 <identifier> <identifiersep> handler . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 case <identifier> : \n \t4 try { \n \t5 this . <identifier> = <identifier> <identifiersep> config . value <identifiersep> of ( value <identifiersep> <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t3 if ( result instanceof exception ) \n \t3 { \n \t4 exception ex = ( exception ) result ; \n \t4 final exception ex <identifiersep> <identifier> = exception <identifiersep> <identifier> . <identifier> ( ex ) ; \n <ect>
\t2 authentication <identifier> <identifiersep> token = new <identifier> <identifiersep> user <identifiersep> authentication ( null , <identifier> . get <identifiersep> user ( user <identifiersep> entity ) , <identifier> . get <identifiersep> user <identifiersep> <identifier> ( user <identifiersep> entity ) ) ; \n \t2 <identifier> <identifiersep> token . set <identifiersep> <identifier> ( true ) ; \n \t2 return <identifier> <identifiersep> token ; } \n \t1 } catch ( authentication <identifiersep> exception e ) { \n <ect>
\t4 transport . do <identifiersep> send ( output . <identifier> ( ) , 0 , output . <identifier> ( ) , <identifier> ) ; \n \t4 if ( transport . <identifier> <identifiersep> enabled ( ) ) \n \t5 transport . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( num <identifiersep> <identifier> ) ; } \n \t3 catch ( exception ex ) { \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = template ( ) . request <identifiersep> body <identifiersep> and <identifiersep> header ( <string_literal> , \n \t3 test <identifiersep> <identifier> <identifiersep> id , <identifier> <identifiersep> endpoint <identifiersep> config . <identifier> <identifiersep> <identifier> , boolean . true , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 string file <identifiersep> name = <identifier> + <string_literal> + address <identifiersep> to <identifiersep> <identifier> ( <identifier> ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> client . delete <identifiersep> object ( <identifier> , file <identifiersep> name ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> manager . listener listener = <identifier> <identifiersep> manager . listener ; \n \t4 if ( listener != null ) { \n \t5 listener . start ( ) ; \n \t4 } else { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> api . delete <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> port ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> port . get <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception exception <identifiersep> delete ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> port . get <identifiersep> <identifier> ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> port . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> + exception <identifiersep> delete . get <identifiersep> message ( ) ) ; } \n <ect>
<comment> \n \t1 public void stop <identifiersep> <identifier> ( cluster cluster , int <identifier> ) { \n <ect>
\t2 logger . debug ( <string_literal> , this ) ; \n \t2 <identifier> ( connection . <identifier> <identifiersep> command ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t3 try { \n \t4 <comment> \n \t4 <identifier> <identifiersep> thread . <identifier> ( thread <identifiersep> <identifier> <identifiersep> timeout ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 log . info ( <string_literal> , db . get <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( <string_literal> , url ) ; \n \t2 log . info ( <string_literal> , get <identifiersep> target <identifiersep> directory ( ) ) ; \n <ect>
\t3 } else { \n \t4 s <identifiersep> logger . warn ( <string_literal> + vm + <string_literal> + network ) ; \n \t4 return false ; } \n \t2 } else if ( vm . get <identifiersep> state ( ) != state . <identifier> ) { \n <ect>
\t5 return <string_literal> ; } \n \t4 return double . to <identifiersep> string ( <identifier> ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n \t4 <comment> \n <ect>
\t2 string method <identifiersep> name = get <identifiersep> get <identifiersep> method <identifiersep> name ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t2 try { \n \t3 method = o . get <identifiersep> class ( ) . get <identifiersep> method ( method <identifiersep> name ) ; \n \t2 } catch ( security <identifiersep> exception <identifier> ) { \n <ect>
\t2 this . <identifier> = <identifier> \n \t2 this . logger = logger } \n \t1 @ <identifier> \n \t1 boolean test ( final <identifier> <identifiersep> authentication <identifiersep> provider p ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <identifier> <identifiersep> volume <identifiersep> to <identifiersep> root <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> name , vm <identifiersep> name , <identifier> <identifiersep> <identifier> ) ; } \n \t2 if ( <identifier> . file <identifiersep> exists ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> mode <identifiersep> <identifier> <identifiersep> <identifier> [ 1 ] ) ) { \n <ect>
\t2 log . info ( <string_literal> , configuration . get <identifiersep> host ( ) , configuration . get <identifiersep> port ( ) ) ; \n \t2 channel = <identifier> <identifiersep> channel ( channel <identifiersep> <identifier> ) ; } \n \t1 protected void stop <identifiersep> server <identifiersep> <identifier> ( ) { \n \t2 <comment> \n <ect>
\t2 job <identifiersep> id = <identifier> . get <identifiersep> id ( ) . to <identifiersep> string ( ) ; } \n \t2 if ( <identifier> != null ) { \n \t2 <identifier> . close ( ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> exception as e : \n \t3 self . <identifier> ( e ) \n \t2 finally : \n \t3 self . assert <identifiersep> <identifier> ( <identifier> is not <identifier> , <string_literal> ) \n <ect>
\t1 throw new <identifier> <identifiersep> security <identifiersep> exception ( <string_literal> ) ; } \n \t1 return <identifier> ; } \n @ <identifier> \n public void add <identifiersep> <identifier> ( final string <identifier> , final <identifier> <identifier> ) throws io <identifiersep> exception , <identifier> <identifiersep> security <identifiersep> exception { \n <ect>
\t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 0 ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 1 ) . state ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 0 ) . current <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; \n \t3 assert <identifiersep> that ( cluster <identifiersep> state . routing <identifiersep> table ( ) . index ( <string_literal> ) . <identifier> ( i ) . shards ( ) . get ( 1 ) . current <identifiersep> node <identifiersep> id ( ) , null <identifiersep> value ( ) ) ; } \n <ect>
\t4 synchronized ( context ) { \n \t5 try { \n \t6 context . set <identifiersep> listener ( false ) ; \n \t6 if ( ! <identifier> <identifiersep> file . set <identifiersep> bytes ( <identifier> ) ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + api . get <identifiersep> test <identifiersep> case <identifiersep> info ( ) + <string_literal> + api . get <identifiersep> url ( ) ) ; \n \t3 } else { \n \t4 <comment> \n \t4 if ( api . set <identifiersep> <identifier> ( this . get <identifiersep> <identifier> ( ) ) == false ) { \n <ect>
\t5 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; } \n \t4 try { \n \t5 <identifier> <identifiersep> store . <identifier> <identifiersep> as <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 try { \n \t3 return p . get <identifiersep> <identifier> ( name ) ; \n \t2 } catch ( exception ex ) { \n \t3 <comment> \n <ect>
\t3 job <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new job <identifiersep> <identifier> <identifiersep> <identifier> ( this ) ; \n \t3 try { \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . add <identifiersep> <identifier> ( attribute <identifiersep> <identifier> ) ; } \n \t3 <identifier> <identifiersep> model = <identifier> <identifiersep> <identifier> <identifiersep> response ( <identifier> <identifiersep> response <identifiersep> <identifier> , <identifier> <identifiersep> model , session , user <identifiersep> session , client <identifiersep> session ) ; \n \t3 <identifier> <identifiersep> <identifier> = builder . build <identifiersep> <identifier> ( <identifier> <identifiersep> model ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t8 } else if ( <identifier> . exists ( ) ) { \n \t9 <identifier> = false ; \n \t9 <identifier> <identifiersep> manager . add <identifiersep> message ( <identifier> <identifiersep> t ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ) ; \n \t9 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 public void run ( ) { \n \t2 try { \n \t2 thread . <identifier> ( <identifier> ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t5 <identifier> <identifiersep> log . debug ( <string_literal> + host + ' : ' + port ) ; } \n \t2 boolean is <identifiersep> <identifier> = boolean . parse <identifiersep> boolean ( <identifier> . get <identifiersep> property ( <string_literal> ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get ( ) > 0 ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t3 m . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> instance ( ) , new object [ ] { <identifier> } ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception <identifier> ) { \n \t3 log . error ( <string_literal> , <identifier> ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n <ect>
\t3 s <identifiersep> logger . info ( <string_literal> + host ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> connection . start ( ) ; \n \t3 } catch ( final <identifier> <identifiersep> connection <identifiersep> exception e ) { \n <ect>
\t2 public void on <identifiersep> close ( web <identifiersep> socket <identifier> , int code , string <identifier> ) { \n \t3 log . info ( <string_literal> + code + <string_literal> + <identifier> ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> error ( throwable t ) { \n <ect>
\t3 s <identifiersep> logger . info ( <string_literal> + vm . get <identifiersep> instance <identifiersep> name ( ) + <string_literal> + vm . get <identifiersep> state ( ) + <string_literal> ) ; \n \t3 try { \n \t4 state <identifiersep> <identifier> <identifiersep> to ( vm , <identifier> <identifiersep> <identifier> . event . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> , vm . get <identifiersep> <identifier> <identifiersep> host <identifiersep> id ( ) ) ; \n \t3 } catch ( final no <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 request <identifiersep> <identifier> = <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> access <identifiersep> token <identifiersep> <identifier> <identifiersep> request ( request , response ) ; \n \t3 logger . debug ( <string_literal> , request <identifiersep> <identifier> ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t1 request <identifiersep> account <identifiersep> number = <identifier> . get <identifiersep> account <identifiersep> number ( ) ; \n \t1 request <identifiersep> <identifier> <identifiersep> id = request <identifiersep> user . get <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t1 <identifier> <identifiersep> context = <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t1 } catch ( final no <identifiersep> such <identifiersep> context <identifiersep> exception e ) { \n <ect>
\t2 load <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> listener = new <identifier> <identifiersep> manager <identifiersep> <identifier> <identifiersep> listener ( this , debug <identifiersep> <identifier> . get <identifiersep> default ( ) . get <identifiersep> <identifier> <identifiersep> manager ( ) ) ; } \n \t1 @ <identifier> \n \t1 public i <identifiersep> <identifier> create <identifiersep> execution <identifiersep> <identifier> ( final <identifier> <identifiersep> data data ) { \n <ect>
\t1 private <identifier> <identifiersep> check . result <identifier> ( <identifier> <identifiersep> check check , map < string , object > options ) { \n \t2 return lock <identifiersep> <identifier> . <identifier> <identifiersep> with <identifiersep> write <identifiersep> lock ( \n \t3 lock , \n \t3 ( ) - > { \n <ect>
\t1 log . debug ( <string_literal> ) ; \n \t1 if ( <identifier> <identifiersep> client != null ) { \n \t1 <identifier> <identifiersep> client . stop ( ) ; \n \t1 } else { \n <ect>
<comment> \n \t1 synchronized public void <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> <identifier> . size ( ) == 0 ) { \n <ect>
\t1 <identifier> . <identifier> <identifiersep> to ( current ) ; \n \t1 return <identifier> . is <identifiersep> empty ( ) ? null : <identifier> . get <identifiersep> <identifier> ( ) ; } } \n private string <identifier> <identifiersep> <identifier> ( request request , <identifier> db <identifiersep> <identifier> , string <identifier> <identifiersep> for ) throws io <identifiersep> exception { \n \t1 string <identifier> <identifiersep> version = get <identifiersep> <identifier> <identifiersep> version ( request . <identifier> <identifiersep> model , <identifier> <identifiersep> for ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> test <identifiersep> bean <identifiersep> <identifier> ( ) { \n <ect>
\t3 log . error ( <string_literal> ) ; \n \t3 log . error ( <string_literal> + <identifier> . get <identifiersep> error <identifiersep> code ( ) ) ; \n \t3 log . error ( <string_literal> + <identifier> . get <identifiersep> error <identifiersep> message ( ) , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> client <identifiersep> exception <identifier> ) { \n <ect>
\t6 <identifier> = string <identifiersep> utils . <identifier> <identifiersep> case ( <identifier> ) ; } \n \t5 <identifier> <identifiersep> list . add ( <identifier> . <identifier> ( <identifier> ) ) ; } \n \t4 log . info ( <string_literal> , file . get <identifiersep> path ( ) ) ; } \n \t2 } else { \n <ect>
\t2 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> store ( configuration . get <identifiersep> <identifier> <identifiersep> key <identifiersep> store <identifiersep> location ( ) , <identifier> <identifiersep> key <identifiersep> service ) ; \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> store . get <identifiersep> key <identifiersep> store <identifiersep> path ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 <comment> \n \t3 transport <identifiersep> service . <identifier> <identifiersep> to <identifiersep> node ( <identifier> <identifiersep> node ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 collection < string > <identifier> = <identifier> <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> by <identifiersep> state ( <identifier> <identifiersep> entity , state ) ; \n \t1 for ( string action : <identifier> ) { \n \t2 action action <identifiersep> to <identifiersep> execute = action <identifiersep> manager . get <identifiersep> action ( action , <identifier> <identifiersep> entity . get <identifiersep> <identifier> <identifiersep> map ( ) ) ; \n \t2 if ( action <identifiersep> to <identifiersep> execute == null ) { \n <ect>
\t1 @ <identifier> private network <identifiersep> manager <identifier> <identifiersep> network <identifiersep> <identifier> = null ; \n \t1 @ <identifier> \n \t1 public boolean is <identifiersep> vm <identifiersep> <identifier> ( vm <identifiersep> instance <identifiersep> vo vm , host <identifiersep> vo host ) { \n \t2 if ( ! <identifier> <identifiersep> <identifier> . type . is <identifiersep> system <identifiersep> vm ( vm . get <identifiersep> type ( ) ) ) { \n <ect>
protected void run <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t1 map < string , cluster > cluster <identifiersep> map = m <identifiersep> <identifier> <identifiersep> provider . get ( ) . get <identifiersep> <identifier> ( ) ; \n \t1 for ( cluster cluster : cluster <identifiersep> map . values ( ) ) { \n \t1 try { \n <ect>
\t10 int item <identifiersep> id = provider . get <identifiersep> item <identifiersep> id ( item <identifiersep> name ) ; \n \t10 if ( key == item <identifiersep> id ) { \n <number_literal> event <identifiersep> <identifier> . <identifier> <identifiersep> update ( item <identifiersep> name , state ) ; } } } } } } \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
<number_literal> file <identifier> [ ] , \n <number_literal> final class <identifiersep> <identifier> <identifier> ) \n \t2 throws exception { \n <ect>
\t7 . build <identifiersep> <identifier> ( <identifier> <identifiersep> store <identifiersep> context . class ) ; \n \t3 context . get <identifiersep> <identifier> <identifiersep> store ( ) . create <identifiersep> <identifier> <identifiersep> in <identifiersep> location ( null , <identifier> <identifiersep> <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 } else { \n \t5 logger . debug ( <string_literal> + node <identifiersep> id ) ; } } } \n \t2 if ( ! <identifier> ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t3 } else { \n \t4 <identifier> . set <identifiersep> null ( 1 , <identifier> . <identifier> ) ; } \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t2 } catch ( sql <identifiersep> exception <identifier> ) { \n <ect>
\t5 try { \n \t6 if ( <identifier> <identifiersep> map . get ( m . <identifier> ) == null ) { \n \t7 <identifier> <identifiersep> socket . send ( request <identifiersep> <identifier> ) ; } \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t7 log . error ( <string_literal> , message , e ) ; } } \n \t4 } ) ; \n \t4 answer = new message <identifiersep> consumer <identifiersep> <identifier> ( session , message <identifiersep> consumer , <identifier> <identifiersep> to <identifiersep> destination ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 <identifier> = null ; } } } } \n private boolean check <identifiersep> <identifier> ( <identifier> <identifiersep> file <identifiersep> key <identifiersep> <identifier> <identifier> ) { \n \t1 <comment> \n \t1 if ( ! file <identifiersep> <identifier> . equals ( <identifier> . get <identifiersep> file <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t3 if ( volume <identifiersep> <identifier> ) { \n \t4 try { \n \t5 delete <identifiersep> <identifier> <identifiersep> volume ( <identifier> <identifiersep> name , s ) ; <comment> \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . key ( <string_literal> ) ; \n \t4 <identifier> . value ( <identifier> <identifiersep> info <identifiersep> string ) ; \n \t4 <identifier> . end <identifiersep> object ( ) ; \n \t3 } catch ( <identifier> <identifiersep> service <identifiersep> exception e ) { \n <ect>
\t5 if ( command instanceof <identifier> <identifiersep> type ) { \n \t6 float <identifier> = ( ( <identifier> <identifiersep> type ) command ) . float <identifiersep> value ( ) ; \n \t6 int value = ( int ) ( <identifier> * <number_literal> . ) ; \n \t6 if ( send <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , value ) ) { \n <ect>
\t3 if ( run <identifiersep> <identifier> . try <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> <identifiersep> <identifier> = true ; \n \t4 run <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } else { \n <ect>
\t1 @ get \n \t1 @ path ( <string_literal> ) \n \t1 @ <identifier> ( <string_literal> ) \n \t1 public string get <identifiersep> <identifier> ( ) { \n <ect>
\t3 final string <identifiersep> builder command <identifiersep> line = get <identifiersep> command <identifiersep> line ( ) ; \n \t3 if ( command <identifiersep> line != null ) { \n \t4 cmd = command <identifiersep> line . to <identifiersep> string ( ) ; \n \t4 string [ ] <identifier> = { <string_literal> , <string_literal> , cmd } ; \n <ect>
\t3 log . trace ( string . format ( <string_literal> , configuration . get <identifiersep> path ( ) ) ) ; } \n \t2 <identifier> . shutdown ( ) ; } \n \t1 private void <identifier> <identifiersep> delete <identifiersep> node ( <identifier> <identifiersep> <identifier> connection , <identifier> <identifiersep> context context ) { \n <ect>
\t5 for ( <identifier> <identifiersep> consumer consumer : <identifier> ) { \n \t6 consumer . <identifier> ( ) ; } \n \t5 connection <identifiersep> failed = false ; \n \t4 } catch ( exception e ) { \n <ect>
<comment> \n \t1 public map <identifiersep> config build <identifiersep> map <identifiersep> config ( final base <identifiersep> <identifier> <identifiersep> properties <identifier> , final string map <identifiersep> name , final long timeout <identifiersep> <identifier> ) { \n \t2 final <identifier> <identifiersep> cluster <identifiersep> properties cluster = <identifier> . get <identifiersep> cluster ( ) ; \n \t2 final <identifier> <identifiersep> policy <identifier> <identifiersep> policy = <identifier> <identifiersep> policy . value <identifiersep> of ( cluster . get <identifiersep> <identifier> <identifiersep> policy ( ) ) ; \n <ect>
\t3 try { \n \t4 <identifier> result = <identifier> . <identifier> ( <identifier> . <identifier> ( ) , <identifier> . <identifier> ( <number_literal> ) , <identifier> . <identifier> ( <number_literal> ) ) \n \t4 return result . <identifier> ( ) \n \t3 } catch ( e : <identifier> <identifiersep> error ) { \n <ect>
\t1 if ( null != header <identifiersep> <identifier> ) \n \t2 <identifier> <identifiersep> name = ( string ) header <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) [ <identifier> <identifiersep> num ] ; \n \t1 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name , type . to <identifiersep> string ( ) , <identifier> <identifiersep> num ) ; \n \t1 header . add ( <identifier> ) ; } \n <ect>
\t3 if ( should <identifiersep> be <identifiersep> <identifier> ) { \n \t4 <identifier> ( <string_literal> ) ; } \n \t2 } catch ( exception e ) { \n \t3 if ( ! should <identifiersep> be <identifiersep> <identifier> ) { \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } \n \t2 <identifier> <identifiersep> vo <identifier> = null ; \n \t2 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> ( new <identifier> <identifiersep> vo ( <identifier> , <identifier> , cmd . get <identifiersep> entity <identifiersep> <identifier> <identifiersep> id ( ) , cmd . get <identifiersep> <identifier> <identifiersep> id ( ) , <identifier> ) ) ; \n <ect>
\t1 private static void run <identifiersep> test ( string <identifier> <identifiersep> host , int <identifier> <identifiersep> port , string <identifier> <identifiersep> options ) { \n \t2 test <identifiersep> <identifier> ( <identifier> <identifiersep> host , <identifier> <identifiersep> port , <identifier> <identifiersep> options ) ; } \n \t1 private static void test <identifiersep> <identifier> ( string host , int port , string <identifier> <identifiersep> options ) { \n \t2 string <identifier> <identifiersep> name = <string_literal> ; \n <ect>
\t3 { \n \t3 final <identifiersep> key = argument <identifiersep> utils . data <identifiersep> map <identifiersep> to <identifiersep> <identifier> <identifiersep> key ( ( data <identifiersep> map ) <identifier> <identifiersep> key , resource . get <identifiersep> <identifier> ( ) ) ; } \n \t3 catch ( illegal <identifiersep> argument <identifiersep> exception e ) \n \t3 { \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( channel <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 <comment> \n \t2 if ( this . is <identifiersep> <identifier> ( ) || this . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t7 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> load ( <identifier> . get <identifiersep> id ( ) ) < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> || has <identifiersep> <identifier> <identifiersep> session ( <identifier> , vm ) ) { \n \t9 s <identifiersep> logger . trace ( <string_literal> + vm <identifiersep> id ) ; } \n \t8 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> session ( ) >= <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 . filter ( r - > r . get <identifiersep> status ( ) == <identifier> <identifiersep> request <identifiersep> status . not <identifiersep> <identifier> ) \n \t4 . for <identifiersep> <identifier> ( r - > { \n \t5 logger . debug ( <string_literal> , r . get <identifiersep> <identifier> <identifiersep> url ( ) . to <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t5 final string <identifier> <identifiersep> message = this . <identifier> <identifiersep> manager . create <identifiersep> <identifier> <identifiersep> channel <identifiersep> <identifier> <identifiersep> message ( r ) ; \n <ect>
\t3 try { \n \t4 <identifier> . cluster <identifiersep> <identifier> <identifiersep> <identifier> ( event ) ; \n \t3 } catch ( exception e ) { \n <ect>
<comment> \n \t1 public static void <identifier> <identifiersep> delete ( file <identifier> , file root ) throws io <identifiersep> exception { \n \t2 if ( <identifier> . exists ( ) ) { \n \t3 file <identifiersep> utils . <identifier> <identifiersep> delete ( <identifier> ) ; \n <ect>
\t2 <identifier> <identifiersep> data . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( event , 0 , long . max <identifiersep> value , time <identifiersep> unit . <identifier> ) ; } \n \t1 public void shutdown ( ) { \n \t2 log . info ( <string_literal> ) ; \n \t2 get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> ( ) ; \n <ect>
\t4 set < method > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( bean <identifiersep> type , attribute <identifiersep> <identifier> ) ; \n \t4 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t5 this . model <identifiersep> attribute <identifiersep> <identifier> <identifiersep> cache . put ( bean , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 try { \n \t4 client . close ( ) ; \n \t4 logger . debug ( <string_literal> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 logger . debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 return true ; } \n \t2 final long count <identifiersep> <identifier> = ticket <identifiersep> state . get <identifiersep> count <identifiersep> of <identifiersep> <identifier> ( ) ; \n \t2 if ( count <identifiersep> <identifier> >= this . number <identifiersep> of <identifiersep> <identifier> ) { \n <ect>
\t2 config . set <identifiersep> time <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( ticket . get <identifiersep> <identifier> <identifiersep> policy ( ) . get <identifiersep> time <identifiersep> to <identifiersep> <identifier> ( ) ) ; \n \t2 config . set <identifiersep> time <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( ticket . get <identifiersep> <identifier> <identifiersep> policy ( ) . get <identifiersep> time <identifiersep> to <identifiersep> <identifier> ( ) ) ; \n \t2 if ( element . is <identifiersep> <identifier> ( config ) || ticket . is <identifiersep> <identifier> ( ) ) { \n \t3 <identifier> . remove ( element ) ; \n <ect>
\t5 if ( key instanceof string ) { \n \t6 if ( this . default <identifiersep> <identifier> || header <identifiersep> map . get ( key ) == null ) { \n \t7 header <identifiersep> map . put ( ( string ) key , entry . get <identifiersep> value ( ) ) ; } } \n <ect>
\t2 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> . class , <identifier> <identifiersep> <identifier> <identifiersep> manager . object <identifiersep> <identifier> . class ) . <identifier> <identifiersep> to ( <number_literal> ) . <identifier> ( object <identifiersep> <identifier> ) ; } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 throw e ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 method method = java <identifiersep> class . get <identifiersep> method ( <string_literal> , java <identifiersep> <identifier> <identifiersep> context . class ) ; \n \t3 is <identifiersep> to <identifiersep> be <identifiersep> registered = ! method . get <identifiersep> <identifier> <identifiersep> class ( ) . equals ( abstract <identifiersep> java <identifiersep> <identifier> <identifiersep> client . class ) ; \n \t3 log . info ( <string_literal> + name + <string_literal> + is <identifiersep> to <identifiersep> be <identifiersep> registered ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public <identifier> <identifiersep> <identifier> ( execution <identifiersep> <identifier> execution <identifiersep> <identifier> , <identifier> <identifier> , list < execution <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> ) { \n \t2 this . execution <identifiersep> <identifier> = check <identifiersep> not <identifiersep> null ( execution <identifiersep> <identifier> ) ; \n \t2 this . <identifier> = check <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t2 this . <identifier> <identifiersep> execution <identifiersep> <identifier> = check <identifiersep> not <identifiersep> null ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t1 throws <identifier> <identifiersep> server <identifiersep> exception , io <identifiersep> exception { \n \t1 if ( all <identifiersep> collection <identifiersep> list . contains ( <identifier> <identifiersep> <identifier> <identifiersep> config . get <identifiersep> collection ( ) ) ) { \n \t1 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> config . get <identifiersep> collection ( ) + <string_literal> ) ; \n \t1 return true ; } \n <ect>
\t1 public static <identifier> <identifiersep> array < string > file <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) { \n \t2 if ( file <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> == null ) { \n \t3 file <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> = <identifier> <identifiersep> properties . array <identifiersep> for <identifiersep> key <identifiersep> with <identifiersep> default ( <string_literal> , new <identifier> <identifiersep> array < > ( new string [ ] { <string_literal> , <string_literal> } ) ) ; \n <ect>
\t4 <identifier> . put ( <identifier> , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 <identifier> <identifiersep> log . error ( <string_literal> , <identifier> ) ; \n \t2 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t1 private boolean remove <identifiersep> <identifier> ( @ <identifier> class <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> ignore , map < string , string > <identifier> , \n \t2 collection < class <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 assert <identifier> != null ; \n <ect>
\t1 io <identifiersep> utils . close <identifiersep> <identifier> ( <identifier> ) ; } \n @ <identifier> \n public <identifier> <identifiersep> <identifier> get <identifiersep> <identifier> ( final string context , final i <identifiersep> <identifier> <identifiersep> session <identifier> <identifiersep> session ) { \n <ect>
\t3 list < node > <identifier> <identifiersep> nodes ) { \n \t2 if ( <identifier> <identifiersep> builder == null || \n \t4 <identifier> <identifiersep> nodes == null || \n \t4 <identifier> <identifiersep> nodes . is <identifiersep> empty ( ) ) { \n <ect>
\t2 throw new v <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> . class + <string_literal> + type \n \t3 + <string_literal> ) ; } } \n \t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 private void <identifier> <identifiersep> <identifier> ( class < ? > type ) { \n <ect>
\t1 for ( file <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t2 try { \n \t2 <identifier> . close ( ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t5 template . execute ( <identifier> , <identifier> ) ; \n \t5 return null ; \n \t4 } ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 self <identifiersep> <identifier> <identifiersep> remote . <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( exception e ) { \n \t2 log . log ( level . <identifier> , <string_literal> , e ) ; } } } \n public void stop ( ) { \n <ect>
* <identifier> . stop ( ) ; <comment> \n * \n * long millis = <identifier> . <identifier> ( <identifier> ) ; \n * \n <ect>
\t4 builder . <identifier> ( <string_literal> ) . <identifier> ( exception . get <identifiersep> <identifier> <identifiersep> number ( ) ) ; \n \t4 builder . <identifier> ( <string_literal> ) . <identifier> ( exception . get <identifiersep> public <identifiersep> id ( ) ) ; \n \t4 builder . <identifier> ( <string_literal> ) . <identifier> ( exception . get <identifiersep> system <identifiersep> id ( ) ) ; \n \t4 builder . <identifier> ( <string_literal> ) . <identifier> ( exception . get <identifiersep> <identifier> <identifiersep> message ( ) ) ; \n <ect>
\t2 final default <identifiersep> exchange exchange = new default <identifiersep> exchange ( <identifier> ) ; \n \t2 final string string = <identifier> . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> to ( string . class , exchange , <identifier> ) ; \n \t2 log . info ( <string_literal> , string ) ; \n \t2 final <identifier> <identifier> = <identifier> . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> to ( <identifier> . class , exchange , string ) ; \n <ect>
\t1 } catch ( number <identifiersep> format <identifiersep> exception exception ) { \n \t1 log . debug ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> = <number_literal> ; } \n \t1 if ( - 1 == <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 { \n \t2 <identifier> <identifiersep> log . warn ( <string_literal> , <identifier> ) ; } } } \n \t1 else \n \t1 { \n <ect>
\t2 if ( host == null ) { \n \t3 s <identifiersep> logger . info ( <string_literal> ) ; \n \t3 return null ; } \n \t2 if ( password == null ) { \n <ect>
\t4 vm <identifiersep> template <identifiersep> vo template = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( template <identifiersep> id ) ; \n \t4 if ( template == null ) { \n \t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + template <identifiersep> id ) ; } \n \t4 if ( template . get <identifiersep> template <identifiersep> type ( ) == template <identifiersep> type . system ) { \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> context . get <identifiersep> out ( ) . <identifier> ( result ) ; \n \t3 } catch ( exception ex ) { \n \t4 if ( log . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t4 if ( <identifier> <identifiersep> response . get <identifiersep> <identifier> <identifiersep> shards ( ) == test . num <identifiersep> <identifier> && ! <identifier> <identifiersep> failed ) { \n \t5 assert <identifiersep> <identifier> <identifiersep> and <identifiersep> log <identifiersep> on <identifiersep> failure ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> response ) ; } \n \t4 <comment> \n \t4 <identifier> <identifiersep> response = client ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> query ( query <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> query ( ) ) . set <identifiersep> size ( num <identifiersep> <identifier> ) . add <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> ) . get ( ) ; \n <ect>
@ <identifier> \n public class <identifier> <identifiersep> exception <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> bean implements <identifier> <identifiersep> exception <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> resource { \n \t1 private static logger logger = logger . get <identifiersep> logger ( <identifier> <identifiersep> exception <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> bean . class ) ; \n \t1 public string get <identifiersep> <identifier> ( ) { \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> channel <identifiersep> <identifier> ( <identifier> <identifiersep> request ) ) { \n \t5 <identifier> <identifiersep> request . set <identifiersep> status ( <identifier> <identifiersep> request <identifiersep> status . success ) ; \n \t4 } else { \n \t5 <identifier> <identifiersep> request . set <identifiersep> status ( <identifier> <identifiersep> request <identifiersep> status . failure ) ; \n <ect>
@ <identifier> \n public void <identifier> <identifiersep> stop ( service <identifiersep> configuration config ) throws service <identifiersep> <identifier> <identifiersep> exception { \n \t1 try { \n \t1 if ( config . is <identifiersep> vm <identifiersep> local ( ) ) { \n <ect>
\t2 log . debug ( <string_literal> + status ) ; \n \t2 if ( <identifier> <identifiersep> set <identifiersep> <identifier> <identifiersep> status == 0 ) { \n \t3 if ( status == status <identifiersep> <identifier> ) { \n \t4 <comment> \n <ect>
\t4 <identifier> <identifiersep> to <identifiersep> entry . put <identifiersep> if <identifiersep> <identifier> ( <identifier> , new <identifiersep> entry ) ; } \n \t3 else \n \t3 { \n \t4 <comment> \n <ect>
\t6 this . <identifier> <identifiersep> provider . get ( ) ) == 0 ) { \n \t6 <comment> \n \t6 set <identifiersep> state ( null ) ; } \n \t4 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 public static void <identifier> ( ) { \n \t2 file <identifier> <identifiersep> directory = new file ( configuration . get <identifiersep> <identifier> <identifiersep> directory ( ) ) ; \n \t2 logger . info ( <string_literal> + <identifier> <identifiersep> directory . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 if ( ! <identifier> <identifiersep> directory . exists ( ) ) { \n <ect>
\t3 if ( <identifier> <identifiersep> transport <identifiersep> type == <identifier> <identifiersep> factory . socket ) { \n \t4 <identifier> <identifiersep> <identifier> = true ; \n \t4 <identifier> <identifiersep> config = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> config ( get <identifiersep> <identifier> ( ) , session <identifiersep> id ) ; \n \t3 } else { \n <ect>
\t2 class < ? > type = method . get <identifiersep> method ( ) . get <identifiersep> return <identifiersep> type ( ) ; \n \t2 return input <identifiersep> stream . class . is <identifiersep> <identifier> <identifiersep> from ( type ) || type == file . class || <identifier> . class . is <identifiersep> <identifier> <identifiersep> from ( type ) \n \t4 || type == byte [ ] . class ; } \n \t1 public void <identifier> ( <identifier> <identifiersep> stack stack , resource <identifiersep> method method , object instance ) throws <identifier> <identifiersep> exception { \n <ect>
\t2 } else { \n \t3 <identifier> <identifiersep> failed ( <identifier> ) ; } } \n \t1 private void <identifier> <identifiersep> function ( <identifier> <identifiersep> <identifier> <identifier> ) \n \t1 { \n <ect>
\t1 logger . debug ( <string_literal> + <identifier> . function . is <identifiersep> <identifier> ) \n \t1 logger . debug ( <string_literal> + \n \t2 ( if ( <identifier> . <identifier> <identifiersep> from <identifiersep> status == null ) <string_literal> else string <identifiersep> utils . <identifier> ( <identifier> . <identifier> <identifiersep> from <identifiersep> status . to <identifiersep> string ) ) + \n \t2 <string_literal> + ( <identifier> . <identifier> <identifiersep> from <identifiersep> status != null && <identifier> . <identifier> <identifiersep> from <identifiersep> status != <identifier> . status ) + <string_literal> ) } \n <ect>
\t5 <identifier> <identifiersep> string = <string_literal> ; } \n \t4 m . put ( <identifier> <identifiersep> string , i ) ; \n \t4 c = r . read ( ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> volume <identifiersep> storage <identifiersep> <identifier> . put ( to <identifiersep> be <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t5 found <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n \t5 break ; } } \n \t3 if ( ! found <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 if ( <identifier> <identifiersep> status . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null ) continue ; \n \t4 assert <identifiersep> equals ( <identifier> <identifiersep> <identifier> <identifiersep> request . default <identifiersep> <identifier> , <identifier> <identifiersep> status . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t4 found <identifiersep> <identifier> = true ; } \n \t3 assert <identifiersep> true ( <string_literal> , found <identifiersep> <identifier> ) ; } \n <ect>
\t1 { \n \t1 @ <identifier> \n \t1 public void process <identifiersep> result ( int <identifier> , string path , object context , byte [ ] bytes , <identifier> <identifier> ) \n \t1 { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t2 <identifier> <identifiersep> count = 0 ; \n \t2 <identifier> <identifiersep> count = ( <identifier> <identifiersep> event <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) * <number_literal> ) / <identifier> <identifiersep> <identifier> - 1 ; } \n \t1 else { \n \t2 <identifier> <identifiersep> count ++ ; \n <ect>
\t6 field . set ( object , value ) ; \n \t5 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t6 logger . error ( <string_literal> , value , field , e ) ; } \n \t4 } else { \n <ect>
<comment> \n \t2 if ( ! <identifier> . send ( ) ) { \n <ect>
\t2 the ( log <identifiersep> line ) . should <identifiersep> <identifier> ( <string_literal> ) ; } \n \t1 @ test \n \t1 public void should <identifiersep> log <identifiersep> exception <identifiersep> with <identifiersep> new <identifiersep> line <identifiersep> in <identifiersep> message ( ) { \n \t2 logger logger = logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) ; \n <ect>
\t2 log . info ( <string_literal> ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> error ( throwable e ) \n \t2 { \n <ect>
\t6 <identifier> <identifiersep> status = run <identifiersep> <identifier> ( ) ; \n \t6 break ; } \n \t5 case <identifier> <identifiersep> <identifier> : { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <identifier> <identifiersep> size <identifiersep> <identifier> . <identifier> ( size ) ; \n \t2 <identifier> <identifiersep> time <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> time <identifiersep> unit . <identifier> ( time <identifiersep> <identifier> , unit ) ) ; \n <ect>
\t3 if ( ! <identifier> <identifiersep> key <identifiersep> file . is <identifiersep> <identifier> ( ) ) \n \t4 <identifier> <identifiersep> key <identifiersep> file = new file ( <identifier> <identifiersep> context . get <identifiersep> config <identifiersep> dir ( ) , <identifier> [ <number_literal> ] ) ; \n \t3 if ( ! <identifier> <identifiersep> key <identifiersep> file . <identifier> <identifiersep> read ( ) ) { \n \t4 <identifier> . log ( get <identifiersep> <identifier> ( ) + <string_literal> + <identifier> [ <number_literal> ] ) ; \n <ect>
\t4 } else { \n \t5 logger . debug ( <string_literal> , \n \t7 message . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> string ( ) , item <identifiersep> name ) ; } } } \n \t2 if ( ! <identifier> ) { \n <ect>
\t5 break ; } \n \t3 } <comment> \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 <identifier> . set <identifiersep> server ( server ) ; \n \t2 server <identifier> <identifiersep> server = null ; \n \t2 if ( <identifier> <identifiersep> port > 0 ) \n \t2 { \n <ect>
\t1 <identifier> <identifiersep> config . put ( property <identifiersep> <identifier> . cluster <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> name ) ; \n \t1 map < string , object > <identifier> <identifiersep> cluster = <identifier> . put ( <identifier> <identifiersep> <identifier> <identifiersep> name , <identifier> <identifiersep> config ) ; \n \t1 if ( <identifier> <identifiersep> cluster != null ) \n \t1 { \n <ect>
\t4 if ( this . channel . is <identifiersep> <identifier> ( ) ) { \n \t5 this . channel . <identifier> <identifiersep> <identifier> ( consumer <identifiersep> <identifier> ) ; } } \n \t3 catch ( io <identifiersep> exception | illegal <identifiersep> state <identifiersep> exception e ) { \n <ect>
<number_literal> <identifier> <identifiersep> size = <identifier> <identifiersep> size , \n <number_literal> max <identifiersep> <identifier> <identifiersep> length = max <identifiersep> <identifier> <identifiersep> length ) \n \t1 <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> , <identifier> <identifiersep> <identifier> ) \n \t1 <identifier> <identifiersep> time = current <identifiersep> time ( ) - <identifier> \n <ect>
\t6 return ; } \n \t5 cluster <identifiersep> service . <identifier> <identifiersep> state <identifiersep> update <identifiersep> task ( cluster <identifiersep> update <identifiersep> task <identifiersep> source , <identifier> <identifiersep> <identifier> <identifiersep> task . this ) ; } \n \t4 @ <identifier> \n \t4 public void on <identifiersep> failure ( exception e ) { \n <ect>
\t2 log . info ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void shutdown ( ) { \n \t2 if ( <identifier> <identifiersep> event ) \n <ect>
\t2 cluster <identifiersep> state = <identifier> . <identifier> ( cluster <identifiersep> state , <string_literal> ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . get ( 0 ) . <identifier> <identifiersep> node <identifiersep> id ( ) , equal <identifiersep> to ( <string_literal> ) ) ; \n <ect>
\t2 if ( ! file <identifiersep> path . exists ( ) ) { \n \t3 logger . debug ( <string_literal> , file <identifiersep> path . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 final boolean <identifier> = file <identifiersep> path . create <identifiersep> new <identifiersep> file ( ) ; \n \t3 if ( <identifier> ) { \n <ect>
\t3 while ( ( bytes <identifiersep> read = <identifier> <identifiersep> input <identifiersep> stream . read ( <identifier> ) ) >= 0 ) { \n \t4 output <identifiersep> stream . write ( <identifier> , 0 , bytes <identifiersep> read ) ; } \n \t3 return output <identifiersep> stream . to <identifiersep> byte <identifiersep> array ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 string <identifier> <identifiersep> file <identifiersep> name = found <identifiersep> volume <identifiersep> info . get <identifiersep> volume <identifiersep> id ( ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> file <identifiersep> name + <string_literal> ) ; \n \t2 string <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> name = <identifier> <identifiersep> storage <identifiersep> info . get <identifiersep> storage <identifiersep> info ( ) . get <identifiersep> <identifier> <identifiersep> dir ( ) + path <identifiersep> <identifier> + <identifier> <identifiersep> file <identifiersep> name ; \n \t2 if ( ! new file ( <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> name ) . exists ( ) ) { \n <ect>
\t2 return false ; } \n \t1 public static boolean <identifier> <identifiersep> <identifier> <identifiersep> lock ( string name ) { \n \t2 connection <identifier> <identifiersep> connection = get <identifiersep> <identifier> <identifiersep> connection ( name , false ) ; \n \t2 if ( <identifier> <identifiersep> connection == null ) { \n <ect>
\t3 json <identifiersep> object json <identifiersep> object = json . get <identifiersep> as <identifiersep> json <identifiersep> object ( ) ; \n \t3 string type = json <identifiersep> object . get ( type <identifiersep> field ) . get <identifiersep> as <identifiersep> string ( ) ; \n \t3 class <identifiersep> metadata < ? extends <identifier> <identifiersep> <identifier> , ? > element <identifiersep> metadata = <identifier> <identifiersep> manager . get <identifiersep> <identifier> <identifiersep> metadata <identifiersep> <identifier> ( ) . <identifier> ( type , <identifier> <identifiersep> context . get <identifiersep> context ( ) ) ; \n \t3 if ( element <identifiersep> metadata == null ) { \n <ect>
\t8 logger . trace ( <string_literal> , lock . id ) ; \n \t8 try { \n \t9 <identifier> <identifiersep> lock ( null , lock . <identifier> , lock . <identifier> , lock . id ) ; \n \t8 } catch ( exception e ) { \n <ect>
\t4 if ( <identifier> < key . length ) { \n \t5 log . debug ( <string_literal> ) ; \n \t5 continue ; } \n \t4 if ( ! check <identifiersep> key ( <identifier> <identifiersep> data ) ) { \n <ect>
\t3 close <identifiersep> <identifier> <identifiersep> result result = new close <identifiersep> <identifier> <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t5 wait ( ) ; \n \t5 assert ( <identifier> ) ; \n \t5 return <identifier> ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 stack <identifiersep> <identifier> <identifiersep> entity <identifiersep> manager . delete <identifiersep> stack <identifiersep> <identifier> <identifiersep> <identifier> ( stack <identifiersep> id ) ; \n \t1 stack <identifiersep> update <identifiersep> info <identifiersep> entity <identifiersep> manager . delete <identifiersep> stack <identifiersep> update <identifiersep> info ( stack <identifiersep> id , account <identifiersep> id ) ; \n \t1 <identifier> <identifiersep> with <identifiersep> no <identifiersep> update <identifiersep> to <identifiersep> <identifier> <identifiersep> entity <identifiersep> manager . delete <identifiersep> stack <identifiersep> with <identifiersep> no <identifiersep> update <identifiersep> to <identifiersep> <identifier> ( stack <identifiersep> id , account <identifiersep> id ) ; \n \t1 <identifier> <identifiersep> entity <identifiersep> manager . delete <identifiersep> <identifier> ( stack <identifiersep> id , account <identifiersep> id ) ; \n <ect>
\t1 string filter = <identifier> <identifiersep> utils . create <identifiersep> filter ( properties ) ; \n \t1 try { \n \t1 collection < service <identifiersep> <identifier> < t > > <identifier> = context . get <identifiersep> service <identifiersep> <identifier> ( interface <identifiersep> class , filter ) ; \n \t1 if ( <identifier> == null || <identifier> . size ( ) == 0 ) { \n <ect>
public void execute ( <identifier> <identifiersep> context context ) { \n \t1 for ( string <identifier> : <identifier> . <identifier> ( ) ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t1 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) { \n <ect>
\t2 <comment> \n \t2 function <identifiersep> <identifier> <identifier> = get ( <identifier> . get <identifiersep> context ( ) ) ; \n \t2 if ( <identifier> == null ) \n \t2 { \n <ect>
\t1 public void <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> config != null ) { \n \t3 if ( <identifier> <identifiersep> config . e <identifiersep> is <identifiersep> set ( <identifier> <identifiersep> config . e <identifiersep> class ( ) . get <identifiersep> e <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ) ) { \n \t4 short data <identifiersep> <identifier> = <identifier> <identifiersep> config . get <identifiersep> data <identifiersep> <identifier> ( ) ; \n <ect>
\t3 } else { \n \t4 logger . warn ( <string_literal> , key , <identifier> <identifiersep> entry . get <identifiersep> <identifier> ( ) ) ; } \n \t2 } ) ; \n \t2 if ( this . <identifier> <identifiersep> <identifier> <identifiersep> attribute ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 string routing <identifiersep> value = find <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> routing <identifiersep> value ( <string_literal> , <string_literal> ) ; \n \t2 logger . info ( <string_literal> , routing <identifiersep> value ) ; \n \t2 client ( ) . <identifier> <identifiersep> index ( index <identifiersep> or <identifiersep> <identifier> ( ) , <string_literal> , <string_literal> ) . set <identifiersep> routing ( routing <identifiersep> value ) . set <identifiersep> source ( <string_literal> , <string_literal> ) . get ( ) ; \n <ect>
\t4 throw ex ; } \n \t3 catch ( exception e ) { \n \t4 throwable root <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> root <identifiersep> <identifier> ( e , true ) ; \n \t4 if ( root <identifiersep> <identifier> != null ) { \n <ect>
<comment> \n \t1 public set < string > get <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> data == null ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> . get ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception ex ) { \n <ect>
\t4 result = <identifier> . <identifier> ( ) . set <identifiersep> <identifier> <identifiersep> provider ( <identifier> ) . set <identifiersep> remote ( endpoint . get <identifiersep> remote <identifiersep> name ( ) ) . <identifier> ( ) ; \n \t3 } else { \n \t4 result = <identifier> . <identifier> ( ) . set <identifiersep> remote ( endpoint . get <identifiersep> remote <identifiersep> name ( ) ) . <identifier> ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t4 logger . error ( <string_literal> \n \t7 <string_literal> ) \n \t4 <identifier> . <identifier> ( 1 ) \n \t3 if not <identifier> . path . <identifier> ( <identifier> ) : \n <ect>
\t3 <identifier> <identifiersep> client . delete ( <string_literal> ) ; \n \t3 value = <identifier> <identifiersep> client . get ( <string_literal> ) ; \n \t3 system . out . <identifier> ( <string_literal> + value ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( ! is <identifiersep> first <identifiersep> <identifier> ) { \n \t4 try { \n \t5 thread . <identifier> ( r . next <identifiersep> int ( <number_literal> ) ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t6 <identifier> <identifiersep> filter . set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; } \n \t5 return <identifier> <identifiersep> filter . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t4 return new array <identifiersep> list ( ) ; \n \t3 } else { \n <ect>
\t2 for ( string <identifier> : text <identifiersep> parse <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> string <identifiersep> to <identifiersep> set ( <identifier> <identifiersep> <identifier> ) ) { \n \t3 <identifier> <identifiersep> <identifier> . add ( <identifier> . <identifier> ( <identifier> , <identifier> . case <identifiersep> <identifier> ) ) ; } } \n \t1 @ <identifier> ( value = x <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> = false ) \n \t1 public void set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n <ect>
\t3 try { \n \t4 task <identifiersep> shutdown <identifiersep> <identifier> shutdown = task . <identifier> <identifiersep> task ( <identifier> <identifiersep> data , task <identifiersep> id ) ; \n \t4 <identifier> <identifiersep> data . add <identifiersep> shutdown <identifiersep> task ( shutdown ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 <identifier> <identifiersep> options <identifier> = get <identifiersep> <identifier> <identifiersep> options ( conf ) ; \n \t1 <identifier> <identifier> = new <identifier> ( <identifier> , conf , <identifier> ) ; \n \t1 <identifier> = <identifier> . run <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t5 } ) . close <identifiersep> handler ( new handler < void > ( ) { \n \t6 @ <identifier> \n \t6 public void handle ( void a <identifiersep> void ) { \n \t7 if ( debug ) { \n <ect>
\t3 class <identifiersep> <identifier> <identifier> = thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) ; \n \t3 return ( <identifier> <identifiersep> <identifier> ) <identifier> . load <identifiersep> class ( target <identifiersep> class <identifiersep> <identifier> ) \n \t5 . get <identifiersep> <identifier> <identifiersep> <identifier> ( new class [ ] { <identifier> <identifiersep> config . class } ) . new <identifiersep> instance ( config ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 log . debug ( <string_literal> , <identifier> <identifiersep> response ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> failure ( \n \t3 job <identifiersep> id , \n \t3 new exception ( s <string_literal> , t ) ) ) } \n \t1 case stop <identifiersep> job ( job <identifiersep> id ) = > \n <ect>
\t1 <identifier> <identifiersep> cmd = format ( <string_literal> ) \n \t1 <identifier> is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) : \n \t1 # <identifier> out of <identifier> <identifiersep> start <identifier> <identifier> <identifier> if we <identifier> <identifier> <identifier> cluster <identifier> \n \t1 return true \n <ect>
\t1 case <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> failed : \n \t2 s <identifiersep> logger . error ( <string_literal> ) ; \n \t1 throw new runtime <identifiersep> exception ( <string_literal> ) ; \n \t1 default : \n <ect>
\t2 if ( key . index <identifiersep> of ( <string_literal> ) != - 1 ) { \n \t3 log . debug ( <string_literal> + o ) ; } \n \t2 return o ; } \n \t1 public string empty <identifiersep> list <identifiersep> message ( ) { \n <ect>
\t4 int <identifier> <identifiersep> <identifier> = 0 ; \n \t4 for ( grid <identifier> : <identifier> . all <identifiersep> <identifier> ( ) ) \n \t5 if ( <identifier> . name ( ) . <identifier> <identifiersep> with ( <identifier> ) ) { \n \t6 try { \n <ect>
\t1 super . <identifier> ( ) ; \n \t1 <identifier> . set ( true ) ; } } \n protected void do <identifiersep> <identifier> ( <identifier> <identifiersep> context context ) throws <identifier> <identifiersep> exception { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> null ( <identifier> <identifiersep> context ) ; \n <ect>
\t5 <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) , <identifier> , \n \t5 <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . get <identifiersep> model <identifiersep> <identifier> <identifiersep> service ( ) \n \t7 . get <identifiersep> <identifier> <identifiersep> as <identifiersep> list ( <identifier> ) , \n \t5 <string_literal> , <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . get <identifiersep> model ( ) . get <identifiersep> path <identifiersep> <identifier> ( ) ) ; \n <ect>
\t2 <identifier> <identifier> = <identifier> . create <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n \t2 string <identifier> = <identifier> <identifiersep> in <identifiersep> read <identifiersep> write <identifiersep> mode <identifiersep> and <identifiersep> create <identifiersep> check <identifiersep> <identifier> ( index <identifiersep> <identifier> ) ; \n \t2 log . info ( <string_literal> , <identifier> ) ; \n <ect>
\t6 thread . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t5 } catch ( interrupted <identifiersep> exception <identifier> ) { \n \t6 s <identifiersep> logger . debug ( <string_literal> ) ; } \n \t4 } else \n <ect>
\t5 . get <identifiersep> local <identifiersep> socket <identifiersep> address ( new <identifier> <identifiersep> socket <identifiersep> address ( \n \t6 <identifier> <identifiersep> destination , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> port ) ) ; } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t4 return <identifier> <identifiersep> config ; } } \n \t2 return null ; } \n \t1 @ <identifier> \n \t1 public void error ( exception e ) { \n <ect>
\t2 switch ( event . get <identifiersep> state ( ) ) { \n \t2 case <identifier> <identifiersep> <identifier> : \n \t3 break ; \n \t2 default : \n <ect>
\t5 return <number_literal> ; } \n \t4 else { \n \t5 s <identifiersep> logger . info ( <string_literal> + response <identifiersep> code ) ; \n \t5 string volume <identifiersep> id = values . get ( <string_literal> ) ; \n <ect>
\t5 <identifier> <identifiersep> response = new <identifier> <identifiersep> response ( response <identifiersep> body . get <identifiersep> content ( ) ) ; \n \t4 } else { \n \t5 <identifier> <identifiersep> response = new <identifier> <identifiersep> response ( <string_literal> ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t5 break ; \n \t4 } else if ( task <identifiersep> status . is <identifiersep> <identifier> ( ) ) { \n \t5 this . <identifier> . <identifier> ( ) ; \n \t5 break ; } } \n <ect>
\t4 <comment> \n \t4 logger . info ( <string_literal> + in <identifiersep> date ) ; \n \t4 <identifier> <identifiersep> entity <identifiersep> manager <identifiersep> <identifier> . execute ( null ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> count = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> count <identifiersep> <identifier> . execute ( in <identifiersep> date ) ; \n <ect>
\t1 string timeout <identifiersep> <identifier> = <identifier> . get <identifiersep> configuration ( ) . get <identifiersep> property <identifiersep> value ( config <identifiersep> <identifier> . cluster <identifiersep> <identifier> , timeout <identifiersep> property <identifiersep> name ) ; \n \t1 if ( timeout <identifiersep> <identifier> != null ) { \n \t1 try { \n \t2 timeout = long . parse <identifiersep> long ( timeout <identifiersep> <identifier> ) ; \n <ect>
\t6 http <identifiersep> <identifier> http <identifiersep> <identifier> = http <identifiersep> <identifier> . parse ( <identifier> [ i ] ) . get ( 0 ) ; \n \t6 log . debug ( <string_literal> + http <identifiersep> <identifier> . get <identifiersep> name ( ) + <string_literal> + http <identifiersep> <identifier> . get <identifiersep> value ( ) + <string_literal> ) ; \n \t6 <identifier> <identifiersep> <identifier> . set <identifiersep> object <identifiersep> for <identifiersep> key ( new <identifier> <identifiersep> array < string > ( http <identifiersep> <identifier> . get <identifiersep> value ( ) ) , http <identifiersep> <identifier> . get <identifiersep> name ( ) ) ; \n \t5 } catch ( throwable t ) { \n <ect>
\t5 thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) ) . new <identifiersep> instance ( ) ; \n \t3 <comment> \n \t3 return client != null ; \n \t2 } catch ( exception ex ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> = null ; } \n \t1 if ( web <identifiersep> server != null ) { \n \t1 try { \n \t2 web <identifiersep> server . stop ( ) ; \n <ect>
\t5 short short <identifiersep> value = ( value == null ) ? 0 : short . value <identifiersep> of ( value ) ; <comment> \n \t5 <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> ) type . get <identifiersep> <identifier> ( short . class ) . new <identifiersep> instance ( short <identifiersep> value ) ; } \n \t4 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 if ( last <identifiersep> <identifier> == null ) \n \t4 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; \n \t3 <identifier> . set ( last <identifiersep> <identifier> ) ; \n \t3 log . error ( <string_literal> ) ; \n <ect>
\t2 string config <identifiersep> file = null ; \n \t2 try { \n \t3 final file <identifier> <identifiersep> file = properties <identifiersep> <identifier> . find <identifiersep> config <identifiersep> file ( <string_literal> ) ; \n \t3 if ( <identifier> <identifiersep> file == null ) { \n <ect>
\t2 string <identifier> <identifiersep> <identifier> = \n \t4 <string_literal> \n \t6 + <string_literal> ; \n \t2 try ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> update = conn . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; ) { \n <ect>
\t1 if ( <identifier> != null ) { \n \t1 try { \n \t2 <identifier> . close ( ) ; \n \t1 } catch ( sql <identifiersep> exception <identifier> ) { \n <ect>
\t2 process <identifiersep> api <identifiersep> response ( exchange , response ) ; } \n \t1 private void process <identifiersep> api <identifiersep> response ( exchange exchange , <identifier> <identifiersep> http <identifiersep> response response ) throws exception { \n \t2 try { \n \t3 map < string , object > json <identifiersep> map = <identifier> . read <identifiersep> value ( response . get <identifiersep> entity ( ) . get <identifiersep> content ( ) , map <identifiersep> type ) ; \n <ect>
\t7 <identifier> <identifiersep> status <identifiersep> update <identifiersep> event event = new <identifier> <identifiersep> status <identifiersep> update <identifiersep> event ( this ) ; \n \t7 while ( <identifier> . has <identifiersep> next ( ) ) { \n \t8 <identifier> . next ( ) . status <identifiersep> update <identifiersep> <identifier> ( event , current <identifiersep> state ) ; } \n \t6 } catch ( exception e ) { \n <ect>
+ \t2 try { \n + \t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . value <identifiersep> of ( <identifier> <identifiersep> <identifier> <identifiersep> name . <identifier> ( ) . to <identifiersep> <identifier> <identifiersep> case ( ) ) ; \n + \t2 final <identifiersep> <identifier> <identifiersep> list . add ( <identifier> ) ; \n + \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t1 node <identifiersep> <identifier> nodes = null ; \n \t1 try { \n \t1 nodes = node . get <identifiersep> nodes ( ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 logger . warn ( <string_literal> , <identifier> . get <identifiersep> next <identifiersep> update ( ) ) ; \n \t3 <identifier> <identifiersep> <identifier> . add ( <identifier> ) ; \n \t2 } ) ; \n \t2 if ( <identifier> . size ( ) == <identifier> <identifiersep> <identifier> . size ( ) ) { \n <ect>
\t9 + get <identifiersep> <identifier> <identifiersep> metadata ( id ) . get <identifiersep> name ( ) \n \t9 + <string_literal> + dir <identifiersep> name ) ; \n \t7 <identifier> = true ; \n \t6 } else { \n <ect>
\t4 if ( ! this . <identifier> <identifiersep> thread <identifiersep> <identifier> ) { \n \t5 try { \n \t6 get <identifiersep> socket ( ) ; } \n \t5 catch ( io <identifiersep> exception e ) { \n <ect>
\t2 log . debug ( <string_literal> + body ) ; \n \t2 assert <identifiersep> false ( <string_literal> , body . <identifier> <identifiersep> with ( <string_literal> ) ) ; } \n \t1 private static class <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> implements <identifier> { \n \t2 public void process ( exchange exchange ) throws exception { \n <ect>
\t3 <identifier> . delete <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> node ( node <identifiersep> id ) ; \n \t3 if ( ! this . is <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( ) ) \n \t4 <identifier> . <identifier> ( ) ; \n \t2 } catch ( json <identifiersep> exception e ) { \n <ect>
\t5 <string_literal> \n \t4 ) ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 create <identifiersep> cache <identifiersep> <identifier> ( ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t1 } catch ( throwable <identifier> ) { \n <ect>
\t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + item . get <identifiersep> name ( ) , e ) ; } } \n \t1 protected file <identifiersep> item <identifiersep> factory create <identifiersep> factory <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> ( file <identifier> <identifiersep> directory ) { \n \t2 <identifier> <identifiersep> file <identifiersep> item <identifiersep> factory factory = new <identifier> <identifiersep> file <identifiersep> item <identifiersep> factory ( ) ; \n \t2 factory . set <identifiersep> <identifier> ( <identifier> <identifiersep> directory ) ; \n <ect>
\t2 t = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . parse ( s , time <identifiersep> <identifier> ) ; \n \t2 is <identifiersep> null = false ; } \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t1 is <identifiersep> null = true ; \n <ect>
<comment> \n \t1 protected <identifier> get <identifiersep> <identifier> ( int <identifier> <identifiersep> port ) throws remote <identifiersep> exception { \n \t2 if ( this . <identifier> <identifiersep> create <identifiersep> <identifier> ) { \n <ect>
@ <identifier> \n private log <identifiersep> <identifier> <identifiersep> security <identifiersep> config log <identifiersep> <identifier> <identifiersep> security <identifiersep> config ; \n @ <identifier> <identifiersep> <identifier> \n public void <identifier> ( ) { \n <ect>
\t2 if ( time >= max <identifiersep> time ) { \n \t3 <comment> \n \t3 log . warn ( <string_literal> + time + <string_literal> ) ; \n \t3 time = test <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifiersep> key = ( list < string > ) msg <identifiersep> map . get ( <string_literal> ) ; \n \t3 if ( <identifier> == null || <identifier> <identifiersep> key == null ) { \n \t4 throw new null <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \t4 s <identifiersep> failure ++ ; \n \t3 } else { \n \t4 final <identifiersep> result = true ; \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> . put <identifiersep> if <identifiersep> <identifier> ( <identifier> , c ) == null ) { \n \t3 <identifier> . grid <identifiersep> io ( ) . add <identifiersep> message <identifiersep> listener ( <identifier> , new <identifier> <identifiersep> message <identifiersep> listener ( \n \t4 ( grid <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> < <identifier> , grid <identifiersep> cache <identifiersep> message < <identifier> , v > > ) c ) ) ; \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <identifier> <identifiersep> job <identifiersep> <identifier> . remove <identifiersep> job <identifiersep> <identifier> ( job <identifiersep> id ) \n \t3 } catch { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> <identifier> . wait ( <identifier> <identifiersep> timeout * <number_literal> ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n \t5 logger . warn ( <string_literal> ) ; } \n <ect>
\t4 log . debug ( <string_literal> ) ; } \n \t3 return <identifier> ; \n \t2 } else { \n <ect>
\t6 . put ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t6 . build ( ) , \n \t4 <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> or <identifiersep> <identifier> <identifiersep> <identifier> . filter ( <identifier> - > <identifier> . <identifier> <identifiersep> with ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) ) ; } \n \t1 private void log <identifiersep> <identifier> <identifiersep> <identifier> ( final string <identifier> <identifiersep> type , final map . entry < string , string > e , final logger logger ) { \n <ect>
\t1 <identifier> <identifiersep> node <identifiersep> <identifier> key = <identifier> . <identifier> . get <identifiersep> conf ( ) . get <identifiersep> key <identifiersep> <identifier> ( ) . get ( <identifier> . <identifier> . get <identifiersep> key <identifiersep> index ( ) ) ; \n \t1 <comment> \n \t1 <identifier> <identifiersep> node <identifiersep> <identifier> <identifier> <identifiersep> key = <identifier> . <identifier> . get <identifiersep> <identifier> ( ) . get ( 0 ) ; \n <ect>
\t3 result = <identifier> <identifiersep> <identifier> . import <identifiersep> <identifier> ( <identifier> , url , <identifier> <identifiersep> name , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 throw e ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 private void <identifier> <identifiersep> resource <identifiersep> value <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> <identifier> { \n \t2 logger . debug ( <string_literal> ) ; \n \t2 if ( <identifier> != null ) { \n \t3 if ( <identifier> . get <identifiersep> connection <identifiersep> state ( ) != connection <identifiersep> state . <identifier> ) { \n <ect>
\t2 assert <identifiersep> <identifier> ( <identifier> <identifiersep> create ( <string_literal> ) . add <identifiersep> <identifier> ( <string_literal> , \n \t4 json <identifiersep> builder ( ) . start <identifiersep> object ( ) . start <identifiersep> object ( <string_literal> ) . start <identifiersep> object ( <string_literal> ) \n \t6 . start <identifiersep> object ( <string_literal> ) . field ( <string_literal> , <string_literal> ) . end <identifiersep> object ( ) \n \t6 . end <identifiersep> object ( ) . end <identifiersep> object ( ) . end <identifiersep> object ( ) ) ) ; \n <ect>
\t3 if ( vm <identifiersep> <identifier> != null ) { \n \t4 vm <identifiersep> <identifier> <identifiersep> map = get <identifiersep> vm <identifiersep> <identifier> ( vm <identifiersep> <identifier> ) ; } \n \t2 } catch ( throwable e ) { \n \t3 if ( e instanceof remote <identifiersep> exception ) { \n <ect>
\t1 public object <identifier> <identifiersep> service ( service <identifiersep> <identifier> < type <identifiersep> <identifier> <identifiersep> <identifier> > service <identifiersep> <identifier> ) { \n \t2 log . trace ( <string_literal> , service <identifiersep> <identifier> , service <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ; \t2 \n \t2 type <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> context . get <identifiersep> service ( service <identifiersep> <identifier> ) ; \n \t2 try { \n <ect>
\t3 integer network <identifiersep> <identifier> = get <identifiersep> network <identifiersep> <identifier> ( config . get <identifiersep> id ( ) , vm . get <identifiersep> id ( ) ) ; \n \t3 vm . add <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> ( vo , network . first ( ) , vo . get <identifiersep> <identifier> <identifiersep> uri ( ) , vo . get <identifiersep> <identifier> <identifiersep> uri ( ) , network <identifiersep> <identifier> , is <identifiersep> security <identifiersep> group <identifiersep> <identifier> <identifiersep> in <identifiersep> network ( network . first ( ) ) , get <identifiersep> network <identifiersep> <identifier> ( vm . get <identifiersep> <identifier> <identifiersep> type ( ) , \n \t5 network . first ( ) ) ) ) ; } \n \t2 if ( <identifier> . size ( ) != <identifier> . size ( ) ) { \n <ect>
\t3 return ; \n \t2 long start = system . <identifier> <identifiersep> time ( ) ; \n \t2 int <identifier> <identifiersep> shards <identifiersep> read = cache <identifiersep> service . instance . <identifier> <identifiersep> cache . load <identifiersep> <identifier> ( this ) ; \n \t2 if ( <identifier> <identifiersep> shards <identifiersep> read > 0 ) \n <ect>
\t4 logger . debug ( <string_literal> + file <identifiersep> name + <string_literal> + dir ) ; \n \t2 } else \n \t3 logger . debug ( <string_literal> + file <identifiersep> name + <string_literal> + dir ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t3 if ( ignore <identifiersep> <identifier> <identifiersep> file ) { \n \t4 try { \n \t5 boolean <identifier> = files . delete <identifiersep> if <identifiersep> exists ( <identifier> <identifiersep> file ) ; \n \t5 if ( <identifier> ) { \n <ect>
\t3 http <identifiersep> get get = new http <identifiersep> get ( url <identifiersep> builder . to <identifiersep> string ( ) ) ; \n \t3 http <identifiersep> response response = new default <identifiersep> http <identifiersep> client ( ) . execute ( get ) ; \n \t3 return response . get <identifiersep> entity ( ) . get <identifiersep> content ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 if ( ! message <identifiersep> queue . remove <identifiersep> message ( item ) ) { \n \t4 <identifier> . wait <identifiersep> for <identifiersep> send ( <identifier> . to <identifiersep> millis ( <number_literal> ) ) ; \n \t4 if ( ! <identifier> . <identifier> ) { \n <ect>
\t6 <identifier> ( ) ; \n \t5 } catch ( io <identifiersep> exception <identifier> ) { \n \t6 logger . warn ( <string_literal> , <identifier> ) ; } } \n \t3 } finally { \n <ect>
\t1 throws io <identifiersep> exception { \n \t1 <identifier> <identifiersep> consumer . <identifier> ( ) ; \n \t1 log . info ( <string_literal> , <identifier> <identifiersep> store . get <identifiersep> <identifier> <identifiersep> size ( ) ) ; \n \t1 if ( <identifier> <identifiersep> store . get <identifiersep> <identifier> <identifiersep> size ( ) > ( <number_literal> * <identifier> <identifiersep> group <identifiersep> size <identifiersep> <identifier> ) ) { \n <ect>
\t2 case <identifier> : \n \t2 case <identifier> : \n \t3 s <identifiersep> logger . info ( <string_literal> + vm . get <identifiersep> instance <identifiersep> name ( ) + <string_literal> + vm . get <identifiersep> state ( ) + <string_literal> ) ; \n \t3 if ( vm . is <identifiersep> <identifier> <identifiersep> enabled ( ) && vm . get <identifiersep> state ( ) == state . <identifier> && vm . get <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> type . v <identifiersep> <identifier> && vm . get <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> type . <identifier> ) { \n <ect>
\t5 if ( account <identifiersep> id != null ) { \n \t6 if ( <identifier> <identifiersep> cluster . get <identifiersep> account <identifiersep> id ( ) . equals ( account <identifiersep> id ) ) { \n \t7 <identifier> <identifiersep> to <identifiersep> <identifier> . add ( <identifier> <identifiersep> cluster ) ; \n \t6 } else { \n <ect>
\t3 last <identifiersep> event <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 is = port . get <identifiersep> input <identifiersep> stream ( ) ; \n \t3 int <identifier> = is . <identifier> ( ) ; \n \t3 if ( <identifier> == 0 ) { \n <ect>
\t3 input <identifiersep> stream is = class <identifiersep> <identifier> . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( path ) ; \n \t3 if ( is != null ) { \n \t4 answer [ 0 ] = load <identifiersep> text ( is ) ; } \n \t2 } catch ( throwable e ) { \n <ect>
\t2 assert . assert <identifiersep> equals ( <identifier> <identifiersep> request , in ) ; \n \t2 list < string > <identifier> = info . get <identifiersep> path <identifiersep> <identifier> ( true ) . get ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> + <identifier> . get ( 0 ) ) ; \n \t2 <identifier> = info . get <identifiersep> path <identifiersep> <identifier> ( false ) . get ( <string_literal> ) ; \n <ect>
\t1 return <identifier> ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t1 throw new no <identifiersep> such <identifiersep> entity <identifiersep> exception ( <identifier> <identifiersep> entity . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 private static logger logger = logger . get <identifiersep> logger ( exception <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> not <identifiersep> found <identifiersep> <identifier> . class ) ; \n \t1 @ context \n \t1 http <identifiersep> <identifier> http <identifiersep> <identifier> ; \n \t1 public response to <identifiersep> response ( not <identifiersep> found <identifiersep> exception exception ) { \n <ect>
\t2 { \n \t2 try { \n \t3 files . create <identifiersep> <identifier> ( dir ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> server <identifier> <identifiersep> server = get <identifiersep> <identifier> <identifiersep> server ( i , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( i ) ) ; \n \t4 <identifier> . add ( <identifier> <identifiersep> server ) ; \n \t4 <identifier> <identifiersep> connection <identifiersep> string += host <identifiersep> and <identifiersep> port <identifiersep> to <identifiersep> url <identifiersep> string ( <identifier> <identifiersep> host , <identifier> <identifiersep> server . socket <identifiersep> server ( ) . <identifier> <identifiersep> port ( security <identifiersep> <identifier> ) ) ; \n \t4 <identifier> <identifiersep> connection <identifiersep> string += <string_literal> ; } \n <ect>
\t4 if ( new <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) \n \t5 logger . debug ( <string_literal> , <identifier> ) ; \n \t4 else \n <ect>
\t2 if ( <identifier> != null && ! <identifier> . is <identifiersep> empty ( ) ) { \n \t3 final <identifier> <identifiersep> authentication <identifiersep> provider provider = this . <identifier> <identifiersep> authentication <identifiersep> provider <identifiersep> <identifier> . <identifier> ( <identifier> , service , principal ) ; \n \t3 logger . debug ( <string_literal> , provider ) ; \n \t3 if ( ! provider . is <identifiersep> <identifier> ( service ) ) { \n <ect>
\t3 try { \n \t4 meta <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> ( message <identifiersep> model . <identifier> , \n \t5 instance <identifiersep> name , config . get <identifiersep> consumer <identifiersep> group ( ) , \n \t5 config . get <identifiersep> <identifier> ( ) , date . get <identifiersep> time ( ) ) ; \n <ect>
\t2 this . <identifier> <identifiersep> list = <identifier> ; \n \t2 this . <identifier> . add <identifiersep> listener ( new <identifier> <identifiersep> <identifier> <identifiersep> listener ( this . <identifier> <identifiersep> list , \n \t3 operation <identifiersep> set ) ) ; \n \t2 set <identifiersep> <identifier> <identifiersep> <identifier> ( this . <identifier> , this . <identifier> <identifiersep> <identifier> <identifiersep> list , max <identifiersep> list <identifiersep> size ) ; \n <ect>
public void <identifier> ( final set < <identifier> <identifiersep> key > <identifier> <identifiersep> <identifier> ) { \n \t1 try { \n \t1 listener <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> <identifiersep> event ( new <identifier> <identifiersep> <identifier> <identifiersep> state <identifiersep> <identifier> <identifiersep> event ( <identifier> <identifiersep> <identifier> ) ) ; \n \t1 } catch ( event <identifiersep> failed <identifiersep> exception e ) { \n <ect>
\t3 if ( ! <identifier> <identifiersep> model . <identifier> ( get <identifiersep> model <identifiersep> <identifier> ( ) ) ) { \n \t4 <identifier> <identifiersep> model . update ( get <identifiersep> model <identifiersep> <identifier> ( ) ) ; } \n \t3 get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . add ( <identifier> <identifiersep> model ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 return false ; } \n \t2 return <identifier> <identifiersep> key <identifiersep> store != null ; } \n \t1 private boolean <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( ! load <identifiersep> root <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> ( ) && ! <identifier> <identifiersep> new <identifiersep> root <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 <identifier> <identifiersep> put <identifiersep> handler = <identifier> ; \n \t3 if ( <identifier> <identifiersep> map != null ) { \n \t4 synchronized ( <identifier> <identifiersep> map ) { \n \t5 if ( <identifier> <identifiersep> map . contains ( this ) ) { \n <ect>
\t2 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t2 if ( <identifier> ) { \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> == import <identifiersep> <identifier> <identifiersep> <identifier> . import <identifiersep> <identifier> <identifiersep> create <identifiersep> new ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
<comment> \n @ <identifier> \n public input <identifiersep> stream <identifier> ( final string uri ) \n \t1 throws io <identifiersep> exception { \n <ect>
\t2 file <identifiersep> input <identifiersep> format . add <identifiersep> input <identifiersep> path ( job , input <identifiersep> path ) ; } \n \t1 protected final int count <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> < long <identifiersep> <identifier> , t > <identifier> ) throws io <identifiersep> exception , interrupted <identifiersep> exception { \n \t2 int count = 0 ; \n \t2 <comment> \n <ect>
\t1 log . warn ( <string_literal> + snapshot <identifiersep> id , e ) ; \n \t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + snapshot <identifiersep> id , e ) ; } \n \t1 <comment> \n \t1 try { \n <ect>
\t2 <identifier> <identifiersep> bytes += event . get <identifiersep> body ( ) . length ; \n \t2 <identifier> ++ ; \n \t2 long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 if ( <identifier> >= last <identifiersep> check + <number_literal> ) { \n <ect>
<comment> \n \t1 private void <identifier> <identifiersep> query ( msg <identifiersep> id msg <identifiersep> id , destination <identifier> , int from <identifiersep> port , string method , map < string , be <identifiersep> value > <identifier> ) throws <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( <identifier> == null && ! method . equals ( <string_literal> ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t8 ? <identifier> <identifiersep> to <identifiersep> <identifier> . get ( field <identifiersep> name ) \n \t8 : field <identifiersep> name ; } \n \t4 value = <identifier> <identifiersep> field ( get <identifiersep> value ( <identifier> , <identifier> <identifiersep> <identifier> ) , field <identifiersep> type <identifiersep> info , field <identifiersep> name ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 for ( snapshot <identifiersep> <identifier> <identifiersep> failure failure : snapshot <identifiersep> info . <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 assert <identifiersep> not <identifiersep> null ( failure . <identifier> ( ) ) ; } } \n \t1 @ <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> url = <string_literal> ) \n \t1 public void test <identifiersep> <identifier> <identifiersep> shutdown <identifiersep> <identifier> <identifiersep> failed <identifiersep> snapshot ( ) throws exception { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 try { \n \t3 execute <identifiersep> <identifier> <identifiersep> json <identifiersep> test ( <string_literal> , <string_literal> , false , <number_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t7 try { \n \t8 <identifier> = new string ( <identifier> , data <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ) ; \n \t8 <identifier> = new string ( <identifier> , data <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ) ; \n \t7 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 final endpoint <identifiersep> <identifier> endpoint = <identifier> <identifiersep> <identifier> <identifiersep> stack <identifiersep> client . get <identifiersep> <identifier> ( this . configuration . get <identifiersep> endpoint <identifiersep> uri ( ) ) . <identifier> <identifiersep> <identifier> ( <identifier> - > { \n \t4 log . debug ( <string_literal> ) ; \n \t4 for ( final endpoint <identifiersep> <identifier> <identifier> : <identifier> ) { \n <ect>
\t1 <comment> \n \t1 <identifier> <identifiersep> <identifier> = context . get <identifiersep> integer ( <identifier> <identifiersep> <identifier> , default <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 <comment> \n \t1 if ( <identifier> <identifiersep> <identifier> < 1 && <identifier> <identifiersep> <identifier> < 1 ) { \n <ect>
\t3 <identifier> . read ( <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> current <identifiersep> size <identifiersep> <identifier> - <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . read ( current <identifiersep> size ) ; \t2 \n \t2 } catch ( exception e ) { \n <ect>
\t5 logger . debug ( <string_literal> , <identifier> , <identifier> ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . is <identifiersep> <identifier> ( <identifier> ) ) { \n \t6 logger . debug ( <string_literal> , <identifier> ) ; \n \t6 return <identifier> ; } \n <ect>
\t1 log . info ( <string_literal> ) ; } \n \t1 if ( <identifier> <identifiersep> <identifier> > 0 . <identifier> || <identifier> <identifiersep> <identifier> > 0 . <identifier> ) { \n \t1 log . info ( <string_literal> ) ; } \n \t1 if ( <identifier> > 0 . <identifier> ) { \n <ect>
\t2 if ( <identifier> . size ( ) == 0 ) { \n \t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + vm <identifiersep> name + <string_literal> ) ; } \n \t2 <comment> \n \t2 if ( <identifier> . size ( ) > 1 ) { \n <ect>
\t2 try { \n \t3 <identifier> = class <identifiersep> <identifier> . for <identifiersep> name ( type , abstract <identifiersep> <identifier> . class ) ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n \t3 <identifier> = <identifier> <identifiersep> <identifier> . class ; \n <ect>
\t1 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( total <identifiersep> <identifier> ) ; \n \t1 try { \n \t1 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 string key <identifiersep> path = ( string ) e . next <identifiersep> element ( ) ; \n \t4 if ( key <identifiersep> path . length ( ) > 0 ) \n \t5 result . add <identifiersep> object ( key <identifiersep> path ) ; } \n <ect>
\t5 this . <identifier> <identifiersep> object <identifiersep> builder . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) , \n \t5 <identifier> <identifiersep> date <identifiersep> time . <identifier> ( <identifier> <identifiersep> <identifier> . <identifier> ) . <identifier> <identifiersep> <identifier> ( this . <identifier> <identifiersep> <identifier> ) , service <identifiersep> id , service ) ; \n \t3 logger . debug ( <string_literal> , service <identifiersep> id ) ; \n \t3 <identifier> <identifiersep> response ( <identifier> <identifiersep> response , model ) ; \n <ect>
\t2 if ( <identifier> . get <identifiersep> private <identifiersep> <identifier> ( <identifier> <identifiersep> ticket . class ) . is <identifiersep> empty ( ) ) { \n \t3 throw new runtime <identifiersep> exception ( <string_literal> <string_literal> \\ <string_literal> \n \t5 + <identifier> <identifiersep> conf ) ; } \n \t2 string principal = <identifier> <identifiersep> utils . get ( <identifier> <identifiersep> conf , <identifier> <identifiersep> utils . <identifier> <identifiersep> context <identifiersep> server , <string_literal> ) ; \n <ect>
\t2 manager . <identifier> <identifiersep> node <identifiersep> type ( create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> content <identifiersep> type ( manager ) , true ) ; \n \t2 manager . <identifier> <identifiersep> node <identifiersep> type ( create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type ( manager ) , true ) ; \n \t2 session . <identifier> ( ) ; } \n \t1 private node <identifiersep> type <identifiersep> template create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> content <identifiersep> type ( node <identifiersep> type <identifiersep> manager manager ) throws <identifier> <identifiersep> exception { \n <ect>
\t4 int result = cmd . execute ( command , <identifier> , <identifier> ) ; \n \t4 if ( <identifier> . length ( ) > 0 ) \n \t5 logger . debug ( <string_literal> , name , <identifier> ) ; \n \t4 if ( <identifier> . length ( ) > 0 ) \n <ect>
\t3 <comment> \n \t3 <comment> \n \t2 assert <identifiersep> false ( <string_literal> \n \t3 , <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) ; \n <ect>
\t2 client <identifiersep> socket . get <identifiersep> output <identifiersep> stream ( ) . write ( <number_literal> ) ; \n \t2 thread . <identifier> ( <number_literal> ) ; \n \t2 log . info ( <string_literal> , client <identifiersep> socket . get <identifiersep> input <identifiersep> stream ( ) . <identifier> ( ) ) ; \n \t2 <identifier> = new byte [ 0 ] ; \n <ect>
\t2 logger . trace ( <string_literal> , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) ) ; \n \t2 cluster <identifiersep> state = service . <identifier> <identifiersep> <identifier> <identifiersep> nodes ( cluster <identifiersep> state , true , <string_literal> ) ; \n \t2 routing <identifiersep> nodes routing <identifiersep> nodes = cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> node <identifiersep> <identifier> ( routing <identifiersep> nodes ) ; \n <ect>
<number_literal> final object [ ] <identifier> , \n <number_literal> final class < t > <identifier> <identifiersep> type ) { \n \t2 try { \n \t3 if ( resource == null ) { \n <ect>
\t3 try { \n \t4 <identifier> . command <identifiersep> <identifier> ( event ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 length += dir . get <identifiersep> <identifier> ( ) ; \n \t5 test <identifiersep> for <identifiersep> <identifier> ( dir ) ; \n \t4 } else { \n <ect>
private int run <identifiersep> <identifier> ( object <identifier> , java <identifiersep> data <identifiersep> model <identifier> <identifiersep> model , string <identifier> ) { \n \t1 <identifier> <identifiersep> map < class < ? > , object <identifiersep> <identifier> > map = <identifier> <identifiersep> object <identifiersep> size <identifiersep> <identifier> . create <identifiersep> <identifier> ( <identifier> ) ; \n \t1 object <identifiersep> <identifier> root = map . get ( <identifier> . get <identifiersep> class ( ) ) ; \n \t1 int <identifier> = root . <identifier> ( <identifier> , map ) ; \n <ect>
\t4 throw new null <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t3 if ( <identifier> + <identifier> > <identifier> . length ) { \n \t4 throw new index <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t6 continue ; } \n \t5 <comment> \n \t5 start <identifiersep> <identifier> <identifiersep> request ( ) ; \n \t4 } catch ( throwable t ) { \n <ect>
\t3 s <identifiersep> logger \n \t5 . info ( <string_literal> ) ; \n \t3 system . <identifier> ( <number_literal> ) ; } \n \t2 if ( password == null ) { \n <ect>
\t5 throw new execution <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> interface <identifiersep> name + <string_literal> + <identifier> <identifiersep> private <identifiersep> <identifier> ) ; \n \t4 } else { \n \t5 return true ; } \n \t3 default : \n <ect>
\t2 <identifier> i = <identifier> . size ( ) - 1 \n \t2 if ( <identifier> ) { \n \t3 this . <identifier> ( i ) } \n \t2 if ( log . debug <identifiersep> enabled ) { \n <ect>
\t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . contains ( <identifier> . to <identifiersep> string ( <identifier> <identifiersep> type . get <identifiersep> value ( ) ) ) ) { \n \t3 log . error ( <string_literal> ) ; \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value ( <identifier> <identifiersep> type . get <identifiersep> field ( ) ) ; } \n \t2 if ( <identifier> <identifiersep> type . get <identifiersep> value ( ) == <identifier> <identifiersep> type . <identifier> && <identifier> <identifiersep> data <identifiersep> provider == null ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> security <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t2 <identifier> <identifiersep> context context = new <identifier> <identifiersep> context <identifiersep> <identifier> ( null , null , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> user ( <identifier> . get <identifiersep> <identifier> <identifiersep> user <identifiersep> id ( ) ) , <identifier> . get <identifiersep> <identifier> <identifiersep> account ( ) ) ; \n \t2 for ( long network <identifiersep> id : network <identifiersep> <identifier> ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + network <identifiersep> id + <string_literal> + <identifier> <identifiersep> id + <string_literal> ) ; \n \t3 if ( ! <identifier> <identifiersep> network <identifiersep> <identifier> . <identifier> <identifiersep> network ( network <identifiersep> id , context , false ) ) { \n <ect>
\t3 <comment> \n \t3 log <identifiersep> msg = true ; \n \t3 break ; } } } \n \t2 if ( log <identifiersep> msg ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> -= number <identifiersep> of <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ; } \n \t3 if ( <identifier> <identifiersep> <identifier> != number <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 final int number <identifiersep> of <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> = number <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> - <identifier> <identifiersep> <identifier> ; \n \t4 if ( <identifier> <identifiersep> <identifier> < = 0 ) { \n <ect>
\t1 return null ; } \n \t1 bytes = bytes . <identifier> ( ) ; \n \t1 bytes . <identifier> ( ) ; \n \t1 if ( bytes . <identifier> ( ) < <identifier> <identifiersep> bytes . <identifier> ( ) ) { \n <ect>
\t2 type <identifiersep> <identifier> . add ( new <identifier> <identifiersep> type <identifiersep> <identifier> ( ) ) ; \n \t2 type <identifiersep> <identifier> . add ( <identifier> <identifiersep> type <identifiersep> <identifier> ) ; \n \t2 <identifier> = java <identifiersep> <identifier> <identifiersep> <identifier> . get ( type <identifiersep> <identifier> ) ; \n \t2 parse <identifiersep> <identifier> ( root <identifiersep> <identifier> , 0 , null ) ; \n <ect>
\t5 log . debug ( <string_literal> , context . get <identifiersep> name ( ) ) ; } \n \t4 try { \n \t5 <identifier> . <identifier> ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t3 client . <identifier> <identifiersep> get ( url ) . execute ( new <identifier> <identifiersep> <identifier> <identifiersep> handler < response > ( ) { \n \t4 @ <identifier> \n \t4 public response on <identifiersep> <identifier> ( response response ) throws exception { \n \t5 if ( response . get <identifiersep> status <identifiersep> code ( ) != <number_literal> ) { \n <ect>
\t2 <string_literal> - > <identifier> <identifiersep> <identifier> <identifiersep> version . <identifier> <identifiersep> <number_literal> \n \t2 <string_literal> - > <identifier> <identifiersep> <identifier> <identifiersep> version . <identifier> <identifiersep> <number_literal> \n \t2 <string_literal> - > <identifier> <identifiersep> <identifier> <identifiersep> version . <identifier> <identifiersep> <number_literal> \n \t2 else - > { \n <ect>
\t4 throw <identifier> ; \n \t3 } finally { \n \t4 io <identifiersep> <identifier> . close ( <identifier> ) ; } } \n \t2 if ( message . get <identifiersep> body <identifiersep> length ( ) > integer . max <identifiersep> value ) { \n <ect>
\t2 public void <identifier> ( final <identifier> <identifiersep> request <identifier> <identifiersep> request , final <identifier> <identifiersep> response <identifier> <identifiersep> response ) throws io <identifiersep> exception { \n \t3 factory . local <identifiersep> <identifier> . thread <identifiersep> local ( ) . set ( <string_literal> , <identifier> ) ; \n \t3 if ( ! <identifier> <identifiersep> request . get <identifiersep> <identifier> <identifiersep> path ( ) . <identifier> <identifiersep> with ( <string_literal> ) \n \t5 && <identifier> <identifiersep> context . <identifier> . <identifier> . equals ( get <identifiersep> mode ( <identifier> <identifiersep> request ) ) ) { \n <ect>
\t3 try { \n \t4 class < ? > <identifier> = get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> <identifier> ( ) . load <identifiersep> class ( <identifier> ) ; \n \t4 db <identifiersep> factory factory = ( db <identifiersep> factory ) <identifier> . new <identifiersep> instance ( ) ; \n <ect>
\t4 if ( metadata <identifiersep> store . cluster <identifiersep> key . equals ( key <identifiersep> string ) ) { \n \t5 server . handle <identifiersep> cluster <identifiersep> update ( ) ; \n \t4 } else if ( metadata <identifiersep> store . node <identifiersep> id <identifiersep> key . <identifier> <identifiersep> with ( key <identifiersep> string ) ) { \n \t5 server . <identifier> <identifiersep> node <identifiersep> id <identifiersep> from <identifiersep> metadata ( ) ; } \n <ect>
\t4 final <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo current = get <identifiersep> in <identifiersep> list <identifiersep> by <identifiersep> id ( entry . get <identifiersep> key ( ) , current <identifiersep> list ) ; \n \t4 if ( current == null ) { \n \t5 if ( entry . get <identifiersep> key ( ) . long <identifiersep> value ( ) != <identifier> <identifiersep> <identifier> <identifiersep> id . long <identifiersep> value ( ) ) { \n <ect>
public void remove <identifiersep> configuration ( string <identifier> <identifiersep> name ) throws no <identifiersep> such <identifiersep> resource <identifiersep> exception { \n \t1 if ( null == <identifier> <identifiersep> name ) { \n \t1 logger . debug ( <string_literal> ) ; \n \t1 } else { \n <ect>
\t2 } catch ( io <identifiersep> exception e ) { \n \t2 log . warn ( <string_literal> , e ) ; \n \t2 throw new runtime <identifiersep> exception ( e ) ; } } \n \t1 } finally { \n <ect>
\t4 <identifier> . remove ( ) ; \n \t4 if ( <identifier> . equals ( get <identifiersep> context ( ) . <identifier> <identifiersep> <identifier> ( ) ) ) \n \t5 continue ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 <comment> \n \t5 throw e ; \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t5 <comment> \n <ect>
\t3 { \n \t4 new event <identifiersep> trace ( <string_literal> , <identifier> . get ( ) ) . <identifier> ( ) ; \n \t4 if ( ! boolean . get <identifiersep> boolean ( debug <identifiersep> utils . property <identifiersep> <identifier> <identifiersep> log <identifiersep> connection <identifiersep> <identifier> ) ) \n \t4 { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( url ) ; \n \t2 } catch ( security <identifiersep> exception <identifier> ) { \n \t3 log . error ( <string_literal> , url , <identifier> ) ; \n \t2 } catch ( exception <identifier> ) { \n <ect>
\t2 cluster <identifiersep> state = <identifier> . <identifier> ( cluster <identifiersep> state , <string_literal> ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> <identifiersep> routing <identifiersep> state . <identifier> ) . get ( 0 ) . current <identifiersep> node <identifiersep> id ( ) , equal <identifiersep> to ( <string_literal> ) ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> endpoint ( ) ; \n \t2 return <identifier> <identifiersep> <identifier> . get <identifiersep> object <identifiersep> metadata ( <identifier> ) ; } \n \t1 } , new get <identifiersep> object <identifiersep> metadata <identifiersep> request ( <identifier> <identifiersep> name , key <identifiersep> name ) , <identifier> <identifiersep> token <identifiersep> <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 . map ( path - > { \n \t2 file file = new file ( path ) ; \n \t2 if ( file . exists ( ) && file . is <identifiersep> file ( ) ) { \n \t2 return file ; } \n <ect>
\t9 false ) ) ) ; } \n \t4 to <identifiersep> <identifier> ++ ; } \n \t3 else if ( <identifier> <identifiersep> <identifier> <identifiersep> user <identifiersep> account <identifiersep> <identifier> . contains ( <identifier> <identifiersep> id ) ) \n \t3 { \n <ect>
\t3 queue <identifiersep> <identifier> ( new <identifier> <identifiersep> action <identifiersep> update <identifiersep> command ( <identifier> ) , lock <identifiersep> failure <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 log . warn ( <string_literal> + e . get <identifiersep> message ( ) + <string_literal> \n \t5 + job <identifiersep> id + <string_literal> + <identifier> . get <identifiersep> id ( ) + <string_literal> ) ; } \n \t2 finally { \n <ect>
\t2 assert <identifiersep> contains ( <identifier> , <identifier> . to <identifiersep> string ( ) ) ; \n \t2 http <identifiersep> client . stop ( ) ; } \n \t1 @ test ( timeout = <number_literal> * <number_literal> ) \n \t1 public void test <identifiersep> <identifier> <identifiersep> client <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 file <identifier> <identifiersep> <identifier> = new file ( <identifier> <identifiersep> file ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> . exists ( ) ) { \n \t2 <comment> \n \t2 if ( ! <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to ( new file ( <identifier> <identifiersep> file + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> <identifier> . <identifier> ( ) ) ) ) { \n <ect>
\t4 service <identifiersep> <identifier> . <identifier> ( item . get <identifiersep> value ( ) ) ; } \n \t3 return item . get <identifiersep> value ( ) ; } \n \t2 logger . debug ( <string_literal> ) ; \n \t2 if ( service != null ) { \n <ect>
\t2 long <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> handler . get <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> property ( <string_literal> ) , <identifier> <identifiersep> name , 0 ) ; \n \t2 long <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> handler . get <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> property ( <string_literal> ) , <identifier> <identifiersep> name , 1 ) ; \n \t2 long <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> handler . get <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> property ( <string_literal> ) , <identifier> <identifiersep> name , <number_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> . close ( ) ; \n <ect>
\t3 logger . debug ( <string_literal> , ticket . get <identifiersep> id ( ) ) ; \n \t3 final ticket <identifiersep> <identifier> <identifier> = build <identifiersep> ticket <identifiersep> as <identifiersep> <identifier> ( ticket ) ; \n \t3 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket ) ; \n \t3 if ( metadata == null ) { \n <ect>
\t1 else { \n \t2 add <identifiersep> object <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> server <identifiersep> user . <identifier> <identifiersep> key ) ; } } \n public void remove <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . server . server <identifiersep> <identifier> object ) { \n <ect>
\t5 list < array <identifiersep> <identifier> > a = get <identifiersep> <identifier> ( ) ; \n \t5 <identifier> = <identifier> ( filter <identifiersep> <identifier> <identifiersep> <identifier> ( a ) ) ; \n \t5 log . info ( <string_literal> , <identifier> <identifiersep> size ( a , <identifier> ) ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> context context = manager . create <identifiersep> context ( ( <identifier> <identifiersep> <identifier> ) null ) ; \n \t4 context . <identifier> <identifiersep> <identifier> <identifiersep> context ( service <identifiersep> ticket , 0 , service <identifiersep> ticket . length ) ; \n \t4 return context . get <identifiersep> <identifier> <identifiersep> name ( ) . to <identifiersep> string ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> dao . load <identifiersep> source <identifiersep> <identifier> ( <identifier> ) ; } \n \t4 create <identifiersep> <identifier> <identifiersep> <identifier> ( ip . get <identifiersep> id ( ) , <identifier> , <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> source <identifiersep> port <identifiersep> start ( ) , <identifier> . get <identifiersep> source <identifiersep> port <identifiersep> end ( ) , <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> source <identifiersep> <identifier> <identifiersep> list ( ) , null , \n \t6 <identifier> . get <identifiersep> <identifier> <identifiersep> code ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) , <identifier> . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> <identifiersep> type . system , <identifier> . get <identifiersep> network <identifiersep> id ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) , true ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 return false ; } \n \t2 final <identifier> <identifiersep> manager manager = <identifier> <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager ( request , response ) ; \n \t2 final <identifier> < user <identifiersep> <identifier> > <identifier> = manager . get ( true ) ; \n \t2 if ( <identifier> == null || ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 result = <identifier> . <identifier> ( ) ; } \n \t3 catch ( throwable t ) \n \t3 { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> throwable ( t ) ; \n <ect>
\t5 logger . info ( <string_literal> , new object [ ] { <identifier> <identifiersep> url , address , <identifier> <identifiersep> address } ) ; \n \t5 <identifier> <identifiersep> url = new url ( new url ( <identifier> <identifiersep> url , address ) , <identifier> <identifiersep> address ) ; \n \t4 } else { \n \t5 <comment> \n <ect>
\t6 new <identifiersep> <identifier> . remove <identifiersep> <identifier> ( <identifier> ) ; \n \t6 if ( <identifier> . get <identifiersep> source <identifiersep> map ( ) . get <identifiersep> id ( ) . <identifier> <identifiersep> to ( <identifier> <identifiersep> map <identifiersep> id ) == 0 && ( <identifier> <identifiersep> map <identifiersep> id . <identifier> <identifiersep> to ( root <identifiersep> <identifier> <identifiersep> map <identifiersep> id ) != 0 ) ) \n \t6 { \n \t7 <identifier> . set <identifiersep> is <identifiersep> <identifier> ( true ) ; \n <ect>
\t2 if ( data <identifiersep> <identifier> <identifiersep> config . get <identifiersep> directory <identifiersep> <identifier> ( ) == null || data <identifiersep> <identifier> <identifiersep> config . get <identifiersep> directory <identifiersep> <identifier> ( ) . length == 0 ) { \n \t3 logger . error ( <string_literal> ) ; \n \t3 return false ; } \n \t2 if ( data <identifiersep> <identifier> <identifiersep> config . get <identifiersep> date <identifiersep> path <identifiersep> format ( ) == null || data <identifiersep> <identifier> <identifiersep> config . get <identifiersep> date <identifiersep> path <identifiersep> format ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t2 try { \n \t3 <comment> \n \t3 builder . <identifier> ( <identifier> <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) . get <identifiersep> <identifier> <identifiersep> host <identifiersep> name ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> host <identifiersep> exception ex ) { \n <ect>
\t3 <identifier> <identifiersep> config . set <identifiersep> attribute ( debug <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> output , true ) ; \n \t3 final i <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> config . <identifier> ( i <identifiersep> <identifier> <identifiersep> manager . run <identifiersep> mode , new null <identifiersep> <identifier> <identifiersep> <identifier> ( ) , false , false ) ; \n \t3 final <identifier> <identifiersep> <identifier> result = new <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . length == 0 ) { \n <ect>
\t2 if status : \n \t2 logger . info ( <string_literal> . format ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> name ) ) \n \t2 return true \n \t2 else : \n <ect>
\t9 return <identifier> <identifiersep> info ; } } } \n \t6 if ( <identifier> <identifiersep> info == null ) { \n \t7 <identifier> <identifiersep> info = <identifier> <identifiersep> info <identifiersep> builder . get <identifiersep> <identifier> <identifiersep> info <identifiersep> by <identifiersep> device <identifiersep> <identifier> <identifiersep> name ( info <identifiersep> in <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t7 if ( <identifier> <identifiersep> info != null ) { \n <ect>
\t2 if ( time <identifiersep> <identifier> <identifiersep> last <identifiersep> <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t2 { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> conf <identifiersep> info <identifiersep> <identifier> ( ) ) \n \t4 return ; \n <ect>
<comment> \n \t1 public void add <identifiersep> data ( byte [ ] data , int <identifier> ) { \n \t2 if ( <identifier> + m <identifiersep> end > max <identifiersep> msg <identifiersep> <identifier> ) { \n <ect>
\t8 ( ( on <identifiersep> <identifier> <identifiersep> type ) command == on <identifiersep> <identifier> <identifiersep> type . on ) ) ; \n \t5 } else if ( <identifier> <identifiersep> config . get <identifiersep> <identifier> ( ) == max <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ) { \n \t6 message <identifiersep> handler . send <identifiersep> <identifier> ( <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t5 } else { \n <ect>
\t4 <identifier> <identifiersep> <identifier> = ( string ) factory . get <identifiersep> bean ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> == null ? <identifier> . <identifier> <identifiersep> user <identifiersep> version : <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } \n \t3 catch ( no <identifiersep> such <identifiersep> bean <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> config <identifiersep> url = <identifier> . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ; \n \t2 } else { \n \t2 log . warn ( <string_literal> + config <identifiersep> file ) ; } \n \t1 } catch ( uri <identifiersep> <identifier> <identifiersep> exception | <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t3 set < string > <identifier> <identifiersep> <identifier> <identifiersep> found <identifiersep> in <identifiersep> <identifier> = new <identifier> <identifiersep> set < > ( ) ; \n \t3 collection < <identifier> <identifiersep> name > <identifier> <identifiersep> in <identifiersep> <identifier> = <identifier> <identifiersep> to <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> name <identifiersep> <identifier> ) ; \n \t3 for ( <identifier> <identifiersep> name name <identifiersep> in <identifiersep> <identifier> : <identifier> <identifiersep> in <identifiersep> <identifier> ) { \n \t4 if ( string <identifiersep> utils . is <identifiersep> blank ( name <identifiersep> in <identifiersep> <identifier> . get <identifiersep> name ( ) ) ) { \n <ect>
\t3 message <identifiersep> channel <identifiersep> <identifier> <identifier> = entry . get <identifiersep> value ( ) ; \n \t3 message <identifiersep> channel channel = ( message <identifiersep> channel ) <identifier> ; \n \t3 if ( channel instanceof <identifier> ) { \n <ect>
\t3 return v == null \n \t5 ? null \n \t5 : v . get <identifiersep> string ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 in . close ( ) ; \n \t3 if ( connection . get <identifiersep> response <identifiersep> code ( ) == <number_literal> ) { \n \t4 log . info ( <string_literal> + url . to <identifiersep> string ( ) + <string_literal> ) ; \n \t3 } else { \n <ect>
\t3 log . warn ( <string_literal> + message . get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> , e ) ; \n \t3 throw new application <identifiersep> exception ( context . get <identifiersep> message <identifiersep> source <identifiersep> service ( ) . get <identifiersep> message ( <string_literal> , \n \t4 new object [ ] { message . get <identifiersep> class ( ) . get <identifiersep> name ( ) } , null ) , e ) ; } \n \t2 catch ( <identifier> e ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> cluster <identifiersep> state . <identifier> ( cluster <identifiersep> <identifier> <identifiersep> event , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> nodes ( ) , <identifier> <identifiersep> listener ) ; \n \t2 } catch ( failed <identifiersep> to <identifiersep> <identifier> <identifiersep> cluster <identifiersep> state <identifiersep> exception t ) { \n \t3 <comment> \n <ect>
\t2 try ( stream < string > <identifier> = files . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> path ) ) { \n \t3 <identifier> <identifiersep> list = <identifier> . filter ( line - > line . <identifier> <identifiersep> with ( <string_literal> ) == false ) <comment> \n \t7 . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception | no <identifiersep> such <identifiersep> file <identifiersep> exception e ) { \n <ect>
\t2 <identifier> += <string_literal> ; } \n \t2 <identifier> += line ; } \n \t1 return <identifier> ; \n \t1 } catch ( exception e ) { \n <ect>
\t4 byte <identifiersep> <identifier> <identifier> = get <identifiersep> byte <identifiersep> <identifier> ( node . get <identifiersep> message ( ) ) ; \n \t4 object <identifier> = get <identifiersep> <identifier> <identifiersep> list ( ) . add <identifiersep> first ( node . get <identifiersep> message <identifiersep> id ( ) . to <identifiersep> string ( ) , <identifier> ) ; \n \t4 node . get <identifiersep> message <identifiersep> id ( ) . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 } else { <comment> \n \t6 string <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> service . result <identifiersep> to <identifiersep> <identifier> <identifiersep> string ( event ) ; \n \t6 out . <identifier> ( <identifier> ) ; } \n \t4 } catch ( exception <identifier> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 try { \n \t5 <identifier> <identifiersep> id = short . parse <identifiersep> short ( <identifier> <identifiersep> <identifier> ) ; \n \t4 } catch ( java . <identifier> . number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 log . error ( <string_literal> ) ; \n \t3 return false ; } \n \t2 <comment> \n \t2 if ( ! is <identifiersep> token <identifiersep> time <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( token ) ) { \n <ect>
\t3 if ( current == - 1 ) { \n \t4 log . warn ( <string_literal> , <identifier> ) ; \n \t4 return null ; <comment> \n \t3 if ( current < = <identifier> ) { \n <ect>
\t2 resource resource = this . resource <identifiersep> <identifier> . get <identifiersep> resource ( get <identifiersep> resource <identifiersep> location ( path ) ) ; \n \t2 try { \n \t3 return resource . get <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ; } \n \t2 catch ( io <identifiersep> exception ex ) { \n <ect>
\t3 log . error ( <string_literal> ) ; \n \t3 log . error ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 log . error ( <string_literal> + <identifier> <identifiersep> action <identifiersep> type + <string_literal> ) ; \n <ect>
\t2 } finally { \n \t3 close ( ) ; } } \n \t1 private void read <identifiersep> <identifier> <identifiersep> <identifier> ( final int <identifier> <identifiersep> num , final list < abstract <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> . <identifier> <identifiersep> info > <identifier> , \n \t8 final boolean header <identifiersep> <identifier> ) { \n <ect>
\t1 else : \n \t1 <identifier> <identifiersep> cmd = <string_literal> \n \t1 # check <identifier> <identifiersep> server \n \t1 logger . info ( <string_literal> ) \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t2 if ( <identifier> ( ) ) { \n \t3 try { \n \t4 cache <identifiersep> long = long . parse <identifiersep> long ( cache ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t3 throw e ; \n \t2 } catch ( final <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> , e ) ; \n \t3 throw e ; } \n <ect>
\t5 } catch ( io <identifiersep> exception e ) { \n \t6 log . error ( <string_literal> + db <identifiersep> <identifier> . get <identifiersep> name ( ) , e ) ; } } \n \t4 return <identifier> ; } \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t4 if ( <identifier> . length ( ) > <identifier> <identifiersep> <identifier> ) <identifier> <identifiersep> <identifier> = <identifier> . length ( ) ; \n \t4 if ( <identifier> . length ( ) > <number_literal> ) ++ num <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 log . debug ( e . get <identifiersep> message ( ) + <string_literal> ) ; } } \n <ect>
\t1 @ <identifier> ( <number_literal> ) \n \t1 public void test <identifiersep> listener <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> connection ( ) throws exception { \n \t2 if ( this . <identifier> == null ) { \n \t3 this . <identifier> = create <identifiersep> <identifier> ( queue . get <identifiersep> name ( ) , listener , connection <identifiersep> factory ) ; } \n <ect>
\t3 case <identifier> . <identifier> : { \n \t4 logger . warn ( <string_literal> , type ) ; \n \t4 return null ; } \n \t3 case <identifier> . <identifier> : { \n <ect>
\t6 <identifier> = name . equals ( context <identifiersep> id ) ; \n \t5 } else { \n \t6 <identifier> = endpoint <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( name , context <identifiersep> id <identifiersep> <identifier> ) ; } \n <ect>
\t2 long read <identifiersep> <identifier> <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> <identifiersep> <identifier> ; \n \t2 <identifier> <identifiersep> info next <identifiersep> <identifier> <identifiersep> info = <identifier> <identifiersep> context . <identifier> <identifiersep> db ( ) . <identifier> <identifiersep> <identifier> <identifiersep> info <identifiersep> <identifier> ( next <identifiersep> <identifier> ) ; \n \t2 long <identifier> <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> <identifiersep> <identifier> ; \n \t2 if ( <identifier> <identifiersep> time > <number_literal> && <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 <identifier> < ? , ? > <identifier> = context . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> != null ) { \n \t4 return ( string ) <identifier> . get ( key ) ; \n \t3 } else { \n <ect>
\t4 <identifier> <identifiersep> lock . wait ( <number_literal> ) ; \n \t4 logger . debug ( <string_literal> ) ; } } \n \t2 catch ( interrupted <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 for ( store <identifiersep> <identifier> <identifier> : store <identifiersep> <identifier> ) \n \t3 if ( <identifier> . get <identifiersep> name ( ) . equals ( store <identifiersep> name ) ) \n \t4 store <identifiersep> <identifier> = <identifier> ; \n \t2 if ( store <identifiersep> <identifier> == null ) { \n <ect>
\t2 string metadata <identifiersep> dir <identifiersep> path = context <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <identifier> ) ; \n \t2 string user <identifiersep> dir <identifiersep> path = context <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> value ( context <identifiersep> <identifier> . user <identifiersep> directory <identifiersep> path ) ; \n \t2 metadata <identifiersep> dir <identifiersep> path = user <identifiersep> dir <identifiersep> path + directory ; \n \t2 context <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> value ( <identifier> , metadata <identifiersep> dir <identifiersep> path ) ; \n <ect>
\t1 public void user <identifiersep> event <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context <identifier> , object <identifier> ) throws exception \n \t1 { \n \t2 if ( <identifier> instanceof connection <identifiersep> type && <identifier> == <identifier> . server ) \n \t2 { \n <ect>
\t1 utils . <identifier> <identifiersep> <identifier> ( self . stop <identifiersep> event ) \n \t1 else : \n \t1 self . response <identifiersep> id = server <identifiersep> id \n \t1 if <identifier> <identifiersep> <identifier> in response and response [ <identifier> <identifiersep> <identifier> ] . <identifier> ( ) == <string_literal> : \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 string request <identifiersep> uri = request <identifiersep> context . get <identifiersep> uri <identifiersep> info ( ) . get <identifiersep> request <identifiersep> uri ( ) . to <identifiersep> string ( ) ; \n \t2 if ( info <identifiersep> level ) { \n \t3 log . info ( <string_literal> , request <identifiersep> uri ) ; \n \t2 } else { \n <ect>
\t1 private static logger logger = logger . get <identifiersep> logger ( filter <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n \t1 private static final long <identifier> <identifiersep> version <identifiersep> <identifier> = <identifier> ; \n \t1 public void service ( <identifier> <identifiersep> request <identifier> , <identifier> <identifiersep> response <identifier> ) throws <identifier> <identifiersep> exception , io <identifiersep> exception { \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t3 <comment> \n \t3 system . <identifier> ( ) ; \n \t3 delete <identifiersep> directory ( <identifier> <identifiersep> file ) ; \n \t3 if ( ! target <identifiersep> file . <identifier> <identifiersep> to ( new file ( target ) ) ) { \n <ect>
\t1 log . trace ( <string_literal> + new date ( ) ) ; \n \t1 try { \n \t1 process <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( msg ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 if ( state == <identifier> ) { \n \t3 if ( <identifier> <identifiersep> read <identifiersep> <identifier> . get ( ) == 0 && <identifier> <identifiersep> write <identifiersep> <identifier> . get ( ) == 0 ) \n \t4 shutdown ( ) ; } } \n \t1 private void shutdown ( ) { \n <ect>
\t3 <comment> \n \t3 if ( error <identifiersep> handler != null ) \n \t4 error <identifiersep> handler . handle <identifiersep> error <identifiersep> on <identifiersep> delete ( this , e , key ) ; \n \t3 <comment> \n <ect>
\t3 this . <identifier> <identifiersep> policy = new default <identifiersep> registered <identifiersep> service <identifiersep> <identifier> <identifiersep> policy ( ) ; } } \n \t1 @ <identifier> \n \t1 public map < string , object > get <identifiersep> <identifier> <identifiersep> attributes ( final principal p , final service <identifier> <identifiersep> service , final registered <identifiersep> service service ) { \n \t2 if ( this . <identifier> <identifiersep> policy != null && ! this . <identifier> <identifiersep> policy . is <identifiersep> enabled ( ) ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 float <identifier> = <identifier> <identifiersep> time / <identifier> / <identifier> / <identifier> ; \n \t2 <identifier> <identifiersep> format <identifier> <identifiersep> format = new <identifier> <identifiersep> format ( <string_literal> ) ; \n \t2 string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> format . format ( <identifier> ) ; \n <ect>
\t3 log . info ( <string_literal> + file <identifiersep> <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> <identifiersep> list <identifiersep> start ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> <identifiersep> size ) ; \n <ect>
\t2 try { \n \t3 context . add <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t3 context . get <identifiersep> <identifier> <identifiersep> service ( ) . <identifier> <identifiersep> super <identifiersep> <identifier> ( <string_literal> , ex , ex . get <identifiersep> message ( ) ) ; } \n \t2 catch ( exception e ) { \n <ect>
\t7 ? <identifier> <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> the <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> first <identifiersep> <identifier> <identifiersep> code ( ) : <identifier> <identifiersep> code ) ; \n \t4 } else if ( command <identifiersep> <identifier> . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) { \n \t5 if ( ( current <identifiersep> state . is <identifiersep> <identifier> <identifiersep> mode ( ) == null ) \n \t7 || current <identifiersep> state . is <identifiersep> <identifier> <identifiersep> mode ( ) . equals ( boolean . false ) ) { \n <ect>
\t2 assert <identifiersep> equals ( password , <identifier> . get <identifiersep> password ( ) ) ; } \n \t1 @ test \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> ticket <identifiersep> as <identifiersep> authentication <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 final map < ? , ? > attributes = <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 int <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( <identifier> ) ; \n \t3 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . set <identifiersep> number <identifiersep> of <identifiersep> query <identifiersep> <identifier> ( i + 1 ) ; \n \t3 get <identifiersep> resource <identifiersep> manager ( <identifier> ) . update ( <identifier> , <identifier> ) ; \n <ect>
\t4 . add <identifiersep> as <identifiersep> new ( meta <identifiersep> data . index ( <string_literal> ) ) \n \t4 . add <identifiersep> as <identifiersep> new ( meta <identifiersep> data . index ( <string_literal> ) ) \n \t4 . build ( ) ; \n \t2 cluster <identifiersep> state cluster <identifiersep> state = cluster <identifiersep> state . builder ( org . <identifier> . cluster . cluster <identifiersep> name . cluster <identifiersep> name <identifiersep> <identifier> . get <identifiersep> default ( <identifier> . empty ) ) . meta <identifiersep> data ( meta <identifiersep> data ) . routing <identifiersep> table ( <identifier> <identifiersep> routing <identifiersep> table ) . build ( ) ; \n <ect>
\t7 if ( <identifier> == null ) { \n \t8 return null ; } \n \t7 state = new <identifier> <identifiersep> type ( <identifier> ) ; \n \t6 } else { \n <ect>
\t4 } catch ( exception e ) { \n \t5 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> factory , \n \t7 e ) ; } } \n \t2 } catch ( <identifier> <identifiersep> config <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 <comment> \n \t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> pool <identifiersep> dao . remove ( template <identifiersep> pool <identifiersep> vo . get <identifiersep> id ( ) ) ) { \n \t6 s <identifiersep> logger . debug ( <string_literal> + template . get <identifiersep> name ( ) + <string_literal> + pool . get <identifiersep> name ( ) ) ; } \n \t4 } else { \n <ect>
\t5 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t6 this . logger . warn ( <string_literal> , \n \t8 <identifier> , exception <identifiersep> utils . get <identifiersep> root <identifiersep> <identifier> <identifiersep> message ( e ) ) ; } } } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 break ; } \n \t3 catch ( grid <identifiersep> cache <identifiersep> entry <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t4 assert entry . <identifier> <identifiersep> version ( ) != null ; \n <ect>
\t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean delete <identifiersep> remote <identifiersep> access <identifiersep> <identifier> ( final network network , final remote <identifiersep> access <identifiersep> <identifier> <identifier> , final list < ? extends <identifier> <identifiersep> <identifier> > <identifier> ) throws resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 if ( provider . <identifier> <identifiersep> <identifier> <identifiersep> for ( item <identifiersep> name ) ) { \n \t4 item <identifiersep> <identifier> = provider . get <identifiersep> item <identifiersep> config ( item <identifiersep> name ) ; \n \t4 break ; } } \n \t2 if ( <identifier> . size ( ) == 0 ) { \n <ect>
\t3 index ( <string_literal> , <string_literal> , integer . to <identifiersep> string ( i ) , <string_literal> , <string_literal> + i ) ; } \n \t2 <identifier> ( ) ; \n \t2 assert <identifiersep> that ( client . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> size ( 0 ) . get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( client . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> size ( 0 ) . get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n <ect>
\t4 return null ; } \n \t3 try { \n \t4 return new <identifier> <identifiersep> date <identifiersep> format ( <string_literal> ) . parse ( text ) ; \n \t3 } catch ( parse <identifiersep> exception e ) { \n <ect>
\t3 logger . info ( <string_literal> , endpoint ) ; \n \t3 token <identifiersep> metadata . update <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , endpoint ) ; } \n \t2 else if ( ! token <identifiersep> metadata . get <identifiersep> <identifier> ( endpoint ) . contains <identifiersep> all ( <identifier> ) ) \n \t2 { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state state = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state . value <identifiersep> of ( value ) ; \n \t3 if ( state == null ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + value ) ; } \n \t3 return state ; } \n <ect>
\t3 <comment> \n \t3 thread . <identifier> ( <number_literal> ) ; \n \t3 <identifier> = <identifier> ( queue , <identifier> <identifiersep> connection ) ; \n \t3 log . info ( <string_literal> , time <identifiersep> unit . <identifier> . to <identifiersep> millis ( system . <identifier> <identifiersep> time ( ) - <identifier> ) , <identifier> ) ; } \n <ect>
\t4 log . debug ( <string_literal> + <identifier> . type <identifiersep> text [ id . type ] + <string_literal> \n \t7 + id . id . to <identifiersep> string ( ) + <string_literal> ) ; \n \t4 <identifier> ( <identifier> , id ) ; } \n \t3 log . debug ( <string_literal> ) ; } \n <ect>
\t1 if e . code == <number_literal> : \n \t2 return <identifier> \n \t1 <identifier> \n \t1 <identifier> exception , e : \n <ect>
\t8 string version <identifiersep> <identifier> , \n \t8 boolean remove <identifiersep> <identifier> ) \n \t2 throws version <identifiersep> exception , item <identifiersep> exists <identifiersep> exception , <identifier> <identifiersep> <identifier> <identifiersep> operation <identifiersep> exception , lock <identifiersep> exception , \n \t2 <identifier> <identifiersep> item <identifiersep> state <identifiersep> exception , <identifier> <identifiersep> exception { \n <ect>
\t3 return <identifier> . to <identifiersep> date ( <identifier> ) ; \n \t3 } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { \n \t3 logger . trace ( <string_literal> , <identifier> , <identifier> ) ; \n \t3 <comment> \n <ect>
\t1 <comment> \n \t1 run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> , conf <identifiersep> for <identifiersep> <identifier> ) ; \n \t1 run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> , conf <identifiersep> for <identifiersep> <identifier> ) ; \n \t1 <identifier> = run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> , conf <identifiersep> for <identifiersep> <identifier> ) ; \n <ect>
\t1 url url = null ; \n \t1 try { \n \t2 url = new url ( network <identifiersep> uri ) ; \n \t1 } catch ( <identifier> <identifiersep> url <identifiersep> exception <identifier> ) { \n <ect>
\t2 this . <identifier> \t1 = <identifier> ; } \n \t1 @ <identifier> \n \t1 public object <identifier> <identifiersep> id <identifiersep> <identifier> ( final id <identifiersep> function <identifiersep> object <identifier> , final context <identifier> , final <identifier> <identifier> , final <identifier> this <identifiersep> <identifier> , final object [ ] <identifier> ) { \n \t2 if ( <identifier> . length < 1 ) { \n <ect>
\t1 } catch ( x <identifiersep> path <identifiersep> exception e ) { \n \t1 if ( e . get <identifiersep> exception ( ) instanceof file <identifiersep> not <identifiersep> found <identifiersep> exception ) { \n \t2 logger . error ( <identifier> . get <identifiersep> instance ( ) . get <identifiersep> string ( <string_literal> , query ) ) ; <comment> \n \t1 } else { \n <ect>
\t3 return false ; } \n \t2 <identifier> <identifier> = [ a , <identifier> ] \n \t2 boolean <identifier> = this . <identifier> [ <identifier> ] \n \t2 if ( <identifier> != null ) { \n <ect>
\t6 } else { \n \t7 out . write ( line ) ; \n \t7 out . new <identifiersep> line ( ) ; } \n \t5 } else { \n <ect>
\t6 try { \n \t7 <identifier> <identifiersep> user . <identifier> <identifiersep> user ( ) ; \n \t7 <identifier> <identifiersep> user . <identifier> <identifiersep> user ( ) ; \n \t6 } catch ( exception e ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + json <identifiersep> body ) ; \n \t3 result = <identifier> <identifiersep> http <identifiersep> request ( json <identifiersep> body . to <identifiersep> string ( ) , <identifier> <identifiersep> uri , <identifier> <identifiersep> <identifier> ) ; \n \t3 s <identifiersep> logger . debug ( <string_literal> + result ) ; \n \t3 result = query <identifiersep> <identifier> <identifiersep> job ( result ) ; \n <ect>
\t4 path <identifier> = debug <identifiersep> dir . <identifier> ( <identifier> . name + <string_literal> ) ; \n \t4 files . create <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t4 files . write ( <identifier> , bytes ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 <identifier> . set <identifiersep> state ( <identifier> <identifiersep> state ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> ( <identifier> ) ; \n \t5 s <identifiersep> logger . debug ( <string_literal> + load <identifiersep> <identifier> <identifiersep> id + <string_literal> ) ; \n \t4 } else { \n <ect>
\t6 <comment> \n \t6 <comment> \n \t3 } ) ; } \n \t2 assert <identifiersep> true ( <string_literal> , <identifier> . <identifier> ( 1 , time <identifiersep> unit . <identifier> ) ) ; \n <ect>
\t6 if ( <identifier> <identifiersep> <identifier> && ! <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t7 log . info ( <string_literal> , info . get <identifiersep> consumer <identifiersep> id ( ) ) ; \n \t7 <identifier> <identifiersep> <identifier> ( ) ; } \n \t5 } catch ( exception e ) { \n <ect>
\t5 test <identifiersep> filter . add <identifiersep> test <identifiersep> filter ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> filter ( <identifier> <identifiersep> host ) ) ; \n \t5 test = new <identifier> <identifiersep> test <identifiersep> file <identifiersep> <identifier> ( test <identifiersep> file , test <identifiersep> filter ) . process ( ) ; \n \t5 log . debug ( <string_literal> + test <identifiersep> file ) ; \n \t5 <identifier> . run ( test ) ; \n <ect>
\t4 channel . get <identifiersep> or <identifiersep> create <identifiersep> state ( <identifier> , <identifier> ) . close ( ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> , e ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> policy . get <identifiersep> <identifier> <identifiersep> attributes ( ) != null && ! <identifier> <identifiersep> policy . get <identifiersep> <identifier> <identifiersep> attributes ( ) . is <identifiersep> empty ( ) ) { \n \t4 <identifier> <identifiersep> policy . get <identifiersep> <identifier> <identifiersep> attributes ( ) . for <identifiersep> <identifier> ( attributes : : remove ) ; \n \t4 logger . debug ( <string_literal> , attributes ) ; \n \t3 } else { \n <ect>
\t4 p <identifiersep> <identifier> . set <identifiersep> int ( <number_literal> , <identifier> <identifiersep> id ) ; \n \t4 p <identifiersep> <identifier> . add <identifiersep> <identifier> ( ) ; } \n \t3 p <identifiersep> <identifier> . execute <identifiersep> <identifier> ( ) ; } \n \t2 catch ( <identifier> <identifiersep> exception | sql <identifiersep> exception e ) { \n <ect>
\t2 <identifier> r = new <identifier> ( ) { \n \t3 public void run ( ) { \n \t4 log . info ( <string_literal> + thread . current <identifiersep> thread ( ) . get <identifiersep> name ( ) ) ; \n \t4 <identifier> . lock ( ) ; \n <ect>
<comment> \n \t1 public void delete <identifiersep> <identifier> ( string <identifier> <identifiersep> id ) { \n \t2 try { \n <ect>
\t3 logger . warn ( <string_literal> + item + <string_literal> ) ; } \n \t2 if ( config != null ) { \n \t3 add <identifiersep> <identifier> <identifiersep> config ( item , config ) ; \n \t2 } else { \n <ect>
\t1 db <identifiersep> name = <identifier> <identifiersep> <identifier> ( db <identifiersep> name ) ; \n \t1 <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t1 list < m <identifiersep> table <identifiersep> <identifier> <identifiersep> <identifier> > m <identifiersep> security <identifiersep> <identifier> <identifiersep> list = new array <identifiersep> list < > ( ) ; \n \t1 try { \n <ect>
\t1 try { \n \t1 log . debug ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> queue . <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 protected void <identifier> ( final <identifier> <identifiersep> client <identifier> ) { \n \t2 try { \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> + job . get <identifiersep> id ( ) + <string_literal> ) ; \n \t4 <identifier> <identifiersep> queue <identifiersep> <identifier> . return <identifiersep> item ( item . get <identifiersep> id ( ) ) ; } \n \t2 } else { \n <ect>
\t2 <comment> \n \t2 if ( ! it . has <identifiersep> next ( ) ) { \n \t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> empty <identifiersep> count ( ) ; \n <ect>
\t7 if ( <identifier> == null ) { \n \t8 return null ; } \n \t7 state = new string <identifiersep> type ( <identifier> ) ; \n \t6 } else { \n <ect>
\t5 else - > <string_literal> } } } \n \t2 map . put ( <string_literal> , <identifier> <identifiersep> builder <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) \n \t2 return map } \n \t1 private <identifier> build <identifiersep> <identifier> <identifiersep> map ( ) : map < string , <identifier> <identifiersep> builder <identifiersep> <identifier> > { \n <ect>
@ <identifier> \n public void set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( boolean <identifier> <identifiersep> <identifier> ) \n { \n \t1 if ( <identifier> ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; \n <ect>
\t1 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t1 <identifier> . <identifier> ( <string_literal> ) . <identifier> ( <identifier> <identifiersep> num ++ ) . <identifier> ( ' ' ) . <identifier> ( <identifier> . get <identifiersep> type ( ) ) ; } \n \t1 <identifier> . <identifier> ( <string_literal> ) ; \n \t1 sql <identifiersep> <identifier> = <identifier> . to <identifiersep> string ( ) ; \n <ect>
\t1 public void request <identifiersep> <identifier> <identifiersep> update ( ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> <identifiersep> message ( new host <identifiersep> state ( host <identifiersep> message . all <identifiersep> <identifier> ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 cluster <identifiersep> state <identifiersep> <identifier> <identifier> = new cluster <identifiersep> state <identifiersep> <identifier> ( current <identifiersep> state , cluster <identifiersep> service , null , logger , thread <identifiersep> pool . get <identifiersep> thread <identifiersep> context ( ) ) ; \n \t2 <identifier> <identifiersep> node <identifier> <identifiersep> node = current <identifiersep> state . nodes ( ) . get <identifiersep> <identifier> <identifiersep> node ( ) ; \n \t2 <identifier> < cluster <identifiersep> state > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> <identifier> . build ( current <identifiersep> state ) ; \n \t2 if ( <identifier> <identifiersep> node == null ) { \n <ect>
\t4 if ( t instanceof <identifier> <identifiersep> interrupted <identifiersep> exception ) \n \t4 { \n \t5 logger . info ( t . get <identifiersep> message ( ) ) ; \n \t5 if ( t . get <identifiersep> <identifier> ( ) != null && t . get <identifiersep> <identifier> ( ) . length > 0 ) \n <ect>
\t2 log . info ( <string_literal> + class <identifiersep> name + <string_literal> + instance ) ; \n \t2 return instance ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( t instance , <identifier> <identifiersep> context < t > <identifier> <identifiersep> context ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void set <identifiersep> class <identifiersep> type ( string type ) \n \t1 { \n <ect>
\t4 <identifier> ( ) ; \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t1 public void <identifier> <identifiersep> json ( ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> json ( this . <identifier> <identifiersep> builder . get <identifiersep> <identifier> ( ) , get <identifiersep> <identifier> <identifiersep> json <identifiersep> name ( ) , true , true ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> length < length <identifiersep> <identifier> ) \n \t3 { \n \t4 <comment> \n \t4 <comment> \n <ect>
\t4 <identifier> <identifiersep> level = connection . transaction <identifiersep> <identifier> ; \n \t3 } else if ( <identifier> <identifiersep> <identifier> <identifiersep> level . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) { \n \t4 <identifier> <identifiersep> level = connection . transaction <identifiersep> read <identifiersep> <identifier> ; \n \t3 } else { \n <ect>
\t7 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) , \n \t7 <identifier> . get <identifiersep> <identifier> ( ) + 1 , <comment> \n \t7 <identifier> <identifiersep> size ) ; } \n \t4 <identifier> . api . <identifier> <identifiersep> request <identifier> <identifiersep> request = <identifier> . build ( ) ; \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> id , <identifier> ) ) ; } } \n \t2 return <identifier> <identifiersep> <identifier> <identifiersep> id ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> for <identifiersep> host <identifiersep> <identifier> ( final int id ) { \n <ect>
\t2 try { \n \t3 return has <identifiersep> access <identifiersep> level ( <identifier> <identifiersep> <identifier> , get <identifiersep> <identifier> <identifiersep> name ( ) ) || has <identifiersep> access <identifiersep> level ( <string_literal> , get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t3 <comment> \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = factory . create <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> <identifier> ( get <identifiersep> <identifier> ( ) ) ; \n \t2 string <identifier> <identifiersep> id <identifiersep> <identifier> = <string_literal> ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> id <identifiersep> <identifier> ) ; \n <ect>
\t3 log . info ( <string_literal> + class <identifiersep> name ) ; \n \t3 method <identifier> <identifiersep> method = class <identifiersep> <identifier> . get <identifiersep> method ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> method . <identifier> ( null ) ; } \n \t2 catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
\t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t3 method m = this . get <identifiersep> class ( ) . get <identifiersep> method ( <string_literal> + <identifier> <identifiersep> num + <string_literal> , string . class ) ; \n \t3 m . <identifier> ( this , value ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 if ( input <identifiersep> stream != null ) { \n \t4 try { \n \t4 input <identifiersep> stream . close ( ) ; } \n \t4 catch ( final io <identifiersep> exception e ) { \n <ect>
\t2 for ( <identifier> <identifiersep> <identifier> <identifiersep> connection <identifier> : <identifier> <identifiersep> <identifier> . values ( ) ) { \n \t3 try { \n \t4 <identifier> . start ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 template <identifiersep> path <identifiersep> <identifier> = new class <identifiersep> template <identifiersep> <identifier> ( get <identifiersep> class ( ) , template <identifiersep> path . <identifier> ( <number_literal> ) ) ; \n \t4 } else if ( template <identifiersep> path . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t5 template <identifiersep> path <identifiersep> <identifier> = new file <identifiersep> template <identifiersep> <identifier> ( new file ( template <identifiersep> path . <identifier> ( <number_literal> ) ) ) ; } } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 has <identifiersep> <identifier> = true ; } \n \t1 client <identifiersep> instance = <identifier> . next ( ) ; } \n \t1 token < <identifier> <identifiersep> token <identifiersep> <identifier> > token = <identifier> <identifiersep> token ( token <identifiersep> bytes ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 for ( int i = 0 ; i < s <identifiersep> num <identifiersep> <identifier> ; i ++ ) { \n \t4 if ( s <identifiersep> num <identifiersep> <identifier> > 1 ) { \n <ect>
\t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> , e ) ; } } } \n \t2 vm = <identifier> <identifiersep> it <identifiersep> <identifier> . find <identifiersep> by <identifiersep> id <identifiersep> and <identifiersep> type ( vm . get <identifiersep> type ( ) , vm . get <identifiersep> id ( ) ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> && ! vm . is <identifiersep> <identifier> <identifiersep> enabled ( ) ) { \n <ect>
\t1 { \n \t1 item = <identifier> <identifiersep> item . get ( ) ; \n \t1 if ( item == null ) \n \t1 { \n <ect>
\t4 final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , path ) ; \n \t4 if ( <identifier> != null ) { \n \t5 <identifier> = <identifier> <identifiersep> <identifier> . load <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> , <identifier> ) ; } \n \t4 if ( ! <identifier> ) { \n <ect>
\t2 final string local <identifiersep> node <identifiersep> id = state . nodes ( ) . get <identifiersep> local <identifiersep> node <identifiersep> id ( ) ; \n \t2 assert local <identifiersep> node <identifiersep> id != null ; \n \t2 for ( index index : event . <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t4 } else { \n \t5 log . debug ( <string_literal> ) ; } \n \t3 } else { \n <ect>
public <identifier> <identifiersep> element ( string <identifier> <identifiersep> uri ) { \n \t1 super ( <identifier> <identifiersep> uri ) ; } \n @ <identifier> \n public response <identifier> <identifiersep> handle ( http <identifiersep> request request ) throws json <identifiersep> exception { \n <ect>
\t3 <identifier> < <identifier> <identifiersep> filter <identifiersep> <identifier> > <identifier> = filter <identifiersep> <identifier> <identifiersep> stream . <identifier> ( ) ; \n \t3 while ( <identifier> . has <identifiersep> next ( ) ) { \n \t4 <identifier> . add ( new <identifier> <identifiersep> <identifier> <identifiersep> filter <identifiersep> <identifier> ( <identifier> . next ( ) , entity <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> ( ) { \n \t2 synchronized ( <identifier> <identifiersep> <identifier> <identifiersep> lock ) { \n \t3 super . get <identifiersep> <identifier> ( ) . <identifier> ( ) ; \n \t3 <comment> \n <ect>
\t4 catch ( t <identifiersep> exception e ) { \n \t5 log . info ( <string_literal> , e ) ; \n \t5 exception <identifiersep> count ++ ; } \n \t4 catch ( throwable t ) { \n <ect>
\t3 if ( text != null ) \n \t3 { \n \t4 log . debug ( <string_literal> , text . length ( ) ) ; \n \t4 return text ; } \n <ect>
private string <identifier> <identifiersep> <identifier> ( request request , <identifier> db <identifiersep> <identifier> , string <identifier> <identifiersep> for ) throws io <identifiersep> exception { \n \t1 string <identifier> <identifiersep> version = get <identifiersep> <identifier> <identifiersep> version ( request . <identifier> <identifiersep> model , <identifier> <identifiersep> for ) ; \n \t1 logger . info ( <string_literal> , <identifier> <identifiersep> version ) ; \n \t1 if ( ! write <identifiersep> <identifier> <identifiersep> xml ( db <identifiersep> <identifier> , request . model <identifiersep> dir , <identifier> <identifiersep> version ) ) { \n <ect>
\t2 queue <identifiersep> <identifier> queue <identifiersep> <identifier> = null ; \n \t2 text <identifiersep> message message = null ; \n \t2 final int num <identifiersep> <identifier> ; \n \t2 if ( ( <identifier> . length < 1 ) || ( <identifier> . length > <number_literal> ) ) { \n <ect>
\t5 log . warn ( <string_literal> , <identifier> ) ; } } \n \t3 <identifier> = new <identifier> <identifiersep> <identifier> ( new output <identifiersep> stream <identifiersep> <identifier> ( new <identifier> <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( <identifier> , \n \t5 <identifier> ) ) , <identifier> <identifiersep> service . get <identifiersep> file <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> . name ( ) ) ) , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 db <identifiersep> service <identifiersep> <identifier> . put ( service <identifiersep> name , config <identifiersep> type ) ; \n \t3 db <identifiersep> service <identifiersep> version <identifiersep> <identifier> . put ( service <identifiersep> version , db <identifiersep> service <identifiersep> <identifier> ) ; \n \t3 db <identifiersep> cluster <identifiersep> service <identifiersep> version <identifiersep> <identifier> . put ( cluster <identifiersep> name , db <identifiersep> service <identifiersep> version <identifiersep> <identifier> ) ; } } } \n \t1 <comment> \n <ect>
\t1 public void close ( ) { \n \t2 try { \n \t3 this . <identifier> <identifiersep> db . <identifier> ( new <identifier> <identifiersep> options ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> db <identifiersep> exception e ) { \n <ect>
\t3 result . <identifier> = ( org . apache . <identifier> . <identifier> . client . <identifier> . thrift . thrift <identifiersep> not <identifiersep> <identifier> <identifiersep> service <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> is <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t2 long <identifier> ; \n \t2 try { \n \t3 <identifier> = <identifier> . get <identifiersep> long ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> parse <identifiersep> exception e ) { \n <ect>
\t3 task . run ( ) ; <comment> \n \t2 try { \n \t3 return <identifier> <identifiersep> <identifier> . get ( ) ; \n \t2 } catch ( interrupted <identifiersep> exception <identifier> ) { \n <ect>
\t3 if ( <identifier> ) { \n \t4 <identifier> [ ] <identifier> = <identifier> <identifiersep> entry <identifiersep> info ( key , value ) ; \n \t4 entry . set <identifiersep> <identifier> <identifiersep> nodes ( <identifier> ) ; } \n \t2 } catch ( channel <identifiersep> exception x ) { \n <ect>
\t7 string table <identifiersep> name , \n \t7 string location , \n \t7 map < string , string > <identifier> <identifiersep> <identifier> \n \t5 ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n <ect>
\t1 <identifier> <identifiersep> context . put <identifiersep> to <identifiersep> properties ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . do <identifiersep> not <identifiersep> update <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . true ) ; \n \t1 <identifier> <identifiersep> list <identifiersep> <identifier> < string , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> by <identifiersep> table = <identifier> . index ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> name <identifiersep> function ) ; \n \t1 log . debug ( <string_literal> , <identifier> <identifiersep> by <identifiersep> table . key <identifiersep> set ( ) ) ; \n \t1 if ( <identifier> <identifiersep> by <identifiersep> table . key <identifiersep> set ( ) . size ( ) < 1 ) { \n <ect>
\t2 logger . debug ( this + <string_literal> ) ; } \n \t1 return ; } \n <ect>
\t3 string output = <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> content ( template . get <identifiersep> content ( ) , template <identifiersep> <identifier> , <identifier> ) ; \n \t3 <comment> \n \t3 return <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> manager ( ) . end <identifiersep> <identifier> ( output , <identifier> ) ; \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 final <identifier> <identifier> = this . <identifier> <identifiersep> to <identifiersep> check <identifiersep> <identifier> . <identifier> ( remote <identifiersep> ip ) ; \n \t2 if ( <identifier> . find ( ) ) { \n \t3 logger . debug ( <string_literal> , remote <identifiersep> ip , this . <identifier> <identifiersep> to <identifiersep> check <identifiersep> <identifier> . <identifier> ( ) ) ; \n \t3 return true ; } \n <ect>
\t3 cmd . set <identifiersep> storage <identifiersep> ip <identifiersep> address ( <string_literal> ) ; \n \t3 cmd . set <identifiersep> storage <identifiersep> <identifier> ( <string_literal> ) ; \n \t3 cmd . set <identifiersep> storage <identifiersep> <identifier> <identifiersep> address ( <string_literal> ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t1 new <identifiersep> <identifier> . delete <identifiersep> on <identifiersep> <identifier> ( ) ; \n \t1 return new <identifiersep> <identifier> ; } \n public static void end <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dir ( file new <identifiersep> <identifier> ) throws io <identifiersep> exception { \n \t1 if ( new <identifiersep> <identifier> == null || ! new <identifiersep> <identifier> . exists ( ) ) return ; \n <ect>
\t2 try { \n \t3 transport . <identifier> <identifiersep> request ( new <identifier> <identifiersep> <identifier> <identifiersep> message ( ) , null ) ; \n \t3 <identifier> ( <string_literal> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 return ip ; } \n @ <identifier> \n public public <identifiersep> ip <identifiersep> address <identifier> ( network input ) { \n \t1 try { \n <ect>
\t6 return integer . parse <identifiersep> int ( value . string <identifiersep> value ( ) ) ; } } \n \t4 return 0 ; \n \t3 } finally { \n \t4 long response <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) - start ; \n <ect>
\t1 <identifier> <identifiersep> options <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> options <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t1 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . length > 0 ) \n \t2 <identifier> ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 { \n \t1 error <identifiersep> <identifier> = <identifier> . <identifier> ( error <identifiersep> status <identifiersep> <identifier> != null ? error <identifiersep> status <identifiersep> <identifier> : default <identifiersep> error <identifiersep> status <identifiersep> <identifier> ) ; } \n \t1 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) \n \t1 { \n <ect>
\t2 int port = url . get <identifiersep> port ( ) ; \n \t2 string path = url . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t2 string query = url . get <identifiersep> <identifier> <identifiersep> query ( ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t7 for ( int i = 1 ; i < ip <identifiersep> <identifier> . length ; i ++ ) { \n \t8 ip <identifiersep> address <identifiersep> log <identifiersep> <identifier> = ip <identifiersep> address <identifiersep> log <identifiersep> <identifier> + <string_literal> + ip <identifiersep> <identifier> [ i ] ; } } \n \t6 s <identifiersep> logger . info ( <string_literal> + ip <identifiersep> address <identifiersep> log <identifiersep> <identifier> ) ; } } \n \t3 } else { \n <ect>
\t3 <identifier> <identifiersep> config <identifiersep> model config = null ; \n \t3 if ( context . get <identifiersep> <identifier> <identifiersep> config ( ) != null && context . get <identifiersep> <identifier> <identifiersep> config ( ) . get <identifiersep> config ( ) != null ) { \n \t4 config = new <identifier> <identifiersep> config <identifiersep> model ( context . get <identifiersep> <identifier> <identifiersep> config ( ) ) ; } \n \t3 if ( config == null ) { \n <ect>
\t7 <comment> \n \t7 try { \n \t8 <identifier> <identifiersep> log . add ( <identifier> <identifiersep> log <identifiersep> header . <identifier> <identifiersep> <identifier> ( <identifier> , status , index <identifiersep> <identifier> , <identifier> <identifiersep> success ) , <identifier> <identifiersep> log <identifiersep> header . get <identifiersep> log <identifiersep> key ( ) ) ; \n \t7 } catch ( throwable e ) { \n <ect>
\t1 final boolean is <identifiersep> abstract <identifiersep> group = string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( is <identifiersep> abstract <identifiersep> as <identifiersep> string ) && boolean . value <identifiersep> of ( is <identifiersep> abstract <identifiersep> as <identifiersep> string ) ; \n \t1 if ( <identifier> <identifiersep> in <identifiersep> process . contains ( name ) ) { \n \t1 throw new <identifier> <identifiersep> group <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + name \n \t2 + <string_literal> + <identifier> <identifiersep> in <identifiersep> process ) ; } \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t7 <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> ) ; \n \t3 break ; \n \t2 case <identifier> <identifiersep> storage <identifiersep> vm <identifiersep> <identifier> <identifiersep> event <identifiersep> <identifier> . <identifier> <identifiersep> storage <identifiersep> <identifier> : \n <ect>
\t7 logger <identifiersep> <identifier> . config , <identifier> , <identifier> <identifiersep> id ) ; \n \t5 device . get <identifiersep> enabled <identifiersep> a ( ) . <identifier> <identifiersep> and <identifiersep> set ( true , false ) ; \n \t4 } else { \n \t5 <identifier> <identifiersep> config device <identifiersep> <identifier> <identifiersep> config = <identifier> <identifiersep> <identifier> . <identifier> ( device <identifiersep> config . get <identifiersep> <identifier> <identifiersep> config ( ) ) ; \n <ect>
public void <identifier> ( final <identifier> <identifiersep> client <identifier> <identifiersep> client , string <identifier> <identifiersep> id ) throws exception { \n \t1 this . <identifier> <identifiersep> client = <identifier> <identifiersep> client ; \n \t1 security <identifiersep> <identifier> = get <identifiersep> security <identifiersep> <identifier> ( ) ; \n \t1 if ( security <identifiersep> <identifier> == null || security <identifiersep> <identifier> . length == 0 ) { \n <ect>
\t2 logger . debug ( <string_literal> , value ) ; \n \t2 model <identifiersep> <identifier> . <identifier> ( value ) ; \n \t2 } ) ; \n \t1 } ) ; \n <ect>
\t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t4 <identifier> = null ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) throws exception { \n \t2 java . <identifier> . <identifier> <identifier> = new java . <identifier> . <identifier> ( ) ; \n \t2 long <identifier> = <identifier> . next <identifiersep> long ( ) ; \n \t2 <comment> \n <ect>
\t5 case <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : \n \t6 <identifier> . <identifier> <identifiersep> update ( item . get <identifiersep> name ( ) , new string <identifiersep> type ( <identifier> ) ) ; \n \t6 break ; \n \t5 default : \n <ect>
\t4 } catch ( exception e ) { \n \t5 log . error ( <string_literal> , remote <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> listener . class , \n \t7 <identifier> <identifiersep> class <identifiersep> name , e ) ; } } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 private builder add <identifiersep> service ( service service ) { \n <comment> \n \t3 add <identifiersep> location <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( service ) ; \n \t3 if ( <identifier> . contains <identifiersep> key ( service . get <identifiersep> id ( ) ) ) { \n <ect>
\t4 string <identifier> <identifiersep> name = <identifier> <identifiersep> this == null \n \t6 ? method . get <identifiersep> <identifier> <identifiersep> class ( ) . get <identifiersep> name ( ) \n \t6 : <identifier> <identifiersep> this . get <identifiersep> class ( ) . get <identifiersep> name ( ) ; \n <ect>
\t5 <comment> \n \t5 if ( <identifier> ) { \n \t6 <identifier> <identifiersep> connection . close ( ) ; \n \t5 } else { \n <ect>
\t1 this . user <identifiersep> <identifier> = check <identifiersep> not <identifiersep> null ( user <identifiersep> <identifier> , <string_literal> ) ; } \n @ <identifier> \n public node <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> < server <identifiersep> info > create <identifiersep> node <identifiersep> with <identifiersep> group <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ( string <identifier> , string name , template template ) { \n \t1 long <identifier> <identifiersep> size = ( long ) ( template . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) . get ( 0 ) . get <identifiersep> size ( ) * <number_literal> * <number_literal> * <identifier> ) ; \n <ect>
\t2 table <identifiersep> metadata <identifiersep> manager metadata <identifiersep> manager = table <identifiersep> metadata <identifiersep> manager . get <identifiersep> instance ( <identifier> <identifiersep> config ) ; \n \t2 for ( table <identifiersep> <identifier> table <identifiersep> <identifier> : <identifier> <identifiersep> metadata <identifiersep> manager . list <identifiersep> all <identifiersep> <identifier> ( null ) ) { \n \t3 table <identifiersep> <identifier> <identifier> = metadata <identifiersep> manager . get <identifiersep> table <identifiersep> <identifier> ( table <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) , target <identifiersep> <identifier> <identifiersep> name ) ; \n \t3 if ( <identifier> != null && ! <identifier> . equals ( table <identifiersep> <identifier> ) ) { \n <ect>
\t2 connection <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = get <identifiersep> connection <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . get <identifiersep> connection ( ) . <identifier> <identifiersep> <identifier> ( ( <identifier> ) <identifier> ) ; } \n \t2 catch ( throwable ex ) { \n <ect>
\t2 <identifier> . get <identifiersep> security <identifiersep> provider ( ) ) ; \n \t1 try { \n \t1 <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> . <identifier> <identifiersep> mode ) ; \n \t1 } catch ( <identifier> <identifiersep> key <identifiersep> exception e ) { \n <ect>
\t3 else if ( false \n \t5 || <identifier> . equals ( <string_literal> ) \n \t3 ) { \n \t4 if ( ! has <identifiersep> <identifier> <identifiersep> options ( ) ) { \n <ect>
<number_literal> final request <identifiersep> context context , \n <number_literal> final collection < <identifier> <identifiersep> authentication <identifiersep> provider > <identifier> , \n <number_literal> final <identifier> < string > <identifier> ) { \n \t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 for ( <identifier> r : base <identifiersep> <identifier> ) { \n \t4 total <identifiersep> <identifier> . add <identifiersep> all ( r . get <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } \n \t2 catch ( class <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> + this ) ; \n <ect>
\t2 <identifier> <identifiersep> manager . for <identifiersep> <identifier> ( <identifier> - > { \n \t3 try { \n \t4 <identifier> . get <identifiersep> <identifier> ( <identifier> . this . cluster <identifiersep> name , <identifier> . this ) ; } \n \t3 catch ( throwable t ) { \n <ect>
\t3 log . info ( <string_literal> ) ; } \n \t2 public void wait <identifiersep> for <identifiersep> start ( ) { \n \t3 log . info ( <string_literal> ) ; } \n \t2 public boolean <identifier> ( string name ) { \n <ect>
\t5 try { \n \t6 resource <identifiersep> <identifier> . <identifier> <identifiersep> resource ( <identifier> , base <identifiersep> <identifier> , user <identifiersep> <identifier> <identifiersep> context . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> . get <identifiersep> account <identifiersep> id ( ) ) ; \n \t5 } catch ( exception e ) { \n \t6 <identifier> <identifiersep> <identifier> = true ; \n <ect>
\t3 throw new load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> , ex ) ; } \n \t3 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . delete <identifiersep> <identifier> <identifiersep> configuration ( <identifier> <identifiersep> type . get <identifiersep> <identifier> <identifiersep> configuration <identifiersep> name ( ) , <identifier> . <identifier> <identifiersep> system <identifiersep> account ( ) ) ; \n \t3 } catch ( final exception ex ) { \n <ect>
\t2 if ( server == null ) { \n \t3 log . debug ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> server ( ) ; \n \t3 server . <identifier> ( ) ; \n <ect>
\t2 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> ) <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 wait . wait <identifiersep> for ( new wait . <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n <ect>
<comment> \n \t1 protected boolean check <identifiersep> <identifier> ( ) { \n \t2 if ( get <identifiersep> from <identifiersep> address ( ) == null && get <identifiersep> <identifier> <identifiersep> name ( ) == null ) { \n <ect>
\t2 throw new exception ( <string_literal> \n \t2 + <identifier> <identifiersep> client <identifiersep> port + <string_literal> + <identifier> <identifiersep> <identifier> ) ; } \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> url = get <identifiersep> <identifier> <identifiersep> connection <identifiersep> url ( <identifier> <identifiersep> client <identifiersep> port , <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> configuration <identifiersep> file <identifiersep> not <identifiersep> found <identifiersep> <identifier> ( string file <identifiersep> name ) { \n <ect>
\t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 log . warn ( <string_literal> , <identifier> ) ; \n \t3 throw <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 public void on <identifiersep> <identifier> ( string <identifier> , <identifier> <identifiersep> user user , string <identifier> <identifiersep> <identifier> , string msg ) { \n \t3 log . debug ( <string_literal> , <identifier> , user . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> mode ( string <identifier> , <identifier> <identifiersep> user user , <identifier> <identifiersep> mode <identifiersep> <identifier> mode <identifiersep> <identifier> ) { \n <ect>
\t5 catch ( grid <identifiersep> cache <identifiersep> entry <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t6 assert entry . <identifier> <identifiersep> version ( ) != null : <string_literal> + \n \t7 entry ; \n <ect>
\t3 for ( t item : <identifier> <identifiersep> <identifier> ) { \n \t4 string <identifier> <identifiersep> <identifier> <identifiersep> name = ( string ) property <identifiersep> utils . get <identifiersep> property ( item , property <identifiersep> <identifier> <identifiersep> field ) ; \n \t4 <identifier> . <identifier> <identifiersep> <identifier> ( new <identifier> ( ) . <identifier> <identifiersep> text ( <identifier> <identifiersep> <identifier> <identifiersep> name ) ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t1 assert in <identifiersep> <identifier> <identifiersep> <identifier> . contains ( <identifier> <identifiersep> <number_literal> . get <identifiersep> <identifier> ( ) ) ; \n \t1 assert in <identifiersep> <identifier> <identifiersep> <identifier> . contains ( <identifier> <identifiersep> <number_literal> . get <identifiersep> <identifier> ( ) ) ; \n \t1 <comment> \n \t1 <identifier> <identifiersep> <number_literal> . first <identifiersep> <identifier> <identifiersep> resource ( ) . <identifier> ( <identifier> <identifiersep> 1 . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t2 <comment> \n \t2 if ( <identifier> . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t3 log . error ( <string_literal> + <identifier> + <string_literal> ) ; \n \t2 } else { \n <ect>
\t3 return <identifier> <identifiersep> transient <identifiersep> <identifier> ; } \n \t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t2 log . debug ( <string_literal> + path <identifiersep> name ) ; \n \t2 if ( new file ( path <identifiersep> name ) . exists ( ) ) { \n \t3 return path <identifiersep> name ; \n \t2 } else { \n <ect>
\t7 <comment> \n \t7 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> run ) { \n \t8 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> run = false ; \n \t8 if ( <identifier> <identifiersep> log . should <identifiersep> info ( ) ) \n <ect>
\t1 public void <identifier> ( long <identifier> <identifiersep> id ) { \n \t2 try { \n \t3 options . do <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 break ; \n \t2 case <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> function <identifiersep> <identifier> <identifiersep> <identifier> : <comment> \n <number_literal> <comment> \n \t3 <comment> \n <ect>
\t3 out . <identifier> ( ) ; \n \t3 byte [ ] <identifier> <identifiersep> data = <identifier> . to <identifiersep> byte <identifiersep> array ( ) ; \n \t3 return <identifier> <identifiersep> data ; } \n \t2 catch ( io <identifiersep> exception e ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> ) ; } \n \t2 final check <identifiersep> network <identifiersep> command <identifier> <identifiersep> cmd = new check <identifiersep> network <identifiersep> command ( network <identifiersep> info <identifiersep> list ) ; \n \t2 final check <identifiersep> network <identifiersep> answer answer = ( check <identifiersep> network <identifiersep> answer ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> send ( host <identifiersep> id , <identifier> <identifiersep> cmd ) ; \n \t2 if ( answer == null ) { \n <ect>
\t5 return <number_literal> ; \n \t4 } else { \n \t5 s <identifiersep> logger . info ( <string_literal> + response <identifiersep> code ) ; \n \t5 string volume <identifiersep> id = values . get ( <string_literal> ) ; \n <ect>
\t5 try { \n \t6 the <identifiersep> channel . channel . <identifier> <identifiersep> <identifier> ( false ) ; \n \t6 <comment> \n \t5 } catch ( exception e ) { \n <ect>
\t3 <identifier> . trace <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> node , <identifier> <identifiersep> from , <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t3 set ( <identifier> ) ; \n \t3 return ; } \n \t2 <comment> \n <ect>
\t5 } finally { \n \t6 try { \n \t7 is . close ( ) ; \n \t6 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> file ( <identifier> <identifiersep> i <identifiersep> stream , <identifier> <identifiersep> o <identifiersep> stream , <identifier> , <identifier> <identifiersep> files ) ; \n \t2 file <identifiersep> input <identifiersep> stream <identifier> <identifiersep> result <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( <identifier> + <string_literal> ) ; \n \t2 <identifier> <identifiersep> ex <identifiersep> result <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( <identifier> + <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> ex <identifiersep> result <identifiersep> stream , <identifier> <identifiersep> result <identifiersep> stream ) ; \n <ect>
\t1 { \n \t2 try { \n \t3 return get <identifiersep> <identifier> <identifiersep> stream ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , max <identifiersep> <identifier> , start <identifiersep> <identifier> , this . context ) ; \n \t2 } catch ( <identifier> <identifiersep> stream <identifiersep> exception ex ) { \n <ect>
\t2 try { \n \t3 return storage . get <identifiersep> entry ( <identifier> <identifiersep> cache <identifiersep> key ) ; \n \t2 } catch ( final resource <identifiersep> io <identifiersep> exception ex ) { \n <ect>
\t2 log . info ( <string_literal> , \n \t4 <identifier> . get <identifiersep> name ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> . class ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t2 <identifier> <identifiersep> queue . <identifier> ( ) ; } \n \t1 <identifier> <identifiersep> session <identifiersep> state . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> mode ( false ) ; \n \t1 if ( <identifier> <identifiersep> session <identifiersep> state . is <identifiersep> default ( ) && \n \t2 <identifier> <identifiersep> session <identifiersep> state instanceof <identifier> <identifiersep> session <identifiersep> pool <identifiersep> session ) { \n <ect>
\t3 log . debug ( <string_literal> \n \t5 + <string_literal> , task <identifiersep> result , next <identifiersep> <identifier> <identifiersep> for <identifiersep> result <identifiersep> <identifier> ( ) ) ; \n \t3 next <identifiersep> <identifier> <identifiersep> for <identifiersep> result <identifiersep> <identifier> ( ) . set <identifiersep> result ( task <identifiersep> result ) ; \n \t3 next <identifiersep> <identifier> <identifiersep> response = next <identifiersep> <identifier> <identifiersep> for <identifiersep> result <identifiersep> <identifier> ( ) . <identifier> <identifiersep> action ( ) ; } \n <ect>
\t3 int status <identifiersep> code = client . execute <identifiersep> method ( <identifier> <identifiersep> method ) ; \n \t3 if ( status <identifiersep> code == http <identifiersep> status . <identifier> <identifiersep> no <identifiersep> content || status <identifiersep> code == http <identifiersep> status . <identifier> <identifiersep> <identifier> ) { \n \t4 return true ; } \n \t3 if ( status <identifiersep> code != http <identifiersep> status . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 log . debug ( <string_literal> , new object [ ] { <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> consumer <identifiersep> id ( ) , <identifier> . get <identifiersep> consumer <identifiersep> info ( ) . get <identifiersep> <identifier> <identifiersep> size ( ) } ) ; \n \t3 try { \n \t4 <identifier> ( consumer <identifiersep> exchange . get <identifiersep> connection <identifiersep> context ( ) , <identifier> . get <identifiersep> destination ( ) , false ) . <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 int read = <identifier> <identifiersep> <identifier> . read ( <identifier> ) ; \n \t4 if ( read != <identifier> <identifiersep> size ) { \n \t5 <identifier> <identifiersep> log . error ( <string_literal> + <identifier> <identifiersep> size + <string_literal> + read ) ; \n \t5 return ; } \n <ect>
\t6 continue ; } \n \t5 if ( key . is <identifiersep> <identifier> ( ) || key . is <identifiersep> <identifier> ( ) ) { \n \t6 handle <identifiersep> io ( key ) ; \n \t5 } else { \n <ect>
\t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t1 throw new parse <identifiersep> exception ( <identifier> . <identifier> ) ; } \n \t1 if ( <identifier> . get <identifiersep> <identifier> ( ) . size ( ) == 0 && <identifier> . <identifier> . size ( ) == 0 ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = true \n \t2 is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = true \n \t2 break \n \t1 else : \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 <identifier> <identifiersep> <identifier> . on <identifiersep> <identifier> ( exchange ) ; } \n \t2 } catch ( throwable e ) { \n \t3 <comment> \n <ect>
\t3 if ( provider <identifiersep> class != null ) { \n \t4 resource <identifiersep> provider = provider <identifiersep> class . new <identifiersep> instance ( ) ; \n \t4 resource <identifiersep> <identifier> . add ( resource <identifiersep> provider ) ; \n \t3 } else { \n <ect>
\t2 current <identifiersep> <identifier> = <identifier> ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) \n \t2 <identifier> ( <identifier> ( current <identifiersep> <identifier> . get ) ) } } \n } catch { \n \t1 case e : exception = > \n <ect>
\t4 logger . trace ( <string_literal> , get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t4 return ; } \n \t3 logger . debug ( <string_literal> ) ; \n \t3 if ( ! this . <identifier> <identifiersep> <identifier> . <identifier> ( ) ) { \n <ect>
\t1 @ <identifier> \n \t1 public void shutdown ( ) { \n \t2 log . info ( <string_literal> + id <identifiersep> <identifier> ) ; \n \t2 if ( ! task <identifiersep> status . is <identifiersep> shutdown ( ) ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void execute ( options <identifiersep> <identifier> options <identifiersep> <identifier> ) throws exception { \n \t2 logger . info ( <string_literal> + options <identifiersep> <identifier> . get <identifiersep> options <identifiersep> as <identifiersep> string ( ) + <string_literal> ) ; \n \t2 logger . info ( <string_literal> + options <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <identifier> <identifiersep> delete ) + <string_literal> ) ; \n <ect>
\t4 delete <identifiersep> pool <identifiersep> <identifier> ( id ) ; \n \t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> dao . remove <identifiersep> by ( <identifier> . <identifier> <identifiersep> type <identifiersep> storage <identifiersep> <identifier> , null , null , null , id ) ; \n \t4 <identifier> . <identifier> ( ) ; \n <ect>
\t1 protected <identifier> get <identifiersep> url <identifiersep> <identifier> ( ) { \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( url <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 string <identifier> = ( string ) parse ( url <identifiersep> <identifier> <identifiersep> <identifier> , string . class ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t3 <comment> \n \t3 logger . warn ( <string_literal> ) ; \n \t3 logger . warn ( <string_literal> ) ; \n \t3 logger . warn ( <string_literal> ) ; \n <ect>
\t2 socket . <identifier> = function ( ) { \n \t2 log . debug ( <identifier> <identifiersep> socket connection <identifier> ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 if ( <identifier> ) { \n <ect>
\t2 if ( <identifier> . is <identifiersep> empty ( nodes ) ) \n \t3 return new grid <identifiersep> cache <identifiersep> query <identifiersep> error <identifiersep> <identifier> < > ( <identifier> . <identifier> <identifiersep> context ( ) , \n \t4 new grid <identifiersep> empty <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> . <identifier> ( ) ) ) ; \n <ect>
\t3 break ; } } \n \t1 for ( resource <identifier> : <identifier> ) { \n \t2 <identifier> <identifiersep> resource ( <identifier> , property <identifiersep> <identifier> , <identifier> <identifiersep> host <identifiersep> <identifier> <identifiersep> map , <identifier> <identifiersep> <identifier> <identifiersep> map ) ; } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . start ( ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 consumer . start ( ) ; \n \t2 int <identifier> <identifiersep> <identifier> <identifiersep> count = 0 ; \n <ect>
\t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> application <identifiersep> id ( ) + <string_literal> + <identifier> <identifiersep> <identifier> \n \t3 . get <identifiersep> <identifier> <identifiersep> application <identifiersep> state ( ) + <string_literal> + <identifier> <identifiersep> <identifier> \n \t3 . get <identifiersep> final <identifiersep> application <identifiersep> status ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> time ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> application <identifiersep> state ( ) == <identifier> <identifiersep> application <identifiersep> state . failed ) { \n <ect>
\t3 byte msg [ ] = new byte [ <number_literal> ] ; \n \t3 integer <identifier> = ( integer ) <identifier> . get ( i ) ; \n \t3 system . <identifier> ( <identifier> , <identifier> . int <identifiersep> value ( ) * <number_literal> , msg , 0 , <number_literal> ) ; \n \t3 in . message <identifiersep> <identifier> ( <identifier> . int <identifiersep> value ( ) , new byte <identifiersep> array ( msg ) ) ; \n <ect>
\t1 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n \t1 logger . error ( <string_literal> , e ) ; \n \t1 <identifier> . set <identifiersep> error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t1 } catch ( property <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 return null ; } \n \t2 final string entity <identifiersep> <identifier> = org . <identifier> . <identifier> . string <identifiersep> utils . collection <identifiersep> to <identifiersep> <identifier> <identifiersep> string ( entity <identifiersep> id <identifiersep> list , <string_literal> ) ; \n \t2 service . set <identifiersep> metadata <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> filter . <identifier> . <identifier> . name ( ) ) ; \n \t2 service . set <identifiersep> metadata <identifiersep> <identifier> <identifiersep> <identifier> ( entity <identifiersep> <identifier> ) ; \n <ect>
\t4 try { \n \t5 log . info ( <string_literal> , this . get <identifiersep> name ( ) ) ; \n \t5 this . <identifier> <identifiersep> start ( ) ; \n \t4 } catch ( exception start <identifiersep> ex ) { \n <ect>
\t2 <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( new class [ ] { } ) ; \n \t2 <identifier> = ( i <identifiersep> <identifier> <identifiersep> request <identifiersep> context <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> <identifiersep> <identifier> . new <identifiersep> instance ( new object [ ] { } ) ; \n \t1 } catch ( exception e ) { \n \t2 throw new runtime <identifiersep> exception ( e ) ; } } \n <ect>
\t4 vm <identifiersep> map = vm . get <identifiersep> all <identifiersep> <identifier> ( conn ) ; <comment> \n \t4 <comment> \n \t4 break ; \n \t3 } catch ( final throwable e ) { \n <ect>
\t1 @ <identifier> \n \t1 protected boolean is <identifiersep> response <identifiersep> <identifier> ( <identifier> <identifiersep> message response ) { \n \t2 <comment> \n \t2 if ( response . get <identifiersep> command ( ) != command <identifiersep> code ) { \n <ect>
\t1 private final i <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> listener <identifier> <identifiersep> to <identifiersep> target <identifiersep> listener = new i <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> listener ( ) \n \t1 { \n \t2 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> event event ) \n \t2 { \n <ect>
\t1 final dir <identifiersep> context <identifiersep> <identifier> <identifier> = ( dir <identifiersep> context <identifiersep> <identifier> ) <identifier> ; \n \t1 final string group <identifiersep> name <identifiersep> attribute = <identifier> . get <identifiersep> string <identifiersep> attribute ( <identifier> <identifiersep> server <identifiersep> properties . get <identifiersep> group <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t1 boolean out <identifiersep> of <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> object <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> from <identifiersep> base <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> server <identifiersep> properties . get <identifiersep> base <identifiersep> <identifier> ( ) ) ; \n \t1 if ( out <identifiersep> of <identifiersep> <identifier> ) { \n <ect>
\t8 logger . debug ( string . format ( <string_literal> , command . get <identifiersep> <identifier> <identifiersep> cmd ( ) ) + <string_literal> \n \t10 + <identifier> <identifiersep> data ( <identifier> <identifiersep> data ) ) ; \n \t8 send ( <identifier> ) ; \n \t8 return <identifier> <identifiersep> data ; } \n <ect>
\t2 key <identifiersep> info <identifiersep> provider <identifiersep> list . add ( new <identifier> <identifiersep> <identifier> <identifiersep> provider ( ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> resource <identifiersep> location ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifier> = build <identifiersep> <identifier> <identifiersep> for <identifiersep> metadata <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> resource <identifiersep> location ) ; \n \t2 logger . info ( <string_literal> , <identifier> <identifiersep> resource <identifiersep> location ) ; \n <ect>
\t3 and not <identifier> . path <identifiersep> exists ( <string_literal> ) and <identifier> . path <identifiersep> exists ( <string_literal> ) : \n \t1 <identifier> ( <string_literal> , to = <string_literal> ) \n \t1 <identifier> <identifiersep> <identifier> = conf <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n \t1 if 0 == <identifier> ( <identifier> <identifiersep> <identifier> ) : \n <ect>
public log <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> client ( <identifier> <identifiersep> <identifier> <identifiersep> config <identifier> <identifiersep> <identifier> <identifiersep> config , log <identifiersep> <identifier> <identifiersep> security <identifiersep> config security <identifiersep> config ) { \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> string = <identifier> <identifiersep> <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> string ( ) ; \n \t1 if ( ! string <identifiersep> utils . is <identifiersep> blank ( <identifier> <identifiersep> <identifier> <identifiersep> string ) ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> string = <identifier> <identifiersep> <identifier> <identifiersep> string . <identifier> ( ) ; \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t5 case <identifier> <identifiersep> <identifier> : \n \t6 <identifier> . <identifier> <identifiersep> update ( item . get <identifiersep> name ( ) , ( state == 1 ) ? on <identifiersep> <identifier> <identifiersep> type . on : on <identifiersep> <identifier> <identifiersep> type . <identifier> ) ; \n \t6 break ; \n \t5 default : \n <ect>
\t3 if ( <identifier> <identifiersep> list . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t4 map < integer , short > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> list . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t4 for ( integer <identifier> : <identifier> <identifiersep> <identifier> . key <identifiersep> set ( ) ) { \n \t5 logger . debug ( <string_literal> , <identifier> , <identifier> <identifiersep> <identifier> . get ( <identifier> ) ) ; \n <ect>
\t3 log . error ( <string_literal> + <identifier> ) ; \n \t3 return false ; } \n \t2 byte [ ] <identifier> = <identifier> . <identifier> ( <identifier> [ 1 ] ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 logger . debug ( <string_literal> + <identifier> . get <identifiersep> integer <identifiersep> value ( <identifier> <identifiersep> name <identifiersep> <identifier> , null ) ) ; \n \t2 logger . debug ( <string_literal> + <identifier> . get <identifiersep> string <identifiersep> value ( <identifier> <identifiersep> name <identifiersep> first <identifiersep> name , null ) ) ; \n \t2 logger . debug ( <string_literal> + <identifier> . get <identifiersep> string <identifiersep> value ( <identifier> <identifiersep> name <identifiersep> last <identifiersep> name , null ) ) ; } \n \t1 } catch ( connection <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public static <identifier> < string , object > <identifier> <identifiersep> principal <identifiersep> attributes <identifiersep> list <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map ( final list < string > list ) { \n \t2 final <identifier> < string , object > <identifier> = array <identifiersep> list <identifiersep> <identifier> . create ( ) ; \n \t2 if ( list . is <identifiersep> empty ( ) ) { \n <ect>
\t4 . with <identifiersep> <identifier> <identifiersep> key <identifiersep> values ( item ) . with <identifiersep> <identifier> <identifiersep> index <identifiersep> <identifier> ( filter . get <identifiersep> <identifier> ( ) == <identifier> . <identifier> ) \n \t4 . with <identifiersep> <identifier> ( filter . get <identifiersep> <identifier> <identifiersep> size ( ) ) ; \n \t2 <identifier> time <identifiersep> filter = <identifier> <identifiersep> add <identifiersep> time <identifiersep> filter ( query <identifiersep> <identifier> , filter ) ; \n \t2 <identifier> <identifiersep> add <identifiersep> state <identifiersep> filter ( filter , query <identifiersep> <identifier> ) ; \n <ect>
\t5 else { \n \t6 update <identifiersep> <identifier> <identifiersep> action ( action ) ; \n \t6 log . debug ( <string_literal> , \n \t10 action . get <identifiersep> <identifier> <identifiersep> action <identifiersep> id ( ) , action . get <identifiersep> status ( ) , action . get <identifiersep> <identifier> ( ) ) ; } } } \n <ect>
public static bytes <identifiersep> input from ( byte [ ] in ) { \n \t1 log . debug ( <string_literal> , in . length ) ; \n \t1 return new byte <identifiersep> array <identifiersep> bytes <identifiersep> input ( in , 0 , in . length ) ; } \n public static bytes <identifiersep> input from ( byte [ ] in , int <identifier> , int length ) { \n <ect>
\t2 <comment> \n \t2 object <identifiersep> <identifier> . not <identifiersep> null ( <identifier> , <string_literal> ) ; \n \t2 final long id = <identifier> . get <identifiersep> id ( ) ; \n \t2 if ( id == null ) { \n <ect>
\t3 for ( <identifier> <identifiersep> method <identifier> <identifiersep> method : <identifier> <identifiersep> class . get <identifiersep> <identifier> ( ) ) { \n \t4 if ( ! <identifier> <identifiersep> method . is <identifiersep> <identifier> ( ) ) { \n \t5 continue ; } \n \t4 if ( is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 <comment> \n \t4 local <identifiersep> state . put ( <identifier> . <identifier> <identifiersep> local <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> version , <identifier> <identifiersep> version ) ; \n \t4 local <identifiersep> state . put ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> status == service <identifiersep> status . <identifier> ) { \n \t4 if ( service <identifiersep> <identifier> . is <identifiersep> <identifier> ( <identifier> . get <identifiersep> consumer ( ) ) ) { \n \t5 <identifier> <identifiersep> or <identifiersep> start <identifiersep> consumer ( <identifier> . get <identifiersep> consumer ( ) ) ; \n \t4 } else { \n <ect>
\t2 logger . info ( <string_literal> + ( config . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ? <string_literal> : <string_literal> ) ) ; \n \t2 logger . info ( <string_literal> + config . get <identifiersep> <identifier> <identifiersep> size ( ) ) ; \n \t2 logger . info ( <string_literal> + config . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 logger . info ( <string_literal> + config . get <identifiersep> socket <identifiersep> write <identifiersep> timeout ( ) ) ; \n <ect>
\t4 return ; } \n \t3 if ( logger . is <identifiersep> <identifier> ( level . info ) ) { \n \t4 string type = <identifier> instanceof <identifier> <identifiersep> info ? <string_literal> : \n \t5 <identifier> instanceof <identifier> <identifiersep> type <identifiersep> info ? <string_literal> : <string_literal> ; \n <ect>
\t1 } else { \n \t2 log . info ( <string_literal> ) ; } \n \t1 return <identifier> <identifiersep> <identifier> ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> ) { \n \t3 <comment> \n \t3 for ( <identifier> <identifiersep> info <identifier> : <identifier> ) { \n \t4 <identifier> . remove ( <identifier> ) ; \n <ect>
\t1 test <identifiersep> result test <identifiersep> result = test <identifiersep> <identifier> . get ( x ) ; \n \t1 log . info ( string . format ( <string_literal> , ( int ) test <identifiersep> result . get <identifiersep> <identifier> ( ) ) ) ; \n \t1 log . info ( string . format ( <string_literal> , <identifier> <identifiersep> <identifier> [ x ] , number <identifiersep> of <identifiersep> <identifier> , \n \t2 test <identifiersep> result . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> count ( ) ) ) ; \n <ect>
\t2 <identifier> . add ( <string_literal> , get <identifiersep> output ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 string <identifiersep> builder <identifier> = new string <identifiersep> builder ( ) ; \n \t2 string <identifier> <identifiersep> <identifier> = <string_literal> ; \n \t2 collection < <identifier> > <identifier> = <identifier> . <identifier> ( get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t1 private final <identifier> <identifiersep> long client <identifiersep> handle <identifiersep> <identifier> = new <identifier> <identifiersep> long ( 0 ) ; \n \t1 private final class <identifier> <identifiersep> listener <identifiersep> <identifier> implements <identifier> <identifiersep> listener { \n \t2 @ <identifier> \n \t2 public void on <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> failed ( final <identifier> <identifiersep> <identifier> <identifier> , final status <identifiersep> code status <identifiersep> code ) { \n <ect>
\t2 final message < ? > message <identifiersep> from <identifiersep> <identifier> = message <identifiersep> store . <identifier> <identifiersep> message <identifiersep> from <identifiersep> group ( <identifier> ) ; \n \t2 final message < ? > message <identifiersep> from <identifiersep> <identifier> = message <identifiersep> store . <identifier> <identifiersep> message <identifiersep> from <identifiersep> group ( <identifier> ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( message <identifiersep> from <identifiersep> <identifier> ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( message <identifiersep> from <identifiersep> <identifier> ) ; \n <ect>
\t4 output . close ( ) ; \n \t4 <identifier> . close ( ) ; \n \t4 socket . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 if <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> enabled : \n \t2 url = <string_literal> . format ( <identifier> <identifiersep> <identifier> <identifiersep> host , <identifier> . <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> port ) \n \t1 else : \n \t2 url = <string_literal> . format ( <identifier> <identifiersep> <identifier> <identifiersep> host , <identifier> . <identifier> <identifiersep> node <identifiersep> port ) \n <ect>
\t2 string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t2 while ( <identifier> . <identifier> ( ) ) { \n \t3 <identifier> . <identifier> ( <identifier> . read <identifiersep> line ( ) ) ; } \n \t2 if ( log . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t2 } finally { \n \t3 if ( is . <identifier> ( ) > 0 ) { \n \t4 try { \n <ect>
\t5 logger . debug ( <string_literal> , <identifier> ) ; \n \t5 to <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> ) ; } } \n \t3 for ( x <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : current <identifiersep> <identifier> ) { \n \t4 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) == null ) { \n <ect>
\t3 return <identifier> . size ( ) == <identifier> <identifiersep> count ? grid <identifiersep> <identifier> <identifiersep> job <identifiersep> result <identifiersep> policy . <identifier> : grid <identifiersep> <identifier> <identifiersep> job <identifiersep> result <identifiersep> policy . wait ; } \n \t2 <comment> \n \t2 @ <identifier> public integer <identifier> ( list < grid <identifiersep> <identifier> <identifiersep> job <identifiersep> result > <identifier> ) throws grid <identifiersep> exception { \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> + id + <string_literal> ) ; \n \t3 return false ; } \n \t2 <identifier> <identifiersep> vo <identifier> = find <identifiersep> by <identifiersep> id ( id ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 try { \n \t3 class . for <identifiersep> name ( <identifier> <identifiersep> <identifier> ) ; \n \t3 return true ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 do <identifiersep> send ( msg ) ; \n \t3 } catch ( <identifier> <identifiersep> message <identifiersep> exception <identifier> ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
<comment> \n \t1 protected map < string , list < object > > <identifier> <identifiersep> <identifier> <identifiersep> attributes <identifiersep> to <identifiersep> principal <identifiersep> attributes ( final string id ) { \n \t2 final i <identifiersep> <identifier> <identifiersep> attributes <identifier> = get <identifiersep> attribute <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( id ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
<comment> \n \t2 void <identifier> ( ) throws io <identifiersep> exception { \n \t3 if ( <identifier> == null || ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 <comment> \n \t5 thread . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t5 <identifier> . create ( <identifier> + current , <identifier> , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , create <identifiersep> mode . <identifier> ) ; } \n \t3 } catch ( throwable t ) { \n <ect>
<comment> \n \t2 protected object <identifier> <identifiersep> property <identifiersep> list <identifiersep> with <identifiersep> stream ( input <identifiersep> stream is ) throws io <identifiersep> exception { \n \t3 if ( is == null ) { \n <ect>
\t1 if ( state != state . <identifier> ) \n \t1 { \n \t1 <identifier> . on <identifiersep> error ( new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + state ) ) ; \n \t1 return ; } \n <ect>
\t3 return ; } \n \t2 try { \n \t3 status = <identifier> <identifiersep> <identifier> . update <identifiersep> <identifier> <identifiersep> volume <identifiersep> size ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> . new <identifiersep> size ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( m , <identifier> , <identifier> <identifiersep> id ) ; \n \t2 } catch ( <identifier> <identifiersep> message <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) { \n \t4 <identifier> <identifiersep> log . warn ( <string_literal> , <identifier> ) ; \n <ect>
\t2 <identifier> <identifiersep> config . <identifier> . set ( <identifier> . get <identifiersep> <identifier> . to <identifiersep> int ) \n \t2 <identifier> <identifiersep> config . <identifier> . set ( <identifier> . get <identifiersep> <identifier> . to <identifiersep> int ) } \n \t1 } catch { \n \t1 case e : exception = > \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> max <identifiersep> <identifier> > static <identifiersep> max ) { <comment> \n \t3 <comment> \n <ect>
\t5 long t <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t5 while ( i ++ < send <identifiersep> count ) { \n \t6 <identifier> . send ( session . create <identifiersep> text <identifiersep> message ( <string_literal> ) ) ; \n \t6 if ( <identifier> == 0 ) { \n <ect>
\t3 final <identifiersep> <identifier> = get <identifiersep> <identifier> ( ) ; \n \t3 <identifier> ( ) ; \n \t3 <comment> \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 <identifier> <identifiersep> name . <identifier> { string <identifier> - > \n \t2 log . info ( <string_literal> ) ; \n \t2 sql ( { sql sql - > \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 <identifier> <identifiersep> utils . update <identifiersep> <identifier> <identifiersep> task <identifiersep> timeout ( <identifier> <identifiersep> data , <identifier> <identifiersep> id ) ; \n <ect>
\t3 <identifier> . <identifier> = true ; \n \t3 try { \n \t4 time <identifiersep> unit . <identifier> . <identifier> ( <number_literal> ) ; \n \t3 } catch ( exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 list < string > <identifier> ; \n \t2 try { \n \t3 <identifier> = files . read <identifiersep> all <identifiersep> <identifier> ( source <identifiersep> file <identifiersep> <identifier> <identifiersep> error ( ) ) ; } \n \t2 catch ( io <identifiersep> exception e ) { \n <ect>
<comment> \n public collection < string > list ( ) { \n \t1 return <identifier> . <identifier> <identifiersep> collection ( <identifier> <identifiersep> <identifier> ) ; } \n public void <identifier> ( ) { \n <ect>
\t4 string name = <identifier> . get <identifiersep> string ( <string_literal> ) . to <identifiersep> <identifier> <identifiersep> case ( ) ; \n \t4 int size = <identifier> . get <identifiersep> int ( <string_literal> ) ; \n \t4 data <identifiersep> type result = db . <identifier> ( ) . get <identifiersep> data <identifiersep> type ( type , name , size ) ; \n \t4 if ( result == null ) { \n <ect>
\t4 <identifier> . service <identifiersep> execution <identifiersep> handler ( ) \n \t3 ) ; \n \t3 <identifier> <identifiersep> resource <identifiersep> <identifier> . <identifier> ( <identifier> . to <identifiersep> array ( new <identifier> <identifiersep> resource <identifiersep> <identifier> [ <identifier> . size ( ) ] ) ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t1 public void on <identifiersep> <identifier> <identifiersep> <identifier> ( final <identifier> in <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t1 { \n \t2 { \n <ect>
\t1 final string <identifier> <identifiersep> value = properties . get <identifiersep> property ( <identifier> <identifiersep> name ) ; \n \t1 if ( ! ignore <identifiersep> <identifier> <identifiersep> <identifier> && <identifier> <identifiersep> value == null ) { \n \t1 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> name + <string_literal> ) ; } \n \t1 final string result = <identifier> <identifiersep> value == null ? string <identifiersep> utils . empty : <identifier> <identifiersep> value ; \n <ect>
\t3 { \n \t4 continue ; } \n \t3 if ( ! <identifier> . is <identifiersep> static ( field . get <identifiersep> <identifier> ( ) ) ) \n \t3 { \n <ect>
\t2 <identifier> ( ) ; } } \n \t1 log . debug ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> instance thread <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> instance ( process <identifiersep> instance <identifiersep> id , <identifier> <identifiersep> instance <identifiersep> id ) ; \n \t1 thread <identifiersep> <identifier> . start <identifiersep> and <identifiersep> wait <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> is <identifiersep> <identifier> ( ) ; \n <ect>
\t3 throw new configuration <identifiersep> exception ( <string_literal> , <string_literal> , ex ) ; } \n \t2 try { \n \t3 <identifier> . check <identifiersep> <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 check <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 object = <identifier> <identifiersep> <identifier> . get <identifiersep> first <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> version ( <identifier> , null , null , <number_literal> , get <identifiersep> handle . default <identifiersep> <identifier> ( ) , get <identifiersep> handle ) ; \n \t3 check <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) - check <identifiersep> time ; \n \t3 <identifier> . check <identifiersep> error ( ) ; \n <ect>
\t3 return ; } \n \t2 if ( time <identifiersep> <identifier> < 0 - max <identifiersep> request <identifiersep> <identifier> ) { \n \t3 <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . add <identifiersep> <identifier> <identifiersep> data ( <string_literal> , 1 ) ; \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 <identifier> <identifiersep> <identifier> . remove <identifiersep> all ( <identifier> . get <identifiersep> transaction <identifiersep> id ( ) ) ; \n \t3 } else { \n \t3 <identifier> <identifiersep> <identifier> . remove <identifiersep> all ( <identifier> . get <identifiersep> transaction <identifiersep> id ( ) ) ; } } } } \n \t1 } catch ( exception e ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 map . entry < ? , ? > <identifier> = ( map . entry < ? , ? > ) it . next ( ) ; \n \t4 string key = ( string ) <identifier> . get <identifiersep> key ( ) ; \n \t4 string value = ( string ) <identifier> . get <identifiersep> value ( ) ; \n \t4 if ( value == null ) { \n <ect>
\t2 assert <identifiersep> equals ( 0 , cache . get <identifiersep> <identifier> <identifiersep> cache ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> max <identifiersep> total <identifiersep> <identifier> ( ) ) ; \n \t2 assert <identifiersep> equals ( 0 , cache . get <identifiersep> cache <identifiersep> <identifier> ( ) . get <identifiersep> max <identifiersep> total <identifiersep> <identifier> ( ) ) ; \n \t2 cache . <identifier> ( id <identifiersep> <identifier> + 0 ) ; \n \t2 cache . close ( ) ; \n <ect>
\t2 set < string > <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( application <identifiersep> context . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 for ( string <identifier> : <identifier> ) { \n \t3 <identifier> . add <identifiersep> all ( application <identifiersep> context . get <identifiersep> <identifier> ( <identifier> ) ) ; } \n \t2 if ( <identifier> . contains ( null ) ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 message message = <identifier> . <identifier> ( <number_literal> ) ; \n \t2 <identifier> . close ( ) ; \n \t2 connection . close ( ) ; \n <ect>
\t1 <identifier> <identifiersep> type <identifier> <identifiersep> type ; \n \t1 try { \n \t2 <identifier> <identifiersep> type = <identifier> <identifiersep> type . value <identifiersep> of ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t1 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t1 # get all <identifier> <identifier> . \n \t1 <identifier> <identifiersep> queue <identifiersep> <identifier> = self . get <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> properties ) \n \t1 self . logger . info ( <string_literal> . format ( <identifier> <identifiersep> queue <identifiersep> <identifier> ) ) \n \t1 if <identifier> ( <identifier> <identifiersep> queue <identifiersep> <identifier> ) == 0 : \n <ect>
\t4 string host = string <identifiersep> url . <identifier> ( 0 , port <identifiersep> <identifier> ) ; \n \t4 int port = integer . value <identifiersep> of ( string <identifiersep> url . <identifier> ( port <identifiersep> <identifier> + 1 ) ) ; \n \t4 <identifier> . add ( new http <identifiersep> host ( host , port , get <identifiersep> <identifier> ( ) ) ) ; } \n \t3 cluster <identifiersep> <identifier> = <identifier> <identifiersep> list ( <identifier> ) ; \n <ect>
\t4 if ( <identifier> > <identifier> <identifiersep> <identifier> ) { \n \t5 <comment> \n \t5 <identifier> <identifiersep> state = <identifier> <identifiersep> event <identifiersep> state . <identifier> ; \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> info ( ) ) \n <ect>
\t1 do { \n \t1 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) != null ) { \n \t2 for ( string <identifier> <identifiersep> name : <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 } else { \n \t4 logger . warn ( <string_literal> ) ; \n \t4 this . default <identifiersep> transaction <identifiersep> <identifier> <identifiersep> value = - 1 ; } } \n \t2 if ( this . max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < 1 ) { \n <ect>
\t3 if ( debug ) logger . info ( <string_literal> , entry . get <identifiersep> key ( ) ) ; \n \t3 try { \n \t4 entry . get <identifiersep> value ( ) . write ( new <identifier> ( <identifier> ) ) ; \n \t3 } catch ( exception ex ) { \n <ect>
<comment> \n \t1 private void <identifier> <identifiersep> xml ( string xml <identifiersep> content ) throws <identifier> <identifiersep> job <identifiersep> exception { \n \t2 <identifier> . xml . <identifier> . <identifier> <identifier> = <identifier> . get ( ) . get ( <identifier> <identifiersep> service . class ) . get <identifiersep> <identifier> ( <identifier> <identifiersep> name . <identifier> ) ; \n \t2 <identifier> <identifier> = <identifier> . new <identifiersep> <identifier> ( ) ; \n <ect>
\t4 map < object , boolean > new <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( <identifier> , is <identifiersep> <identifier> <identifiersep> event ) ; \n \t4 <comment> \n \t4 <comment> \n \t4 <identifier> = new <identifiersep> <identifier> ; } \n <ect>
\t1 return ; } \n \t1 log . info ( <string_literal> ) ; \n \t1 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> conf . get <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t2 conf , <identifier> <identifiersep> conf . conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 public void <identifier> ( ) { \n \t3 if ( ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t4 long <identifier> = utils . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time <identifiersep> <identifier> ; \n \t4 <identifier> . this . add <identifiersep> <identifier> <identifiersep> time <identifiersep> data ( <identifier> ) ; \n <ect>
\t5 system . <identifier> . <identifier> ( <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> + <identifier> + <string_literal> ) ; \n \t4 <comment> \n \t4 } else if ( e . new <identifiersep> uri != null ) { \n \t5 <identifier> . delete ( ) ; \n <ect>
\t8 attribute . get <identifiersep> node <identifiersep> name ( ) ) ; } } } \n \t2 } catch ( x <identifiersep> path <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 logger . warn ( <string_literal> , e . get <identifiersep> message ( ) , e ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 field . set ( object , value ) ; } \n \t1 @ <identifier> \n \t1 public object method <identifiersep> value ( object object , method method ) throws illegal <identifiersep> argument <identifiersep> exception , illegal <identifiersep> access <identifiersep> exception , \n \t1 <identifier> <identifiersep> target <identifiersep> exception { \n <ect>
\t7 || ( ! <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> ( ) && <identifier> . get <identifiersep> <identifier> ( ) != null && <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . is <identifiersep> in <identifiersep> <identifier> ( ) ) ) { \n \t6 <identifier> < user > user = user <identifiersep> manager . instance . get <identifiersep> user ( user <identifiersep> <identifier> <identifiersep> entry . get <identifiersep> key ( ) ) ; \n \t6 if ( ! user . is <identifiersep> <identifier> ( ) || ! user . get ( ) . is <identifiersep> <identifier> ( ) ) { \n \t7 logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> name ( ) ) ; \n <ect>
\t1 r = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( new file <identifiersep> input <identifiersep> stream ( <identifier> ) ) ) ; \n \t1 for ( string <identifier> <identifiersep> line : <identifier> <identifiersep> <identifier> ) { \n \t2 assert <identifiersep> equals ( <identifier> <identifiersep> line , r . read <identifiersep> line ( ) ) ; } \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t6 <comment> \n \t6 <comment> \n \t6 <comment> \n \t5 } else { \n <ect>
\t9 <string_literal> \n \t9 <string_literal> ) \n \t4 return failed \n \t3 self . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> data <identifiersep> config = self . <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> <identifier> . get <identifiersep> config ( ) \n <ect>
\t9 <identifier> <identifiersep> store . set <identifiersep> error <identifiersep> string ( msg ) ; \n \t9 s <identifiersep> logger . info ( msg ) ; \n \t9 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> ( <identifier> <identifiersep> manager . <identifier> <identifiersep> type . <identifier> <identifiersep> type <identifiersep> <identifier> <identifiersep> failed , <identifier> <identifiersep> id , null , msg , msg ) ; \n \t9 if ( <identifier> . get <identifiersep> state ( ) == <identifier> <identifiersep> <identifier> <identifiersep> template . state . not <identifiersep> <identifier> || <identifier> . get <identifiersep> state ( ) == <identifier> <identifiersep> <identifier> <identifiersep> template . state . <identifier> <identifiersep> in <identifiersep> <identifier> ) { \n <ect>
\t7 <identifier> = 0 ; \n \t7 put <identifiersep> map = <identifier> . new <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map ( <identifier> <identifiersep> <identifier> ) ; } } \n \t5 assert <identifier> < <identifier> <identifiersep> <identifier> ; \n \t5 assert put <identifiersep> map . size ( ) == ( data . size ( ) <identifier> <identifier> <identifiersep> <identifier> ) : <string_literal> + put <identifiersep> map . size ( ) ; \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> time ( ) == null ) { \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> time ( new date ( ) ) ; } \n \t2 <identifier> . <identifier> ( ) ; \n \t1 } catch ( transaction <identifiersep> exception | no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n <ect>
\t4 } else { \n \t5 path <identifier> <identifiersep> directory = files . create <identifiersep> <identifier> <identifiersep> directory ( <string_literal> ) ; \n \t5 <identifier> ( <string_literal> , <identifier> <identifiersep> directory ) ; \n \t5 <identifier> ( <string_literal> , <identifier> <identifiersep> directory ) ; \n <ect>
\t7 logger . warn ( <string_literal> + object <identifiersep> name + <string_literal> + \n \t9 <string_literal> ) ; } } } \n \t4 catch ( <identifier> <identifiersep> exception ex ) { \n \t5 if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t4 entry . <identifier> <identifiersep> from <identifiersep> <identifier> ( <identifier> . <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> version ( ) ) ; \n \t4 return entry ; } \n \t3 catch ( grid <identifiersep> cache <identifiersep> entry <identifiersep> <identifier> <identifiersep> exception ignore ) { \n <ect>
\t3 { \n \t4 throw new <identifier> <identifiersep> exception ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } \n \t2 } catch ( exception e ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t3 return ; } \n \t2 t <identifier> = <identifier> . in <identifiersep> <identifier> ( <identifier> ) . with <identifiersep> name ( id ) . get ( ) ; \n \t2 if ( is <identifiersep> <identifier> ( <identifier> ) ) { \n \t3 if ( user <identifiersep> configuration <identifiersep> <identifier> . config <identifiersep> equal ( resource , <identifier> ) ) { \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t3 resource = ( server <identifiersep> resource ) <identifier> . new <identifiersep> instance ( ) ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + host . get <identifiersep> resource ( ) , e ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 if ( process == null ) { \n \t1 return ; } \n \t1 if ( ! is <identifiersep> <identifier> <identifiersep> client <identifiersep> <identifier> ( ) ) { \n \t1 if ( first <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> log . get <identifiersep> and <identifiersep> set ( false ) ) { \n <ect>
\t3 } catch ( final no <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t4 throw new <identifier> <identifiersep> operation <identifiersep> exception ( <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t4 if ( ! check <identifiersep> vm <identifiersep> on <identifiersep> host ( vm , <identifier> <identifiersep> host <identifiersep> id ) ) { \n <ect>
\t2 try { \n \t3 <comment> \n \t3 password = url <identifiersep> <identifier> . <identifier> ( password , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 if ( http <identifiersep> status <identifiersep> code <identifiersep> <identifier> . is <identifiersep> <identifier> ( e . get <identifiersep> error <identifiersep> code ( ) ) ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> ) ; \n \t3 return new <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> answer ( command , false , <string_literal> ) ; } \n \t2 else { \n <ect>
\t8 if ( ++ <identifier> < = <number_literal> ) { \n \t9 log . info ( <string_literal> ) ; \n \t9 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } } \n \t7 exchange . get <identifiersep> in ( ) . set <identifiersep> body ( <string_literal> + body ) ; \n <ect>
\t5 } else \n \t6 log . info ( <string_literal> ) ; \n \t5 return null ; \n \t4 } else if ( m instanceof <identifier> ) { \n <ect>
\t6 <identifier> = provider . get <identifiersep> <identifier> ( item ) . get ( <string_literal> ) ; \n \t5 } else if ( command == on <identifiersep> <identifier> <identifiersep> type . on ) { \n \t6 <identifier> = provider . get <identifiersep> <identifier> ( item ) . get ( <string_literal> ) ; } \n \t4 } else { \n <ect>
\t5 for ( property <identifiersep> key <identifiersep> <identifier> v : <identifier> ) { \n \t6 try { \n \t7 <identifier> <identifiersep> <identifier> . add ( v . name ( ) ) ; \n \t6 } catch ( throwable t ) { \n <ect>
\t3 return <identifier> <identifiersep> client <identifiersep> request ( context , operation , <identifier> ) ; \n \t2 } else if ( <string_literal> . equals ( operation ) || <string_literal> . equals ( operation ) || <string_literal> . equals ( operation ) ) { \n \t3 return <identifier> <identifiersep> <identifier> <identifiersep> request ( context , operation , <identifier> ) ; } \n \t2 <comment> \n <ect>
\t2 if ( <identifier> <identifiersep> name <identifiersep> action . equals <identifiersep> ignore <identifiersep> case ( type ) ) { \n \t3 url = response . create <identifiersep> action <identifiersep> url ( ) ; } \n \t2 else { \n <ect>
\t3 if ( date <identifiersep> <identifier> . current <identifiersep> <identifier> <identifiersep> time ( ) . get <identifiersep> time ( ) - vm . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time ( ) . get <identifiersep> time ( ) < <identifier> <identifiersep> <identifier> <identifiersep> session <identifiersep> timeout <identifiersep> value ) { \n \t4 return true ; } \n \t3 return false ; \n \t2 } else { \n <ect>
\t1 } catch ( t <identifiersep> application <identifiersep> exception e ) { \n \t1 log . debug ( <string_literal> , server , e . get <identifiersep> message ( ) , e ) ; \n \t1 throw new <identifier> <identifiersep> server <identifiersep> exception ( server , e ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> id <identifiersep> exception e ) { \n <ect>
\t3 return null ; } \n \t2 <identifier> . add ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 string result = <identifier> . execute ( ) ; \n \t2 if ( result != null && ! result . contains ( <string_literal> ) ) { \n <ect>
\t3 <identifier> <identifiersep> manager <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> manager . get <identifiersep> instance ( <identifier> <identifiersep> config . get <identifiersep> instance <identifiersep> from <identifiersep> <identifier> ( ) ) ; \n \t3 <identifier> <identifiersep> instance <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> by <identifiersep> id ( <identifier> <identifiersep> id ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 return get <identifiersep> <identifier> ( class <identifiersep> utils . get <identifiersep> default <identifiersep> class <identifiersep> <identifier> ( ) ) ; } \n \t1 @ <identifier> \n \t1 public object get <identifiersep> <identifier> ( @ <identifier> class <identifiersep> <identifier> class <identifiersep> <identifier> ) { \n <ect>
\t1 public set <identifiersep> date <identifiersep> message <identifiersep> handler ( <identifier> <identifiersep> <identifier> <identifiersep> context <identifier> ) { \n \t2 super ( <identifier> , set <identifiersep> date <identifiersep> message . message <identifiersep> type ) ; } \n \t1 public void handle <identifiersep> message ( <identifier> <identifiersep> message message , <identifier> <identifiersep> session <identifiersep> <identifier> session ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t6 logger . info ( <string_literal> , node ) ; \n \t6 <comment> \n \t6 <identifier> failure <identifiersep> mode = <identifier> <identifiersep> from ( \n \t8 ( ) - > { \n <ect>
\t4 handle <identifiersep> <identifier> <identifiersep> <identifier> ( ( <identifier> <identifiersep> <identifier> ) <identifier> ) ; } } } \n \t1 private void handle <identifiersep> name <identifiersep> <identifier> ( name <identifiersep> <identifier> <identifier> ) { \n \t2 <comment> \n \t2 if ( <identifier> . get ( <identifier> . get <identifiersep> default <identifiersep> name ( ) ) == null ) { \n <ect>
\t7 <string_literal> + <identifier> + ' ] ' ) ; \n \t5 <identifier> . on <identifiersep> <identifier> <identifiersep> <identifier> ( entry , <identifier> ) ; \n \t5 return true ; } \n <ect>
\t6 s <identifiersep> logger . debug ( <string_literal> + <identifier> <identifiersep> name + <string_literal> + ip ) ; } \n \t5 <identifier> <identifiersep> <identifier> . put ( <identifier> <identifiersep> name , <identifier> ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . put ( <identifier> <identifiersep> name , <identifier> <identifiersep> <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 static <identifier> <identifiersep> map < integer , array <identifiersep> list < <identifier> <identifiersep> enum <identifiersep> value > > parse <identifiersep> <identifier> ( <identifier> <identifier> , string <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> file ) { \n <ect>
\t5 data <identifiersep> context ) ; \n \t3 files . <identifier> <identifiersep> file <identifiersep> <identifier> ( template <identifiersep> directory . to <identifiersep> path ( ) , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> , ex ) ; } \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 @ <identifier> \n \t1 protected void <identifier> ( ) throws exception { \n <ect>
\t5 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t6 <identifier> . add <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } } \n \t4 in . close ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 <identifier> <identifiersep> node <identifiersep> <identifier> new <identifiersep> <identifier> = <identifier> <identifiersep> in <identifiersep> <identifier> ( <identifier> ) ; \n \t1 if ( new <identifiersep> <identifier> != null ) { \n \t2 <comment> \n <ect>
\t4 string <identifier> = values [ 0 ] ; \n \t4 log . trace ( <string_literal> , <identifier> ) ; \n \t4 return <identifier> ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 thread . <identifier> ( <number_literal> ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> ) ; } \n \t2 } catch ( final configuration <identifiersep> exception e ) { \n <ect>
\t1 private <identifier> client <identifiersep> <identifier> ( int id ) { \n \t2 <identifier> current = client <identifiersep> <identifier> . get ( id ) ; \n \t2 if ( current == null ) { \n \t3 if ( debug <identifiersep> <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t3 message <identifiersep> <identifier> . send ( message , <identifier> <identifiersep> mode . <identifier> , message . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , 0 ) ; \n \t3 long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - start ; \n \t3 max = <identifier> . max ( max , <identifier> ) ; \n \t3 if ( <identifier> == max ) { \n <ect>
\t4 <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> . <identifier> , client <identifiersep> state ) ; \n \t4 count ++ ; } \n \t3 catch ( request <identifiersep> <identifier> <identifiersep> exception e ) \n \t3 { \n <ect>
\t4 { \n \t5 <identifier> . add ( new <identifier> <identifiersep> error ( ( ( status . has <identifiersep> status ) e . get <identifiersep> <identifier> ( ) ) . status ( ) , e ) ) ; } \n \t4 else \n \t4 { \n <ect>
\t3 thread . <identifier> ( <number_literal> ) ; \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> ( 1 , <number_literal> , <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n <ect>
\t6 boolean <identifier> <identifiersep> exists = get <identifiersep> <identifier> <identifiersep> object ( ) . exists <identifiersep> resource ( start <identifiersep> <identifier> ) ; \n \t6 if ( <identifier> <identifiersep> exists ) { \n \t7 data . set <identifiersep> start <identifiersep> <identifier> ( start <identifiersep> <identifier> ) ; \n \t6 } else { \n <ect>
\t1 else { \n \t2 add <identifiersep> object <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ) ; } } \n public void remove <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . model . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> object ) { \n <ect>
\t4 <identifier> <identifiersep> exception <identifier> = log <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> exception ( ex ) ; \n \t4 int <identifier> <identifiersep> code = <number_literal> ; \n \t4 string msg = <string_literal> \n \t6 + ( <identifier> == null ? ex . get <identifiersep> message ( ) : <identifier> . get <identifiersep> message ( ) ) ; \n <ect>
\t3 s <identifiersep> logger . error ( msg , e ) ; \n \t3 return new get <identifiersep> <identifier> <identifiersep> port <identifiersep> answer ( cmd , msg ) ; } } \n \t1 protected answer execute ( <identifier> <identifiersep> command cmd ) { \n <ect>
\t3 { \n \t4 target = <identifier> <identifiersep> utils . <identifier> <identifiersep> default <identifiersep> target ( content ) ; } \n \t3 catch ( illegal <identifiersep> argument <identifiersep> exception e ) \n \t3 { \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t3 } else { \n \t4 logger . debug ( <string_literal> , address , configuration . get <identifiersep> nodes ( ) ) ; \n \t4 this . <identifier> . <identifier> ( ) . <identifier> ( ) ; \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 final map < string , <identifier> <identifiersep> authentication <identifiersep> provider > <identifier> = \n \t4 <identifier> <identifiersep> authentication <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> authentication <identifiersep> <identifier> ( application <identifiersep> context ) ; \n \t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 } finally { \n <comment> \n \t4 <identifier> . stop ( ) ; } \n \t2 } catch ( throwable e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> first <identifiersep> file <identifiersep> with <identifiersep> <identifier> <identifiersep> index ( list , <identifier> <identifiersep> manager ) ; \n \t2 if ( <identifier> != null ) { \n \t3 return <identifier> ; } \n \t2 <comment> \n <ect>
\t2 return <identifier> <identifiersep> resource . get <identifiersep> uri ( ) ; } \n \t1 @ <identifier> \n \t1 public class <identifiersep> <identifier> get <identifiersep> class <identifiersep> <identifier> ( ) { \n \t2 if ( ! class <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> mode = ( string ) <identifier> . get ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> mode != null ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> model = ( string ) <identifier> . get ( <string_literal> ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> version < <number_literal> * <number_literal> + <number_literal> ) { \n <ect>
\t2 string <identifier> <identifiersep> dir = system . get <identifiersep> property ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> dir == null ) { \n \t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + <identifier> ) ; } \n <ect>
\t1 thread . <identifier> ( <identifier> ) ; \n \t1 <identifier> <identifiersep> server . <identifier> ( <identifier> , <string_literal> , <string_literal> ) ; \n \t1 thread . <identifier> ( <identifier> ) ; \n \t1 <identifier> <identifiersep> source . set <identifiersep> channel <identifiersep> <identifier> ( create <identifiersep> <identifier> <identifiersep> channel ( ) ) ; \n <ect>
\t1 string log <identifiersep> level <identifiersep> name = logger . get <identifiersep> log <identifiersep> level <identifiersep> name ( log <identifiersep> level ) ; \n \t1 int log <identifiersep> level <identifiersep> with <identifiersep> <identifier> = logger . get <identifiersep> log <identifiersep> level ( log <identifiersep> level <identifiersep> name ) ; \n \t1 assert . assert <identifiersep> equals ( log <identifiersep> level <identifiersep> with <identifiersep> <identifier> , i <identifiersep> logger . warn ) ; \n \t1 logger . warn ( <string_literal> + i <identifiersep> logger . warn ) ; <comment> \n <ect>
\t1 private void send <identifiersep> <identifier> ( abstract <identifiersep> job <identifiersep> <identifier> job <identifiersep> <identifier> , string <identifier> , map < string , string > <identifier> ) { \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n \t3 return ; } \n \t2 string <identifier> <identifiersep> <identifier> = string . format ( <string_literal> , cluster <identifiersep> <identifier> , job <identifiersep> <identifier> . <identifier> <identifiersep> id ) ; \n <ect>
\t2 <comment> \n \t2 if ( 0 == <identifier> <identifiersep> <identifier> && ! input <identifiersep> format <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t3 <identifier> <identifiersep> input <identifiersep> format . <identifier> <identifiersep> <identifier> ( job , input <identifiersep> format <identifiersep> <identifier> ) ; } \n \t2 collection < <identifier> > <identifier> = <identifier> . <identifier> ( new <identifier> ( start , end ) ) ; \n <ect>
\t2 for ( int i = 0 ; i < timeout ; ++ i ) { \n \t3 thread . <identifier> ( <number_literal> ) ; \n \t3 if ( <identifier> . get ( ) == 0 ) { \n \t4 return true ; } } \n <ect>
\t1 logger . debug ( <string_literal> ) ; \n \t1 map < string , string > default <identifiersep> <identifier> = key <identifiersep> <identifier> . get ( ) ; \n \t1 key default <identifiersep> key = api . key <identifiersep> api ( ) . create ( <identifier> + <string_literal> + system . get <identifiersep> property ( <string_literal> ) , default <identifiersep> <identifier> . get ( <string_literal> ) ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> . add ( default <identifiersep> key . id ( ) ) ; \n <ect>
\t5 try { \n \t6 channel . send <identifiersep> response ( e ) ; \n \t5 } catch ( io <identifiersep> exception <identifier> ) { \n \t6 <identifier> . add <identifiersep> <identifier> ( e ) ; \n <ect>
\t4 request . get <identifiersep> header ( <identifier> <identifiersep> state <identifiersep> header . name ) ; \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> header == null ) \n \t2 { \n <ect>
\t2 if ( network . get <identifiersep> network <identifiersep> <identifier> <identifiersep> id ( ) == null ) { \n \t3 return true ; } \n \t2 final list < network <identifiersep> <identifier> <identifiersep> item <identifiersep> vo > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> item <identifiersep> dao . list <identifiersep> by <identifiersep> <identifier> ( network . get <identifiersep> network <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> session consumer <identifiersep> session = ( <identifier> <identifiersep> <identifier> <identifiersep> session ) consumer <identifiersep> connection . create <identifiersep> session ( false , session . <identifier> <identifiersep> <identifier> ) ; \n \t2 message <identifiersep> consumer consumer = consumer <identifiersep> session . create <identifiersep> consumer ( send <identifiersep> <identifier> ) ; \n \t2 text <identifiersep> message <identifier> = ( text <identifiersep> message ) consumer . <identifier> ( <identifier> <identifiersep> timeout ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , <identifier> ) ; \n <ect>
\t9 info . <identifier> , item . <identifier> ) ; \n \t3 item <identifiersep> service . add <identifiersep> metadata ( context , item , info . <identifier> , info . element , \n \t9 info . <identifier> , null , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> no <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t3 assert . assert <identifiersep> equals ( 1 , <identifier> ( read <identifiersep> <identifier> <identifiersep> id ) ) ; \n \t3 assert . assert <identifiersep> equals ( <number_literal> , <identifier> ( listener <identifiersep> <identifier> <identifiersep> id ) ) ; \n \t2 } finally { \n \t3 listener . close ( ) ; } \n <ect>
\t2 field . set ( object , value ) ; } \n \t1 @ <identifier> \n \t1 public object method <identifiersep> value ( object object , method method ) throws illegal <identifiersep> argument <identifiersep> exception , illegal <identifiersep> access <identifiersep> exception , \n \t1 <identifier> <identifiersep> target <identifiersep> exception { \n <ect>
\t2 if ( ticket <identifiersep> state . get <identifiersep> count <identifiersep> of <identifiersep> <identifier> ( ) == 0 && current <identifiersep> time . is <identifiersep> <identifier> ( <identifier> <identifiersep> time ) ) { \n \t3 logger . debug ( <string_literal> + <string_literal> ) ; \n \t3 return super . is <identifiersep> <identifier> ( ticket <identifiersep> state ) ; } \n \t2 if ( current <identifiersep> time . is <identifiersep> <identifier> ( <identifier> <identifiersep> time ) ) { \n <ect>
\t3 byte [ ] message = new byte [ length ] ; \n \t3 system . <identifier> ( data , <identifier> , message , 0 , length ) ; \n \t3 this . consumer . send <identifiersep> message ( this . connection <identifiersep> key , message ) ; \n \t2 } else { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t1 if ( ! <identifier> <identifiersep> to <identifiersep> request ) { \n \t2 boolean add <identifiersep> to <identifiersep> <identifier> <identifiersep> list = true ; \n \t2 for ( host <identifiersep> <identifier> registered : <identifier> <identifiersep> <identifier> ) { \n \t2 if ( registered . get <identifiersep> host <identifiersep> id ( ) == host . get <identifiersep> host <identifiersep> id ( ) ) { \n <ect>
\t3 try { \n \t4 vm <identifiersep> map = vm . get <identifiersep> all <identifiersep> <identifier> ( conn ) ; <comment> \n \t4 break ; \n \t3 } catch ( final throwable e ) { \n <ect>
\t2 new <identifiersep> service <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> remove <identifiersep> host <identifiersep> from <identifiersep> principal ( new <identifiersep> service <identifiersep> user , <identifier> <identifiersep> <identifier> ) ) \n \t1 user <identifiersep> <identifier> <identifiersep> map = { } \n \t1 for new <identifiersep> service <identifiersep> user in new <identifiersep> service <identifiersep> <identifier> : \n \t2 user <identifiersep> <identifier> <identifiersep> map [ new <identifiersep> service <identifiersep> user ] = <identifier> \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t5 if ( ! value <identifiersep> list [ i ] . contains ( to <identifiersep> <identifier> <identifiersep> with ) ) key <identifiersep> result = true ; \n \t5 break ; \n \t4 default : \n \t5 return false ; } \n <ect>
\t1 try { \n \t2 if ( null != <identifier> ) { \n \t2 <identifier> . close ( ) ; } \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t4 return class . for <identifiersep> name ( class <identifiersep> name , true , <identifier> ) ; } \n \t3 catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) \n \t3 { \n \t4 <comment> \n <ect>
\t6 bean . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; \n \t4 throw new <identifier> <identifiersep> config <identifiersep> exception ( msg ) ; \n \t3 } else { \n \t4 <comment> \n <ect>
\t5 <identifier> . remove ( i ) ; \n \t5 try { \n \t6 e . task . run ( ) ; \n \t5 } catch ( throwable t ) { \n <ect>
\t1 private void <identifier> <identifiersep> index ( file data <identifiersep> dir ) throws exception { \n \t2 <identifier> <identifiersep> file ( data <identifiersep> dir , <string_literal> ) ; } \n \t1 private void <identifier> <identifiersep> file ( file data <identifiersep> dir , string name ) throws exception { \n \t2 file index <identifiersep> to <identifiersep> delete = new file ( data <identifiersep> dir , name ) ; \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> socket . close ( ) ; \n \t5 logger . debug ( <string_literal> ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 . <identifier> <identifiersep> key ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> property <identifiersep> key ) \n \t2 . build ( ) ) ; } \n private void load <identifiersep> <identifier> ( set < string > <identifier> <identifiersep> <identifier> , string property <identifiersep> key ) { \n \t1 if ( config . has <identifiersep> key ( property <identifiersep> key ) ) { \n <ect>
\t7 delete <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; } } \n \t4 } finally { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> lock . <identifier> ( ) ; } \n \t3 } catch ( exception ex ) { \n <ect>
\t3 for ( task <identifiersep> local <identifiersep> state <identifiersep> store <identifiersep> <identifier> state <identifiersep> store : to <identifiersep> <identifier> ) { \n \t4 try { \n \t5 state <identifiersep> store . <identifier> ( ) ; \n \t4 } catch ( exception <identifier> <identifiersep> ex ) { \n <ect>
\t2 long host <identifiersep> id = <identifier> . get <identifiersep> id ( ) ; \n \t2 host <identifiersep> vo host = <identifier> <identifiersep> host <identifiersep> dao . find <identifiersep> by <identifiersep> id ( host <identifiersep> id ) ; \n \t2 for ( <identifier> < integer , listener > <identifier> : <identifier> <identifiersep> host <identifiersep> <identifier> ) { \n <ect>
\t3 . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ) ) ; \n \t2 last <identifiersep> <identifier> . set ( <identifier> ) ; \n \t2 return <identifier> ; \n \t2 } catch ( final throwable e ) { \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + host . get <identifiersep> resource ( ) , e ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + host . get <identifiersep> resource ( ) , e ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t6 try ( thread <identifiersep> <identifier> <identifier> = thread <identifiersep> <identifier> . start <identifiersep> thread <identifiersep> <identifier> ( <string_literal> ) ) { \n \t7 update <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } \n \t4 } catch ( exception e ) { \n \t5 thread <identifiersep> <identifier> . add <identifiersep> error ( e ) ; \n <ect>
\t3 message ex <identifiersep> msg = new message ( <identifier> ) . set <identifiersep> <identifier> ( <identifier> . exception <identifiersep> to <identifiersep> <identifier> ( exception ) ) \n \t3 . put <identifiersep> header ( get <identifiersep> id ( ) , new state <identifiersep> header ( state <identifiersep> header . state <identifiersep> ex ) ) ; \n \t3 <identifier> ( ex <identifiersep> msg ) ; } \n \t2 catch ( throwable t ) { \n <ect>
\t2 public void run ( ) { \n \t3 try { \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 public void check <identifiersep> <identifier> <identifiersep> access ( final account <identifier> , final data <identifiersep> <identifier> <identifier> ) { \n \t2 for ( final security <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 if ( <identifier> . check <identifiersep> access ( <identifier> , <identifier> ) ) { \n <ect>
\t2 response <identifier> = null ; \n \t2 try { \n \t3 <identifier> = response . parse ( bytes ) ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public void set <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> ( final string <identifier> ) { \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> ) && number <identifiersep> utils . is <identifiersep> <identifier> ( <identifier> ) ) { \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n \t2 for ( <identifier> <identifiersep> <identifier> device : <identifier> . values ( ) ) { \n \t3 device . <identifier> <identifiersep> and <identifiersep> <identifier> ( ) ; } \n <ect>
\t5 map . put ( size <identifiersep> key , file <identifiersep> size ) ; } \n \t4 file . <identifier> <identifiersep> system <identifiersep> properties <identifiersep> <identifier> ( ) ; \n \t4 file . set <identifiersep> properties ( file . get <identifiersep> security <identifiersep> context ( ) , map ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 public item store <identifiersep> item <identifiersep> value ( item item ) { \n \t2 logger . debug ( <string_literal> , item . to <identifiersep> string ( ) ) ; \n \t2 string table <identifiersep> name = get <identifiersep> table ( item ) ; \n \t2 if ( table <identifiersep> name == null ) { \n <ect>
\t4 if ( <identifier> . length > 0 ) { \n \t5 type = <identifier> [ 0 ] ; \n \t5 <identifier> = <identifier> [ 1 ] ; \n \t5 if ( <identifier> != null ) { \n <ect>
\t2 assert . assert <identifiersep> equals ( <identifier> , test <identifiersep> <identifier> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t5 } else { \n \t7 s <identifiersep> logger . debug ( <string_literal> + instance . get <identifiersep> id ( ) ) ; } \n \t4 } else { \n <ect>
\t1 protected void do <identifiersep> close ( ) throws exception { \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> log . debug ( <string_literal> ) ; \n \t3 try { thread . <identifier> ( <number_literal> * <number_literal> ) ; } catch ( interrupted <identifiersep> exception <identifier> ) { } \n \t3 s . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 assert <identifiersep> <identifier> ( client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> create ( <string_literal> ) . set <identifiersep> <identifier> ( <identifier> . builder ( ) \n \t3 . put ( <string_literal> , 1 ) \n \t3 . put ( <string_literal> , <number_literal> ) ) ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t6 s <identifiersep> logger . error ( <string_literal> , e ) ; } \n \t5 try { \n \t6 thread . <identifier> ( <number_literal> ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> command = <string_literal> + <identifier> <identifiersep> url + <string_literal> ; \n \t4 else \n \t5 <identifier> <identifiersep> command = <string_literal> + <identifier> <identifiersep> url + <string_literal> ; \n \t4 session <identifier> = conn . <identifier> <identifiersep> session ( ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> type <identifier> <identifiersep> <identifier> , device <identifiersep> options <identifier> ) { \n \t2 logger . trace ( <string_literal> , <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 <identifier> <identifiersep> date = org . apache . http . client . utils . date <identifiersep> utils \n \t5 . parse <identifiersep> date ( <identifier> ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t4 file . delete ( ) ; } } } \n \t1 protected string <identifier> ( string path , string <identifier> , integer <identifier> <identifiersep> version ) { \n \t2 string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t1 if ( files != null ) { \n \t2 for ( final file file : files ) { \n \t2 <identifier> <identifiersep> find <identifiersep> all <identifiersep> <identifier> ( <identifier> , file <identifiersep> name , file ) ; } } \n \t1 else { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> storage <identifiersep> dao . <identifier> ( storage <identifiersep> vo ) ; \n \t2 } else if ( event <identifiersep> <identifier> . event <identifiersep> snapshot <identifiersep> delete . equals ( event . get <identifiersep> type ( ) ) ) { \n \t3 list < <identifier> <identifiersep> storage <identifiersep> vo > storage <identifiersep> v <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> storage <identifiersep> dao . list <identifiersep> by <identifiersep> id ( event . get <identifiersep> account <identifiersep> id ( ) , <identifier> <identifiersep> id , storage <identifiersep> <identifier> . snapshot ) ; \n \t3 if ( storage <identifiersep> v <identifiersep> <identifier> . size ( ) > 1 ) { \n <ect>
\t6 + msg . get <identifiersep> failed <identifiersep> <identifier> ( ) + <string_literal> + get <identifiersep> <identifier> ( ) ) ; \n \t3 if ( ( all <identifiersep> time > <number_literal> * <number_literal> ) && ( send <identifiersep> <identifier> ) ) { \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 } catch ( io <identifiersep> exception ex ) { \n \t3 string msg = <string_literal> ; \n \t3 msg += ex . to <identifiersep> string ( ) ; \n \t3 log . warn ( <string_literal> ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void on <identifiersep> success ( <identifier> <identifiersep> result result , client <identifiersep> <identifier> state ) { \n \t2 result . as <identifiersep> <identifier> ( ) . <identifier> ( ) ; \n \t2 if ( ! file <identifiersep> <identifier> . <identifier> <identifiersep> to ( <identifier> <identifiersep> file , <identifier> <identifiersep> to ) ) { \n <ect>
\t1 public t <identifier> ( <identifier> <identifiersep> data data , <identifier> <identifiersep> context context ) { \n \t2 if ( data . is <identifiersep> string ( ) ) { \n \t3 t result = case <identifiersep> <identifier> <identifiersep> <identifier> . get ( data . get <identifiersep> as <identifiersep> string ( ) . to <identifiersep> <identifier> <identifiersep> case ( <identifier> . <identifier> ) ) ; \n \t3 if ( result == null ) { \n <ect>
\t2 <comment> \n \t2 io <identifiersep> <identifier> . assert <identifiersep> file <identifiersep> is <identifiersep> <identifier> ( <identifier> <identifiersep> map ) ; \n \t2 if ( output != null ) io <identifiersep> <identifier> . assert <identifiersep> file <identifiersep> is <identifiersep> <identifier> ( output ) ; \n \t2 if ( ! <identifier> <identifiersep> input . is <identifiersep> empty ( ) && <identifier> <identifiersep> mode == check <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t6 try { \n \t7 update <identifiersep> filter . set <identifiersep> <identifier> <identifiersep> <identifier> ( false ) ; \n \t7 web <identifiersep> <identifier> . start <identifiersep> <identifier> ( filter <identifiersep> config . get <identifiersep> <identifier> <identifiersep> context ( ) ) ; } \n \t6 catch ( <identifier> <identifiersep> update <identifiersep> exception update <identifiersep> ex ) { \n <ect>
<comment> \n \t1 public void <identifier> ( final <identifier> <identifiersep> context <identifier> <identifiersep> context , \n \t3 final map < string , object > configuration ) { \n \t2 this . <identifier> <identifiersep> context = <identifier> <identifiersep> context ; \n <ect>
\t3 logger . info ( <string_literal> , endpoint ) ; \n \t3 token <identifiersep> metadata . update <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , endpoint ) ; } \n \t2 else if ( ! token <identifiersep> metadata . get <identifiersep> <identifier> ( endpoint ) . contains <identifiersep> all ( <identifier> ) ) \n \t2 { \n <ect>
\t7 new data <identifiersep> input <identifiersep> stream ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> length ( <identifier> , context . <identifier> <identifiersep> <identifier> <identifiersep> factory , <number_literal> ) ) ; \n \t6 try { \n \t7 return <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> from ( <identifier> <identifiersep> <identifier> , context . <identifier> <identifiersep> <identifier> , context . <identifier> <identifiersep> file <identifiersep> <identifier> , context . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t6 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 log . info ( <string_literal> ) ; \n \t2 set < string > <identifier> <identifiersep> <identifier> <identifiersep> user <identifiersep> account <identifiersep> <identifier> = new <identifier> <identifiersep> set < string > ( <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> status <identifiersep> dao . execute ( false ) ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> user <identifiersep> account <identifiersep> <identifier> . size ( ) + <string_literal> ) ; \n <ect>
\t2 try { \n \t3 <identifier> . start ( ) ; \n \t3 <identifier> <identifiersep> vo <identifier> <identifiersep> <identifier> = super . lock <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) , true ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t6 try { \n \t7 final int wait = integer . value <identifiersep> of ( entry . get <identifiersep> value ( ) ) ; \n \t7 thread . <identifier> ( wait ) ; \n \t6 } catch ( final number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . load ( resource ( resource <identifiersep> path , source ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 public string get <identifiersep> <identifier> <identifiersep> from <identifiersep> token ( final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 final <identifier> <identifiersep> key <identifiersep> info <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> key <identifiersep> info ( ) ; \n \t2 final <identifier> [ ] <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 final string <identifier> = parse <identifiersep> <identifier> <identifiersep> value ( <identifier> [ 0 ] . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> name ( ) ) ; \n <ect>
\t5 <identifier> . close ( ) ; } \n \t4 if ( <identifier> != null ) { \n \t5 <identifier> . close ( ) ; } \n \t3 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t1 int <identifier> <identifiersep> code ; \n \t1 try { \n \t1 <identifier> <identifiersep> code = p . wait <identifiersep> for ( ) ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t4 method <identifiersep> <identifier> return <identifiersep> type = get <identifiersep> return <identifiersep> type ( ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifier> = this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( return <identifiersep> type . get <identifiersep> <identifier> <identifiersep> type ( ) ) ; \n \t4 boolean <identifier> <identifiersep> void = is <identifiersep> <identifier> <identifiersep> void <identifiersep> return <identifiersep> type ( return <identifiersep> type , <identifier> ) ; \n \t4 if ( ( value == null || <identifier> <identifiersep> void ) && is <identifiersep> response <identifiersep> <identifier> ( <identifier> , exchange ) ) { \n <ect>
\t2 try { \n \t3 final ticket <identifiersep> <identifier> <identifier> = build <identifiersep> ticket <identifiersep> as <identifiersep> <identifier> ( ticket ) ; \n \t3 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket ) ; \n \t3 if ( metadata == null ) { \n <ect>
\t4 } catch ( final file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t5 s <identifiersep> logger . error ( <string_literal> + snapshot <identifiersep> <identifier> <identifiersep> path + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t5 return new <identifier> <identifiersep> cmd <identifiersep> answer ( e . to <identifiersep> string ( ) ) ; \n \t4 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t6 = ( string ) ( ( json <identifiersep> object ) result . get ( 0 ) ) \n \t7 . get ( <string_literal> ) ; } } \n \t3 catch ( throwable e ) \n \t3 { \n <ect>
<comment> \n \t1 protected void run <identifiersep> <identifier> <identifiersep> load <identifiersep> test ( <identifier> <identifiersep> load <identifiersep> test load <identifiersep> test ) { \n \t2 try { \n <ect>
\t3 byte data [ ] = <identifier> . to <identifiersep> byte <identifiersep> array ( ) ; \n \t3 <identifier> <identifiersep> log . error ( <string_literal> + data . length + <string_literal> + new string ( data ) ) ; \n \t3 properties <identifier> = new properties ( ) ; \n \t3 <identifier> . load ( new java . io . byte <identifiersep> array <identifiersep> input <identifiersep> stream ( data ) ) ; \n <ect>
\t1 protected long get <identifiersep> last <identifiersep> <identifier> ( ) { \n \t2 return last <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public void shutdown ( ) { \t1 \n <ect>
\t4 if ( <identifier> . <identifier> <identifiersep> <identifier> ( ) ) { \n \t5 <identifier> <identifiersep> array <identifier> = <identifier> . all <identifiersep> <identifier> ( ) ; \n \t5 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> i <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get ( msg . get <identifiersep> <identifier> <identifiersep> id <identifiersep> <identifier> ( ) ) ; \n \t2 if ( <identifier> != null ) { \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 if ( ! info . instance . start ( ) ) { \n \t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + info . name ) ; } \n \t4 if ( info . instance instanceof <identifier> <identifiersep> bean ) { \n \t5 <identifier> <identifiersep> m <identifiersep> bean ( ( <identifier> <identifiersep> bean ) info . instance ) ; } \n <ect>
\t5 string <identifier> = <identifier> ( out , version , false , event <identifiersep> handler , mode , user , password , <string_literal> ) ; \n \t5 if ( <identifier> == null ) \n \t6 throw new io <identifiersep> exception ( <string_literal> + ( <number_literal> + i ) + <string_literal> ) ; \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 { \n \t4 try \n \t4 { \n \t5 client . <identifier> ( server . get <identifiersep> port ( ) ) ; \n <ect>
\t4 if ( test <identifiersep> <identifier> . <identifier> . <identifier> [ i ] == test <identifiersep> <identifier> ) { \n \t5 <identifier> = false ; \n \t5 break ; } } } \n \t2 if ( <identifier> ) { \n <ect>
\t2 case <identifier> : \n \t2 case <identifier> : \n \t2 case <identifier> : \n \t2 case <identifier> : \n <ect>
\t5 check <identifiersep> entry ( grid ( i ) , <identifier> <identifiersep> key , <number_literal> , false ) ; } } \n \t2 map < integer , integer > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> map < > ( ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) \n \t3 <identifier> <identifiersep> <identifier> . put ( key ( <identifier> , not <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ) , <number_literal> ) ; \n <ect>
\t4 int <identifier> = integer . parse <identifiersep> int ( value ) ; \n \t4 if ( <identifier> < = 0 ) { \n \t5 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> + name ) ; } \n \t3 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 final long <identifier> <identifiersep> <identifier> = system . <identifier> <identifiersep> time ( ) ; \n \t3 <identifier> <identifiersep> db . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 final long end <identifiersep> <identifier> = system . <identifier> <identifiersep> time ( ) ; \n <ect>
\t1 try { \n \t2 result = run <identifiersep> command ( new string [ ] { <string_literal> , <string_literal> , <string_literal> , path } ) . get <identifiersep> <identifier> ( ) ; \n \t1 } catch ( io <identifiersep> exception | interrupted <identifiersep> exception e ) { \n \t2 <comment> \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> dir ( ) ; \n \t1 run ( <string_literal> + db <identifiersep> name + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> result ( 0 , 0 , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id = get <identifiersep> result ( 0 , 1 , true , <identifier> ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> node == null ) { \n \t4 logger . error ( <string_literal> ) ; \n \t4 return ; } \n \t3 if ( current <identifiersep> node == null ) { \n <ect>
\t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> handler ( enum <identifiersep> map < <identifier> <identifiersep> storage <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , object > <identifier> ) { \n \t2 <identifier> <identifiersep> storage <identifiersep> <identifier> <identifiersep> command <identifiersep> handler handler = ( <identifier> <identifiersep> storage <identifiersep> <identifier> <identifiersep> command <identifiersep> handler ) storage <identifiersep> handler ; \n \t2 boolean success = handler . <identifier> <identifiersep> storage <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( success ) { \n <ect>
\t4 <identifier> . set <identifiersep> read <identifiersep> <identifier> ( true ) ; \n \t4 next <identifiersep> <identifier> = ( list < snapshot <identifiersep> info > ) <identifier> . list ( ) ; \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> <identifier> ) { \n <ect>
\t2 s <identifiersep> logger . info ( <string_literal> + vm ) ; \n \t2 try { \n \t3 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) == <identifier> <identifiersep> type . stop ) { \n \t4 if ( <identifier> <identifiersep> it <identifiersep> <identifier> . <identifier> <identifiersep> stop ( vm , false , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> system <identifiersep> user ( ) , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> system <identifiersep> account ( ) ) ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t5 logger . info ( <string_literal> , ip , \n \t7 e . get <identifiersep> message ( ) ) ; \n \t5 socket <identifiersep> close ( ) ; <comment> \n \t4 } catch ( exception e ) { \n <ect>
\t1 public void <identifier> ( final <identifier> <identifiersep> <identifier> in <identifiersep> <identifier> <identifiersep> <identifier> , final string in <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url ) \n \t1 { \n \t2 final map < string , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> map < string , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . put ( in <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url , in <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 throw <identifier> <identifiersep> <identifier> <identifiersep> exception . <identifier> <identifiersep> runtime <identifiersep> exception <identifiersep> for <identifiersep> throwable ( <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t2 catch ( execution <identifiersep> exception <identifier> ) { \n \t3 throw <identifier> <identifiersep> <identifier> <identifiersep> exception . <identifier> <identifiersep> runtime <identifiersep> exception <identifiersep> for <identifiersep> throwable ( <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t2 catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 return <identifier> . get <identifiersep> enum <identifiersep> <identifier> ( ) [ value ] ; } \n \t2 } else if ( <identifier> == null ) { \n \t3 return null ; \n \t2 } else { \n <ect>
\t3 if ( ! remote <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t4 <identifier> . set <identifiersep> properties ( remote <identifiersep> <identifier> ) ; } \n \t3 return <identifier> ; \n \t2 } catch ( exception ex ) { \n <ect>
\t1 log . error ( <string_literal> \n \t3 + <string_literal> ) ; \n \t1 <identifier> . <identifier> ( ex ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> + info . name ) ; \n \t4 string key = get <identifiersep> attribute ( <identifier> , <string_literal> ) ; \n \t4 if ( key == null ) { \n \t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + info . name ) ; } \n <ect>
\t6 . get <identifiersep> input <identifiersep> stream ( ) ) ) ; \n \t4 <comment> \n \t4 message = line <identifiersep> <identifier> . read <identifiersep> line ( ) ; \n <ect>
public void close ( ) { \n \t1 try { \n \t1 <identifier> . close ( ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 if ( cmd != null ) { \n \t7 status <identifiersep> map . put ( cmd , <identifier> . group ( <number_literal> ) ) ; \n \t7 logger . debug ( <string_literal> , cmd . name ( ) , <identifier> . group ( <number_literal> ) ) ; } \n \t5 } catch ( illegal <identifiersep> state <identifiersep> exception e ) { \n <ect>
\t2 return <identifier> ( name ) ; } \n \t1 private static <identifier> <identifiersep> <identifier> <identifiersep> factory load <identifiersep> <identifier> ( xml <identifiersep> <identifier> <identifier> ) { \n \t2 string <identifier> = <identifier> . get ( <string_literal> ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> not <identifiersep> found <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t2 throws exception { \n \t2 <comment> \n \t2 exception exception = action <identifiersep> <identifier> . get <identifiersep> exception ( ) ; \n \t2 if ( exception == null ) { \n <ect>
\t2 response response = client . target ( port <identifiersep> provider <identifiersep> <identifier> . <identifier> <identifiersep> url ( <string_literal> , provider <identifiersep> class . get <identifiersep> <identifier> <identifiersep> name ( ) ) ) . request ( ) \n \t4 . <identifier> ( entity . entity ( <identifier> , <string_literal> ) ) ; \n \t2 string response <identifiersep> <identifier> = response . read <identifiersep> entity ( string . class ) ; \n \t2 logger . info ( <string_literal> + response . get <identifiersep> status ( ) ) ; \n <ect>
\t5 throw new <identifier> <identifiersep> security <identifiersep> exception ( <string_literal> + type , <identifier> ) ; } \n \t4 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) \n \t5 throw new <identifier> <identifiersep> security <identifiersep> exception ( <identifier> + <string_literal> + type , <identifier> ) ; \n \t4 if ( log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 break ; } \n \t3 try { \n \t4 thread . <identifier> ( <number_literal> ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 this . total = <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t1 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( configuration , total ) ; \n \t1 this . filter <identifiersep> <identifier> = configuration . get <identifiersep> boolean ( <identifier> <identifiersep> <identifier> <identifiersep> enabled , true ) ; \n \t1 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 try { \n \t3 if ( ! <identifier> <identifiersep> service . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t4 <identifier> <identifiersep> service . shutdown <identifiersep> <identifier> ( ) ; \n \t4 if ( ! <identifier> <identifiersep> service . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n <ect>
\t2 collection . put ( id , <identifier> ) ; \n \t2 log . info ( <string_literal> + id + <string_literal> + <identifier> ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 read <identifiersep> process <identifiersep> event . <identifier> ( <string_literal> ) ; \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> user <identifiersep> list <identifiersep> <identifier> <identifiersep> <identifier> ( json <identifiersep> object <identifier> <identifiersep> <identifier> , json <identifiersep> object <identifier> , json <identifiersep> object user <identifiersep> list , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception , json <identifiersep> exception { \n \t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> user <identifiersep> list <identifiersep> <identifier> <identifiersep> <identifier> ( json <identifiersep> object <identifier> <identifiersep> <identifier> , json <identifiersep> object <identifier> , json <identifiersep> object user <identifiersep> list , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception , json <identifiersep> exception { \n <ect>
\t2 } else if ( <identifier> . get <identifiersep> state ( ) == state . <identifier> || <identifier> . get <identifiersep> state ( ) == state . <identifier> ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> instance <identifiersep> name ( ) + <string_literal> + <identifier> . get <identifiersep> state ( ) + <string_literal> ) ; \n \t3 return true ; \n \t2 } else { \n <ect>
\t2 string count = <identifier> . get ( <string_literal> ) ; \n \t2 string data = <identifier> . get ( <string_literal> ) ; \n \t2 string <identifier> = <identifier> . get ( <string_literal> ) ; \n \t2 if ( id == null ) { \n <ect>
\t2 if ( host != null && ( host . equals ( <string_literal> ) || host . equals ( <string_literal> ) ) && uri . get <identifiersep> port ( ) == <number_literal> ) { \n \t3 try { \n \t4 uri = new uri ( null , null , null , - 1 , uri . get <identifiersep> path ( ) , uri . get <identifiersep> query ( ) , uri . get <identifiersep> <identifier> ( ) ) ; \n \t3 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 connection . close ( ) ; \n \t3 connection = null ; \n \t2 } catch ( exception e ) { \n <ect>
public integer <identifier> ( ) { \n \t1 return ( integer ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> ( integer value ) { \n <ect>
\t2 if ( request . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . contains ( new <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 this . logger . debug ( <string_literal> , new <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 } else if ( this . model <identifiersep> <identifier> . exists ( new <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 <comment> \n <ect>
<comment> \n \t1 public static void <identifier> <identifiersep> <identifier> <identifiersep> input <identifiersep> stream <identifiersep> factory ( string file <identifiersep> <identifier> , <identifier> <identifiersep> input <identifiersep> stream <identifiersep> factory < ? > factory ) { \n \t2 synchronized ( <identifier> <identifiersep> input <identifiersep> stream <identifiersep> <identifier> ) { \n \t3 if ( <identifier> <identifiersep> input <identifiersep> stream <identifiersep> <identifier> . put ( file <identifiersep> <identifier> , factory ) != null ) { \n <ect>
\t3 private final <identifier> <identifiersep> integer <identifier> = new <identifier> <identifiersep> integer ( ) ; \n \t3 private final thread . <identifier> <identifiersep> exception <identifiersep> handler handler = new thread . <identifier> <identifiersep> exception <identifiersep> handler ( ) { \n \t4 @ <identifier> \n \t4 public void <identifier> <identifiersep> exception ( thread t , throwable e ) { \n <ect>
\t2 string <identifier> <identifiersep> user = <identifier> <identifiersep> <identifier> <identifiersep> properties . get ( <string_literal> ) ; \n \t2 string <identifier> <identifiersep> user = <identifier> <identifiersep> <identifier> <identifiersep> properties . get ( <string_literal> ) ; \n \t2 if ( ! string <identifiersep> utils . equals ( <identifier> <identifiersep> user , <identifier> <identifiersep> user ) ) { \n \t3 system . out . <identifier> ( <string_literal> ) ; \n <ect>
\t1 public void test <identifiersep> <identifier> ( ) { \n \t2 <identifier> . test <identifiersep> <identifier> ( ) ; } \n \t1 @ <identifier> \n \t1 public void test <identifiersep> <identifier> ( string host ) { \n <ect>
\t3 method . set <identifiersep> entity ( new url <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> entity ( <identifier> . as <identifiersep> list ( \n \t5 new <identifier> <identifiersep> name <identifiersep> value <identifiersep> <identifier> ( <string_literal> , <identifier> ) , \n \t5 new <identifier> <identifiersep> name <identifiersep> value <identifiersep> <identifier> ( <string_literal> , password ) ) ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . <identifier> ( <string_literal> + <identifier> . size ( ) ) . <identifier> ( <string_literal> ) ; \n \t4 log . trace ( <identifier> ) ; } \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; } \n \t2 catch ( throwable t ) { \n <ect>
\t5 <identifier> , <identifier> , is <identifiersep> <identifier> ( ) , <identifier> . < <identifier> , v > empty ( ) ) ; \n \t4 <identifier> < grid <identifiersep> cache <identifiersep> return < v > > <identifier> = new <identifier> < grid <identifiersep> cache <identifiersep> return < v > > ( <identifier> ) { \n \t5 @ <identifier> public grid <identifiersep> cache <identifiersep> return < v > <identifier> <identifiersep> lock ( grid <identifiersep> cache <identifiersep> return < v > <identifier> ) throws grid <identifiersep> exception { \n <ect>
\t1 if ( write <identifiersep> method == null ) { \n \t2 string method <identifiersep> <identifier> = <string_literal> + <identifier> <identifiersep> name . to <identifiersep> <identifier> <identifiersep> case ( <identifier> . <identifier> ) ; \n \t2 write <identifiersep> method = <identifier> . stream ( ) . filter ( m - > m . get <identifiersep> name ( ) . equals ( method <identifiersep> <identifier> ) && m . get <identifiersep> <identifier> <identifiersep> count ( ) == 1 ) . find <identifiersep> first ( ) . or <identifiersep> else ( null ) ; } \n \t1 if ( write <identifiersep> method == null ) { \n <ect>
\t3 return ; } \n \t2 <comment> \n \t2 if ( is <identifiersep> map <identifiersep> <identifier> ( <identifier> ) && map <identifiersep> <identifier> . size ( ) == 1 && num <identifiersep> <identifier> == 1 ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> <identifier> <identifiersep> <identifier> ( map <identifiersep> <identifier> . get ( 0 ) , <identifier> ) ; \n <ect>
\t5 int <identifier> <identifiersep> version <identifiersep> <identifier> = integer . parse <identifiersep> int ( version <identifiersep> <identifier> [ 1 ] ) ; \n \t5 if ( <identifier> <identifiersep> version <identifiersep> <identifier> < <number_literal> ) { \n \t6 logger . warn ( <string_literal> ) ; \n \t6 logger . warn ( <string_literal> ) ; \n <ect>
\t4 logger . debug ( <string_literal> + instance <identifiersep> id ) ; \n \t3 return <identifier> != null ; \n \t2 } catch ( exception e ) { \n <ect>
\t7 log . error ( <string_literal> + <identifier> <identifiersep> name + <string_literal> + e , e ) ; \n \t7 <comment> \n \t7 log . error ( <string_literal> ) ; \n \t7 context . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> node <identifiersep> store <identifiersep> service . class . get <identifiersep> name ( ) ) ; \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> manager . stop ( ) ; \n \t5 break ; \n \t4 } catch ( throwable <identifier> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> snapshot == null ) \n \t4 s <identifiersep> logger . error ( <string_literal> ) ; \n \t3 return true ; \n \t2 } else { \n <ect>
\t1 if ( null != client ) { \n \t2 <identifier> = client . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , context . <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t1 } catch ( t <identifiersep> exception e ) { \n \t1 <comment> \n <ect>
\t3 logger . info ( <string_literal> , <identifier> . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> name ( ) ) ; \n \t3 update <identifiersep> index <identifiersep> <identifier> ( index , <identifier> . builder ( ) . put ( <string_literal> , <identifier> . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> name ( ) ) ) ; \n \t3 <identifier> <identifiersep> <identifier> ( index ) ; \n \t3 n <identifiersep> <identifier> = <identifier> <identifiersep> int <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , max <identifiersep> <identifier> ) ; \n <ect>
\t4 <identifier> <identifiersep> <identifier> ) ; } \n \t1 <identifier> < long [ ] , list < path > > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = null ; \n \t1 <comment> \n \t1 if ( should <identifiersep> <identifier> || process <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> . process <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 system . out . <identifier> ( <string_literal> + <identifier> <identifiersep> <identifier> . size ( ) + <string_literal> + response <identifiersep> <identifier> . size ( ) ) ; \n \t2 <comment> \n \t2 try { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 if ( is <identifiersep> in <identifiersep> <identifier> && is <identifiersep> out <identifiersep> end ) { \n \t3 <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . add <identifiersep> <identifier> <identifiersep> data ( <string_literal> , 1 ) ; \n <ect>
\t2 status status ; \n \t2 try { \n \t3 status = status . parse <identifiersep> from ( entry . get <identifiersep> value ( ) . get ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t6 <string_literal> + <identifier> <identifiersep> client <identifiersep> log <identifiersep> <identifier> + \n \t6 <string_literal> ) ; } \n \t3 return <identifier> . empty ( ) ; } \n \t2 if ( response . set <identifiersep> status <identifiersep> code ( http <identifiersep> status . <identifier> <identifiersep> server <identifiersep> error ) ) { \n <ect>
\t5 <identifier> . set <identifiersep> long ( 1 , <identifier> <identifiersep> id ) ; \n \t5 <identifier> . set <identifiersep> long ( <number_literal> , network <identifiersep> id ) ; \n \t5 <identifier> . set <identifiersep> string ( <number_literal> , network <identifiersep> type ) ; \n \t5 <identifier> . execute <identifiersep> update ( ) ; } \n <ect>
\t1 check <identifiersep> not <identifiersep> null ( root <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <string_literal> ) ; \n \t1 file root <identifiersep> <identifier> <identifiersep> <identifier> = root <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> file ( ) ; \n \t1 logger . debug ( <string_literal> , root <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 if ( ! contains <identifiersep> <identifier> <identifiersep> <identifier> ( root <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t1 <identifier> . add ( cache ) ; \n \t1 wait <identifiersep> for <identifiersep> cluster <identifiersep> to <identifiersep> <identifier> ( ) ; \n \t1 assert <identifiersep> <identifier> ( ) ; } \n protected void test <identifiersep> remove <identifiersep> <identifier> ( ) throws interrupted <identifiersep> exception { \n <ect>
\t2 log . info ( msg ( <string_literal> ) + <string_literal> + <identifier> . get <identifiersep> id ( ) ) ; \n \t2 log . info ( msg ( <string_literal> ) + <string_literal> + info . is <identifiersep> info <identifiersep> found ( ) ) ; \n \t2 log . info ( msg ( <string_literal> ) + <string_literal> + <identifier> . is <identifiersep> <identifier> ( ) ) ; \n \t2 log . info ( msg ( <string_literal> ) + <string_literal> + info . is <identifiersep> <identifier> <identifiersep> found ( ) ) ; \n <ect>
\t1 <identifier> <identifiersep> set < string > <identifier> <identifiersep> in <identifiersep> <identifier> = new <identifier> <identifiersep> set < > ( <identifier> . as <identifiersep> list ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <string_literal> ) ) ) ; \n \t1 <identifier> = new <identifier> <identifiersep> context ( <identifier> <identifiersep> in <identifiersep> <identifier> ) ; \n \t1 } catch ( exception <identifier> ) { \n \t1 system . <identifier> . <identifier> ( <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; \n <ect>
\t1 <string_literal> <string_literal> <string_literal> \n <ect>
\t6 <identifier> [ ] <identifier> , <identifier> <identifiersep> type <identifier> <identifiersep> type , \n \t6 <identifier> <identifiersep> map < string , object > http <identifiersep> <identifier> , output <identifiersep> stream entity <identifiersep> stream ) \n \t3 throws io <identifiersep> exception , web <identifiersep> application <identifiersep> exception { \n \t2 logger . info ( <string_literal> ) ; \n <ect>
class <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> not <identifiersep> <identifier> { \n \t1 @ <identifier> ( type = <identifier> <identifiersep> type . not <identifiersep> <identifier> ) \n \t1 void do <identifiersep> <identifier> ( ) { \n \t1 <identifier> <identifiersep> <identifier> = <identifier> . current <identifiersep> transaction ( ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> ) return ; \n \t2 <comment> \n \t2 if ( ( <identifier> <identifiersep> context . <identifier> ( ) == null || <identifier> <identifiersep> context . <identifier> ( ) . is <identifiersep> <identifier> ( ) ) && \n \t3 <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t1 protected void set <identifiersep> <identifier> ( ) throws exception { \n \t3 group <identifiersep> id = <string_literal> + system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 <identifier> = new <identifier> <identifiersep> service [ <identifier> <identifiersep> count ] ; \n \t2 for ( int i = 0 ; i < <identifier> . length ; i ++ ) { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> system ( ) . new <identifiersep> <identifier> ( <identifier> ) ) ; \n \t2 <identifier> . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> . set <identifiersep> message ( msg . to <identifiersep> string ( ) ) ; \n <ect>
\t4 if ( ! boolean . get <identifiersep> boolean ( debug <identifiersep> utils . property <identifiersep> <identifier> <identifiersep> log <identifiersep> connection <identifiersep> <identifier> ) ) \n \t4 { \n \t5 long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - connection <identifiersep> start <identifiersep> <identifier> ; \n \t5 int max <identifiersep> timeout = <identifier> . max ( <identifier> <identifiersep> session <identifiersep> timeout <identifiersep> <identifier> , connection <identifiersep> timeout <identifiersep> <identifier> ) ; \n <ect>
\t5 filter <identifiersep> <identifier> = system . <identifier> <identifiersep> time ( ) ; \n \t5 log . debug ( <string_literal> , <identifier> ) ; } \n \t3 } else { \n \t4 filter <identifiersep> <identifier> = system . <identifier> <identifiersep> time ( ) ; \n <ect>
\t2 builder . <identifier> <identifiersep> object ( <string_literal> ) ; \n \t2 return builder . build ( ) . get <identifiersep> as <identifiersep> object ( ) ; } \n \t1 @ <identifier> \n \t1 protected json <identifiersep> value <identifier> <identifiersep> get <identifiersep> item ( http <identifiersep> action action ) { \n <ect>
\t3 item item = item <identifiersep> <identifier> . get <identifiersep> item ( item <identifiersep> id ) ; \n \t3 item <identifiersep> state = item . get <identifiersep> state ( ) ; \n \t3 logger . debug ( <string_literal> , item <identifiersep> id , item <identifiersep> state ) ; \n \t2 } catch ( item <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
\t2 for ( <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> first ( ) ; <identifier> <identifiersep> <identifier> != null ; <identifier> <identifiersep> <identifier> = ( <identifier> ) <identifier> <identifiersep> it . next ( <identifier> <identifiersep> <identifier> ) ) { \n \t5 count ++ ; } \n \t2 logger . info ( <identifier> ( ) + <string_literal> + <identifier> . size ( ) + <string_literal> + count ) ; \n \t2 if ( <identifier> . size ( ) != count ) { \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> . action == <identifier> . <identifier> <identifiersep> action <identifiersep> <identifier> ) { \n \t5 <identifier> <identifiersep> <identifier> ( ) \n \t4 } else { \n \t5 if ( <identifier> <identifiersep> <identifier> . action == <identifier> . <identifier> <identifiersep> action <identifiersep> <identifier> ) { \n <ect>
\t2 try { \n \t3 add <identifiersep> <identifier> ( <string_literal> , body ) ; \n \t3 <identifier> <identifiersep> template ( <identifier> , build <identifiersep> template <identifiersep> name ( template , get <identifiersep> default <identifiersep> template ( ) ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 } catch ( remote <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> , e ) ; } \n \t3 if ( ! <identifier> <identifiersep> file . delete ( ) ) { \n <ect>
\t4 return ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) \n \t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> policy . new <identifiersep> <identifier> ( ) ; \n \t3 long next <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . next <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 this . logger . debug ( <string_literal> ) ; \n \t2 <identifier> . for <identifiersep> <identifier> ( this : : <identifier> <identifiersep> consumer ) ; \n \t2 this . <identifier> . <identifier> ( ) ; \n \t2 this . <identifier> <identifiersep> by <identifiersep> queue . <identifier> ( ) ; \n <ect>
\t1 public void exception <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context <identifier> , exception <identifiersep> event exception <identifiersep> event ) throws exception { \n \t2 <comment> \n \t2 if ( consumer . is <identifiersep> run <identifiersep> <identifier> ( ) ) { \n \t3 if ( exception <identifiersep> event . get <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> channel <identifiersep> exception ) { \n <ect>
\t3 access <identifiersep> <identifier> access <identifiersep> <identifier> = connection <identifiersep> factory . get <identifiersep> o <identifiersep> <identifier> <identifiersep> <identifier> ( ) . exchange <identifiersep> for <identifiersep> access ( code , <identifier> <identifiersep> url ( request ) , null ) ; \n \t3 return connection <identifiersep> factory . create <identifiersep> connection ( access <identifiersep> <identifier> ) ; \n \t2 } catch ( http <identifiersep> client <identifiersep> error <identifiersep> exception e ) { \n \t3 logger . warn ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n <ect>
\t2 public void on <identifiersep> <identifier> ( web <identifiersep> socket <identifier> ) { \n \t3 log . debug ( <string_literal> ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> close ( web <identifiersep> socket <identifier> , int code , string <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> resource <identifiersep> filter . ignore <identifiersep> <identifier> ) ) { \n \t4 log . debug ( debug <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> check <identifiersep> resource . get <identifiersep> root <identifiersep> path ( ) ) ; \n \t4 return status . <identifier> ; } \n \t3 if ( ! check <identifiersep> lock ( <identifier> <identifiersep> check <identifiersep> resource ) ) { \n <ect>
\t2 } catch ( lock <identifiersep> failed <identifiersep> exception e ) { \n \t3 send <identifiersep> lock <identifiersep> <identifier> <identifiersep> error ( <identifier> , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 <identifier> . send <identifiersep> error ( <identifier> <identifiersep> status . <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> error ) ; \n <ect>
\t3 if ( assert <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> && result != null && result != dir <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> . add ( result ) ; } \n \t3 return result ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 assert . assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t4 <identifier> <identifiersep> e <identifiersep> <identifier> . put ( <identifier> , <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . put ( <identifier> , context . <identifier> <identifiersep> entity ( <identifier> <identifiersep> <identifier> . get ( <identifier> ) ) ) ; } \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t4 . add <identifiersep> all ( values ) \n \t4 . add ( target <identifiersep> value ) \n \t4 . build ( ) ) ) ; } \n \t1 private void remove ( string name , list < <identifier> <identifiersep> state > values , <identifier> <identifiersep> state target <identifiersep> value ) throws io <identifiersep> exception { \n <ect>
\t2 try { \n \t2 <identifier> <identifiersep> value <identifiersep> <identifier> <identifier> <identifiersep> value <identifiersep> enum = <identifier> <identifiersep> value <identifiersep> <identifier> . value <identifiersep> of ( class <identifiersep> <identifier> ) ; \n \t2 return <identifier> . to <identifiersep> java <identifiersep> object ( <identifier> <identifiersep> value . to <identifiersep> string ( ) , <identifier> <identifiersep> value <identifiersep> enum . get <identifiersep> value <identifiersep> class ( ) ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n @ <identifier> \n public <identifier> get ( long key ) \n { \n <ect>
\t2 string principal <identifiersep> id = <identifier> <identifiersep> principal <identifiersep> id ( <identifier> , current <identifiersep> principal ) ; \n \t2 if ( principal <identifiersep> name <identifiersep> <identifier> != null ) { \n \t3 principal <identifiersep> id = principal <identifiersep> name <identifiersep> <identifier> . <identifier> ( principal <identifiersep> id ) ; } \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( principal <identifiersep> id ) ) { \n <ect>
\t1 log . trace ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <string_literal> ) ; \n \t1 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> factory . get <identifiersep> factory ( ) . delete <identifiersep> <identifier> ( object <identifiersep> storage <identifiersep> <identifier> . get <identifiersep> instance ( ) , <identifier> , null , null ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t7 s <identifiersep> logger . debug ( <string_literal> ) ; } \n \t5 } else { \n \t6 s <identifiersep> logger . debug ( <string_literal> ) ; } } } \n <ect>
\t1 try { \n \t2 <identifier> = read <identifiersep> <identifier> ( <identifier> . <identifier> , name ) \n \t1 } catch ( e : io <identifiersep> exception ) { \n \t2 <identifier> <identifier> <identifiersep> <identifier> = name . <identifier> ( <string_literal> . to <identifiersep> <identifier> ( ) , <string_literal> ) \n <ect>
\t3 try { \n \t4 <comment> \n \t4 logger . info ( <string_literal> + file <identifiersep> <identifier> . get <identifiersep> file <identifiersep> <identifier> ( web <identifiersep> conf <identifiersep> path ) ) ; \n \t3 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t5 if ( response != null ) { \n \t6 <comment> \n \t6 string <identifier> <identifiersep> url = exchange . get <identifiersep> in ( ) . get <identifiersep> header ( exchange . http <identifiersep> url , string . class ) ; \n \t6 int code = response . get <identifiersep> status ( ) != null ? response . get <identifiersep> status ( ) . get <identifiersep> code ( ) : - 1 ; \n <ect>
\t2 for ( int last <identifiersep> index = uri . last <identifiersep> index <identifiersep> of ( ' / ' ) ; last <identifiersep> index > ( - 1 ) ; last <identifiersep> index = uri . last <identifiersep> index <identifiersep> of ( ' / ' , last <identifiersep> index - 1 ) ) { \n \t3 action <identifiersep> <identifier> action <identifiersep> <identifier> = action <identifiersep> <identifier> . get ( uri . <identifier> ( 0 , last <identifiersep> index ) ) ; \n \t3 if ( action <identifiersep> <identifier> != null ) { \n \t4 action <identifiersep> <identifier> action <identifiersep> <identifier> = action <identifiersep> <identifier> . get <identifiersep> <identifier> ( request , config <identifiersep> manager ) ; \n <ect>
\t5 if ( set <identifiersep> to <identifiersep> null ) \n \t6 <identifier> = null ; } \n \t3 } <comment> \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t7 synchronized ( lock ) { \n \t8 final service <identifiersep> status status = <identifier> . get <identifiersep> status ( ) ; \n \t8 final boolean <identifier> = status . is <identifiersep> <identifier> ( ) || status . is <identifiersep> <identifier> ( ) ; \n \t8 if ( <identifier> <identifiersep> <identifier> <identifiersep> task != null && <identifier> <identifiersep> <identifier> <identifiersep> task . get <identifiersep> status ( ) == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . task . status . <identifier> && <identifier> ) { \n <ect>
\t3 result . success = o ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t3 final set < string > <identifier> = get <identifiersep> client <identifiersep> <identifier> ( <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> client ( ) ) ; \n \t3 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t4 <identifier> . <identifier> <identifiersep> authentication <identifiersep> handler ( <identifier> <identifiersep> authentication <identifiersep> handler ( ) ) ; \n \t3 } else { \n <ect>
\t5 <identifier> . write ( msg ) ; \n \t4 } else { \n \t5 put <identifiersep> in <identifiersep> context ( msg ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 <identifier> . <identifier> ( <string_literal> ) ; } \n \t1 if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> table <identifiersep> set ) { \n \t1 <comment> \n \t1 <identifier> . <identifier> ( <string_literal> + options . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> table <identifiersep> dir ( ) + <string_literal> ) ; } \n <ect>
\t4 . add <identifiersep> <identifier> ( <string_literal> , <string_literal> ) \n \t4 . add <identifiersep> <identifier> ( <string_literal> , <string_literal> , <identifier> <identifiersep> query ( <string_literal> , <string_literal> ) ) \n \t4 . add <identifiersep> <identifier> ( <string_literal> , <string_literal> , <identifier> <identifiersep> query ( <string_literal> , <string_literal> ) ) \n \t4 . add <identifiersep> <identifier> ( <string_literal> , <string_literal> , <identifier> <identifiersep> query ( <string_literal> , <string_literal> ) ) ) ; \n <ect>
\t3 <identifier> <identifiersep> queue <identifier> <identifiersep> queue = command . get <identifiersep> <identifier> <identifiersep> queue ( ) ; \n \t3 if ( <identifier> <identifiersep> queue != null ) { \n \t4 <identifier> <identifiersep> queue . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> id ) ; \n \t3 } else { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t7 to <identifiersep> <identifier> ( m . get <identifiersep> byte ( <string_literal> ) ) , to <identifiersep> <identifier> ( m . get <identifiersep> byte ( <string_literal> ) ) ) ; } \n \t4 logger . debug ( <string_literal> ) ; } \n \t3 logger . debug ( <string_literal> ) ; \n \t2 } catch ( field <identifiersep> exception e ) { \n <ect>
\t4 return <identifier> ( <identifier> <identifiersep> stream ) ; \n \t3 } finally { \n \t4 in . close ( ) ; } \n \t2 } else { \n <ect>
\t4 this . <identifier> <identifiersep> builder = new <identifier> <identifiersep> builder ( <identifier> <identifiersep> manager , <identifier> , false ) ; \n \t3 this . node <identifiersep> id <identifiersep> factory = this . <identifier> <identifiersep> builder . get <identifiersep> node <identifiersep> id <identifiersep> factory ( ) ; \n \t3 logger . info ( <string_literal> ) ; } \n \t2 if ( this . <identifier> <identifiersep> builder . get <identifiersep> <identifier> ( ) != null ) { \n <ect>
\t5 <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n \t5 if ( <identifier> . get ( ) == <number_literal> ) { \n \t6 <identifier> . count <identifiersep> <identifier> ( ) ; } \n \t4 } catch ( throwable e ) { \n <ect>
\t2 final ticket ticket = get <identifiersep> ticket ( ticket <identifiersep> id ) ; \n \t2 if ( ticket != null ) { \n \t3 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket ) ; \n \t3 if ( metadata == null ) { \n <ect>
\t2 public static log <identifiersep> file <identifiersep> location find ( configuration config ) { \n \t3 final string log <identifiersep> <identifier> = <string_literal> ; \n \t3 string log <identifiersep> file <identifiersep> path = system . get <identifiersep> property ( log <identifiersep> <identifier> ) ; \n \t3 if ( log <identifiersep> file <identifiersep> path == null ) { \n <ect>
\t2 <identifier> <identifiersep> function function = null ; \n \t2 try { \n \t3 function = ( <identifier> <identifiersep> function ) <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t4 exchange exchange = create <identifiersep> exchange ( ) ; \n \t4 exchange . get <identifiersep> in ( ) . set <identifiersep> body ( <identifier> <identifiersep> state ) ; \n \t4 <identifier> . process ( exchange ) ; \n \t3 } else { \n <ect>
\t5 do <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> timeout <identifiersep> in <identifiersep> millis / <number_literal> , \n \t7 time <identifiersep> unit . <identifier> ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> log . <identifier> ( <identifier> <identifiersep> dir , <identifier> <identifiersep> dir , <number_literal> ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 super ( message ) ; \n \t2 try { \n \t3 <identifier> = get <identifiersep> string <identifiersep> from <identifiersep> text ( <identifier> <identifiersep> id <identifiersep> <identifier> <identifiersep> <identifier> , message ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> message <identifiersep> exception <identifier> ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> ) { \n \t3 assert <identifiersep> that ( files <identifiersep> to <identifiersep> <identifier> . size ( ) , equal <identifiersep> to ( 0 ) ) ; \n \t3 index . stop ( ) ; \n \t3 assert <identifiersep> that ( index . time ( ) , <identifier> <identifiersep> <identifier> <identifiersep> or <identifiersep> equal <identifiersep> to ( <identifier> ) ) ; } \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 return null ; } \n \t2 final i <identifiersep> <identifier> <identifier> = get <identifiersep> build <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 logger . debug ( <string_literal> , this ) ; \n \t2 shutdown <identifiersep> <identifier> ( true ) ; \n \t2 start ( ) ; } \n \t1 private void start ( ) throws exception { \n <ect>
\t5 logger . info ( <string_literal> \n \t8 + node <identifiersep> id ) ; \n \t4 } catch ( exception ex ) { \n \t5 last <identifiersep> ex = ex ; \n <ect>
\t3 <identifier> <identifiersep> item <identifiersep> <identifier> <identifiersep> final ( <identifier> . <identifier> , false ) ; \n \t3 context <identifiersep> <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n <ect>
\t1 try { \n \t1 new user <identifiersep> service ( ) . create ( new user ( <identifier> , <string_literal> ) ) ; \n \t1 <identifier> ( <string_literal> ) ; \n \t1 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , exchange ) ; \n \t2 message in = exchange . get <identifiersep> in ( ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , in ) ; \n \t2 map < string , object > <identifier> = in . get <identifiersep> <identifier> ( ) ; \n <ect>
\t5 <string_literal> + num <identifiersep> <identifier> <identifiersep> <identifier> . get ( ) + \n \t5 <string_literal> + num <identifiersep> <identifier> <identifiersep> <identifier> . get ( ) ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> byte <identifiersep> <identifier> ) { \n \t4 log . info ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> string ( <string_literal> , <identifier> . <identifier> <identifiersep> first <identifiersep> key <identifiersep> size ) ) ; \n <ect>
\t1 string <identifier> <identifiersep> volume <identifiersep> id = volume <identifiersep> info . get <identifiersep> <identifier> <identifiersep> volume <identifiersep> id ( ) ; \n \t1 log . info ( <string_literal> + <identifier> <identifiersep> volume <identifiersep> id + <string_literal> + node <identifiersep> <identifier> ) ; \n \t1 string <identifier> = connection <identifiersep> manager . <identifier> <identifiersep> resource ( <identifier> <identifiersep> volume <identifiersep> id , node <identifiersep> <identifier> , volume <identifiersep> info . get <identifiersep> <identifier> ( ) ) ; \n \t1 if ( <identifier> == null ) { \n <ect>
\t5 <identifier> <identifiersep> cache . <identifier> <identifiersep> to <identifiersep> local ( remote <identifiersep> db <identifiersep> <identifier> <identifiersep> dir + <string_literal> + <identifier> <identifiersep> file , <identifier> <identifiersep> db <identifiersep> dir ) ; } \n \t4 file <identifiersep> utils . delete <identifiersep> <identifier> ( file ) ; } \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> db ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 if ( this . <identifier> <identifiersep> manager != null ) { \n \t4 command <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> manager . start <identifiersep> new <identifiersep> <identifier> ( total <identifiersep> conf , <identifier> . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> id ) ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> id = default <identifiersep> <identifier> <identifiersep> context . create <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . next ( ) ) ; \n \t6 if ( id != null && id . get <identifiersep> <identifier> <identifiersep> id <identifiersep> <identifier> ( ) != null ) { \n \t7 return id ; } \n \t5 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + network . get <identifiersep> id ( ) ) ; \n \t3 return true ; } \n \t2 if ( network . get <identifiersep> <identifier> <identifiersep> id ( ) == null ) { \n \t3 return super . <identifier> <identifiersep> public <identifiersep> ip ( network , ip <identifiersep> <identifier> , <identifier> ) ; } \n <ect>
\t2 network = <identifier> . network ( <identifier> . get ( ) . network ( ) ) ; \n \t2 options . <identifier> ( <identifier> <identifiersep> set . of ( <identifier> . get ( ) . self <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> . get ( ) . name ( ) , <identifier> ) ; \n \t1 } else { \n <ect>
@ to <identifiersep> string \n public class <identifier> <identifiersep> principal <identifiersep> <identifier> implements principal <identifiersep> <identifier> { \n \t1 @ <identifier> \n \t1 public principal <identifier> ( final <identifier> <identifier> , final principal principal , final authentication <identifiersep> handler handler ) { \n <ect>
\t1 public static <identifier> <identifiersep> config load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> metadata ( ) throws io <identifiersep> exception { \n \t2 file meta <identifiersep> dir = new file ( <string_literal> ) ; \n \t2 if ( ! meta <identifiersep> dir . get <identifiersep> <identifier> <identifiersep> path ( ) . equals ( system . get <identifiersep> property ( <identifier> <identifiersep> config . <identifier> <identifiersep> conf ) ) ) { \n \t3 system . set <identifiersep> property ( <identifier> <identifiersep> config . <identifier> <identifiersep> conf , meta <identifiersep> dir . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n <ect>
<comment> \n protected void <identifier> <identifiersep> transaction <identifiersep> if <identifiersep> <identifier> ( throwable e ) { \n \t1 if ( <identifier> <identifiersep> transaction ) { \n \t1 transaction . <identifier> ( e ) ; \n <ect>
\t2 <identifier> . delete <identifiersep> all <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . start ( ) ; \n \t2 <identifier> . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 try { \n <ect>
\t2 . filter ( <identifier> - > filter . <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ( ) ) ) \n \t2 . <identifier> ( to <identifiersep> collection ( ( ) - > <identifier> <identifiersep> <identifier> ) ) ; } } \n private static boolean <identifier> <identifiersep> <identifier> ( meta <identifiersep> class <identifier> ) { \n \t1 if ( <identifier> . is <identifiersep> interface ( ) ) { \n <ect>
\t2 <comment> \n \t2 log . debug ( <string_literal> + s + <string_literal> ) ; \n \t2 int <identifier> = <identifier> . execute <identifiersep> update ( s ) ; \n \t2 if ( <identifier> < 1 ) { \n <ect>
<identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( self , <identifier> , <identifier> <identifiersep> type = <identifier> ) : \n \t1 import <identifier> \n \t1 <identifier> . set <identifiersep> <identifier> ( <identifier> ) \n \t1 if <identifier> . version and check <identifiersep> stack <identifiersep> <identifier> ( stack <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , <identifier> . version ) : \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> url = new url ( <string_literal> , <string_literal> , request <identifiersep> handler <identifiersep> path ) ; \n \t4 response = response <identifiersep> for <identifiersep> data <identifiersep> <identifier> <identifiersep> url ( <identifier> <identifiersep> url ) ; \n \t3 } catch ( <identifier> <identifiersep> url <identifiersep> exception exception ) { \n <ect>
\t4 <identifier> . add ( new <identifier> <identifiersep> error <identifiersep> update ( <string_literal> + model <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ) ; \n \t4 return ; } } \n \t2 boolean result = <identifier> . get <identifiersep> <identifier> <identifiersep> type <identifiersep> model <identifiersep> handler ( ) . read <identifiersep> model <identifiersep> from <identifiersep> file ( model <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 if ( ! result ) \n <ect>
\t4 try { \n \t5 long new <identifiersep> count = <identifier> <identifiersep> count . get ( ) ; \n <comment> \n <comment> \n <ect>
\t10 query ) ; \n \t5 <identifier> . send <identifiersep> <identifier> ( <identifier> ) ; } } \n \t2 } catch ( runtime <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 for ( string <identifier> <identifiersep> name : <identifier> <identifiersep> <identifier> ) { \n \t3 try { \n \t4 <comment> \n \t4 if ( ! <identifier> <identifiersep> name . <identifier> <identifiersep> <identifier> ( 0 , <identifier> , 0 , <identifier> . length ( ) ) ) { \n <ect>
<comment> \n \t2 final set < string > attributes = new <identifier> <identifiersep> set < > ( ) ; \n \t2 logger . debug ( <string_literal> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( this . principal <identifiersep> id <identifiersep> attribute ) ) { \n <ect>
\t2 <comment> \n \t2 if ( <identifier> <identifiersep> <identifier> ) { \n \t3 if ( logger . is <identifiersep> enabled <identifiersep> for ( level . warn ) ) { \n \t4 long <identifier> <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - node <identifiersep> status . get <identifiersep> start <identifiersep> millis ( ) ; \n <ect>
\t3 result . set <identifiersep> success <identifiersep> is <identifiersep> set ( true ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> to . get <identifiersep> <identifier> <identifiersep> type ( ) == <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> ) { \n \t3 if ( <identifier> <identifiersep> to . get <identifiersep> <identifier> <identifiersep> uri ( ) != null ) { \n \t4 return <identifier> <identifiersep> to . get <identifiersep> <identifier> <identifiersep> uri ( ) . get <identifiersep> host ( ) ; \n \t3 } else { \n <ect>
\t1 return true ; } \n @ <identifier> \n public void <identifier> <identifiersep> and <identifiersep> close ( <identifier> <identifiersep> <identifier> <identifier> ) { \n \t1 <identifier> <identifiersep> <identifier> . close ( ) ; \n <ect>
\t4 logger . debug ( <string_literal> , <identifier> ) ; } \n \t3 throw <identifier> ; \n \t2 } catch ( exception <identifier> ) { \n <ect>
\t9 . to <identifiersep> string ( ) ; } \n \t6 if ( error <identifiersep> <identifier> != null && error <identifiersep> <identifier> . equals ( this . <identifier> <identifiersep> session ) ) { \n \t7 this . <identifier> ( ) ; \n \t6 } else if ( error <identifiersep> <identifier> != null ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t5 <identifier> <identifiersep> <identifier> = true ; } } } \n \t2 private void do <identifiersep> run ( ) throws io <identifiersep> exception , <identifier> <identifiersep> exception { \n \t3 string line = <identifier> <identifiersep> <identifier> . read <identifiersep> line ( ) ; \n <ect>
\t7 <comment> \n \t7 log . info ( log . <identifier> <identifiersep> test , <string_literal> + <identifier> . name ( ) + <string_literal> + <identifier> <identifiersep> content + \n \t8 <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> last <identifiersep> version <identifiersep> as <identifiersep> long ( <identifier> . name ( ) ) + <string_literal> ) ; \n \t6 } else { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> ( ) ; \n \t3 task . run ( ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 <string_literal> : <string_literal> } } \n <identifier> \n <identifier> <identifier> <identifier> <identifier> : \n <identifier> \n <ect>
\t7 <identifier> . write <identifiersep> all ( out <identifiersep> file , <identifier> . get <identifiersep> input <identifiersep> stream ( ) ) ; \n \t7 out <identifiersep> file . close ( ) ; } } } \n \t4 <identifier> <identifiersep> count ++ ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 final <identifier> <identifiersep> security <identifiersep> authentication <identifiersep> service <identifier> <identifiersep> authentication <identifiersep> service = get <identifiersep> <identifier> <identifiersep> authentication <identifiersep> service ( ) ; \n \t3 final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> c = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class . <identifier> ( <identifier> ) ; \n \t3 if ( <identifier> <identifiersep> authentication <identifiersep> service . <identifier> ( c ) . get <identifiersep> key ( ) ) { \n \t4 final principal principal = c . get <identifiersep> authentication ( ) . get <identifiersep> principal ( ) ; \n <ect>
\t1 protected static void log <identifiersep> <identifier> ( ) { \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( false ) ; \n \t2 try { \n \t3 queue . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> manager = <identifier> <identifiersep> manager . <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , \n \t6 <string_literal> + new <identifier> ( ) . to <identifiersep> string ( ) ) ; \n \t4 <identifier> <identifiersep> <identifier> . put ( <identifier> , <identifier> <identifiersep> manager ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 protected void log <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final <identifier> <identifier> ) { \n \t2 logger . debug ( <string_literal> , <identifier> . is <identifiersep> <identifier> ( ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> . get <identifiersep> principal ( ) . get <identifiersep> name ( ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> . get <identifiersep> authentication <identifiersep> date ( ) ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 if ( method . is <identifiersep> <identifier> ( ) && <identifier> <identifiersep> remove <identifiersep> files ) { \n \t4 if ( <identifier> <identifiersep> file . get <identifiersep> type ( ) == resource . type . resource ) { \n \t5 if ( ! <identifier> <identifiersep> file . <identifier> ( ) . delete ( ) ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t1 logger . debug ( <string_literal> + <identifier> <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) + <string_literal> + <identifier> <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t1 if ( ! <identifier> <identifiersep> file . exists ( ) ) { \n \t2 try { \n \t2 if ( <identifier> <identifiersep> file . is <identifiersep> file ( ) ) { \n <ect>
\t2 metadata <identifiersep> provider . set <identifiersep> id ( metadata <identifiersep> provider . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 build <identifiersep> metadata <identifiersep> <identifier> ( service , metadata <identifiersep> provider , metadata <identifiersep> filter <identifiersep> list ) ; \n \t2 logger . debug ( <string_literal> , service . get <identifiersep> metadata <identifiersep> location ( ) ) ; \n \t2 metadata <identifiersep> provider . <identifier> ( ) ; \n <ect>
\t6 get <identifiersep> channel ( ) . send ( <identifier> , msg , get <identifiersep> channel <identifiersep> send <identifiersep> options ( ) ) ; } \n \t5 entry . set <identifiersep> <identifier> <identifiersep> nodes ( <identifier> ) ; \n \t5 if ( map <identifiersep> <identifier> != null ) map <identifiersep> <identifier> . object <identifiersep> <identifier> <identifiersep> <identifier> ( entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; \n \t4 } catch ( channel <identifiersep> exception x ) { \n <ect>
\t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n \t6 <identifier> <identifiersep> log . warn ( <string_literal> + <identifier> . to <identifiersep> string ( ) ) ; } \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 private void send <identifiersep> message ( <identifier> node <identifiersep> id , grid <identifiersep> cache <identifiersep> message < <identifier> , v > msg ) { \n \t2 try { \n \t3 <identifier> . io ( ) . send ( node <identifiersep> id , msg ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> > 0 ) { \n \t4 read = read . <identifier> ( 0 , <identifier> <identifiersep> <identifier> ) ; } \n \t3 int value = integer . value <identifiersep> of ( read . <identifier> ( ) ) * - 1 ; \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t1 if ( db <identifiersep> <identifier> == null ) { \n \t2 db <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> factory . get <identifiersep> <identifier> ( conf ) ; \n \t2 <identifier> = db <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( conf , <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t1 if ( <identifier> . has <identifiersep> next ( ) ) { \n <ect>
\t2 } else if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . equals ( <identifier> ) ) { \n \t3 return string . format ( <string_literal> \n \t5 + <string_literal> , <identifier> <identifiersep> name , <identifier> <identifiersep> name ) ; \n \t2 } else { \n <ect>
\t4 result = this . get <identifiersep> protected <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> , <identifier> , this . context ) ; \n \t3 } else { \n \t4 result = <identifier> <identifiersep> operation <identifiersep> result . not <identifiersep> <identifier> ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t4 <identifier> = create <identifiersep> <identifier> ( <identifier> ) ; \n \t4 if ( <identifier> != null ) { \n \t5 this . <identifier> <identifiersep> cache . put ( <identifier> , <identifier> ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t1 private boolean is <identifiersep> empty ( ) { \n \t2 return this . <identifier> . is <identifiersep> empty ( ) ; } \n \t1 private authentication build <identifiersep> authentication ( ) { \n \t2 if ( is <identifiersep> empty ( ) ) { \n <ect>
<comment> \n \t1 protected void process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( logger . is <identifiersep> <identifier> ( level . info ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . add ( out <identifiersep> <identifier> [ <identifier> ] ) ; \n \t2 } else if ( ! <identifier> . <identifier> ( out <identifiersep> <identifier> [ <identifier> ] , final <identifiersep> <identifier> [ <identifier> ] ) ) { \n \t3 file <identifiersep> status file <identifiersep> status = file <identifiersep> utils . get <identifiersep> file <identifiersep> status <identifiersep> or <identifiersep> null ( <identifier> , final <identifiersep> <identifier> [ <identifier> ] ) ; \n \t3 if ( file <identifiersep> status != null ) { \n <ect>
\t1 public i <identifiersep> <identifier> <identifiersep> attributes get <identifiersep> <identifier> ( final string <identifier> ) { \n \t2 final <identifier> <identifiersep> query <identifiersep> result result = <identifier> . query ( <identifier> <identifiersep> properties . get <identifiersep> <identifier> <identifiersep> attribute ( ) , <identifier> ) ; \n \t2 final map < string , ? > attributes ; \n \t2 if ( result . all <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t3 output <identifiersep> stream out = s . get <identifiersep> output <identifiersep> stream ( ) ; \n \t3 out . write ( data <identifiersep> <identifier> . get <identifiersep> <identifier> ( <string_literal> ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( s . get <identifiersep> input <identifiersep> stream ( ) ) ) ; \n \t3 string line = <identifier> . read <identifiersep> line ( ) ; \n <ect>
\t5 <comment> \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> store store = <identifier> <identifiersep> <identifier> <identifiersep> store . get <identifiersep> if <identifiersep> exists ( <identifier> . <identifier> , <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t5 if ( store == null ) \n \t5 { \n <ect>
\t3 } else if ( <identifier> <identifiersep> <identifier> ) { \n \t4 logger . info ( <string_literal> ) ; \n \t4 this . <identifier> <identifiersep> transaction ( read <identifiersep> write . write ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 public void <identifier> ( string body ) { \n \t3 <identifier> ( <string_literal> + body ) ; } \n \t2 public void <identifier> ( @ <identifier> ( <string_literal> ) string <identifier> ) { \n \t3 this . <identifier> = <identifier> ; \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; } \n \t2 } else { \n <ect>
\t2 assert <identifiersep> <identifier> <identifiersep> count ( handle <identifiersep> a , handle <identifiersep> <identifier> , <number_literal> ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> count ( handle <identifiersep> a , handle <identifiersep> c , 0 ) ; <comment> \n \t2 assert <identifiersep> <identifier> <identifiersep> count ( handle <identifiersep> a , handle <identifiersep> <identifier> , 0 ) ; <comment> \n \t2 <comment> \n <ect>
\t1 if ( ! <identifier> . <identifier> ( timeout , time <identifiersep> unit . <identifier> ) ) { \n \t2 logger . error ( <string_literal> + \n \t3 <string_literal> ) ; } \n \t1 } catch ( exception ex ) { \n <ect>
\t2 logger . debug ( <string_literal> + event . get <identifiersep> metadata ( ) + <string_literal> + event . get <identifiersep> file ( ) ) ; } \n \t1 public void metadata <identifiersep> <identifier> ( <identifier> <identifiersep> event event ) { \n \t2 logger . debug ( <string_literal> + event . get <identifiersep> metadata ( ) ) ; } \n \t1 public void metadata <identifiersep> <identifier> ( <identifier> <identifiersep> event event ) { \n <ect>
\t2 try { \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> device <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> network ( network ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t4 logger . warn ( <string_literal> ) ; \n \t4 number <identifiersep> of <identifiersep> shards = <string_literal> ; } \n \t3 string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> utils . get <identifiersep> as <identifiersep> string <identifiersep> value ( root , p <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 if ( count <identifiersep> of <identifiersep> <identifier> <identifiersep> type == null ) { \n \t3 logger . error ( <string_literal> ) ; \n \t3 return <identifier> ; } \n \t2 if ( <identifier> <identifiersep> uri == null || <identifier> <identifiersep> uri . is <identifiersep> empty ( ) ) { \n <ect>
\t4 logger . debug ( <string_literal> , result . get <identifiersep> id ( ) ) ; \n \t4 map . remove ( <identifier> <identifiersep> ticket <identifiersep> id ) ; \n \t4 return null ; } \n \t3 return result ; } \n <ect>
\t1 public list < <identifier> <identifiersep> <identifier> > get <identifiersep> <identifier> ( long time <identifiersep> start , long time <identifiersep> end <identifiersep> <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 try { \n \t3 return store . get <identifiersep> all <identifiersep> <identifier> ( resource <identifiersep> store . execute <identifiersep> resource <identifiersep> root , time <identifiersep> start , time <identifiersep> end <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> . class , job <identifiersep> <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 m <identifiersep> bean <identifiersep> server <identifier> = <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifiersep> server ( ) ; \n \t2 string <identifier> = get <identifiersep> <identifier> <identifiersep> name ( <identifier> ) ; \n \t2 set < object <identifiersep> name > s = <identifier> . query <identifiersep> <identifier> ( new object <identifiersep> name ( <identifier> + <string_literal> ) , null ) ; \n \t2 if ( s . size ( ) > 0 ) { \n <ect>
\t3 <identifier> . close ( ) ; \n \t3 system . set <identifiersep> property ( <string_literal> , \n \t5 <identifier> <identifiersep> conf <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 stop ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> group ) ) { \n \t3 log . debug ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t4 public void handle <identifiersep> throwable ( security <identifiersep> context security <identifiersep> context , throwable t , abstract <identifiersep> <identifier> <identifier> ) { \n \t5 logger . warn ( <string_literal> , new object [ ] { <identifier> . get <identifiersep> <identifier> ( ) , t . get <identifiersep> message ( ) } ) ; } \n \t4 @ <identifier> \n \t4 public void handle <identifiersep> transaction <identifiersep> failure ( security <identifiersep> context security <identifiersep> context , throwable t ) { \n <ect>
\t2 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> property <identifiersep> <identifier> <identifiersep> event <identifier> ) \n \t2 { \n \t3 synchronized ( this ) \n \t3 { \n <ect>
\t7 <string_literal> + \n \t7 <string_literal> + <identifier> . null ; \n \t2 <identifier> <identifiersep> connection . send <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 string <identifier> = <identifier> <identifiersep> connection . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 <identifier> <identifiersep> count ++ ; } \n \t1 <identifier> <identifiersep> table . <identifier> ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t5 { \n \t6 client . <identifier> ( new authentication <identifiersep> request ( <identifier> ) ) ; } \n \t5 catch ( authentication <identifiersep> exception e ) \n \t5 { \n <ect>
\t3 for ( <identifier> <identifiersep> <identifier> <identifiersep> service service : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 try { \n \t5 service . shutdown ( ) ; \n \t4 } catch ( exception ex ) { \n <ect>
\t5 thread . <identifier> ( <identifier> ) ; \n \t4 } catch ( interrupted <identifiersep> exception <identifier> ) { \n \t5 log . debug ( <string_literal> + <identifier> ) ; } } \n \t3 consumer . close ( ) ; \n <ect>
\t3 try { \n \t4 if ( bean . is <identifiersep> <identifier> ( ) ) { \n \t5 if ( bean instanceof <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> resource first <identifiersep> resource <identifiersep> <identifier> = get <identifiersep> default <identifiersep> file <identifiersep> or <identifiersep> self ( first <identifiersep> resource ) ; \n \t3 <identifier> <identifiersep> resource <identifier> <identifiersep> resource <identifiersep> <identifier> = get <identifiersep> default <identifiersep> file <identifiersep> or <identifiersep> self ( <identifier> <identifiersep> resource ) ; \n \t3 if ( ( first <identifiersep> resource <identifiersep> <identifier> == null ) || ( <identifier> <identifiersep> resource <identifiersep> <identifier> == null ) ) { \n <ect>
\t4 <identifier> . <identifier> ( ) ; \n \t4 log . info ( <string_literal> ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t5 <identifier> . <identifier> ( ) ; \n <ect>
\t2 } else { \n \t3 if ( endpoint . get <identifiersep> <identifier> ( ) != null ) { \n \t4 endpoint . get <identifiersep> <identifier> ( ) . <identifier> ( endpoint . get <identifiersep> <identifier> <identifiersep> name ( ) , new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( endpoint . get <identifiersep> <identifier> ( ) ) ) ; \n \t3 } else { \n <ect>
\t5 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> instance <identifiersep> name ( ) , <identifier> . get <identifiersep> host ( ) . get <identifiersep> name ( ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> answer <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> answer ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send ( <identifier> <identifiersep> server <identifiersep> id , cmd ) ; \n \t3 return <identifier> . get <identifiersep> result ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 string key = entry . get <identifiersep> key ( ) ; \n \t2 string value = entry . get <identifiersep> value ( ) ; \n \t2 conf . set ( key , value ) ; } \n \t1 } else { \n <ect>
\t3 <identifier> . add ( new <identifier> <identifiersep> name <identifiersep> value <identifiersep> <identifier> ( <string_literal> , get <identifiersep> <identifier> <identifiersep> type ( <identifier> ) ) ) ; } \n \t2 http <identifiersep> <identifier> . set <identifiersep> entity ( new url <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> entity ( <identifier> ) ) ; \n \t2 try ( <identifier> <identifiersep> http <identifiersep> response <identifier> = <identifier> . execute ( http <identifiersep> <identifier> ) ) { \n \t3 <comment> \n <ect>
<comment> \n \t1 <comment> void add <identifiersep> <identifier> <identifiersep> command ( <identifier> <identifiersep> <identifier> <identifiersep> info < ? > command ) { \n \t2 if ( ! all <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( command ) ) { \n \t3 <comment> \n <ect>
\t4 <comment> \n \t4 input <identifiersep> format <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> ( c . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , null ) ) ; \n \t4 break ; \n \t3 default : \n <ect>
\t1 private void do <identifiersep> handle <identifiersep> <identifier> <identifiersep> from <identifiersep> client ( final map < string , string > message , string uri , final object <identifier> <identifiersep> channel ) { \n \t2 try { \n \t3 if ( debug ) logger . info ( <string_literal> , message ) ; \n \t3 final data <identifiersep> store <identifiersep> request data <identifiersep> store <identifiersep> request = create <identifiersep> request ( message ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . add ( <string_literal> ) ; \n \t2 boolean status = true ; \n \t2 if ( ! ( event <identifiersep> list . size ( ) == <identifier> <identifiersep> <identifier> . size ( ) ) ) { \n \t3 status = false ; \n <ect>
\t2 if ( connection == null ) \n \t3 return ; \n \t2 try { \n \t3 connection . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> sql ) . execute ( ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> ( null , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> out ) ; \n \t3 return ; } \n \t2 <identifier> <identifiersep> request <identifier> = new <identifier> <identifiersep> request ( ) ; \n \t2 <identifier> . <identifier> ( destination <identifiersep> <identifier> . to <identifiersep> array ( new string [ destination <identifiersep> <identifier> . size ( ) ] ) ) ; \n <ect>
\t3 logger . info ( <string_literal> + store <identifiersep> name \n \t6 + <string_literal> + <identifier> <identifiersep> version <identifiersep> dir + <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 response . set <identifiersep> error ( <identifier> <identifiersep> utils . <identifier> <identifiersep> error ( error <identifiersep> code <identifiersep> <identifier> , e ) ) ; \n <ect>
\t4 table <identifiersep> name , table <identifiersep> size <identifiersep> in <identifiersep> <identifier> , table <identifiersep> size <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; \n \t2 } else { \n \t2 throw new exception ( ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + cmd . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <string_literal> + host <identifiersep> <identifier> . get <identifiersep> host <identifiersep> name ( ) ) ; } \n \t3 return new answer ( cmd , true , <string_literal> + cmd . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( exception e ) { \n \t3 if ( e instanceof remote <identifiersep> exception ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } } \n private class log <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task extends <identifier> <identifiersep> task { \n \t1 @ <identifier> \n \t1 public void run ( ) { \n <ect>
\t1 cluster <identifiersep> entity . set <identifiersep> security <identifiersep> type ( security <identifiersep> type ) ; } \n \t1 try { \n \t1 cluster <identifiersep> dao . create ( cluster <identifiersep> entity ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 if ( this . client != null ) { \n \t4 this . client . on <identifiersep> failure ( new <identifier> <identifiersep> exception ( <identifier> <identifiersep> exception <identifiersep> mode . <identifier> <identifiersep> error , e , null ) , this ) ; } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 string <identifier> = key . <identifier> ( service <identifiersep> name . length ( ) + 1 ) ; \n \t4 try { \n \t5 <comment> \n \t5 bean <identifiersep> <identifier> . set <identifiersep> property <identifiersep> value ( <identifier> , config . get <identifiersep> property ( key ) ) ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
# end \n # if ( ! ( <identifier> . user <identifiersep> info . <identifier> <identifiersep> <identifier> ) ) \n public void <identifier> { attribute . <identifier> <identifiersep> name } ( <identifier> . java <identifiersep> class <identifiersep> name value ) { \n <ect>
\t6 log . info ( <string_literal> + grid ) ; \n \t6 log . info ( <string_literal> + node <identifiersep> id ) ; \n \t6 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t1 protected principal create <identifiersep> principal ( final string <identifier> , final <identifier> <identifiersep> entry <identifier> <identifiersep> entry ) throws <identifier> <identifiersep> exception { \n \t2 logger . debug ( <string_literal> , <identifier> , <identifier> <identifiersep> entry . get <identifiersep> <identifier> ( ) , \n \t3 <identifier> <identifiersep> entry . get <identifiersep> attribute <identifiersep> <identifier> ( ) ) ; \n \t2 final string id = get <identifiersep> <identifier> <identifiersep> principal <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> entry ) ; \n <ect>
\t6 socket <identifiersep> channel . <identifier> ( <identifier> , <identifier> <identifiersep> key . <identifier> <identifiersep> read , <identifier> ) ; \n \t6 <identifier> . add <identifiersep> connection ( ) ; } \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> volume <identifiersep> <identifier> ( <identifier> <identifiersep> volume ) ; \n \t5 <identifier> <identifiersep> <identifier> . get ( ) ; } \n \t4 <identifier> . <identifier> ( <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 public string get <identifiersep> <identifier> <identifiersep> config ( string <identifier> <identifiersep> config , collection < job <identifiersep> <identifier> > <identifier> ) throws failed <identifiersep> job <identifiersep> <identifier> <identifiersep> exception { \n \t2 return job <identifiersep> <identifier> . <identifier> <identifiersep> job ( <identifier> <identifiersep> config , <identifier> ) ; } \n \t1 public void write <identifiersep> update <identifiersep> if <identifiersep> data <identifiersep> not <identifiersep> null ( string path , string data ) throws exception { \n \t2 if ( data == null ) { \n <ect>
\t5 logger . warn ( <string_literal> { } \\ <string_literal> , type <identifiersep> string ) ; \n \t5 return error <identifiersep> message <identifiersep> find <identifiersep> <identifier> <identifiersep> type <identifiersep> not <identifiersep> found + type <identifiersep> string ; } } \n \t3 <comment> \n \t3 if ( type == null ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 string service <identifiersep> name = find <identifiersep> service <identifiersep> name ( cluster , request . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( service <identifiersep> name ) ) { \n <ect>
\t1 map < string , <identifier> < string , string > > cluster <identifiersep> service <identifiersep> config <identifiersep> type = new <identifier> <identifiersep> map < > ( ) ; \n \t1 result <identifiersep> set <identifier> = null ; \n \t1 <identifier> <identifier> = null ; \n \t1 <identifier> <identifiersep> connection ( ) ; \n <ect>
\t2 final string <identifier> <identifiersep> <identifier> = <identifier> == null ? null : <identifier> . first ( ) ; \n \t2 boolean update <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> = false ; \n \t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t3 if ( cmd . get <identifiersep> <identifier> <identifiersep> num ( ) > <identifier> <identifiersep> <identifier> ) { \n <ect>
\t5 <identifier> . <identifier> ( ) ; } \n \t3 } ) ; \n \t2 } catch ( final resource <identifiersep> io <identifiersep> exception ex ) { \n <ect>
\t1 <identifier> <identifier> <identifiersep> blank <identifiersep> <identifier> ( self ) : \n \t2 new <identifiersep> body = [ ] \n \t2 for <identifier> in self . file <identifiersep> body [ 0 : <number_literal> ] : \n \t3 if self . is <identifiersep> <identifier> <identifiersep> line ( <identifier> ) and <identifier> . <identifier> ( ) . <identifier> ( self . <identifier> <identifiersep> <identifier> ) . <identifier> ( ) . <identifier> ( ' \\ <identifier> ) == <string_literal> : \n <ect>
\t3 query . add <identifiersep> <identifier> ( <identifier> . <identifier> ( <string_literal> ) . <identifier> ( on <identifiersep> or <identifiersep> <identifier> ) ) ; \n \t3 final write <identifiersep> result <identifier> = this . <identifier> <identifiersep> template . remove ( query , <identifier> <identifiersep> authentication <identifiersep> <identifier> <identifiersep> <identifier> . class , this . collection <identifiersep> name ) ; \n \t3 logger . info ( <string_literal> , <identifier> . get <identifiersep> n ( ) ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t3 assert <identifiersep> that ( client ( ) . <identifier> <identifiersep> get ( <string_literal> , <string_literal> , <string_literal> ) . set <identifiersep> routing ( routing <identifiersep> value ) . execute ( ) . action <identifiersep> get ( ) . is <identifiersep> exists ( ) , equal <identifiersep> to ( true ) ) ; } \n \t2 logger . info ( <string_literal> ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 assert <identifiersep> that ( client ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> query ( query <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> query ( ) ) . execute ( ) . action <identifiersep> get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; } \n <ect>
\t3 } else { \n \t4 log . info ( <string_literal> ) ; \n \t4 <identifier> . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t1 if ( ! task <identifiersep> <identifier> . contains <identifiersep> key ( key ) ) { \n \t1 log . warn ( <string_literal> + key + <string_literal> ) ; \n \t1 return ; } \n \t1 try { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = create <identifiersep> <identifier> ( <string_literal> , <string_literal> , new string [ ] { <string_literal> , <string_literal> } , network <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . start ( ) ; \n \t2 do <identifiersep> test <identifiersep> network <identifiersep> send <identifiersep> <identifier> ( <identifier> <identifiersep> a , <identifier> <identifiersep> <identifier> ) ; \n \t2 do <identifiersep> test <identifiersep> network <identifiersep> send <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> a ) ; \n <ect>
\t2 string <identifier> = <string_literal> ; \n \t2 if ( <identifier> . size ( ) == 0 ) \n \t2 { \n \t3 <comment> \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 try ( string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ) { \n \t3 this . json <identifiersep> <identifier> . to ( <identifier> , <identifier> ) ; \n \t3 <identifier> . add ( new <identifier> <identifiersep> attribute ( <identifier> . get <identifiersep> service <identifiersep> <identifier> <identifiersep> attribute ( ) , <identifier> . to <identifiersep> string ( ) ) ) ; \n \t3 <identifier> . add ( new <identifier> <identifiersep> attribute ( <identifier> <identifiersep> utils . object <identifiersep> class <identifiersep> attribute , <string_literal> , <identifier> . get <identifiersep> object <identifiersep> class ( ) ) ) ; } \n <ect>
<comment> \n <comment> \n private <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( a : <identifier> , <identifier> : <identifier> , r : <identifier> [ <identifier> ] = <identifier> ) = { \n \t1 <comment> \n <ect>
<comment> \n \t2 private boolean <identifier> <identifiersep> all ( map < <identifier> < <identifier> <identifiersep> key , boolean > , <identifier> < integer , set < <identifier> <identifiersep> context > > > <identifier> <identifiersep> to <identifiersep> <identifier> ) { \n \t3 boolean files <identifiersep> to <identifiersep> <identifier> = false ; \n \t3 if ( ! conf . get <identifiersep> boolean ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> enabled , <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> by <identifiersep> default ) ) { \n <ect>
\t3 } catch ( <identifier> <identifiersep> failed <identifiersep> exception | runtime <identifiersep> exception e ) { \n \t4 log . warn ( <string_literal> , e ) ; \n \t4 if ( success ) { \n \t5 throw e ; } } } \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> <identifiersep> index ( 0 ) ; } \n \t2 <identifier> . add <identifiersep> item <identifiersep> listener ( new item <identifiersep> listener ( ) { \n \t3 public void item <identifiersep> state <identifiersep> <identifier> ( item <identifiersep> event e ) { \n \t4 if ( e . get <identifiersep> state <identifiersep> <identifier> ( ) == item <identifiersep> event . <identifier> ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t3 <identifier> <identifiersep> source <identifiersep> <identifier> . class , <identifier> <identifiersep> <identifier> ) ; } \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> event <identifier> <identifiersep> event = new <identifier> <identifiersep> <identifier> <identifiersep> event ( ) ; \n \t1 <identifier> <identifiersep> event . set <identifiersep> <identifier> ( new <identifier> <identifiersep> map < char <identifiersep> <identifier> , char <identifiersep> <identifier> > ( ) ) ; \n \t1 <identifier> <identifiersep> event . set <identifiersep> body ( byte <identifiersep> <identifier> . <identifier> ( <string_literal> . get <identifiersep> bytes ( ) ) ) ; \n <ect>
\t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n \t4 return <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> count ( ) == 0 ; } \n \t2 } ) ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , 0 , <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> count ( ) ) ; \n <ect>
\t7 <string_literal> ) ; \n \t5 if ( <identifier> <identifiersep> value == - 1 ) { \n \t6 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t5 } else if ( <identifier> <identifiersep> value == - <number_literal> && ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t6 target <identifiersep> <identifier> , <identifier> <identifiersep> short <identifiersep> <identifier> ) ; } \n \t4 else \n \t4 { \n \t5 <comment> \n <ect>
\t2 else { \n \t3 final string routing <identifiersep> key = this . <identifier> <identifiersep> <identifier> <identifiersep> routing <identifiersep> key ( message ) ; \n \t3 this . error <identifiersep> template . send ( routing <identifiersep> key , message ) ; \n <ect>
\t1 { \n \t2 logger . info ( <string_literal> , <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> version <identifiersep> string ( ) ) ; \n \t2 logger . info ( <string_literal> , \n \t4 string <identifiersep> utils . <identifier> ( client <identifiersep> state . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> version ( ) , <string_literal> ) , client <identifiersep> state . default <identifiersep> <identifier> <identifiersep> version ) ; \n <ect>
\t3 } else { \n \t4 principal <identifiersep> manager = ( ( <identifier> <identifiersep> session ) session ) . get <identifiersep> principal <identifiersep> manager ( ) ; } \n \t3 <identifier> = true ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 } else { \n <comment> \n \t3 user <identifiersep> account <identifier> = <identifier> <identifiersep> account <identifiersep> service . get <identifiersep> <identifier> <identifiersep> user <identifiersep> account ( user . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> id ( ) ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t2 return ! resource <identifiersep> url . to <identifiersep> string ( ) . <identifier> <identifiersep> with ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( filter <identifiersep> <identifier> filter <identifiersep> <identifier> , http <identifiersep> <identifier> <identifiersep> request request , \n \t3 http <identifiersep> <identifier> <identifiersep> response response ) throws io <identifiersep> exception , <identifier> <identifiersep> exception { \n <ect>
\t3 final object attribute <identifiersep> value = attributes <identifiersep> to <identifiersep> <identifier> . get ( attribute <identifiersep> name ) ; \n \t3 if ( attribute <identifiersep> value == null ) { \n \t4 logger . debug ( <string_literal> , attribute <identifiersep> name , principal . get <identifiersep> id ( ) ) ; \n \t4 continue ; } \n <ect>
\t4 if ( wait <identifiersep> <identifier> != null ) { \n \t5 if ( wait <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t6 log . info ( <string_literal> ) ; \n \t5 } else { \n <ect>
\t1 <identifier> total <identifiersep> cluster <identifiersep> <identifier> > <number_literal> and total <identifiersep> cluster <identifiersep> <identifier> < = <number_literal> : \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> <identifier> <identifiersep> <identifier> = <number_literal> \n \t1 <identifier> total <identifiersep> cluster <identifiersep> <identifier> > <number_literal> : \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> <identifier> <identifiersep> <identifier> = <number_literal> \n <ect>
\t2 try { \n \t3 <identifier> . stop ( stop <identifiersep> timeout <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; \n \t2 } catch ( exception e ) { \n \t3 <comment> \n <ect>
\t5 <identifier> <identifiersep> <identifier> . read <identifiersep> from ( client <identifiersep> socket ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t6 <identifier> <identifiersep> bytes = <identifier> <identifiersep> <identifier> . to <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t4 <identifier> <identifiersep> error <identifiersep> handler . handle <identifiersep> error ( this , <identifier> <identifiersep> error <identifiersep> handler . <identifier> <identifiersep> timeout <identifiersep> exception , e ) ; \n \t3 } catch ( not <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 <identifier> <identifiersep> error <identifiersep> handler . handle <identifiersep> error ( this , <identifier> <identifiersep> error <identifiersep> handler . <identifier> <identifiersep> not <identifiersep> connection <identifiersep> exception , e ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 <identifier> < string > <identifier> = <identifier> . <identifier> ( ) ; \n \t2 while ( <identifier> . has <identifiersep> next ( ) ) { \n \t3 string path = <identifier> . next ( ) ; \n \t3 if ( <identifier> <identifiersep> file <identifiersep> <identifier> . remove <identifiersep> <identifier> <identifiersep> <identifier> ( path ) . equals ( <identifier> <identifiersep> file <identifiersep> <identifier> . remove <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) ) { \n <ect>
\t4 return principal ; } \n \t3 final <identifier> <identifiersep> registered <identifiersep> service <identifier> <identifiersep> service = ( <identifier> <identifiersep> registered <identifiersep> service ) registered <identifiersep> service ; \n \t3 <identifier> . <identifier> <identifiersep> all ( <identifier> <identifiersep> service . get <identifiersep> <identifier> ( ) ) ; \n \t3 final map < string , object > attributes = filter <identifiersep> attributes <identifiersep> by <identifiersep> <identifier> ( <identifier> , principal , service , <identifier> <identifiersep> service , access <identifiersep> token ) ; \n <ect>
<comment> \n \t1 public void <identifier> ( state new <identifiersep> state , state <identifiersep> <identifier> <identifiersep> type <identifier> <identifiersep> type ) { \n <ect>
\t5 final byte <identifiersep> array <identifiersep> output <identifiersep> stream <identifier> = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; \n \t5 <identifier> . write ( <identifier> ) ; \n \t5 return <identifier> . to <identifiersep> string ( <string_literal> ) ; \n \t4 } catch ( throwable t ) { \n <ect>
\t5 try { \n \t6 <identifier> <identifier> = do <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> file , find <identifiersep> <identifier> <identifiersep> class <identifiersep> <identifier> ( <identifier> <identifiersep> file ) ) ; \n \t6 result . add ( <identifier> ) ; \n \t5 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> exception e ) { \n <ect>
<number_literal> final object [ ] <identifier> , \n <number_literal> final class < t > <identifier> <identifiersep> type ) { \n \t2 try { \n \t3 if ( resource == null ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> dir ( ) ; \n \t1 run ( <string_literal> + db <identifiersep> name + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id , <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> result ( 0 , 0 , <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> id = get <identifiersep> result ( 0 , 1 , true , <identifier> ) ; \n <ect>
\t4 try { \n \t5 lock <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . this . <identifier> <identifiersep> event <identifiersep> <identifier> . <identifier> <identifiersep> on <identifiersep> <identifier> ( \n \t7 lock <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . this , this . context , this . lock <identifiersep> key ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n <ect>
\t3 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; \n \t3 assert . <identifier> ( ) ; } \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 public void test <identifiersep> get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t1 { \n \t2 if ( in <identifiersep> value == null ) \n \t2 { \n \t3 <comment> \n <ect>
\t2 close <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> device <identifiersep> exception e ) { \n <ect>
\t7 <identifier> = data <identifiersep> type . <identifier> ( <identifier> . result , <identifier> . result ) ; \n \t7 if ( <identifier> != 0 ) { \n \t8 return <identifier> ; } } } \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 logger . debug ( <string_literal> , new object [ ] { user . get <identifiersep> name ( ) , file <identifiersep> system <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> directory ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) , file <identifiersep> system <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> directory ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) } ) ; \n \t3 <identifier> . success ( ) ; \n \t3 return file <identifiersep> system <identifiersep> <identifier> ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 string <identifier> = command <identifiersep> <identifier> . run <identifiersep> action ( <string_literal> ) . get <identifiersep> output ( ) ; \n \t3 integer <identifier> <identifiersep> status = <identifier> . try <identifiersep> parse ( command <identifiersep> <identifier> . run <identifiersep> action ( <string_literal> ) . get <identifiersep> output ( ) . <identifier> ( ) ) ; \n \t3 <identifier> = new <identifier> <identifiersep> response ( <identifier> , <identifier> , <identifier> <identifiersep> status == null ? integer . value <identifiersep> of ( - 1 ) : <identifier> <identifiersep> status ) ; \n \t2 } while ( ! is <identifiersep> <identifier> ( ) && <identifier> . get <identifiersep> <identifier> <identifiersep> status ( ) == - 1 ) ; \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t4 logger . debug ( <string_literal> ) ; \n \t3 } else { \n \t4 logger . debug ( <string_literal> , default <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> thread ) ; \n <ect>
\t3 <identifier> . <identifier> ( output . get <identifiersep> file <identifiersep> on <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 <identifier> . close ( ) ; \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 synchronized ( file <identifiersep> handle ) { \n \t3 try { \n \t4 file <identifiersep> handle . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 if ( this . <identifier> <identifiersep> method == <identifier> <identifiersep> method . <identifier> <identifiersep> <identifier> && ! is <identifiersep> <identifier> ( <identifier> ) ) \n \t2 { \n <ect>
\t4 return <identifier> <identifiersep> factory ; \n \t3 } catch ( <identifier> <identifiersep> security <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> , port , e ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 } catch ( throwable e ) { \n \t4 if ( utils . exception <identifiersep> <identifier> <identifiersep> is <identifiersep> instance <identifiersep> of ( <identifier> <identifiersep> exception . class , e ) ) { \n \t5 throw new runtime <identifiersep> exception ( e ) ; \n \t4 } else { \n <ect>
\t3 public void handle <identifiersep> throwable ( security <identifiersep> context security <identifiersep> context , throwable t , abstract <identifiersep> node node ) { \n \t4 logger . warn ( <string_literal> , new object [ ] { node , t . get <identifiersep> message ( ) } ) ; } \n \t3 @ <identifier> \n \t3 public void handle <identifiersep> transaction <identifiersep> failure ( security <identifiersep> context security <identifiersep> context , throwable t ) { \n <ect>
\t3 response . set <identifiersep> response <identifiersep> name ( get <identifiersep> command <identifiersep> name ( ) ) ; \n \t3 response . set <identifiersep> object <identifiersep> name ( <string_literal> ) ; \n \t3 this . set <identifiersep> response <identifiersep> object ( response ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 } catch ( exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; \n \t3 return false ; } } \n \t1 private string <identifiersep> builder get <identifiersep> <identifier> <identifiersep> message ( string <identifier> <identifiersep> cmd ) { \n <ect>
\t4 return ; } \n \t3 try { \n \t4 thread . <identifier> ( <number_literal> ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 + <string_literal> \n \t2 + <string_literal> ) ; \n \t1 conn . <identifier> ( ) ; \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t5 create <identifiersep> <identifier> <identifiersep> file <identifiersep> if <identifiersep> no <identifiersep> process <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; } } \n \t3 for ( file <identifier> <identifiersep> file : <identifier> <identifiersep> files ) { \n \t4 integer <identifier> = process <identifiersep> utils . get <identifiersep> <identifier> ( <identifier> <identifiersep> file ) ; \n \t4 if ( <identifier> == null ) { \n <ect>
\t4 for ( <identifier> <identifiersep> vo <identifier> : <identifier> ) { \n \t5 long vm <identifiersep> id = <identifier> . get <identifiersep> instance <identifiersep> id ( ) ; \n \t5 vm <identifiersep> instance <identifiersep> vo vm = <identifier> <identifiersep> vm <identifiersep> dao . find <identifiersep> by <identifiersep> id ( vm <identifiersep> id ) ; \n \t5 if ( vm == null ) { \n <ect>
\t5 . int <identifiersep> value ( ) ) ) { \n \t4 throw new network <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + new <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> source <identifiersep> port <identifiersep> start ( ) . int <identifiersep> value ( ) + <string_literal> + new <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> source <identifiersep> port <identifiersep> end ( ) . int <identifiersep> value ( ) + \n \t5 <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> source <identifiersep> port <identifiersep> start ( ) . int <identifiersep> value ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> source <identifiersep> port <identifiersep> end ( ) . int <identifiersep> value ( ) ) ; } } \n <ect>
\t5 catch ( interrupted <identifiersep> exception e ) { \n \t6 if ( ! this . <identifier> ) { \n \t7 return ; \n \t6 } else { \n <ect>
\t2 <identifier> = null ; } \n \t1 } catch ( exception e ) { \n \t1 throw new <identifier> <identifiersep> exception ( e ) ; } \n <ect>
\t3 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t4 for ( <identifier> <identifiersep> id <identifier> <identifiersep> id : <identifier> . key <identifiersep> set ( ) . to <identifiersep> array ( new <identifier> <identifiersep> id [ <identifier> . size ( ) ] ) ) { \n \t5 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> . new <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t4 <identifier> . add ( <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> name ( host . <identifier> ( ) ) ) ; } \n \t3 catch ( <identifier> <identifiersep> host <identifiersep> exception ex ) \n \t3 { \n \t4 <comment> \n <ect>
\t2 final <identifier> <identifiersep> <identifier> <identifiersep> password <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> password <identifiersep> <identifier> ) transaction . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get ( ) ; \n \t2 final string target <identifiersep> user <identifiersep> id = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 if ( string <identifiersep> utils . is <identifiersep> blank ( target <identifiersep> user <identifiersep> id ) ) { \n <ect>
\t2 get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> ( <identifier> ) ; \n \t2 try { \n \t3 file <identifiersep> server . get <identifiersep> file <identifiersep> server ( ) . set <identifiersep> <identifier> ( test <identifiersep> <identifier> <identifiersep> file ) ; \n \t2 } catch ( illegal <identifiersep> state <identifiersep> exception <identifier> ) { \n <ect>
public java . <identifier> . <identifier> <identifiersep> <identifier> <identifier> ( ) { \n \t1 return ( java . <identifier> . <identifier> <identifiersep> <identifier> ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <string_literal> ) ; } \n public void set <identifiersep> <identifier> ( java . <identifier> . <identifier> <identifiersep> <identifier> value ) { \n <ect>
\t2 db <identifiersep> conn = get <identifiersep> db <identifiersep> conn ( connection . transaction <identifiersep> read <identifiersep> <identifier> ) ; \n \t2 <identifier> = db <identifiersep> conn . create <identifiersep> <identifier> ( ) ; \n \t2 string s = <string_literal> + \n \t2 <string_literal> + <identifier> <identifiersep> state + <string_literal> ; \n <ect>
\t4 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> client <identifiersep> name ( ) ) ) { \n \t5 client . set <identifiersep> name ( client . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) + count ) ; } \n \t4 <identifier> <identifiersep> client ( client , <identifier> ) ; \n \t4 index . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n <ect>
\t3 field <identifier> <identifiersep> field = class . for <identifiersep> name ( <string_literal> ) . get <identifiersep> <identifier> <identifiersep> field ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> final <identifiersep> field <identifiersep> <identifier> ( <identifier> <identifiersep> field ) ; \n \t3 <identifier> <identifiersep> field . set ( null , <identifier> <identifiersep> file ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 logger . error ( <string_literal> , port ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> operation <identifiersep> exception e ) { \n \t3 logger . error ( e . to <identifiersep> string ( ) , e ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 assert . assert <identifiersep> equals ( 0 , conn . table <identifiersep> <identifier> ( ) . list <identifiersep> <identifier> ( table <identifiersep> name ) . size ( ) ) ; } \n <comment> \n @ test ( timeout = <number_literal> * <number_literal> ) \n public void <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 public void stop ( ) { \n \t2 data <identifiersep> store <identifiersep> server . stop ( ) ; } \n \t1 private void handle <identifiersep> <identifier> <identifiersep> <identifier> ( final string <identifier> <identifiersep> uri , final http <identifiersep> server <identifiersep> request request ) { \n \t2 if ( debug ) { \n <ect>
\t2 type result = metadata . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> type ( type <identifiersep> name , type <identifiersep> <identifier> ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 if ( is <identifiersep> version && <identifier> <identifiersep> type . class . is <identifiersep> instance ( result ) ) { \n <ect>
\t4 return false ; } \n \t3 try { \n \t4 thread . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> wait <identifiersep> <identifier> ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t6 last <identifiersep> exchange <identifiersep> id + <string_literal> + <identifier> <identifiersep> id + ' ] ' ) ; \n \t4 return null ; } \n \t3 if ( <identifier> != null && <identifier> . <identifier> <identifiersep> to ( <identifier> <identifiersep> map ) >= 0 ) { \n <ect>
\t2 <identifier> <identifiersep> data <identifiersep> entry [ ] meta = request . get <identifiersep> meta <identifiersep> <identifier> ( ) ; \n \t2 s <identifiersep> <identifier> <identifiersep> dao <identifier> <identifiersep> dao = new s <identifiersep> <identifier> <identifiersep> dao ( ) ; \n \t2 s <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> dao . get <identifiersep> by <identifiersep> name ( <identifier> <identifiersep> name ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 <identifier> <identifiersep> store <identifiersep> info <identifier> = null ; \n \t2 try { \n \t3 <identifier> = <identifier> ( <identifier> , store <identifiersep> <identifier> . <identifier> , <identifier> <identifiersep> store <identifiersep> info . class ) ; \n \t3 <identifier> . add ( <identifier> ) ; \n <ect>
\t1 if ( path == null ) { \n \t2 log . warn ( <string_literal> + <identifier> + <string_literal> ) ; \n \t2 continue ; } \n \t1 if ( ! local <identifiersep> <identifier> . exists ( path ) ) { \n <ect>
\t3 logger . info ( <string_literal> + <identifier> . get <identifiersep> id ( ) ) ; \n \t3 <identifier> = new update <identifiersep> <identifier> ( ) ; \n \t3 <identifier> . add ( new <identifier> <identifiersep> list <identifiersep> update ( ) ) ; \n \t3 <identifier> . <identifier> ( <identifier> <identifiersep> update <identifiersep> factory . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> id ( ) , super <identifiersep> <identifier> <identifiersep> manager . default <identifiersep> <identifier> , <identifier> . get <identifiersep> context <identifiersep> id ( ) ) ) ; \n <ect>
\t3 <identifier> . get <identifiersep> content <identifiersep> metadata ( ) . set <identifiersep> content <identifiersep> length ( apache <identifiersep> response . get <identifiersep> entity ( ) . get <identifiersep> content <identifiersep> length ( ) ) ; \n \t3 if ( apache <identifiersep> response . get <identifiersep> entity ( ) . get <identifiersep> content <identifiersep> type ( ) != null ) \n \t3 <identifier> . get <identifiersep> content <identifiersep> metadata ( ) . set <identifiersep> content <identifiersep> type ( apache <identifiersep> response . get <identifiersep> entity ( ) . get <identifiersep> content <identifiersep> type ( ) . get <identifiersep> value ( ) ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 @ get \n \t1 @ <identifier> ( <string_literal> ) \n \t1 @ path ( <string_literal> ) \n \t1 public string get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> path <identifiersep> <identifier> ( @ path <identifiersep> <identifier> ( <string_literal> ) path <identifiersep> <identifier> <identifier> ) { \n <ect>
\t1 try : \n \t1 code , out , <identifier> = <identifier> . <identifier> ( command , <identifier> = <identifier> . <identifier> , <identifier> = <identifier> . <identifier> , timeout = int ( timeout ) , <identifier> = true ) \n \t1 <identifier> = out \n \t1 <identifier> exception as ex : \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> user ( <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> user ( <identifier> ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t2 response response = client . target ( <identifier> <identifiersep> url ( <string_literal> ) ) . request ( ) \n \t4 . header ( <string_literal> , <string_literal> ) . get ( ) ; \n \t2 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> content , response . get <identifiersep> status ( ) ) ; \n \t2 assert . assert <identifiersep> equals ( <string_literal> , <number_literal> , response . get <identifiersep> length ( ) ) ; \n <ect>
\t5 input <identifiersep> stream = url <identifiersep> connection . get <identifiersep> input <identifiersep> stream ( ) ; \n \t5 <identifier> = <identifier> . read <identifiersep> file <identifiersep> <identifier> ( url <identifiersep> connection . get <identifiersep> input <identifiersep> stream ( ) ) ; } \n \t4 response = new response ( url <identifiersep> connection . get <identifiersep> header <identifiersep> <identifier> ( ) , url <identifiersep> connection . get <identifiersep> response <identifiersep> code ( ) , <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t6 <string_literal> ) ; \n \t3 } else { \n \t4 <identifier> <identifiersep> log . error ( <string_literal> ) ; } \n \t2 } else { \n <ect>
\t5 result = <identifier> . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> uri ( endpoint . get <identifiersep> remote <identifiersep> path ( ) ) . set <identifiersep> directory ( new file ( endpoint . get <identifiersep> local <identifiersep> path ( ) , <string_literal> ) ) . <identifier> ( ) ; } \n \t3 } else { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 return new org . apache . thrift . <identifier> . <identifier> <identifiersep> method <identifiersep> <identifier> < void > ( ) { \n \t2 public void on <identifiersep> <identifier> ( void o ) { } \n \t2 public void on <identifiersep> error ( java . <identifier> . exception e ) { \n \t3 if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t3 } catch ( interrupted <identifiersep> io <identifiersep> exception e ) { \n \t4 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n \t4 logger . error ( <string_literal> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> xml <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> xml <identifiersep> <identifier> ( <string_literal> ) ; \n \t3 response response = client . target ( <identifier> <identifiersep> url ( <string_literal> ) ) . request ( ) . <identifier> ( <identifier> <identifiersep> type . application <identifiersep> xml ) . <identifier> ( entity . entity ( <identifier> , <string_literal> ) ) ; \n \t3 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> request , response . get <identifiersep> status ( ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> = response . read <identifiersep> entity ( <identifier> <identifiersep> <identifier> . class ) ; \n <ect>
\t5 <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> answer answer = null ; \n \t5 try { \n \t6 answer = ( <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> answer ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> send ( <identifier> <identifiersep> device . get <identifiersep> <identifier> <identifiersep> host <identifiersep> id ( ) , <identifier> <identifiersep> delete <identifiersep> cmd ) ; \n \t6 if ( answer == null || ! answer . get <identifiersep> result ( ) ) { \n <ect>
\t4 return result ; \n \t3 } catch ( final exception e ) { \n \t4 logger . warn ( <string_literal> , e ) ; \n \t4 if ( <identifier> >= <identifier> ) { \n <ect>
\t3 <identifier> . <identifier> ( ) ; \n \t2 try { \n \t3 data <identifiersep> <identifier> . store <identifiersep> <identifier> ( config , conf ) ; \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> info ( ) ) \n <ect>
\t2 return http <identifiersep> server . create ( new <identifier> <identifiersep> socket <identifiersep> address ( port ) , <number_literal> ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> server <identifiersep> socket create <identifiersep> <identifier> <identifiersep> server <identifiersep> socket ( int port ) throws io <identifiersep> exception { \n <ect>
\t10 return 1 ; } } } } } \n \t5 if ( <identifier> . get <identifiersep> <identifier> ( ) == <identifier> . <identifier> <identifiersep> <identifier> ) { \n \t6 for ( target target : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t7 if ( target instanceof target <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 public boolean <identifier> ( file dir , string name ) { \n \t4 return ( name . <identifier> <identifiersep> with ( <string_literal> ) ) ; } \n \t2 } ) ; \n \t2 if ( log <identifiersep> files == null || array <identifiersep> utils . is <identifiersep> empty ( log <identifiersep> files ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> ( ) ; \n \t3 return true ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 check <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t3 <identifier> . close ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
private <identifier> <identifiersep> socket <identifiersep> address <identifier> <identifiersep> server ; \n private final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n @ <identifier> \n public void set <identifiersep> <identifier> ( collection < socket <identifiersep> address > <identifier> ) { \n <ect>
\t1 @ test \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifiersep> server . start ( ) ; \n \t2 <identifier> <identifiersep> server . create <identifiersep> <identifier> <identifiersep> account ( test <identifiersep> user . get <identifiersep> <identifier> ( ) , <string_literal> ) ; \t2 \n <ect>
\t2 assert log != null ; \n \t3 log . info ( <string_literal> + get <identifiersep> <identifier> ( ) ) ; \n \t3 log . info ( <string_literal> + <identifier> . <identifier> <identifiersep> string ( ) ) ; \n <ect>
\t2 log . warn ( <string_literal> + config <identifiersep> file , e ) ; } \n \t1 } else { \n \t1 <identifier> <identifiersep> config <identifiersep> url = <identifier> <identifiersep> class <identifiersep> <identifier> . class . get <identifiersep> class <identifiersep> <identifier> ( ) . get <identifiersep> resource ( config <identifiersep> file ) ; \n \t1 if ( <identifier> <identifiersep> config <identifiersep> url == null ) \n <ect>
<identifier> get <identifiersep> <identifier> <identifiersep> files ( self ) : \n \t1 import status <identifiersep> <identifier> \n \t1 return [ status <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> file ] \n <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( self , <identifier> , <identifier> <identifiersep> type = <identifier> ) : \n <ect>
\t2 <identifier> <identifiersep> info <identifier> <identifiersep> info = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> info ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> info . get <identifiersep> <identifier> ( ) == null || <identifier> <identifiersep> info . get <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( ) ; \n \t3 <identifier> <identifiersep> info . set <identifiersep> <identifier> ( <identifier> . next <identifiersep> string ( <number_literal> ) ) ; } \n <ect>
\t10 @ query <identifiersep> <identifier> ( <string_literal> ) string user <identifiersep> <identifier> , \n \t10 @ query <identifiersep> <identifier> ( <string_literal> ) string <identifier> , @ context http <identifiersep> <identifier> <identifier> , \n \t10 @ context http <identifiersep> <identifier> <identifiersep> request request ) \n \t2 throws web <identifiersep> application <identifiersep> exception { \n <ect>
\t1 try { \n \t1 <identifier> = <identifier> <identifiersep> client . get <identifiersep> object ( request ) ; \n \t1 } catch ( exception e ) { \n \t1 <comment> \n <ect>
\t5 new default <identifiersep> http <identifiersep> method <identifiersep> <identifier> <identifiersep> handler ( <number_literal> , false ) ) ; \n \t3 try { \n \t4 final int status <identifiersep> code = http <identifiersep> client . execute <identifiersep> method ( method ) ; \n \t4 if ( status <identifiersep> code != http <identifiersep> status . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 status status = client . update <identifiersep> status ( <identifier> <identifiersep> <identifier> ) ; \n \t3 logger . debug ( <string_literal> , status . get <identifiersep> text ( ) ) ; \n \t3 return true ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 port <identifiersep> num = integer . parse <identifiersep> int ( <identifier> [ 1 ] ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n \t4 <identifier> . log ( <string_literal> ) ; \n <ect>
\t6 <identifier> <identifiersep> response <identifiersep> <identifier> response <identifiersep> <identifier> = ( <identifier> <identifiersep> response <identifiersep> <identifier> ) response <identifiersep> <identifier> <identifiersep> enum . next <identifiersep> element ( ) ; \n \t6 response <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> response ( this , <identifier> <identifiersep> context ) ; } } \n \t4 if ( <identifier> <identifiersep> content <identifiersep> length ( ) == 0 ) { \n \t5 set <identifiersep> status ( http <identifiersep> status <identifiersep> <identifier> <identifiersep> error ) ; \n <ect>
public void on <identifiersep> model <identifiersep> <identifier> <identifiersep> <identifier> ( final long <identifier> ) { \n \t1 try { \n \t1 manager <identifiersep> <identifier> . get ( ) . on <identifiersep> model <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t1 } catch ( final <identifier> <identifiersep> runtime <identifiersep> exception e ) { \n <ect>
\t6 vm <identifiersep> <identifier> <identifiersep> conf . set <identifiersep> long ( input <identifiersep> size <identifiersep> <identifier> <identifiersep> <identifier> . bytes <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , bytes <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t5 vm <identifiersep> <identifier> <identifiersep> conf . set <identifiersep> boolean ( <identifier> <identifiersep> <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , true ) ; \n \t5 vm <identifiersep> <identifier> <identifiersep> conf . set <identifiersep> long ( <identifier> <identifiersep> <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager <identifiersep> <identifier> <identifiersep> task <identifiersep> input <identifiersep> size , bytes <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t5 <identifier> <identifiersep> <identifier> = true ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t4 start ( ) ; } \n \t3 try { \n \t4 this . connection <identifiersep> <identifier> . <identifier> ( this . connection <identifiersep> timeout , time <identifiersep> unit . <identifier> ) ; } \n \t3 catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t5 } else { \n \t6 get <identifiersep> response ( ) . set <identifiersep> header ( <string_literal> , uri <identifiersep> location ) ; \n \t6 get <identifiersep> response ( ) . set <identifiersep> status ( <identifier> <identifiersep> code ) ; } \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( authentication <identifiersep> <identifier> <identifiersep> context context ) { \n \t2 string <identifier> <identifiersep> value = context . get <identifiersep> authentication <identifiersep> session ( ) . get <identifiersep> client <identifiersep> <identifier> ( <identifier> <identifiersep> endpoint . <identifier> <identifiersep> session <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t2 string <identifier> <identifiersep> value = context . get <identifiersep> <identifier> <identifiersep> config ( ) . get <identifiersep> config ( ) . get ( <identifier> <identifiersep> value ) ; \n <ect>
private final boolean is <identifiersep> <identifier> ; \n public node <identifiersep> type <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t1 <comment> \n \t1 final string <identifier> <identifiersep> name = system . get <identifiersep> property ( <string_literal> ) ; \n <ect>
\t2 if ( <identifier> != null ) { \n \t3 try { \n \t4 <identifier> . close ( ) ; \n \t3 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t4 logger . debug ( <string_literal> , job <identifiersep> name , <identifier> . format ( <identifier> . get <identifiersep> time ( ) ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception ex ) { \n \t4 logger . error ( ex . get <identifiersep> message ( ) , ex ) ; } \n \t2 } else { \n <ect>
\t1 boolean create <identifiersep> <identifier> = ( <identifier> <identifiersep> name <identifiersep> in != null && string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> <identifier> <identifiersep> collection ) ) ; \n \t1 if ( create <identifiersep> <identifier> ) { \n \t2 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this ) . start ( ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t4 log . debug ( <string_literal> , <identifier> . id ( ) , v . id ( ) ) ; \n \t4 <comment> \n <comment> \n <comment> \n <ect>
\t1 else { \n \t2 add <identifiersep> object <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } } \n public void remove <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . model . <identifier> object ) { \n <ect>
\t3 int <identifier> = <identifier> <identifiersep> value <identifiersep> item . get <identifiersep> value <identifiersep> list <identifiersep> index ( type . to <identifiersep> string ( ) ) ; \n \t3 if ( <identifier> != - 1 ) { \n \t4 return string . value <identifiersep> of ( <identifier> ) ; \n \t3 } else { \n <ect>
\t1 public void set <identifiersep> property ( string name , object value ) { \n \t2 super . set <identifiersep> property ( name , value ) ; \n \t2 if ( name . equals ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> root ) && type == field <identifiersep> type . <identifier> <identifiersep> <identifier> ) { \n \t3 <identifier> <identifiersep> root = ( string ) value ; \n <ect>
\t5 throw new execution <identifiersep> exception ( <string_literal> + public <identifiersep> ip + <string_literal> + private <identifiersep> <identifier> ) ; \n \t4 } else { \n \t5 return true ; } \n \t3 default : \n <ect>
\t2 { \n \t3 <identifier> <identifiersep> user <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> name ( ) , <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t6 public void on <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> event <identifier> ) { \n \t7 <comment> \n \t6 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t6 public void <identifier> <identifiersep> failed ( <identifier> <identifiersep> error <identifiersep> event <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> id <identifier> = new <identifier> <identifiersep> id ( <identifier> , <identifier> <identifiersep> type . <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> id <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> id ( ) ; \n \t2 <identifier> <identifiersep> id <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> id ( ) ; \n \t2 xml <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> test ( <string_literal> , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 logger . error ( this , <string_literal> + <identifier> , <identifier> ) ; } \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 public boolean is <identifiersep> <identifier> ( string device <identifiersep> id ) { \n \t2 if ( <identifier> <identifiersep> data == null ) { \n <ect>
\t3 if ( class <identifiersep> <identifier> == null ) { \n \t4 log . warn ( <identifier> . class , <string_literal> + class <identifiersep> name ) ; \n \t4 return null ; } } \n \t2 if ( <identifier> <identifiersep> class != null && ! <identifier> <identifiersep> class . is <identifiersep> <identifier> <identifiersep> from ( class <identifiersep> <identifier> ) ) { \n <ect>
\t4 <identifier> = new <identifier> ( url . get <identifiersep> file ( ) , in ) ; } } \n \t2 add <identifiersep> close ( <identifier> ) ; \n \t2 return <identifier> ; } \n \t1 private void <identifier> ( file file , string <identifier> ) throws exception { \n <ect>
<comment> \n public map < string , list < integer > > get <identifiersep> <identifier> <identifiersep> info <identifiersep> for <identifiersep> query ( string query ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 <string_literal> ) . as <identifiersep> <identifier> ( <identifier> <identifiersep> model <identifiersep> factory . class ) ; \n \t1 return <identifier> <identifiersep> factory <identifiersep> class . new <identifiersep> instance ( ) ; \n \t1 } catch ( final exception e ) { \n \t1 log . debug ( <string_literal> ) ; \n <ect>
\t1 log . debug ( <string_literal> ) ; } \n \t1 if ( conf . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> conf . conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> enabled ) ) { \n \t1 ( new <identifier> ( ) ) . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t1 } else { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> name . set <identifiersep> <identifier> ( true ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> name . set ( null , default <identifiersep> <identifier> <identifiersep> name ) ; \n \t3 } catch ( no <identifiersep> such <identifiersep> field <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception <identifier> ) { \n <ect>
\t1 public < response extends action <identifiersep> response > void store <identifiersep> result ( task task , response response , action <identifiersep> listener < response > listener ) { \n \t2 <identifier> <identifiersep> node local <identifiersep> node = last <identifiersep> <identifier> <identifiersep> nodes . get <identifiersep> local <identifiersep> node ( ) ; \n \t2 if ( local <identifiersep> node == null ) { \n \t3 <comment> \n <ect>
\t4 . <identifier> ( address , info <identifiersep> message <identifiersep> listener <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n \t3 info <identifiersep> message <identifiersep> listener <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t4 ( info <identifiersep> message <identifiersep> listener <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , throwable failure ) - > { \n \t5 if ( failure != null ) { \n <ect>
\t1 list < <identifier> <identifiersep> node <identifiersep> <identifier> > <identifier> = conf . get <identifiersep> key <identifiersep> <identifier> ( ) ; \n \t2 log . debug ( <string_literal> + <identifier> . size ( ) ) ; \n \t2 for ( <identifier> <identifiersep> node <identifiersep> <identifier> <identifier> : <identifier> ) { \n <ect>
\t3 public void process ( exchange exchange ) throws exception { \n \t4 <identifier> <identifier> = exchange . get <identifiersep> in ( ) . get <identifiersep> body ( <identifier> . class ) ; \n \t4 <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 private void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( object <identifier> , <identifier> <identifier> ) throws api <identifiersep> exception { \n <ect>
\t2 } finally { \n \t3 try { \n \t4 service <identifiersep> <identifier> . stop <identifiersep> and <identifiersep> shutdown <identifiersep> service ( consumer ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 } else if ( ! ( boolean ) <identifier> . get <identifiersep> method ( <string_literal> ) . <identifier> ( null ) ) { \n \t5 logger . warn ( <string_literal> \n \t7 + <string_literal> , ( throwable ) <identifier> . get <identifiersep> method ( <string_literal> ) . <identifier> ( null ) ) ; \n \t4 } else { \n <ect>
\t7 + <identifier> <identifiersep> storage <identifiersep> host . get <identifiersep> name ( ) ) ; \n \t5 for ( vm <identifiersep> template <identifiersep> host <identifiersep> vo <identifier> <identifiersep> template <identifiersep> host <identifiersep> vo : <identifier> <identifiersep> template <identifiersep> host <identifiersep> v <identifiersep> <identifier> ) { \n \t6 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . template <identifiersep> is <identifiersep> <identifier> ( <identifier> <identifiersep> template <identifiersep> host <identifiersep> vo ) ) { \n <ect>
private void execute ( <identifier> <identifiersep> context context , collection < <identifier> <identifiersep> job > <identifier> <identifiersep> <identifier> ) { \n \t1 log <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifier> = new <identifier> ( <identifier> ) ; \n \t1 for ( <identifier> <identifiersep> job <identifier> <identifiersep> job : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 if ( get ( ) instanceof <identifier> ) { \n \t2 try { \n \t2 ( ( <identifier> ) get ( ) ) . <identifier> ( ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t2 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> log . logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> config . config . get <identifiersep> config <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) + <string_literal> ) ; \n \t2 <identifier> <identifiersep> log . logger . warn ( <string_literal> ) ; \n <ect>
\t6 + <string_literal> + state . to <identifiersep> string ( ) + <string_literal> + <identifier> <identifiersep> status . to <identifiersep> string ( ) \n \t6 + <string_literal> ) ; \n \t4 return false ; \n \t3 } else if ( <identifier> <identifiersep> application <identifiersep> state . <identifier> == state ) { \n <ect>
\t7 task . set <identifiersep> <identifier> ( <identifier> <identifiersep> m <identifiersep> bean ) ; } } } } \n \t3 try { \n \t4 <identifier> <identifiersep> object ( <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 data . put ( property , <identifier> . get <identifiersep> property ( property ) ) ; } } } \n \t3 return data ; } \n \t2 catch ( resource <identifiersep> stream <identifiersep> not <identifiersep> found <identifiersep> exception | io <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t3 return msg . <identifier> ( 0 , <number_literal> ) + <string_literal> + msg . length ( ) + <string_literal> ; } \n \t2 @ <identifier> \n \t2 public void exception <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context <identifier> , throwable <identifier> ) throws exception { \n <ect>
\t1 <identifier> <identifier> , \n \t1 <identifier> <identifier> , \n \t1 list < <identifier> > <identifier> ) { \n \t1 if ( this . mode . <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 add <identifiersep> load <identifiersep> listener ( <identifier> <identifiersep> element , this . <identifier> <identifiersep> <identifier> <identifiersep> load ) ; \n \t2 <identifier> <identifiersep> element [ <identifier> ] = true ; \n \t2 <identifier> <identifiersep> element [ <string_literal> + this . <identifier> <identifiersep> id ] = <identifier> ; \n \t1 log . debug ( <string_literal> + this . <identifier> <identifiersep> id ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void shutdown ( network <identifiersep> <identifier> <identifier> , network <identifiersep> <identifier> <identifier> ) { \n \t2 network <identifiersep> vo network <identifiersep> object = <identifier> <identifiersep> network <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> . get <identifiersep> id ( ) ) ; \n \t2 if ( network <identifiersep> object . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> || network <identifiersep> object . get <identifiersep> <identifier> <identifiersep> uri ( ) == null ) { \n <ect>
\t5 byte [ ] msg = data <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> . to <identifiersep> string ( ) ) ; \n \t5 synchronized ( <identifier> <identifiersep> <identifier> <identifiersep> out ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> out . write ( msg ) ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> out . <identifier> ( ) ; } \n <ect>
<comment> \n \t1 protected <identifier> <identifiersep> message <identifiersep> session ( input <identifiersep> stream <identifier> <identifiersep> stream , properties <identifier> ) throws io <identifiersep> exception , data <identifiersep> format <identifiersep> exception , <identifier> <identifiersep> session <identifiersep> exception { \n \t2 <identifier> <identifiersep> log = <identifier> <identifiersep> <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> context ( ) . log <identifiersep> manager ( ) . get <identifiersep> log ( get <identifiersep> class ( ) ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 <comment> \n \t3 if ( dao != null ) { \n \t4 dao . shutdown ( ) ; } } \n \t2 catch ( exception e ) { \n <ect>
\t3 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> , log ) ; \n <ect>
\t1 try { \n \t1 set <identifiersep> <identifier> <identifiersep> path ( conf , <identifier> <identifiersep> <identifier> <identifiersep> dir ) ; \n \t1 set <identifiersep> base <identifiersep> <identifier> ( conf , name , <identifier> ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> . size ( ) > 0 ) \n \t4 <identifier> <identifiersep> user <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) \n \t3 <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t3 return <identifier> <identifiersep> manager . create ( ) . write ( ) \n \t2 } catch ( e : exception ) { \n <ect>
\t2 assert . assert <identifiersep> null ( <identifier> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 <comment> \n \t3 <identifier> = runtime . get <identifiersep> runtime ( ) . <identifier> ( cmd <identifiersep> array ) ; } \n \t2 catch ( io <identifiersep> exception <identifier> ) { \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + cmd <identifiersep> array , <identifier> ) ; } \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t3 <identifier> <identifiersep> log . debug ( <string_literal> ) ; \n \t3 properties <identifier> = <identifier> <identifiersep> utils . parse <identifiersep> <identifier> ( line ) ; \n \t3 string value = <identifier> . get <identifiersep> property ( <string_literal> ) ; \n \t3 if ( value == null ) { \n <ect>
\t2 <identifier> < <identifier> <identifiersep> entity <identifiersep> pool > pool = <identifier> . of <identifiersep> <identifier> ( pool <identifiersep> map . get ( id ) ) ; \n \t2 if ( ! pool . is <identifiersep> <identifier> ( ) ) { \n \t3 if ( id != null <identifiersep> id ) { \n \t4 if ( is <identifiersep> <identifier> <identifiersep> entity ( id ) ) { \n <ect>
\t4 if ( <identifier> . <identifier> ( ) ) { \n \t5 string <identifier> <identifiersep> name = <identifier> . group ( 1 ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) || <identifier> <identifiersep> <identifier> . contains ( <identifier> <identifiersep> name ) ) { \n \t6 if ( <identifier> <identifiersep> <identifier> . contains ( <identifier> <identifiersep> name ) ) { \n <ect>
\t6 return new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> result ( address , data ) ; \n \t5 } else { \n \t6 logger . warn ( <string_literal> , xml <identifiersep> <identifier> . as <identifiersep> xml ( ) ) ; } } \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> . close ( ) ; } \n \t1 protected object <identifiersep> name assert <identifiersep> registered <identifiersep> object <identifiersep> name ( string name ) throws <identifier> <identifiersep> object <identifiersep> name <identifiersep> exception , null <identifiersep> <identifier> <identifiersep> exception { \n \t2 object <identifiersep> name object <identifiersep> name = new object <identifiersep> name ( name ) ; \n \t2 if ( <identifier> <identifiersep> server . is <identifiersep> registered ( object <identifiersep> name ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . put <identifiersep> if <identifiersep> <identifier> ( <identifier> , new <identifier> <identifiersep> long ( 0 ) ) ; \n \t3 <identifier> = <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; } \n \t2 <identifier> . add <identifiersep> and <identifiersep> get ( <identifier> ) ; \n <ect>
\t6 <string_literal> + <identifier> + ' ] ' ) ; \n \t4 return ; } \n \t3 if ( is <identifiersep> local <identifiersep> node <identifiersep> <identifier> ( ) && ! <identifier> <identifiersep> node <identifiersep> id . equals ( msg . <identifier> <identifiersep> node <identifiersep> id ( ) ) ) { \n <ect>
\t9 <identifier> <identifiersep> for <identifiersep> <identifier> ( default <identifiersep> <identifier> <identifiersep> name ) ) ; \n \t4 logger . info ( <string_literal> , default <identifiersep> <identifier> <identifiersep> name ) ; } } \n \t2 catch ( request <identifiersep> execution <identifiersep> exception e ) \n \t2 { \n <ect>
\t1 ) \n \t1 object to <identifiersep> <identifier> : <identifier> <identifiersep> info <identifiersep> <identifier> < <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> info > > ( \n \t2 on <identifiersep> result = { result - > result ? . <identifier> { <identifier> <identifiersep> of ( it ) } ? : empty <identifiersep> <identifier> ( ) } , \n \t2 on <identifiersep> failure = { <identifier> - > \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> + response <identifiersep> code + <string_literal> + url ) ; \n \t3 return response <identifiersep> code ; } \n \t2 { \n \t3 url = server + <string_literal> + <identifier> <identifiersep> volume <identifiersep> from <identifiersep> snapshot . get ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> vm <identifiersep> id . get ( ) ; \n <ect>
\t2 private void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) { \n \t3 log . debug ( <string_literal> + <identifier> . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) ) ; \n \t3 for ( int i = 0 ; i < <identifier> . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) ; i ++ ) { \n \t4 log . debug ( <string_literal> + i + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) . get ( i ) . get <identifiersep> <identifier> <identifiersep> location ( ) ) ; \n <ect>
\t2 assert <identifiersep> <identifier> <identifiersep> snapshot ( client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> create <identifiersep> snapshot ( <identifier> <identifiersep> name , snapshot <identifiersep> name ) \n \t4 . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( true ) . set <identifiersep> <identifier> ( index <identifiersep> <identifier> ) ) ; \n \t2 list < string > delete <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> of ( <identifier> <identifiersep> int <identifiersep> <identifier> ( 0 , index <identifiersep> count ) , index <identifiersep> <identifier> ) ; \n \t2 if ( delete <identifiersep> <identifier> . size ( ) > 0 ) { \n <ect>
\t3 version = value . get <identifiersep> version ( ) ; \n \t2 } catch ( exception e ) { \n \t4 logger . debug ( <string_literal> + e ) ; } \n <ect>
\t4 key . <identifier> <identifiersep> <identifier> ( key . <identifier> <identifiersep> <identifier> ( ) | <identifier> <identifiersep> key . <identifier> <identifiersep> read ) ; \n \t3 } catch ( <identifier> <identifiersep> key <identifiersep> exception <identifier> ) { \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 info . get <identifiersep> <identifier> <identifiersep> list ( ) . size ( ) > 0 ? info . get <identifiersep> <identifier> <identifiersep> list ( ) : <string_literal> ) ; \n \t2 log . info ( <string_literal> , info . has <identifiersep> principal ( ) ? info . get <identifiersep> principal ( ) : <string_literal> ) ; \n \t2 log . info ( <string_literal> , info . has <identifiersep> <identifier> ( ) ? info . get <identifiersep> <identifier> ( ) : <string_literal> ) ; \n \t2 if ( <identifier> . contains <identifiersep> key ( <string_literal> ) ) { \n <ect>
\t2 <comment> \n \t2 if ( options <identifiersep> map . contains <identifiersep> key ( <string_literal> ) && ! options <identifiersep> map . contains <identifiersep> key ( <string_literal> ) ) { \n \t3 options <identifiersep> map . put ( <string_literal> , options <identifiersep> map . remove ( <string_literal> ) ) ; \n <ect>
\t2 map < object , object > <identifier> <identifiersep> conf = <identifier> <identifiersep> config . read <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> conf ( <identifier> <identifiersep> id , <identifier> <identifiersep> data . get <identifiersep> <identifier> <identifiersep> store ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> config . read <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> code ( <identifier> <identifiersep> id , <identifier> <identifiersep> data . get <identifiersep> <identifier> <identifiersep> store ( ) ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 map <identifier> <identifiersep> conf = new <identifier> <identifiersep> map ( ) ; \n <ect>
\t5 <identifier> <identifiersep> manager <identifiersep> <identifier> . <identifier> <identifiersep> context \n \t6 . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> path <identifiersep> field . get <identifiersep> text ( ) ) ; } \n \t4 catch ( <identifier> <identifiersep> exception ex ) \n \t4 { \n <ect>
\t1 public synchronized int queue <identifiersep> size ( ) { \n \t2 return queue . size ( ) ; } \n \t1 private synchronized boolean queue ( <identifier> <identifiersep> <identifier> <identifier> , boolean ignore <identifiersep> queue <identifiersep> size ) { \n \t2 if ( ! ignore <identifiersep> queue <identifiersep> size && queue . size ( ) >= queue <identifiersep> size ) { \n <ect>
\t2 create <identifiersep> <identifier> <identifiersep> <identifier> ( metadata ) ; \n \t2 this . <identifier> = new <identifier> <identifiersep> <identifier> ( this ) ; \n \t2 for ( <identifier> <identifiersep> meta <identifiersep> data <identifier> : new array <identifiersep> list < <identifier> <identifiersep> meta <identifiersep> data > ( metadata . <identifier> <identifiersep> meta <identifiersep> data ( ) . values ( ) ) ) \n \t2 { \n <ect>
\t2 out <identifiersep> <identifier> <identifiersep> message msg = null ; \n \t2 synchronized ( <identifier> <identifiersep> <identifier> ) { \n \t3 if ( <identifier> <identifiersep> current <identifiersep> <identifier> != null ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 <identifier> <identifiersep> <identifier> = new file ( file . get <identifiersep> <identifier> ( ) , <identifier> ) ; \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 { \n \t3 <identifier> . <identifier> ( ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t5 s <identifiersep> logger . error ( <string_literal> + ex ) ; } \n \t4 if ( conn == null ) { \n \t5 s <identifiersep> logger . error ( <string_literal> ) ; } \n \t4 session <identifier> = conn . <identifier> <identifiersep> session ( ) ; \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <comment> \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> stop ( vm <identifiersep> instance <identifiersep> vo vm , long host <identifiersep> id , <identifier> <identifiersep> type type ) { \n \t2 assert ( type == <identifier> <identifiersep> type . check <identifiersep> stop || type == <identifier> <identifiersep> type . <identifier> <identifiersep> stop || type == <identifier> <identifiersep> type . stop ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> dao . has <identifiersep> <identifier> <identifiersep> <identifier> ( vm . get <identifiersep> id ( ) , type ) ) { \n <ect>
\t3 } catch ( final <identifier> <identifiersep> url <identifiersep> exception e ) { \n \t4 uri = new uri ( uri <identifiersep> string ) ; } \n \t3 list . add ( uri ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t4 config . set <identifiersep> <identifier> ( integer . parse <identifiersep> int ( <identifier> <identifiersep> <identifier> [ 0 ] ) ) ; \n \t4 config . set <identifiersep> <identifier> <identifiersep> <identifier> ( long . parse <identifiersep> long ( <identifier> <identifiersep> <identifier> [ 1 ] ) ) ; \n \t3 } else { \n \t4 config . set <identifiersep> <identifier> ( config <identifiersep> <identifier> [ <number_literal> ] ) ; } } \n <ect>
\t2 json <identifiersep> <identifier> json <identifiersep> <identifier> = new json <identifiersep> <identifier> ( <identifier> ) ; \n \t2 try { \n \t3 write ( json <identifiersep> <identifier> , new properties ( ) ) ; \n \t2 } catch ( json <identifiersep> exception e ) { \n <ect>
\t9 <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> update . to <identifiersep> string ( ) + \n \t9 <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) + \n \t9 <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . to <identifiersep> string ( ) ) ; } } \n \t4 } catch ( <identifier> <identifiersep> runtime <identifiersep> exception e ) { \n <ect>
\t1 log . warn ( <string_literal> + <identifier> ) ; } \n \t1 log . warn ( <string_literal> ) ; \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t1 object <identifier> = s . next <identifiersep> id ( null ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 s <identifiersep> logger . info ( <string_literal> ) ; \n \t4 context . <identifier> <identifiersep> <identifier> <identifiersep> object ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; } \n \t3 if ( ! data <identifiersep> <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> <identifiersep> port <identifiersep> group ( network <identifiersep> name ) ) { \n <ect>
\t3 public <identifier> < <identifier> < string , <identifier> > > <identifier> ( ) { \n \t4 return new <identifier> <identifiersep> <identifier> < <identifier> < <identifier> , object > , <identifier> < string , <identifier> > > ( in ) { \n \t5 @ <identifier> \n \t5 protected <identifier> < string , <identifier> > <identifier> ( <identifier> < <identifier> , object > next ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t1 class <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map . set ( <identifier> , new <identifier> <identifiersep> map < string , class <identifiersep> <identifier> <identifiersep> <identifier> > ( ) ) ; \n \t1 log . debug ( <string_literal> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n \t3 logger . debug ( <string_literal> , principal ) ; \n \t3 return no ( ) ; } \n \t2 final string <identifier> = device <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( principal , request <identifiersep> context ) ; \n <ect>
public response write <identifiersep> and <identifiersep> <identifier> <identifiersep> configuration ( json <identifiersep> object request ) { \n \t1 log . debug ( <string_literal> , request ) ; \n \t1 try { \n \t1 if ( is <identifiersep> <identifier> ( ) == false ) { \n <ect>
\t1 log . warn ( <string_literal> + ex . get <identifiersep> message ( ) , ex ) ; \n \t1 host . set <identifiersep> state ( host <identifiersep> state . <identifier> ) ; \n \t1 <identifier> <identifiersep> session <identifiersep> manager . <identifier> <identifiersep> by <identifiersep> host ( host . get <identifiersep> host <identifiersep> id ( ) ) ; } } \n protected void process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , string <identifier> ) throws <identifier> <identifiersep> exception { \n <ect>
\t3 logger . info ( <string_literal> + line ) ; \n \t3 if ( ! line . <identifier> <identifiersep> with ( <identifier> <identifiersep> <identifier> ) ) \n \t4 continue ; \n \t3 if ( <identifier> == true ) { \n <ect>
\t1 { \n \t2 stream <identifiersep> result <identifiersep> <identifier> <identifier> = stream <identifiersep> manager . instance . get <identifiersep> <identifier> <identifiersep> stream ( <identifier> <identifiersep> id ) ; \n \t2 if ( <identifier> == null ) \n \t2 { \n <ect>
\t3 try { \n \t4 <identifier> . <identifier> ( status , <identifier> ) ; \n \t3 } catch ( exception e ) { \n \t4 <comment> \n <ect>
\t2 string <identifier> = <identifier> . get <identifiersep> property ( <identifier> . <identifier> ) ; \n \t2 logger . debug ( <string_literal> , <identifier> ) ; \n \t2 <identifier> . set <identifiersep> ignore ( <identifier> ) ; \n \t2 <identifier> <identifier> = new <identifier> ( new <identifier> ( <identifier> . get <identifiersep> property ( <identifier> . <identifier> ) , this ) ) ; \n <ect>
\t2 return true ; } \n \t1 @ action <identifiersep> <identifier> ( text = <string_literal> , <identifier> = <string_literal> ) \n \t1 public static boolean <identifier> <identifiersep> start <identifiersep> <identifier> ( @ <identifier> <identifiersep> <identifier> ( name = <string_literal> ) string <identifier> ) { \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> action <identifiersep> service . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 if ( <identifier> != null ) { \n \t3 try { \n \t4 <identifier> . shutdown ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 url config <identifiersep> url = ( url ) e . next <identifiersep> element ( ) ; \n \t4 log . info ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t4 <identifier> . add ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , config <identifiersep> url ) ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 { \n \t3 log . error ( <string_literal> ) ; } \n \t2 else \n \t2 { \n <ect>
\t4 logger . <identifier> ( this , <string_literal> + <identifier> <identifiersep> type ) ; \n \t3 return ; } \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> type != <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 close <identifiersep> <identifier> <identifiersep> result result = new close <identifiersep> <identifier> <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t3 do <identifiersep> close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t2 action <identifiersep> <identifier> < create <identifiersep> snapshot <identifiersep> response > <identifier> = client ( <identifier> <identifiersep> <identifier> ) . <identifier> ( ) . cluster ( ) \n \t3 . <identifier> <identifiersep> create <identifiersep> snapshot ( <string_literal> , <string_literal> ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( false ) . set <identifiersep> <identifier> ( <identifier> <identifiersep> name ) . execute ( ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 assert <identifiersep> true ( <identifier> <identifiersep> <identifier> . <identifier> ( 1 , time <identifiersep> unit . <identifier> ) ) ; \n <ect>
\t2 if ( host == null || host . get <identifiersep> <identifier> ( ) != null ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + host <identifiersep> id ) ; \n \t3 return false ; } \n \t2 if ( host . get <identifiersep> status ( ) != status . <identifier> && host . get <identifiersep> status ( ) != status . <identifier> && host . get <identifiersep> status ( ) != status . <identifier> ) { \n <ect>
\t1 logger . info ( <string_literal> ) ; \n \t1 logger . info ( <string_literal> ) ; \n \t1 logger . error ( <string_literal> ) ; \n \t1 logger . error ( <string_literal> ) ; \n <ect>
<number_literal> } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <number_literal> logger . warn ( <string_literal> , \n <number_literal> result , entry . get <identifiersep> key ( ) ) ; } } \n \t9 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( account . get <identifiersep> type ( ) != account . account <identifiersep> type <identifiersep> <identifier> ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + account + <string_literal> + <identifier> <identifiersep> id + <string_literal> ) ; \n \t4 success = ( success && <identifier> <identifiersep> account <identifiersep> <identifier> . delete <identifiersep> account ( account , user <identifiersep> context . current ( ) . get <identifiersep> <identifier> <identifiersep> user <identifiersep> id ( ) , user <identifiersep> context . current ( ) . get <identifiersep> <identifier> ( ) ) ) ; \n \t4 if ( ! success ) { \n <ect>
\t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n \t3 return response . <identifier> ( <string_literal> ) \n \t5 . build ( ) ; \n \t2 } catch ( throwable <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> type ( i <identifiersep> <identifier> <identifiersep> <identifier> . id <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> storage <identifiersep> type ( i <identifiersep> storage <identifiersep> <identifier> . id <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> manager . update <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 <identifier> <identifiersep> test = false ; \n \t4 string name = system . get <identifiersep> property ( <string_literal> ) ; \n \t4 string message = <identifier> . get <identifiersep> message ( ) ; \n <ect>
\t4 wait <identifiersep> for <identifiersep> <identifier> <identifiersep> thread . <identifier> ( ) ; } } \n \t2 remove <identifiersep> thread . <identifier> ( ) ; \n \t2 add <identifiersep> thread . <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) != 0 || <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) != <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> = int <identifiersep> <identifier> ; } \n \t4 try { \n \t5 user <identifiersep> <identifier> = integer . parse <identifiersep> int ( configuration . get <identifiersep> <identifier> <identifiersep> no <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception n ) { \n <ect>
\t3 throw new configuration <identifiersep> exception ( <string_literal> + conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , false ) ; \n \t2 if ( conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > 0 . <identifier> ) \n \t3 throw new configuration <identifiersep> exception ( <string_literal> + conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , false ) ; \n \t2 if ( conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < 0 . <identifier> ) \n <ect>
\t3 + <string_literal> , <identifier> <identifiersep> service ) ; \n \t2 update <identifiersep> service <identifiersep> <identifier> <identifiersep> with <identifiersep> registered <identifiersep> service ( <identifier> , <identifier> <identifiersep> service , service <identifiersep> <identifier> ) ; } \n \t1 private void update <identifiersep> service <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> service ( final list < registered <identifiersep> service > <identifier> , final registered <identifiersep> service <identifier> <identifiersep> service , \n <number_literal> final registered <identifiersep> service <identifier> <identifiersep> service , final service <identifiersep> <identifier> service <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> ( nodes <identifiersep> to <identifiersep> <identifier> , <identifier> ( ) ) ; \n \t2 logger . debug ( <string_literal> , final <identifiersep> <identifier> , nodes <identifiersep> to <identifiersep> <identifier> . size ( ) ) ; \n \t2 for ( <identifier> <identifiersep> node node : nodes <identifiersep> to <identifiersep> <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> node <identifiersep> <identifier> ( node ) ) ; } \n <ect>
\t5 assert <identifiersep> <identifier> <identifiersep> and <identifiersep> log <identifiersep> on <identifiersep> failure ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> response ) ; } \n \t4 <comment> \n \t4 <identifier> <identifiersep> response = client ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> query ( query <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> query ( ) ) \n \t5 . set <identifiersep> size ( num <identifiersep> <identifier> + num <identifiersep> <identifier> <identifiersep> <identifier> ) . add <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> ) . get ( ) ; \n <ect>
\t1 public abstract <identifiersep> <identifier> <identifiersep> <identifier> ( context context , list < ? extends <identifier> > <identifier> , \n \t7 <identifier> <identifiersep> store <identifier> <identifiersep> store ) throws <identifier> <identifiersep> store <identifiersep> exception { \n \t2 this . <identifier> <identifiersep> store = <identifier> <identifiersep> store ; \n \t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> store . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 final i <identifiersep> <identifier> <identifiersep> endpoint endpoint = get <identifiersep> endpoint ( ) ; \n \t2 int total = <identifier> . size ( ) ; \n \t2 <comment> \n \t2 if ( max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > 0 && total > max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 return queue <identifiersep> <identifier> . get <identifiersep> in <identifiersep> <identifier> <identifiersep> count ( ) == 0 ; } \n \t2 } ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n <ect>
\t2 <identifier> <identifiersep> config . set <identifiersep> max <identifiersep> <identifier> ( max <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; \n \t2 <identifier> <identifiersep> config . set <identifiersep> max <identifiersep> <identifier> ( max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size ) ; \n \t2 <identifier> <identifiersep> config . set <identifiersep> max <identifiersep> write <identifiersep> <identifier> ( max <identifiersep> write <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> output <identifiersep> format . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> options ( job , <identifier> <identifiersep> config ) ; \n <ect>
\t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t7 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t8 try { \n \t9 <identifier> <identifiersep> node . set <identifiersep> properties ( <identifier> <identifiersep> node . get <identifiersep> security <identifiersep> context ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t8 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 . url ( ) ; \n \t1 metadata . put ( <string_literal> , task <identifiersep> id ) ; \n \t1 metadata . put ( <string_literal> , task <identifiersep> url . to <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t1 log . info ( <string_literal> , <identifier> <identifiersep> url ) ; \n <ect>
\t5 get <identifiersep> default <identifiersep> port <identifiersep> end ( ) , get <identifiersep> source <identifiersep> ip <identifiersep> address <identifiersep> id ( ) , get <identifiersep> <identifier> ( ) , get <identifiersep> <identifier> ( ) , get <identifiersep> network <identifiersep> id ( ) , get <identifiersep> entity <identifiersep> <identifier> <identifiersep> id ( ) , get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , is <identifiersep> <identifier> ( ) ) ; \n \t3 this . set <identifiersep> entity <identifiersep> id ( result . get <identifiersep> id ( ) ) ; \n \t3 this . set <identifiersep> entity <identifiersep> <identifier> ( result . get <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( network <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t7 <identifier> <identifiersep> <identifier> . put ( <identifier> <identifiersep> node . <identifier> <identifiersep> to <identifiersep> public <identifiersep> <identifier> , <identifier> <identifiersep> node . get <identifiersep> property ( <identifier> <identifiersep> node . <identifier> <identifiersep> to <identifiersep> public <identifiersep> <identifier> ) ) ; \n \t7 try { \n \t8 new <identifiersep> node . set <identifiersep> properties ( new <identifiersep> node . get <identifiersep> security <identifiersep> context ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t7 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
public void remove <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . model . <identifier> <identifiersep> <identifier> object ) { \n \t1 <identifier> <identifiersep> object <identifiersep> from <identifiersep> property <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> key ) ; } \n public void add <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . model . <identifier> <identifiersep> <identifier> object ) { \n <ect>
<comment> \n public cache <identifiersep> entry <identifier> ( <identifier> <identifiersep> info request ) { \n \t1 cache <identifiersep> entry result = null ; \n <ect>
\t1 run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <identifier> ) ; \n \t1 list < string > <identifier> = run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( \n \t1 <string_literal> ) ; \n \t1 assert . assert <identifiersep> equals ( <string_literal> , <number_literal> , <identifier> . size ( ) ) ; \n <ect>
\t4 logger . debug ( e . get <identifiersep> message ( ) , e ) ; \n \t3 } finally { \n \t4 handler . <identifier> ( ) ; } } \n \t2 if ( ! found <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
<comment> \n \t1 protected void process <identifiersep> next <identifiersep> line ( string data ) { \n \t2 log . debug ( <string_literal> , data ) ; \n \t2 if ( <string_literal> . equals ( data ) ) { \n <ect>
<comment> \n \t1 void <identifier> <identifiersep> session <identifiersep> <identifier> ( remote <identifiersep> host <identifiersep> id from , <identifier> <identifiersep> <identifier> <identifiersep> state state ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 log . error ( <identifier> + <string_literal> ) ; \n \t2 map < <identifier> <identifiersep> <identifier> , set < <identifier> > > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t2 for ( map . entry < <identifier> <identifiersep> <identifier> , set < <identifier> > > entry : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . entry <identifiersep> set ( ) ) { \n \t3 log . error ( <identifier> + <string_literal> + entry . get <identifiersep> key ( ) ) ; \n <ect>
\t4 log . info ( <string_literal> , <string_literal> + <identifier> <identifiersep> type ) ; \n \t4 get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . add ( <identifier> <identifiersep> type ) ; } } \n \t2 <comment> \n \t2 catch ( no <identifiersep> class <identifiersep> <identifier> <identifiersep> found <identifiersep> error e ) { \n <ect>
\t5 log . debug ( <string_literal> , this . <identifier> , <identifier> ) ; \n \t5 final <identifier> <identifier> <identifiersep> <identifier> = this . <identifier> ; \n \t5 this . <identifier> = <identifier> ; \n \t5 if ( <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t3 if ( result != null ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + vm <identifiersep> name + <string_literal> + result ) ; \n \t4 return new check <identifiersep> <identifier> <identifiersep> answer ( cmd , <string_literal> + vm <identifiersep> name + <string_literal> + result ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t1 <comment> \n \t1 private static void <identifier> <identifiersep> out <identifiersep> debug <identifiersep> info ( ) { \n <ect>
\t4 if ( ! entry . is <identifiersep> directory ( ) && name . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) { \n \t5 <identifier> = to <identifiersep> <identifier> ( config , <identifier> , null ) ; } \n \t4 <identifier> . close <identifiersep> entry ( ) ; } } \n \t2 catch ( throwable t ) { \n <ect>
\t5 } finally { \n \t6 thread . current <identifiersep> thread ( ) . set <identifiersep> name ( name ) ; } } \n \t3 } ; \n \t2 } else if ( <identifier> . <identifier> <identifiersep> <identifier> ( m ) ) { \n <ect>
\t5 <string_literal> \n \t4 ) ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) \n \t2 { \n <ect>
\t1 return is <identifiersep> <identifier> <identifiersep> service ( stack <identifiersep> manager , stack <identifiersep> name , stack . get <identifiersep> <identifier> <identifiersep> stack <identifiersep> version ( ) , service <identifiersep> name , <identifier> <identifiersep> name ) ; } } \n private static boolean is <identifiersep> <identifier> <identifiersep> service ( stack <identifiersep> info stack , string service <identifiersep> name , string <identifier> <identifiersep> name ) { \n \t1 <identifier> <identifiersep> info <identifier> = stack . get <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t1 if ( <identifier> == null ) { \n <ect>
<comment> \n public <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> metadata [ ] metadata ) { \n \t1 this ( metadata , new <identifier> <identifiersep> channel [ 0 ] ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> = true ; } \n \t2 catch ( throwable t ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> throwable ( t ) ; \n <ect>
\t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . get <identifiersep> status ( ) , equal <identifiersep> to ( cluster <identifiersep> <identifier> <identifiersep> status . <identifier> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> shards ( ) , equal <identifiersep> to ( num <identifiersep> shards . num <identifiersep> <identifier> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) . get <identifiersep> <identifier> <identifiersep> shards ( ) , equal <identifiersep> to ( num <identifiersep> shards . num <identifiersep> <identifier> * <number_literal> ) ) ; \n <ect>
\t2 final run <identifiersep> <identifier> <identifiersep> type msg = ( run <identifiersep> <identifier> <identifiersep> type ) <identifier> . get <identifiersep> request ( ) ; \n \t2 if ( ( msg . get <identifiersep> <identifier> <identifiersep> id ( ) != null ) && ! <string_literal> . equals ( msg . get <identifiersep> <identifier> <identifiersep> id ( ) ) ) { \n \t2 <identifier> <identifiersep> id = msg . get <identifiersep> <identifier> <identifiersep> id ( ) ; <comment> \n \t1 } catch ( final illegal <identifiersep> context <identifiersep> access <identifiersep> exception ex ) { \n <ect>
\t3 return null ; <comment> \n \t3 <identifier> <identifiersep> <identifier> -- ; \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> == 0 ) { \n <ect>
\t3 <identifier> <identifiersep> provider . add <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> store ( <identifier> , password ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; } \n \t2 } else { \n <ect>
\t7 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> query . <identifier> <identifiersep> properties [ \n \t8 ( ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) \n \t8 . get <identifiersep> property ( ) ] ) ; } \n \t3 else \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> info info = null ; \n \t1 try { \n \t1 info = <identifier> . find ( new <identifier> <identifiersep> <identifier> <identifiersep> info ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 throw new <identifier> <identifiersep> exception ( e ) ; \n \t2 } finally { \n \t3 session . <identifier> ( ) ; } \n \t2 if ( long <identifiersep> name <identifiersep> found ) { \n <ect>
\t3 context . start ( ) ; \n \t3 <identifier> = true ; \n \t2 } catch ( exception e ) { \n \t3 <comment> \n <ect>
<comment> \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> consumer ( ) throws exception { \n \t2 consumer <identifiersep> connection = create <identifiersep> connection ( ) ; \n \t2 consumer <identifiersep> connection . start ( ) ; \n <ect>
\t2 try \n \t2 { \n \t3 if ( ! service . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) \n \t3 { \n <ect>
\t4 if ( <identifier> <identifiersep> request <identifiersep> context . is <identifiersep> current <identifiersep> thread <identifiersep> <identifier> ( ) ) { \n \t5 <identifier> <identifiersep> request <identifiersep> log log = <identifier> <identifiersep> request <identifiersep> log . get <identifiersep> current <identifiersep> request ( ) ; \n \t5 logger . info ( <string_literal> , request <identifiersep> url . to <identifiersep> string ( ) , log . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> as <identifiersep> string ( ) ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } \n \t3 if ( <identifier> <identifiersep> account <identifiersep> to <identifiersep> <identifier> ( <identifier> , account . get <identifiersep> id ( ) , <identifier> <identifiersep> account . <identifier> . <identifier> ) != null ) { \n \t4 return true ; \n \t3 } else { \n <ect>
\t1 <identifier> ( action = <string_literal> ) \n @ <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . default ) \n class s <identifiersep> name <identifiersep> node <identifiersep> default ( s <identifiersep> name <identifiersep> node ) : \n <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( self , <identifier> , <identifier> <identifiersep> type = <identifier> ) : \n <ect>
\t3 <identifier> . add ( map . get <identifiersep> instance <identifiersep> id ( ) ) ; \n \t3 <identifier> <identifiersep> to <identifiersep> <identifier> . put ( <identifier> <identifiersep> id , <identifier> ) ; \n \t3 map . set <identifiersep> <identifier> ( true ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> dao . <identifier> ( map ) ; \n <ect>
\t3 long size = - 1 ; \n \t3 if ( volume <identifiersep> host != null ) { \n \t4 size = volume <identifiersep> host . get <identifiersep> <identifier> <identifiersep> size ( ) ; } \n \t3 else { \n <ect>
public void set <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . model . <identifier> value ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( value , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . model . <identifier> value ) { \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 return session . create <identifiersep> <identifier> <identifiersep> <identifier> ( ( <identifier> ) consumer <identifiersep> destination , get <identifiersep> name ( ) ) ; } \n \t2 return session . create <identifiersep> consumer ( consumer <identifiersep> destination ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 item item = item <identifiersep> <identifier> . get <identifiersep> item ( item <identifiersep> id ) ; \n \t3 state <identifiersep> <identifier> state = get <identifiersep> state ( item ) ; \n \t3 item <identifiersep> state = new item <identifiersep> state <identifiersep> data ( system . current <identifiersep> time <identifiersep> millis ( ) , item <identifiersep> id , state ) ; \n \t2 } catch ( item <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
\t2 logger . info ( <string_literal> , state . id ) \n \t2 state . get <identifiersep> entry <identifiersep> action <identifiersep> list ( ) . add ( { request <identifiersep> context - > \n \t3 <identifier> <identifier> <identifiersep> <identifier> = request <identifiersep> context . <identifier> <identifiersep> <identifier> \n \t3 <identifier> http <identifiersep> request = web <identifiersep> utils . get <identifiersep> http <identifiersep> <identifier> <identifiersep> request <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( request <identifiersep> context ) \n <ect>
\t2 <identifier> <identifiersep> <identifier> . delete <identifiersep> file ( <identifier> <identifiersep> file . get <identifiersep> id ( ) , true , null ) ; } \n \t1 } else if ( content <identifiersep> item instanceof file <identifiersep> content <identifiersep> item ) { \n \t1 <comment> \n \t1 string path = ( ( file <identifiersep> content <identifiersep> item ) content <identifiersep> item ) . get <identifiersep> file ( ) . get <identifiersep> name ( ) ; \n <ect>
\t3 <identifier> = new <identifier> <identifiersep> field <identifiersep> set ( <identifier> , false , true ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 <comment> \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t6 start <identifiersep> grid ( <identifier> ) ; } \n \t5 return null ; } \n \t3 } ) ; \n \t3 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n <ect>
\t1 for ( final string queue : <identifier> ) { \n \t1 try { \n \t2 <identifier> <identifiersep> queue <identifiersep> client <identifiersep> manager . get <identifiersep> instance ( ) . delete <identifiersep> queue ( queue ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t1 if self . <identifier> <identifiersep> version is not <identifier> : \n \t2 self . <identifier> <identifiersep> version = self . <identifier> <identifiersep> version . <identifier> ( ) \n \t2 self . <identifier> <identifiersep> output [ <identifier> <identifiersep> <identifier> ] = self . <identifier> <identifiersep> version \n \t2 self . put <identifiersep> <identifier> <identifiersep> out ( self . <identifier> <identifiersep> output ) \n <ect>
\t1 log . debug ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> location , \n \t2 location . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t1 } else { \n \t1 location = new file ( path , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> default ) ; \n <ect>
\t1 query query = null ; \n \t1 list < string > table <identifiersep> <identifier> = new array <identifiersep> list < > ( ) ; \n \t1 try { \n \t1 <identifier> <identifiersep> transaction ( ) ; \n <ect>
\t4 <identifier> ( <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> data ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t4 <comment> \n \t5 <comment> \n \t4 <comment> \n <ect>
\t4 public <identifiersep> <identifier> = network <identifiersep> model . get <identifiersep> network ( entry . get <identifiersep> value ( ) . get <identifiersep> network <identifiersep> id ( ) ) ; \n \t4 uri <identifier> <identifiersep> uri = <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> . to <identifiersep> uri ( entry . get <identifiersep> key ( ) ) ; \n \t4 it <identifiersep> <identifier> . remove <identifiersep> vm <identifiersep> from <identifiersep> network ( <identifier> <identifiersep> <identifier> , public <identifiersep> <identifier> , <identifier> <identifiersep> uri ) ; \n \t3 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t6 status <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> on ( true ) ; \n \t5 } else { \n \t6 status <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> on ( false ) ; } \n \t4 } else { \n <ect>
\t1 public void set <identifiersep> <identifier> ( ) throws exception { \n \t2 super . set <identifiersep> <identifier> ( ) ; \n \t2 byte [ ] <identifier> = <identifier> . get <identifiersep> bytes ( <string_literal> ) ; \n \t2 byte [ ] <identifier> = <identifier> . get <identifiersep> bytes ( <string_literal> ) ; \n <ect>
\t2 lock . <identifier> ( ) ; } \n \t2 try { \n \t2 task . run ( ) ; \n \t2 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> config . put ( <string_literal> , <string_literal> ) ; \n \t3 <identifier> . run <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> \n \t5 + <identifier> <identifiersep> name + <string_literal> + <identifier> <identifiersep> name \n \t5 + <string_literal> ) ; \n <ect>
\t3 out . <identifier> ( ) ; } \n \t2 catch ( resource <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { <identifier> <identifiersep> log . error ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } \n \t2 catch ( parse <identifiersep> error <identifiersep> exception ex ) \t1 { <identifier> <identifiersep> log . error ( <string_literal> + path + <string_literal> + ex . get <identifiersep> message ( ) ) ; } \n \t2 catch ( method <identifiersep> <identifier> <identifiersep> exception ex ) { <identifier> <identifiersep> log . error ( <string_literal> + path + <string_literal> + ex . get <identifiersep> message ( ) ) ; } \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> map . get ( <identifier> <identifiersep> num ) ; \n \t1 if ( <identifier> == null ) { \n \t2 <identifier> = new <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> map . put ( <identifier> <identifiersep> num , <identifier> ) ; } \n <ect>
\t2 <identifier> <identifier> = <identifier> <identifiersep> <identifier> ( context <identifiersep> <identifier> ) ; \n \t2 logger . debug ( <string_literal> , source <identifiersep> name ) ; \n \t2 try \n \t2 { \n <ect>
\t4 if ( ! cache <identifiersep> policy . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> version <identifiersep> id ( ) , null , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> millis ( ) , \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> source . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . equals ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ) ) { \n \t5 result . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t5 return ; } \n <ect>
\t2 <identifier> <identifiersep> context <identifier> = <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t2 properties p = <identifier> . get <identifiersep> <identifier> <identifiersep> properties ( get <identifiersep> class ( ) , new string [ ] { <identifier> <identifiersep> <identifier> } ) ; \n \t2 string <identifier> <identifiersep> <identifier> = p . get <identifiersep> property ( <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t2 file file = <identifier> . <identifier> ( ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 class <identifiersep> <identifier> . add <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> == <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n <ect>
\t4 assert <identifiersep> that ( <string_literal> , snapshot , contains <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) ; \n \t4 assert <identifiersep> that ( snapshot . <identifier> <identifiersep> <identifier> ( ) , equal <identifiersep> to ( 1 ) ) ; } \n \t3 <comment> \n \t3 index <identifiersep> <identifier> <identifier> = shards . add <identifiersep> <identifier> ( ) ; \n <ect>
\t6 <comment> \n \t6 s <identifiersep> logger . debug ( <string_literal> , e ) ; } } \n \t4 snapshot = <identifier> ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 string . format ( \n \t3 <string_literal> , \n \t3 api <identifiersep> key , <identifier> , <identifier> ) ; \n \t1 if ( method == http <identifiersep> method . get ) { \n <ect>
\t10 <comment> \n \t10 <comment> \n \t10 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> account . get ( ) + <string_literal> + <identifier> + <string_literal> ) ; \n \t10 int stop <identifiersep> response <identifiersep> code = execute <identifiersep> stop ( server , <identifier> <identifiersep> server , <identifier> , false ) ; \n <ect>
\t1 public boolean <identifier> ( property <identifiersep> <identifier> <identifiersep> listener listener ) { \n \t2 if ( <identifier> == null ) { \n \t3 <identifier> = <identifier> . new <identifiersep> <identifier> <identifiersep> set ( ) ; } \n \t2 if ( listener == null ) { \n <ect>
\t3 try { \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> static <identifiersep> <identifier> ( ip . get <identifiersep> id ( ) , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> account ( account . account <identifiersep> id <identifiersep> system ) , user . <identifier> <identifiersep> system , true ) ) { \n \t5 s <identifiersep> logger . debug ( <string_literal> + ip + <string_literal> + vm <identifiersep> id + <string_literal> ) ; \n \t4 } else { \n <ect>
\t2 <identifier> < string > <identifier> <identifiersep> <identifier> = properties . key <identifiersep> set ( ) . <identifier> ( ) ; <identifier> <identifiersep> <identifier> . has <identifiersep> next ( ) ; ) { \n \t3 string <identifier> <identifiersep> property <identifiersep> name = <identifier> <identifiersep> <identifier> . next ( ) ; \n \t3 string property <identifiersep> name = <identifier> <identifiersep> property <identifiersep> name ; \n \t3 string value = ( ( string ) properties . get ( property <identifiersep> name ) ) ; \n <ect>
\t2 <identifier> . <identifier> ( file <identifiersep> key , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . all <identifiersep> <identifier> , <identifier> <identifiersep> file <identifiersep> <identifier> . length ) ; \n \t2 try { \n \t2 consumer . <identifier> <identifiersep> data ( <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( message message , data <identifiersep> type type ) throws <identifier> <identifiersep> exception { \n \t2 exchange exchange = message . get <identifiersep> exchange ( ) ; \n <ect>
\t4 if ( in <identifiersep> stream != null ) { \n \t5 try { \n \t6 in <identifiersep> stream . close ( ) ; } \n \t5 catch ( io <identifiersep> exception io ) { \n <ect>
\t5 table <identifiersep> model . manager . add <identifiersep> file ( <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t5 table <identifiersep> model . <identifier> <identifiersep> table <identifiersep> data <identifiersep> <identifier> ( ) ; \n \t5 check <identifiersep> <identifier> <identifiersep> status ( ) ; } \n \t3 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t1 collection <identifiersep> <identifier> = command <identifiersep> <identifier> . is <identifiersep> collection <identifiersep> <identifier> <identifiersep> on <identifiersep> host ( ) \n \t1 if command <identifiersep> <identifier> . check <identifiersep> <identifier> and not collection <identifiersep> <identifier> : \n \t1 logger . info ( format ( <string_literal> ) ) \n \t1 return \n <ect>
<comment> \n \t1 public synchronized boolean <identifier> <identifiersep> update ( string <identifier> <identifiersep> item <identifiersep> name , int <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> in <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> item <identifiersep> name == null ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t2 properties . put <identifiersep> all ( directory <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t1 <comment> \n \t1 <comment> \n <ect>
\t7 try { \n \t8 <identifier> <identifiersep> <identifier> . delete ( user , group , path ) ; \n \t8 log . debug ( <string_literal> + path ) ; } \n \t7 catch ( action <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t8 <identifier> <identifiersep> utils . <identifier> <identifiersep> template <identifiersep> name ( template <identifiersep> <identifier> . get <identifiersep> template ( ) ) , context . get <identifiersep> <identifier> ( ) , <identifier> , <identifier> <identifiersep> <identifier> , \n \t8 template <identifiersep> <identifier> , context . get <identifiersep> <identifier> ( ) , <identifier> , <identifier> <identifiersep> <identifier> } ) ; } \n \t2 } catch ( final template <identifiersep> output <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t2 return create <identifiersep> <identifier> <identifiersep> dir <identifiersep> context ( principal , password , null , is <identifiersep> system <identifiersep> context , <identifier> <identifiersep> id ) ; } \n \t1 private <identifier> <identifiersep> context create <identifiersep> <identifier> <identifiersep> dir <identifiersep> context ( final string principal , final string password , final string provider <identifiersep> url , final boolean is <identifiersep> system <identifiersep> context , long <identifier> <identifiersep> id ) \n \t2 throws <identifier> <identifiersep> exception , io <identifiersep> exception { \n \t2 <identifier> < string , string > <identifier> = get <identifiersep> <identifier> ( principal , password , provider <identifiersep> url , is <identifiersep> system <identifiersep> context , <identifier> <identifiersep> id ) ; \n <ect>
\t1 public void write <identifiersep> bytes ( output <identifiersep> stream out ) throws data <identifiersep> format <identifiersep> exception , io <identifiersep> exception { \n \t2 if ( ( <identifier> <identifiersep> <identifier> <identifiersep> mode < 0 ) || ( <identifier> <identifiersep> <identifier> <identifiersep> mode > <identifier> <identifiersep> mode <identifiersep> <identifier> ) ) throw new data <identifiersep> format <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> mode ) ; \n \t2 long <identifier> = get <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n <ect>
<comment> \n \t1 public public <identifiersep> key <identifiersep> object get <identifiersep> <identifier> <identifiersep> key <identifiersep> for <identifiersep> principal ( <identifier> principal ) throws content <identifiersep> <identifier> <identifiersep> exception , io <identifiersep> exception { \n \t2 if ( null == principal ) { \n \t3 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n <ect>
\t1 { \n \t2 log . info ( <string_literal> + entity <identifiersep> class . to <identifiersep> string ( ) + <string_literal> + entity <identifiersep> name + <string_literal> ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> index ( entity <identifiersep> class , <identifier> ) ; \n <ect>
\t2 } ) ; \n \t2 break ; \n \t2 case <identifier> : \n \t2 <comment> \n <ect>
\t3 logger . info ( <string_literal> , out <identifiersep> file ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; } } \n \t1 private void write <identifiersep> <identifier> <identifiersep> file ( <identifier> <identifiersep> node < <identifier> , <identifier> > <identifier> , file out <identifiersep> file ) throws io <identifiersep> exception , <identifier> <identifiersep> command <identifiersep> exception { \n \t2 string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ; \n <ect>
\t2 log . info ( <string_literal> + ( <identifier> == store . get ( <string_literal> ) ) ) ; \n \t2 log . info ( <string_literal> + ( <identifier> == store . get ( <string_literal> ) ) ) ; \n \t2 log . info ( <string_literal> + ( <identifier> . the <identifiersep> <identifier> ( ) == integer . class . <identifier> ( store . get ( <string_literal> ) ) ) ) ; \n \t2 log . info ( <string_literal> + ( <identifier> . the <identifiersep> <identifier> ( ) == integer . class . <identifier> ( store . get ( <string_literal> ) ) ) ) ; \n <ect>
\t3 return null ; } \n \t2 final <identifier> <identifiersep> cache < string , ticket > cache = get <identifiersep> <identifier> <identifiersep> cache <identifiersep> from <identifiersep> metadata ( metadata ) ; \n \t2 final ticket ticket = cache . get ( ticket <identifiersep> id ) ; \n \t2 if ( ticket == null ) { \n <ect>
\t3 try { \n \t4 t . <identifier> ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception <identifier> ) { \n <ect>
\t4 default : \n \t5 <identifier> . set <identifiersep> connection <identifiersep> <identifier> ( new default <identifiersep> connection <identifiersep> <identifier> ( ) ) ; \n \t5 break ; } } \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) != null ) { \n <ect>
\t3 <identifier> . <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 } else if ( <identifier> . is <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 <identifier> . <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 } else { \n <ect>
\t1 public void run ( ) { \n \t2 command <identifiersep> task <identifiersep> new new <identifiersep> task = ( command <identifiersep> task <identifiersep> new ) <identifier> ; \n \t2 job <identifiersep> task task = <identifier> . <identifier> . get ( new <identifiersep> task . get <identifiersep> job <identifiersep> key ( ) . to <identifiersep> string ( ) ) ; \n \t2 if ( task == null ) { \n <ect>
\t2 public void write <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context <identifier> , write <identifiersep> <identifier> <identifiersep> event e ) throws exception \n \t2 { \n \t3 if ( last <identifiersep> exception != null ) \n \t3 { \n <ect>
\t5 if ( <identifier> == ' \\ \\ ' ) { \n \t6 <comment> \n \t6 <identifier> . <identifier> ( c ) ; \n \t6 break ; } \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \t3 return <identifier> <identifiersep> <identifier> . process ( <identifier> ) ; } \n \t2 <identifier> <identifiersep> <identifier> = new <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . <identifier> ( ) ) { \n <ect>
\t4 <comment> \n <ect>
<comment> \n \t1 public void test <identifiersep> start <identifiersep> stop <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 grid <identifiersep> logger log = new grid <identifiersep> java <identifiersep> logger ( ) ; \n <ect>
\t4 to <identifiersep> delete <identifiersep> resource . add ( resource <identifiersep> store . execute <identifiersep> output <identifiersep> resource <identifiersep> root + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t4 for ( <identifier> <identifiersep> <identifier> task : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t5 to <identifiersep> delete <identifiersep> resource . add ( resource <identifiersep> store . execute <identifiersep> output <identifiersep> resource <identifiersep> root + <string_literal> + task . get <identifiersep> <identifier> ( ) ) ; } } } \n \t2 if ( to <identifiersep> delete <identifiersep> resource . size ( ) > 0 ) { \n <ect>
\t3 entry . set <identifiersep> value ( get <identifiersep> <identifier> <identifiersep> state ( task <identifiersep> id , last <identifiersep> <identifier> <identifiersep> snapshot ) ) ; } } \n \t1 public transaction <identifiersep> state get <identifiersep> <identifier> <identifiersep> state ( int task <identifiersep> id ) { \n \t2 <comment> \n \t2 if ( ! contains <identifiersep> task ( task <identifiersep> id ) ) { \n <ect>
\t3 log . error ( <string_literal> ) ; \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( \n \t5 <string_literal> ) ; } \n \t2 if ( object <identifiersep> <identifier> . is <identifiersep> empty ( <identifier> <identifiersep> name ) ) { \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> time == 0 ) { \n <ect>
\t5 create <identifiersep> configuration <identifiersep> <identifier> <identifiersep> event . and <identifiersep> next ( <identifier> ) , \n \t5 create <identifiersep> configuration <identifiersep> <identifier> <identifiersep> event . and <identifiersep> next ( <identifier> ) ) ; \n \t4 <identifier> . start ( config . get <identifiersep> name ( ) ) ; \n \t3 } else { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 int i = 0 ; \n \t2 for ( map . entry < entity <identifiersep> key , object > entity <identifiersep> key <identifiersep> and <identifiersep> entity : <identifier> <identifiersep> by <identifiersep> entity <identifiersep> key ) { \n \t3 if ( i ++ > <number_literal> ) { \n <ect>
\t4 if ( count == 0 ) { \n \t5 if ( last <identifiersep> count > 0 ) { \n \t6 long time = <identifier> <identifiersep> context . <identifier> ( ) . <identifier> ( ) - start <identifiersep> time ; \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t1 if ( volume <identifiersep> <identifier> <identifiersep> token <identifiersep> map != null && ! volume <identifiersep> <identifier> <identifiersep> token <identifiersep> map . is <identifiersep> empty ( ) ) { \n \t1 try { \n \t2 <identifier> . as <identifiersep> transaction ( vm <identifiersep> instance . class , update <identifiersep> function , vm <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) . <identifier> ( volume <identifiersep> <identifier> <identifiersep> token <identifiersep> map ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> update <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 for ( <identifier> <identifiersep> server <identifier> : <identifier> . values ( ) ) { \n \t3 assert <identifiersep> null ( <identifier> . get <identifiersep> store <identifiersep> <identifier> ( ) . get <identifiersep> local <identifiersep> store ( <string_literal> ) ) ; } \n <ect>
\t6 string <identifier> = ( string ) task <identifiersep> <identifier> . get <identifiersep> attribute ( job <identifiersep> id ) ; \n \t6 assert <identifier> != null : <string_literal> ; \n \t6 assert <identifier> . equals ( <string_literal> + job <identifiersep> id ) : <string_literal> + <identifier> ; \n <ect>
\t5 response = <identifier> <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) \n \t8 . create <identifiersep> response ( response . <identifier> , request ) ; } \n \t4 catch ( exception e ) \n \t4 { \n <ect>
\t2 final string <identifier> <identifiersep> name = <identifier> <identifiersep> list . get ( i ) . to <identifiersep> string ( ) ; \n \t2 <identifier> <identifiersep> client . execute <identifiersep> void ( <identifier> , new client <identifiersep> <identifier> < <identifier> <identifiersep> client <identifiersep> service . client > ( ) { \n \t3 @ <identifier> \n \t3 public void execute ( <identifier> <identifiersep> client <identifiersep> service . client client ) throws exception { \n <ect>
\t3 if ( <identifier> <identifiersep> out == null ) { \n \t4 continue ; } \n \t3 <identifier> <identifier> <identifiersep> <identifier> <identifiersep> key = <identifier> <identifiersep> out . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ( ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> key ) ) { \n <ect>
\t1 <comment> \n \t1 try { \n \t1 <identifier> <identifiersep> list . add <identifiersep> all ( <identifier> <identifiersep> storage <identifiersep> handler <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> ( table <identifiersep> dir , get <identifiersep> conf ( ) ) ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 try { \n \t3 send <identifiersep> <identifier> <identifiersep> check ( <string_literal> <ect>
\t1 list < load <identifiersep> <identifier> > <identifier> = null ; \n \t1 try { \n \t1 <identifier> = load <identifiersep> <identifier> . list <identifiersep> <identifier> ( ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t4 <identifier> <identifiersep> result = 0 ; \n \t4 <identifier> . count <identifiersep> <identifier> ( ) ; } \n \t3 @ <identifier> \n \t3 public void on <identifiersep> error ( exception exception ) { \n <ect>
protected <identifier> parse <identifiersep> <identifier> ( server from ) { \n \t1 try { \n \t2 return <identifier> . find ( <identifier> . get ( ) , new find <identifiersep> <identifier> <identifiersep> for <identifiersep> server ( from ) ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n <ect>
\t4 <comment> \n \t4 last = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 } catch ( socket <identifiersep> exception e ) \n \t3 { \n <ect>
\t2 <identifier> . add <identifiersep> <identifier> ( m ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t2 log . warn ( <string_literal> , e ) ; } \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 if ( ! <identifier> . contains <identifiersep> key ( <identifier> , <identifier> ) ) \n \t5 log . warn ( format ( <string_literal> , <identifier> . get <identifiersep> name ( ) , <identifier> . get <identifiersep> name ( ) ) ) ; \n \t4 store <identifiersep> <identifier> x = <identifier> . get ( <identifier> , <identifier> ) ; \n \t4 if ( <identifier> . contains ( x ) ) \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> ( true ) ; \n \t3 <identifier> = <identifier> ; } \n \t2 catch ( throwable t ) \n \t2 { \n <ect>
\t6 e . add <identifiersep> <identifier> ( <identifier> ) ; } \n \t5 throw e ; } \n \t3 } ) ; \n \t2 } catch ( timeout <identifiersep> exception e ) { \n <ect>
\t3 num = <identifier> . <identifier> ( ) . time ( ) ; \n \t3 count = new <identifier> <identifiersep> count ( <identifier> , data <identifiersep> store <identifiersep> source . server , action . get <identifiersep> <identifier> , <string_literal> , num ) ; \n \t3 this . queue . put ( count ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t2 try { \n \t3 configuration configuration = <identifier> . get <identifiersep> configuration ( <string_literal> ) ; \n \t3 properties = configuration . get <identifiersep> properties ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 max <identifiersep> <identifier> <identifiersep> size = integer . parse <identifiersep> int ( max <identifiersep> <identifier> <identifiersep> size <identifiersep> <identifier> ) ; \n \t4 log . info ( <string_literal> + max <identifiersep> <identifier> <identifiersep> size ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n \t4 max <identifiersep> <identifier> <identifiersep> size = - 1 ; \n <ect>
\t2 int <identifier> = 0 ; \n \t2 for ( int i = 0 ; i < <number_literal> ; ++ i ) { \n \t3 message message = connection <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n \t3 assert <identifiersep> not <identifiersep> null ( <string_literal> + i , message ) ; \n <ect>
\t4 <identifier> = true ; \n \t3 } catch ( <identifier> <identifiersep> update <identifiersep> exception e ) { \n \t4 if ( handle <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ) { \n \t5 <comment> \n <ect>
\t4 system <identifiersep> info . parse ( <identifier> ) ; \n \t4 system <identifiersep> info . set <identifiersep> ip ( ip ) ; \n \t4 this . system <identifiersep> info = system <identifiersep> info ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 <comment> \n \t2 if ( ! check <identifiersep> connection ( ) ) { \n \t3 logger . error ( <string_literal> ) ; } } \n \t1 public void <identifier> ( ) { \n <ect>
\t2 if ( <identifier> . get <identifiersep> current <identifiersep> <identifier> <identifiersep> key ( ) == null ) \n \t3 return ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> builder . build <identifiersep> session <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 <identifier> <identifiersep> to <identifiersep> <identifier> = new array <identifiersep> list < load <identifiersep> <identifier> <identifiersep> <identifier> > ( ) ; } \n \t4 <identifier> <identifiersep> to <identifiersep> <identifier> . add ( <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . put ( source <identifiersep> ip , <identifier> <identifiersep> to <identifiersep> <identifier> ) ; \n \t3 } else { \n <ect>
\t3 synchronized ( <identifier> ) \n \t3 { \n \t4 logger . debug ( <string_literal> ) ; \n \t4 <identifier> . wait ( <number_literal> ) ; \n <ect>
\t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 if ( i == <number_literal> ) { \n \t4 logger . debug ( <string_literal> ) ; \n \t3 } else { \n <ect>
\t1 { \n \t1 final string uri = this . config . get <identifiersep> connection <identifiersep> uri ( ) ; \n \t1 if ( log . is <identifiersep> <identifier> ( level . info ) ) \n \t1 { \n <ect>
\t4 log . info ( <string_literal> + ( size - last <identifiersep> size ) ) ; \n \t4 assert <identifiersep> true ( size > last <identifiersep> size ) ; \n \t4 last <identifiersep> size = size ; } \n \t2 } finally { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 return null ; } \n \t1 private void handle <identifiersep> <identifier> ( interrupted <identifiersep> exception e ) { \n \t2 if ( is <identifiersep> shutdown . get ( ) ) return ; \n <ect>
\t6 } else \n \t7 all <identifiersep> <identifier> = false ; } \n \t5 if ( all <identifiersep> <identifier> ) { \n \t6 task . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t3 assert <identifiersep> that ( e . get <identifiersep> message ( ) , contains <identifiersep> string ( <string_literal> ) ) ; } } \n \t1 public void test <identifiersep> <identifier> <identifiersep> get <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t2 try { \n \t3 if ( ! stop <identifiersep> <identifier> ) { \n \t4 logger . debug ( <string_literal> ) ; \n \t4 <identifier> . put ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> update . <identifier> <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , \n \t3 map < job <identifiersep> <identifier> <identifiersep> id , execution <identifiersep> job <identifiersep> <identifier> > <identifier> , \n \t3 class <identifiersep> <identifier> user <identifiersep> class <identifiersep> <identifier> ) throws exception { \n \t2 <identifier> . check <identifiersep> not <identifiersep> null ( <identifier> <identifiersep> <identifier> , <string_literal> ) ; \n <ect>
\t4 string <identifier> = <identifier> . to <identifiersep> string ( config . get ( <string_literal> ) , null ) ; \n \t4 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> ) ) { \n \t5 device . set <identifiersep> <identifier> ( <identifier> ) ; \n \t4 } else { \n <ect>
\t4 this . <identifier> = false ; \n \t4 return ; } \n \t3 logger . debug ( <string_literal> + this . get <identifiersep> <identifier> <identifiersep> number ( ) ) ; \n \t2 } else { \n <ect>
\t4 public void on <identifiersep> result ( final write <identifiersep> <identifier> <identifiersep> result result , final throwable t ) { \n \t5 if ( t != null ) { \n \t6 <identifier> . on <identifiersep> result ( null , t ) ; \n \t5 } else { \n <ect>
\t2 if ( get <identifiersep> <identifier> ( ) . port != null ) { \n \t3 try { \n \t4 port <identifiersep> num = integer . parse <identifiersep> int ( get <identifiersep> <identifier> ( ) . port ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t7 return false ; } } \n \t5 return true ; } } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t1 private volatile int <identifier> ; \n \t1 protected static list < string > <identifier> <identifiersep> values ( ) { \n \t2 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> list ( ) ; } \n \t1 public void time <identifiersep> run ( final int <identifier> ) throws exception { \n <ect>
\t7 create <identifiersep> test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> file ( <identifier> . as <identifiersep> list ( <string_literal> ) ) } ) ; \n \t2 return <identifier> . to <identifiersep> array ( new object [ ] [ ] { } ) ; } \n \t1 @ test ( data <identifiersep> provider = <string_literal> , <identifier> <identifiersep> <identifier> = user <identifiersep> exception . class ) \n \t1 public void test <identifiersep> load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> file ( final string test <identifiersep> name , final file map <identifiersep> file ) { \n <ect>
\t2 if ( host <identifiersep> version <identifiersep> entity . get <identifiersep> state ( ) . equals ( <identifier> <identifiersep> version <identifiersep> state . <identifier> ) ) { \n \t3 host <identifiersep> version <identifiersep> entity . set <identifiersep> state ( <identifier> <identifiersep> version <identifiersep> state . out <identifiersep> of <identifiersep> <identifier> ) ; \n \t3 host <identifiersep> version <identifiersep> dao . get ( ) . <identifier> ( host <identifiersep> version <identifiersep> entity ) ; } } } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 . <identifier> ( entity . entity ( <identifier> <identifiersep> <identifier> <identifiersep> element , <string_literal> ) ) ; \n \t3 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , response . get <identifiersep> status ( ) ) ; \n \t3 string entity = response . read <identifiersep> entity ( string . class ) ; \n \t3 int <identifier> = <identifier> . <identifier> ( entity . length ( ) , <number_literal> ) ; \n <ect>
\t5 http <identifiersep> context . get <identifiersep> <identifier> ( ) . add <identifiersep> all ( this . <identifier> ) ; } \n \t4 if ( this . <identifier> != null ) { \n \t5 http <identifiersep> context . set <identifiersep> <identifier> ( this . <identifier> ) ; } } } \n <ect>
\t3 success = <identifier> <identifiersep> ip <identifiersep> <identifier> ( network , false ) ; \n \t3 if ( success ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + ip . get <identifiersep> address ( ) . <identifier> ( ) + <string_literal> + <identifier> . get <identifiersep> id ( ) + <string_literal> + network . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t3 } else { \n <ect>
\t2 client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> update <identifiersep> <identifier> ( <string_literal> ) \n \t4 . set <identifiersep> <identifier> ( <identifier> . builder ( ) . put ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . index <identifiersep> routing <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> key ( ) , \n \t6 <identifier> <identifiersep> boolean ( ) ? <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> . <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> . all ) ) \n \t4 . get ( ) ; \n <ect>
\t3 return ; } \n \t2 if ( configuration . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 <comment> \n \t3 if ( configuration . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> host ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t2 assert <identifiersep> true ( <identifier> . <identifier> <identifiersep> with ( <string_literal> ) ) ; \n \t2 <identifier> = <string_literal> + <string_literal> + get <identifiersep> queue <identifiersep> name ( ) + <string_literal> + <string_literal> + <string_literal> + <identifier> . <identifier> . <identifier> <identifiersep> map <identifiersep> json + <string_literal> + <identifier> . null ; \n \t2 <identifier> <identifiersep> connection . send <identifiersep> <identifier> ( <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> json = <identifier> <identifiersep> connection . <identifier> ( ) ; \n <ect>
\t7 . end <identifiersep> object ( ) \n \t6 . end <identifiersep> object ( ) \n \t5 . end <identifiersep> array ( ) \n \t4 . end <identifiersep> object ( ) ) ; \n <ect>
\t3 throws io <identifiersep> exception \n \t1 { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> output == null ) { \n <ect>
\t2 assert . assert <identifiersep> equals ( <string_literal> , <string_literal> , <identifier> . get <identifiersep> message ( ) ) ; \n \t2 assert . assert <identifiersep> equals ( <string_literal> , <string_literal> , <identifier> . get <identifiersep> value ( ) ) ; \n \t2 <identifier> = e . get <identifiersep> class <identifiersep> <identifier> ( ) . <identifier> ( ) . next ( ) ; \n \t2 assert . assert <identifiersep> equals ( <string_literal> , <string_literal> , <identifier> . get <identifiersep> message ( ) ) ; \n <ect>
\t4 try { \n \t5 <comment> \n \t5 parse <identifiersep> header ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 this . <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( this . <identifier> <identifiersep> port . get <identifiersep> output <identifiersep> stream ( ) , true ) ; \n \t3 logger . debug ( <string_literal> ) ; \n \t3 return true ; \n \t2 } catch ( exception e ) { \n <ect>
\t6 break ; } \n \t5 default : \n \t6 throw new runtime <identifiersep> exception ( <string_literal> + message <identifiersep> type + <string_literal> ) ; } } \n \t2 } catch ( throwable e ) { \n <ect>
\t3 return null ; } \n \t2 final <identifier> <identifiersep> context <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t2 final <identifier> action = this . <identifier> <identifiersep> builder <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . parse <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t2 final <identifier> <identifiersep> action new <identifiersep> action = new <identifier> <identifiersep> action ( action , null ) ; \n <ect>
\t3 <identifier> <identifiersep> result . <identifier> ( <string_literal> , <identifier> <identifiersep> path <identifiersep> in <identifiersep> <identifier> ) ; \n \t3 logger . info ( <string_literal> , <identifier> <identifiersep> path <identifiersep> in <identifiersep> <identifier> , <identifier> <identifiersep> dir . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 } else { \n \t3 <identifier> <identifiersep> result . <identifier> ( <string_literal> , <identifier> <identifiersep> path <identifiersep> in <identifiersep> <identifier> ) ; \n <ect>
\t1 public static int find <identifiersep> node <identifiersep> id ( cluster cluster , host <identifiersep> <identifier> <identifier> ) { \n \t2 logger . info ( <string_literal> + <identifier> . get <identifiersep> debug <identifiersep> info ( ) ) ; \n \t2 if ( is <identifiersep> <identifier> <identifiersep> local <identifiersep> cluster ( cluster , <identifier> ) ) { \n \t3 int node <identifiersep> id = cluster . get <identifiersep> node <identifiersep> <identifier> ( ) . <identifier> ( ) . next ( ) ; \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \t3 json <identifiersep> object result = success ( <identifier> , request , response , <identifier> <identifiersep> lock , <string_literal> , <identifier> , <string_literal> , user , <string_literal> , integer . to <identifiersep> string ( all ) , <string_literal> , <string_literal> ) ; \n \t3 assert <identifiersep> json ( result , <string_literal> , <string_literal> ) ; \n \t3 string lock = result . get <identifiersep> string ( <string_literal> ) ; \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> + <string_literal> + network + <string_literal> ) ; \n \t4 if ( remove <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> network ( <identifier> , network ) ) { \n \t5 s <identifiersep> logger . debug ( <string_literal> + <identifier> + <string_literal> + network + <string_literal> ) ; \n \t4 } else { \n <ect>
\t2 destination [ ] <identifier> = create <identifiersep> <identifier> ( <identifier> <identifiersep> count ) ; \n \t2 destination <identifier> <identifiersep> destination = <identifier> [ 0 ] ; \n \t2 if ( <identifier> . length > 1 ) { \n \t3 string destination <identifiersep> name = ( ( <identifier> <identifiersep> <identifier> <identifiersep> destination ) <identifier> <identifiersep> destination ) . get <identifiersep> <identifier> <identifiersep> name ( ) ; \n <ect>
\t2 long <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 long <identifier> <identifiersep> total <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> total <identifiersep> <identifier> ( ) ; \n \t2 long total <identifiersep> <identifier> = ( long ) ( <identifier> <identifiersep> total <identifiersep> <identifier> * <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t5 } catch ( exception e ) { \n \t6 <identifier> <identifiersep> <identifier> . log . warn ( <string_literal> + e ) ; } \n \t5 long <identifier> <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time <identifiersep> <identifier> ; \n \t5 if ( failure ) { \n <ect>
\t3 state = <identifier> . get <identifiersep> execution <identifiersep> status <identifiersep> <identifier> ( ) . get <identifiersep> state ( ) . <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> . contains ( state ) ) { \n \t4 logger . info ( <string_literal> + job <identifiersep> <identifier> <identifiersep> id + <string_literal> + state ) ; \n \t4 break ; } \n <ect>
\t1 if ( <identifier> ) { \n \t2 log <identifiersep> <identifier> <identifiersep> config . <identifier> ( properties ) ; } \n \t1 return log <identifiersep> <identifier> <identifiersep> config ; \n \t1 } catch ( exception e ) { \n <ect>
\t4 final <identifier> <identifiersep> service job <identifiersep> manager <identifiersep> <identifier> <identifiersep> service ; \n \t4 final <identifier> <identifiersep> service resource <identifiersep> manager <identifiersep> <identifier> <identifiersep> service ; \n \t4 final <identifier> <identifiersep> service [ ] task <identifiersep> manager <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> service [ num <identifiersep> task <identifiersep> <identifier> ] ; \n \t4 <comment> \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> && \n \t3 ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> access <identifiersep> mode ( ) != config . <identifier> <identifiersep> access <identifiersep> mode . <identifier> || <identifier> <identifiersep> <identifier> . get <identifiersep> index <identifiersep> access <identifiersep> mode ( ) != config . <identifier> <identifiersep> access <identifiersep> mode . <identifier> ) && \n \t3 <identifier> == <identifier> <identifiersep> <identifier> . <identifier> ) \n \t2 { \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> authentication <identifiersep> handler ( final string name , final <identifier> <identifiersep> manager <identifier> <identifiersep> manager , final principal <identifiersep> factory principal <identifiersep> factory , \n \t9 final list < <identifier> <identifiersep> server > <identifier> , final boolean <identifier> <identifiersep> on <identifiersep> exception , final boolean <identifier> <identifiersep> on <identifiersep> authentication <identifiersep> failure ) { \n \t2 super ( name , <identifier> <identifiersep> manager , principal <identifiersep> factory , null ) ; \n <ect>
<identifier> <identifier> <identifiersep> <identifier> ( method <identifiersep> name , * <identifier> ) : \n \t1 <identifier> <identifier> <identifiersep> class \n \t1 p = method <identifiersep> name . <identifier> ( ' . ' ) \n \t1 if <identifier> ( p ) != <number_literal> : \n <ect>
\t5 is <identifiersep> new <identifiersep> <identifier> = true ; } \n \t3 } else if ( <identifier> <identifiersep> config . is <identifiersep> <identifier> ( ) ) { \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> location == null ) { \n <ect>
\t5 long <identifier> = get <identifiersep> next <identifiersep> add <identifiersep> <identifier> ( ) ; \n \t5 long <identifier> = get <identifiersep> next <identifiersep> add <identifiersep> <identifier> ( ) ; \n \t5 long result = client . add ( <identifier> , <identifier> ) ; \n \t5 if ( result != <identifier> + <identifier> ) { \n <ect>
\t1 if ( <identifier> . length != <number_literal> ) { \n \t1 throw new <identifier> <identifiersep> argument <identifiersep> length <identifiersep> exception ( \n \t2 <string_literal> ) ; \n \t1 } else if ( ! ( <identifier> [ 0 ] instanceof string <identifiersep> object <identifiersep> <identifier> ) ) { \n <ect>
\t2 try { \n \t3 if ( cluster != null ) { \n \t4 cluster . close ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 for ( int i = 0 ; i < number ; i ++ ) { \n \t3 <identifier> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 if ( <identifier> != null ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> client . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> id ( ) ) ; \n <ect>
\t4 t . send <identifiersep> response <identifiersep> <identifier> ( status , response . length ) ; \n \t4 <identifier> . write ( response ) ; \n \t4 <identifier> . close ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 <comment> \n \t5 boolean <identifier> = <identifier> . delete <identifiersep> file ( <identifier> <identifiersep> file <identifiersep> name ) ; \n \t5 log . trace ( <string_literal> , <identifier> <identifiersep> file <identifiersep> name , <identifier> ) ; \n \t5 if ( ! <identifier> ) { \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 <identifier> <identifiersep> <identifier> ( message <identifiersep> status <identifiersep> message . status <identifiersep> send <identifiersep> failure <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 return ; } \n \t2 <comment> \n <ect>
\t3 <identifier> <identifiersep> switch <identifiersep> port . set <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> <identifier> <identifiersep> resource . <identifier> ( network <identifiersep> id + <string_literal> , name <identifiersep> max <identifiersep> <identifier> ) ) ; \n \t3 <identifier> <identifiersep> switch <identifiersep> port . set <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> <identifiersep> switch <identifiersep> port = <identifier> <identifiersep> <identifier> <identifiersep> api . create <identifiersep> <identifier> <identifiersep> switch <identifiersep> port ( <identifier> <identifiersep> switch <identifiersep> <identifier> , <identifier> <identifiersep> switch <identifiersep> port ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t4 <comment> \n \t4 continue ; } \n \t3 string [ ] <identifier> = key . <identifier> ( <string_literal> ) ; \n \t3 if ( <identifier> . length != <number_literal> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> [ i ] . is <identifiersep> <identifier> <identifiersep> map <identifiersep> on <identifiersep> <identifier> ( ) ) { \n \t3 try { \n \t4 continue <identifiersep> process ( i ) ; \t1 <comment> \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> . delete ( <identifier> ) ; } \n \t2 try { \n \t3 api . delete ( <identifier> <identifiersep> ip . class , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t3 result . <identifier> ( out . <identifier> ( get <identifiersep> java <identifiersep> type ( <identifier> . get <identifiersep> type ( <identifier> ( ) ) ) ) ) ; \n \t3 <identifier> = <string_literal> ; } \n \t2 return result . to <identifiersep> string ( ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n <ect>
\t3 <comment> \n \t3 file <identifiersep> utils . <identifier> <identifiersep> file ( new file ( <identifier> <identifiersep> file <identifiersep> name + <string_literal> ) , new file ( <identifier> <identifiersep> file <identifiersep> name ) ) ; \n \t3 system . out . <identifier> ( <string_literal> + <identifier> <identifiersep> file <identifiersep> name + <string_literal> + <string_literal> + <identifier> <identifiersep> file <identifiersep> name + <string_literal> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 protected void execute ( http <identifiersep> <identifier> <identifiersep> request http <identifiersep> request , http <identifiersep> <identifier> <identifiersep> response http <identifiersep> response ) \n \t1 { \n \t2 try { \n <ect>
\t4 if ( ! context . get <identifiersep> <identifier> ( ) . <identifier> ( get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> , <string_literal> ) , \n \t5 <identifier> ) ) { \n \t5 return - <number_literal> ; } \n \t3 } catch ( runtime <identifiersep> exception ex ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> dao . update ( <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> dao . update ( <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> <identifier> ) ; } \n \t3 } ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 log . debug ( <string_literal> ) ; \n \t4 this . command <identifiersep> <identifier> ( this . result ) ; \n \t4 this . continue <identifiersep> test ( ) ; \n \t3 } else if ( this . wait <identifiersep> for <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 resource = <identifier> <identifiersep> name <identifiersep> base + <string_literal> ; } \n \t2 file resource <identifiersep> file = get <identifiersep> <identifier> <identifiersep> resource <identifiersep> file <identifiersep> or <identifiersep> null ( resource ) ; \n \t2 <comment> \n \t2 if ( resource <identifiersep> file != null && ! resource <identifiersep> file . <identifier> <identifiersep> read ( ) ) { \n <ect>
<comment> \n \t1 private file <identifier> <identifiersep> config ( file <identifier> <identifiersep> file ) { \n \t2 file dir = new <identifier> <identifiersep> directory ( <identifier> <identifiersep> file + config <identifiersep> dir <identifiersep> <identifier> ) ; \n \t2 if ( ( ! dir . exists ( ) ) && ( ! dir . <identifier> ( ) ) ) { \n <ect>
\t2 <identifier> <identifiersep> io <identifiersep> <identifier> . log . info ( <string_literal> ) ; \n \t2 <identifier> . on <identifiersep> <identifier> ( this ) ; \n \t2 return ; } \n \t1 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 for ( ; i < <number_literal> ; i ++ ) { \n \t4 <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> time ( i , r . next <identifiersep> int ( <number_literal> ) ) ; } \n \t2 } catch ( null <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t6 if ( <identifier> <identifiersep> message == null ) return m ; \n \t6 if ( log <identifiersep> <identifier> ) logger . <identifier> ( message . class , <string_literal> + <identifier> <identifiersep> message ) ; \n \t6 m . add <identifiersep> <identifier> <identifiersep> message ( <identifier> <identifiersep> message ) ; \n \t5 } catch ( throwable t ) { \n <ect>
\t4 int <identifier> <identifiersep> <identifier> = ( int ) <identifier> . <identifier> ( ( double ) <identifier> / ( double ) m <identifiersep> <identifier> <identifiersep> size ) ; \n \t4 <comment> \n \t4 m <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> - 1 ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 <comment> \n \t2 @ <identifier> <identifiersep> <identifier> ( { <string_literal> } ) \n \t2 @ <identifier> public void on <identifiersep> timeout ( ) { \n <ect>
\t1 return input <identifiersep> format ; } \n private static boolean check <identifiersep> input <identifiersep> format <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( configuration conf , string if <identifiersep> name ) { \n \t1 string format <identifiersep> list = <identifier> <identifiersep> conf . get <identifiersep> <identifier> ( conf , conf <identifiersep> <identifier> . <identifier> <identifiersep> io <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 <identifier> . set <identifiersep> exception ( new <identifier> <identifiersep> message <identifiersep> <identifier> <identifiersep> exception ( <string_literal> , message , <identifier> <identifiersep> code , <identifier> <identifiersep> text , \n \t6 exchange , routing <identifiersep> key ) ) ; } \n \t3 else { \n <ect>
\t4 <identifier> <identifier> = find <identifiersep> <identifier> ( <identifier> <identifiersep> method , <identifier> . class ) ; \n \t4 if ( <identifier> != null && method . equals ( class <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> method ( method , bean <identifiersep> class ) ) ) { \n \t5 if ( <identifier> . is <identifiersep> static ( method . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw ex ; \n \t1 } catch ( exception ex ) { \n <ect>
\t3 if ( ! is <identifiersep> test <identifiersep> mode ) \n \t4 add <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 else \n \t4 add <identifiersep> <identifier> ( root , integer . <identifier> <identifiersep> value , integer . max <identifiersep> value ) ; \n <ect>
\t3 string value = ( string ) <identifier> . get <identifiersep> value ( ) ; \n \t3 try { \n \t4 <identifier> = <identifier> + key + <string_literal> + url <identifiersep> <identifier> . <identifier> ( value , <string_literal> ) + <string_literal> ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 collection < address > <identifier> = <identifier> . read <identifiersep> <identifier> ( in , array <identifiersep> list : : new ) ; \n \t3 <identifier> <identifier> = <identifier> . read <identifiersep> <identifier> ( <identifier> : : new , in ) ; \n \t3 return new <identifier> < > ( <identifier> , <identifier> ) ; } \n \t2 catch ( exception ex ) { \n <ect>
\t5 <identifier> = query <identifiersep> map . get ( <string_literal> ) ; \n \t5 try { \n \t6 <identifier> = integer . parse <identifiersep> int ( <identifier> ) ; \n \t5 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t7 <identifier> <identifiersep> <identifier> . add ( token <identifiersep> data . get <identifiersep> <identifier> <identifiersep> set <identifiersep> code ( ) ) ; \n \t7 logger . debug ( <string_literal> + key ) ; } \n \t6 list . add ( token <identifiersep> data ) ; } \n \t4 } catch ( exception exception ) { \n <ect>
\t9 + <string_literal> + <string_literal> ) \n \t5 . set <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> to <identifiersep> <identifier> . get <identifiersep> id ( ) ) . set <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> group . get <identifiersep> id ( ) ) \n \t5 . execute <identifiersep> update ( ) ; \n \t3 logger . debug ( <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - start ) + <string_literal> ) ; \n <ect>
\t2 <identifier> <identifiersep> key <identifier> = <identifier> <identifiersep> key . <identifier> <identifiersep> key ( <identifier> <identifiersep> <identifier> <identifiersep> key , null , a <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> key ) ; \n \t2 key <identifier> <identifiersep> key = <identifier> . <identifier> <identifiersep> key ( <identifier> <identifiersep> <identifier> <identifiersep> key ) ; \n \t2 assert . assert <identifiersep> array <identifiersep> equals ( <identifier> <identifiersep> <identifier> <identifiersep> key . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> key . get <identifiersep> <identifier> ( ) ) ; \n \t2 <comment> \n <ect>
\t3 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ( <identifier> . <identifier> <identifiersep> <identifier> , <identifier> . local <identifiersep> host <identifiersep> address ( ) ) \n \t2 ) ) ) ; \n \t2 <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> ( config , create <identifiersep> <identifier> ) ; } \n \t1 } catch ( final exception e ) { \n <ect>
\t2 assert <identifiersep> that ( client . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> state ( ) . set <identifiersep> routing <identifiersep> table ( false ) . set <identifiersep> nodes ( false ) . execute ( ) . action <identifiersep> get ( ) . get <identifiersep> state ( ) \n \t4 . get <identifiersep> meta <identifiersep> data ( ) . <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> as <identifiersep> int ( <identifier> <identifiersep> <identifier> <identifiersep> service . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> nodes <identifiersep> <identifier> . get <identifiersep> key ( ) , - 1 ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 stop <identifiersep> node ( <identifier> <identifiersep> node ) ; \n \t2 assert <identifiersep> that ( client . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> wait <identifiersep> for <identifiersep> nodes ( <string_literal> ) . get ( ) . is <identifiersep> <identifier> <identifiersep> out ( ) , equal <identifiersep> to ( false ) ) ; \n <ect>
\t4 if ( ! <identifier> && <identifier> . throws <identifiersep> exception ) { \n \t5 log . error ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> first <identifiersep> <identifier> ++ ; \n \t4 } else if ( ! <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> header ( ) . get <identifiersep> <identifier> ( ) . equals ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t1 @ <identifier> \n \t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 public < t > t instance <identifiersep> for ( class < t > type ) { \n \t2 type = ( class < t > ) <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> type <identifiersep> if <identifiersep> <identifier> ( type ) ; \n <ect>
\t5 new uri ( <string_literal> , null , <identifier> <identifiersep> ip , default <identifiersep> port , \n \t7 <string_literal> , null , null ) ; \n \t3 json <identifiersep> object <identifier> <identifiersep> config <identifiersep> cmd = new json <identifiersep> object ( ) ; \n \t3 json <identifiersep> object <identifier> = new json <identifiersep> object ( <identifier> <identifiersep> <identifier> <identifiersep> config ) ; \n <ect>
\t1 public byte [ ] <identifier> <identifiersep> <identifier> ( string value , byte [ ] response , <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) \n \t3 throws <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 short new <identifiersep> value = 0 ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> data <identifiersep> type ( ) != type . <identifier> ) { \n <ect>
\t3 <identifier> . update ( request . get <identifiersep> bytes ( ) ) ; \n \t3 byte [ ] <identifier> <identifiersep> bytes = <identifier> . do <identifiersep> final ( ) ; \n \t3 return <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> bytes ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 <identifier> <identifiersep> <identifier> = new m <identifiersep> bean <identifiersep> <identifier> ( <identifier> ) ; \n \t4 start <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } else { \n <ect>
\t4 } else { \n \t5 <comment> \n \t5 if ( ( answer == null || ! answer . get <identifiersep> result ( ) ) && <identifier> <identifiersep> for <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) < <number_literal> ) { \n \t6 <comment> \n <ect>
\t2 throw new <identifier> <identifiersep> exception ( message ) ; } } } } \n private static boolean is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> service ( stack <identifiersep> manager stack <identifiersep> manager , stack <identifiersep> info stack , string service <identifiersep> name , string <identifier> <identifiersep> name ) { \n \t1 <comment> \n \t1 if ( is <identifiersep> <identifier> <identifiersep> service ( stack , service <identifiersep> name , <identifier> <identifiersep> name ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( table , out ) ; \n \t2 close <identifiersep> java <identifiersep> <identifier> ( out ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 java <identifiersep> <identifier> out = new <identifiersep> java <identifiersep> <identifier> ( get <identifiersep> file ( <identifier> , mode . <identifier> ) ) ; \n <ect>
\t1 m <identifiersep> bean <identifiersep> server <identifiersep> connection <identifier> = <identifier> . get <identifiersep> connection ( ) ; \n \t1 for ( object <identifiersep> name query : <identifier> ) { \n \t2 set < object <identifiersep> name > <identifier> = <identifier> . query <identifiersep> <identifier> ( query , null ) ; \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 } catch ( value <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> , e ) ; \n \t4 error ( e . get <identifiersep> message ( ) , <identifier> . error . error <identifiersep> code . <identifier> <identifiersep> transaction , close <identifiersep> <identifier> . remote <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 file file = new file ( current , name ) ; \n \t2 return file . is <identifiersep> directory ( ) && ! file <identifiersep> utils . is <identifiersep> file <identifiersep> <identifier> ( file , <identifier> <identifiersep> date ) ; } \n \t1 } ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> . length > 0 ) { \n <ect>
\t4 try { \n \t5 return super . get <identifiersep> destination <identifiersep> <identifier> ( ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t3 result <identifiersep> item result <identifiersep> item = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . create <identifiersep> and <identifiersep> <identifier> <identifiersep> object ( task <identifiersep> info . <identifier> <identifiersep> context ( ) , result <identifiersep> item . class ) ; \n \t3 result <identifiersep> item . set <identifiersep> task <identifiersep> info ( task <identifiersep> info ) ; \n \t4 result <identifiersep> item . set <identifiersep> number <identifiersep> to <identifiersep> check ( <identifier> <identifiersep> number <identifiersep> to <identifiersep> check ) ; \n \t4 if ( <identifier> . is <identifiersep> <identifier> ( <identifier> <identifiersep> number <identifiersep> to <identifiersep> check ) ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> item <identifiersep> type ( item item , string <identifier> <identifiersep> config ) throws <identifier> <identifiersep> config <identifiersep> parse <identifiersep> exception { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> error <identifiersep> <identifier> <identifiersep> operation <identifiersep> name ( throwable t ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 message <identifiersep> consumer queue <identifiersep> consumer = <identifier> . create <identifiersep> consumer ( queue ) ; \n \t2 for ( int i = 0 ; i < msg <identifiersep> num * <number_literal> ; i ++ ) { \n \t3 message msg = queue <identifiersep> consumer . <identifier> ( <number_literal> ) ; \n <ect>
\t1 <comment> \n \t1 public void update <identifiersep> config ( map < object , object > configuration ) { \n <ect>
\t1 <comment> \n \t1 public void execute ( ) throws io <identifiersep> exception { \n <ect>
\t2 string <identifier> <identifiersep> id = <identifier> [ <identifier> . length - 1 ] ; \n \t2 string <identifier> = <identifier> . get <identifiersep> file <identifiersep> system ( ) . get <identifiersep> <identifier> <identifiersep> path ( file <identifiersep> type . <identifier> , <identifier> ) . to <identifiersep> string ( ) ; \n \t2 string <identifier> = <identifier> <identifiersep> path . get <identifiersep> <identifier> <identifiersep> path ( <identifier> . get <identifiersep> file <identifiersep> system ( ) , new path ( <identifier> ) ) \n \t3 . to <identifiersep> string ( ) ; \n <ect>
\t3 return client <identifiersep> web <identifiersep> socket <identifiersep> map . contains <identifiersep> key ( client <identifiersep> id ) || client <identifiersep> http <identifiersep> map . contains <identifiersep> key ( client <identifiersep> id ) ; } \n \t2 @ <identifier> \n \t2 protected void <identifier> <identifiersep> output <identifiersep> handler ( string client <identifiersep> id , object <identifier> <identifiersep> channel ) { \n \t3 if ( debug ) { \n <ect>
\t2 configuration <identifiersep> <identifier> <identifier> = super . <identifier> <identifiersep> service ( <identifier> ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> ( new config <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> context ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 <comment> \n \t6 <identifier> . close ( true ) ; \n \t5 <comment> \n \t4 } catch ( <identifier> <identifiersep> address <identifiersep> exception <identifier> ) { \t5 \n <ect>
\t5 <identifier> <identifiersep> <identifier> = entry . get <identifiersep> element ( ) ; \n \t5 this . <identifier> <identifiersep> <identifier> = entry . get <identifiersep> element ( ) . get <identifiersep> <identifier> <identifiersep> code ( ) ; } } \n \t3 <identifier> <identifiersep> <identifier> . put ( entry . get <identifiersep> element ( ) != null ? entry . get <identifiersep> element ( ) . get <identifiersep> <identifier> <identifiersep> code ( ) : <string_literal> , \n \t4 entry . get <identifiersep> count ( ) ) ; } \n <ect>
\t3 <identifier> . warn ( <string_literal> ) ; \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t2 if ( result <identifiersep> set != null && boolean <identifiersep> result != null ) \n \t2 { \n <ect>
\t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw ex ; \n \t1 } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { \n <ect>
\t2 bean . <identifier> <identifiersep> properties <identifiersep> set ( ) ; \n \t2 return bean . get <identifiersep> object ( ) ; } \n \t1 private <identifier> build <identifiersep> <identifier> <identifiersep> db <identifiersep> client ( final base <identifiersep> <identifier> <identifiersep> db <identifiersep> properties <identifier> ) { \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> . get <identifiersep> client <identifiersep> uri ( ) ) ) { \n <ect>
\t3 { \n \t4 data <identifiersep> <identifier> . start ( ) ; } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t2 command . add ( system <identifiersep> vm <identifiersep> <identifier> <identifiersep> path ) ; \n \t2 final string result = command . execute ( ) ; \n \t2 s <identifiersep> logger . info ( <string_literal> + result ) ; \n \t2 if ( result != null ) { \n <ect>
\t1 logger logger = <identifier> . get ( <string_literal> ) ; \n \t1 try { \n \t2 logger . info ( <string_literal> + <identifier> . get <identifiersep> name ( ) ) ; \n \t2 <identifier> . <identifier> ( ) ; \n <ect>
\t4 if ( result == <identifier> <identifiersep> code ) \n \t5 lock . wait ( ) ; } \n \t3 catch ( interrupted <identifiersep> exception e ) \n \t3 { \n <ect>
\t4 long <identifier> = <identifier> . current <identifiersep> time <identifiersep> millis ( ) ; \n \t4 <comment> \n \t4 if ( <identifier> == null && ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == 0 || last <identifiersep> <identifier> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> >= <identifier> ) ) { \n <ect>
\t1 public void <identifier> <identifiersep> failed ( ) { \n \t2 try ( final <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( security <identifiersep> context ) . <identifier> ( ) ) { \n \t3 <identifier> <identifiersep> client <identifier> <identifiersep> client = new <identifier> <identifiersep> client ( ) ; \n \t3 <identifier> <identifiersep> client . <identifier> ( <string_literal> , <identifier> <identifiersep> port ) ; \n <ect>
\t3 self . <identifier> . log . exception ( e ) \n \t3 try : \n \t4 self . <identifier> . connection . send <identifiersep> <identifier> ( error <identifiersep> <identifier> ( <identifier> ( e ) , <identifier> ( e ) ) ) \n \t3 <identifier> exception as e : # <identifier> : no <identifier> \n <ect>
\t2 <comment> \n \t2 final test <identifiersep> <identifier> <identifiersep> handler < o <identifiersep> data <identifiersep> entry > entry <identifiersep> handler = new test <identifiersep> <identifier> <identifiersep> handler < o <identifiersep> data <identifiersep> entry > ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . create ( <identifier> , <identifier> , null , get <identifiersep> entity <identifiersep> data ( ) , entry <identifiersep> handler ) ; \n \t2 o <identifiersep> data <identifiersep> entry <identifier> <identifiersep> entry = entry <identifiersep> handler . <identifier> ( ) ; \n <ect>
\t2 string default <identifiersep> json = <string_literal> ; \n \t2 try { \n \t3 s = file <identifiersep> utils . read <identifiersep> file <identifiersep> to <identifiersep> string ( get <identifiersep> file ( ) , <string_literal> ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t2 thread . current <identifiersep> thread ( ) . set <identifiersep> name ( <identifier> <identifiersep> thread <identifiersep> name ) ; \n \t2 try { \n \t2 close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } \n \t2 catch ( throwable t ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> throwable ( t ) ; \n <ect>
\t5 try { \n \t6 <identifier> . shutdown ( ) ; \n \t6 <identifier> . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 config . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> . to <identifiersep> int ) \n \t1 try { \n \t1 config . <identifier> ( ) \n \t1 } catch { \n <ect>
@ <identifier> ( <identifier> <identifiersep> type . application <identifiersep> json ) \n @ <identifier> ( <identifier> <identifiersep> type . application <identifiersep> json ) \n @ path ( <string_literal> ) \n public response write <identifiersep> and <identifiersep> <identifier> <identifiersep> configuration ( json <identifiersep> object request ) { \n <ect>
\t2 abstract <identifiersep> xml <identifiersep> application <identifiersep> context <identifier> = new class <identifiersep> path <identifiersep> xml <identifiersep> application <identifiersep> context ( <string_literal> ) ; \n \t2 <comment> \n \t2 log . warn ( <string_literal> ) ; \n \t2 io <identifiersep> <identifier> . close ( <identifier> ) ; \n <ect>
\t3 throw new table <identifiersep> <identifier> <identifiersep> exception ( table <identifiersep> id <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> . get <identifiersep> table <identifiersep> state ( instance , table <identifiersep> id ) == table <identifiersep> state . <identifier> ) \n \t3 throw new table <identifiersep> <identifier> <identifiersep> exception ( instance , table <identifiersep> id <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t1 if ( message instanceof get <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t1 try { \n \t2 get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 else \n \t4 <identifier> <identifiersep> from ( object , object . get <identifiersep> class ( ) , node ) ; \n \t3 return object ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw ex ; \n \t1 } catch ( exception ex ) { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + network . get <identifiersep> id ( ) ) ; \n \t4 return true ; } \n \t3 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . start <identifiersep> remote <identifiersep> access <identifiersep> <identifier> ( network , <identifier> , <identifier> ) ; \n \t2 } else { \n <ect>
\t4 status = this . status ; } \n \t3 if ( status != not <identifiersep> <identifier> ) \n \t4 <identifier> . on <identifiersep> request <identifiersep> <identifier> <identifiersep> <identifier> ( status , <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> key , this ) ; \n \t3 else \n <ect>
\t3 final <identifier> <identifier> = new <identifier> ( cmd ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> , <identifier> ) ) { \n \t4 return false ; } } \n \t2 if ( <identifier> == <identifier> . size ( ) ) { \n <ect>
\t1 private file file ; \n \t1 @ json <identifiersep> <identifier> \n \t1 public file <identifiersep> <identifier> <identifiersep> host <identifiersep> location <identifiersep> <identifier> ( ) { \n \t2 file = new file ( system . get <identifiersep> property ( <string_literal> , <string_literal> ) ) ; \n <ect>
\t5 <identifier> <identifiersep> run <identifiersep> <identifier> = new array <identifiersep> list < > ( ) ; \n \t4 string <identifier> <identifiersep> <identifier> <identifiersep> string = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> run <identifiersep> <identifier> ) ; \n \t4 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> string ) ; \n \t4 string <identifier> <identifiersep> string = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( run <identifiersep> <identifier> ) ; \n <ect>
\t2 <identifier> . <identifier> <identifiersep> info ( <string_literal> ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 java <identifiersep> <identifier> out = new <identifiersep> java <identifiersep> <identifier> ( get <identifiersep> file ( <identifier> ) ) ; \n \t2 log . info ( <string_literal> ) ; \n <ect>
\t1 @ <identifier> <identifiersep> <identifier> \n \t1 private void <identifier> ( ) { \n \t2 boolean current <identifiersep> state = true ; \n \t2 if ( this . test <identifiersep> <identifier> == null ) { \n <ect>
\t4 <identifier> <identifiersep> account <identifiersep> <identifier> . check <identifiersep> access ( account <identifiersep> <identifier> , null , true , vm ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t4 if ( account <identifiersep> <identifier> . get <identifiersep> type ( ) == account . account <identifiersep> type <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> == [ \n \t3 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> ) , \n \t3 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> ) \n \t2 ] \n <ect>
\t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw ex ; \n \t1 } catch ( item <identifiersep> not <identifiersep> found item <identifiersep> not <identifiersep> found ) { \n <ect>
\t5 short <identifier> = - 1 ; \n \t5 try { \n \t6 <identifier> = short . parse <identifiersep> short ( value ) ; \n \t5 } catch ( java . <identifier> . number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 logger . error ( <string_literal> , \n \t5 <identifier> . get <identifiersep> key ( ) , <identifier> <identifiersep> id , configuration . get <identifiersep> <identifier> <identifiersep> provider <identifiersep> <identifier> ( ) ) ; \n \t4 return error ( ) ; } \n \t3 if ( <identifier> != null && <identifier> . is <identifiersep> <identifier> ( <identifier> <identifiersep> id , configuration . get <identifiersep> <identifier> <identifiersep> provider <identifiersep> <identifier> ( ) , configuration . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t5 response = get <identifiersep> response ( ) ; \n \t5 try { \n \t6 thread . <identifier> ( <number_literal> ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 int length = 0 ; \n \t3 int <identifier> <identifiersep> of <identifiersep> body = 0 ; \n \t3 byte <identifiersep> array <identifiersep> output <identifiersep> stream <identifier> = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; \n \t3 while ( <identifier> <identifiersep> of <identifiersep> body < = 0 && ( ( length = in . read ( <identifier> ) ) != - 1 ) ) { \n <ect>
<comment> \n \t1 protected <identifier> <identifiersep> manager <identifier> <identifiersep> <identifier> <identifiersep> manager ( string <identifier> <identifiersep> manager <identifiersep> name ) throws transaction <identifiersep> system <identifiersep> exception { \n \t2 try { \n <ect>
<comment> \n \t1 public synchronized void shutdown ( boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 if ( ! <identifier> <identifiersep> shutdown ( ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> to < 0 || <identifier> <identifiersep> to > max <identifiersep> <identifier> ) { \n \t3 logger . error ( <string_literal> , max <identifiersep> <identifier> ) ; \n \t3 return ; } \n \t2 if ( <identifier> <identifiersep> from < 0 || <identifier> <identifiersep> from > max <identifiersep> line ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( false ) ; \n \t2 assert <identifiersep> false ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) . <identifier> ( ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> success ( ) ; \n <ect>
\t4 <string_literal> ) ; \n \t3 log . debug ( <string_literal> , e ) ; \n \t3 return new json <identifiersep> <identifier> [ 0 ] ; \n \t2 } catch ( throwable t ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> = false ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> error e ) \n \t2 { \n \t3 logger . warn ( <string_literal> ) ; \n <ect>
\t1 long session <identifiersep> id = <identifier> . get <identifiersep> session <identifiersep> id ( ) ; \n \t1 if ( <identifier> <identifiersep> event . get <identifiersep> type ( ) == event . event <identifiersep> type . <identifier> ) \n \t1 { \n \t2 event . <identifier> <identifiersep> state state = <identifier> <identifiersep> event . get <identifiersep> state ( ) ; \n <ect>
\t2 public synchronized void queue <identifiersep> <identifier> ( <identifier> <identifier> ) \n \t2 { \n \t3 if ( <identifier> <identifiersep> queue <identifiersep> max <identifiersep> size - <identifier> <identifiersep> to <identifiersep> <identifier> . size ( ) == 0 ) \n \t3 { \n <ect>
\t1 @ test ( <identifier> = <string_literal> ) \n \t1 public void test <identifiersep> <identifier> ( ) { \n \t2 event <identifiersep> list event <identifiersep> list = create <identifiersep> event <identifiersep> list ( ) ; \n \t2 assert . assert <identifiersep> equals ( event <identifiersep> list . to <identifiersep> json ( ) . length ( ) == 0 , false ) ; \n <ect>
\t3 if ( <identifier> . get <identifiersep> session <identifiersep> id ( ) == session <identifiersep> id ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; \n \t3 <identifier> <identifiersep> <identifier> = true ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
public synchronized void start ( ) { \n \t1 if ( is <identifiersep> <identifier> ( ) != true ) { \n \t1 start <identifiersep> <identifier> ( ) ; \n \t1 } else { \n <ect>
\t6 if ( <identifier> <identifiersep> last <identifiersep> <identifier> < = ( <number_literal> * <number_literal> * <number_literal> ) ) { \n \t7 <comment> \n \t7 is <identifiersep> <identifier> = true ; } } \n <ect>
\t2 try { \n \t3 if ( <identifier> != null ) { \n \t4 <identifier> . <identifier> ( ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 s <identifiersep> logger . debug ( <string_literal> + <identifier> <identifiersep> service <identifiersep> url + <string_literal> + result + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> in <identifiersep> millis ( ) + <string_literal> ) ; } \n \t3 } else { \n \t4 <identifier> . stop ( ) ; \n <ect>
\t1 public class <identifier> <identifiersep> task extends <identifier> <identifiersep> task { \n \t2 protected <identifier> \t3 <identifier> <identifiersep> <identifier> ; \n \t2 protected volatile boolean <identifier> = false ; \n \t2 public <identifier> <identifiersep> task ( final <identifier> <identifier> ) { \n <ect>
\t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , ex ) ; \n \t3 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . resource <identifiersep> <identifier> <identifiersep> error , ex . get <identifiersep> message ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> operation <identifiersep> exception ex ) { \n <ect>
<comment> \n \t1 public void try <identifiersep> <identifier> ( ) { \n \t2 try ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ignore = <identifier> <identifiersep> <identifier> . try <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 string <identifier> <identifiersep> id = node . get <identifiersep> location ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> id ( ) ; \n \t1 <identifier> <identifiersep> ip <identifiersep> api <identifier> <identifiersep> ip <identifiersep> api = <identifier> <identifiersep> api . get <identifiersep> <identifier> <identifiersep> ip <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ( <identifier> <identifiersep> id ) . get ( ) ; \n \t1 <identifier> <identifiersep> ip ip = null ; \n \t1 try { \n <ect>
\t5 <identifier> . <identifier> ( timeout , time <identifiersep> unit . <identifier> ) ; \n \t4 else \n \t5 log . info ( <string_literal> ) ; \n \t3 } catch ( interrupted <identifiersep> exception int <identifiersep> <identifier> ) { \n <ect>
\t1 void <identifier> <identifiersep> command ( item item , command command , <identifier> <identifiersep> <identifier> <identifiersep> node node , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class command <identifiersep> class , \n \t3 int endpoint <identifiersep> id , map < string , string > <identifier> ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> <identifier> < ? , ? > <identifier> = this . get <identifiersep> command <identifiersep> <identifier> ( command . get <identifiersep> class ( ) ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t7 <comment> \n \t1 log . info ( <string_literal> ) ; \n \t1 bytes <identifiersep> bytes <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map <identifier> <identifiersep> <identifier> <identifiersep> map = <identifier> . get <identifiersep> <identifier> <identifiersep> map <identifiersep> from <identifiersep> <identifier> ( <identifier> <identifiersep> count ) ; \n \t1 <identifier> <identifiersep> count += <identifier> <identifiersep> <identifier> <identifiersep> map . get <identifiersep> num <identifiersep> values ( ) ; \n <ect>
\t1 for ( final <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> and <identifiersep> get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t1 try { \n \t2 <identifier> . start ( ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t3 string path = read <identifiersep> dir + file . <identifier> + file <identifiersep> name ; \n \t3 try { \n \t4 path <identifiersep> utils . <identifier> ( path ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> ) { \n \t4 throw new io <identifiersep> exception ( <string_literal> + request ) ; } \n \t3 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> http <identifiersep> <identifier> <identifiersep> read ( request . native <identifiersep> request ( ) , <identifier> , <identifier> <identifiersep> <identifier> . byte <identifiersep> array <identifiersep> <identifier> + <identifier> , size ) ; } \n <ect>
\t4 log . info ( <string_literal> + input <identifiersep> file . get <identifiersep> short <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> = input <identifiersep> file . <identifier> <identifiersep> log <identifiersep> file ( log <identifiersep> path <identifiersep> file ) ; \n \t4 line <identifiersep> count = 0 ; \n \t4 } catch ( exception ex ) { \n <ect>
\t2 try { \n \t2 start ( ) ; \n \t2 return ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean stop ( ) { \n <ect>
\t6 <comment> \n \t6 process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <number_literal> , null , <identifier> <identifiersep> to , false , true , <identifier> <identifiersep> type , <identifier> <identifiersep> type ) ; } } \n \t3 } ) ; \n \t2 } else { \n <ect>
\t1 public void <identifier> <identifiersep> values <identifiersep> to <identifiersep> attribute ( attribute attribute ) { \n \t2 logger . warn ( <string_literal> + attribute ) ; } \n \t1 <comment> \n \t1 public void <identifier> <identifiersep> values <identifiersep> to <identifiersep> blank <identifiersep> node <identifiersep> id ( blank <identifiersep> node <identifiersep> id id ) { \n <ect>
<comment> \n \t1 private static string get <identifiersep> url ( http <identifiersep> <identifier> <identifiersep> request <identifier> ) { \n \t2 string <identifier> <identifiersep> url = <identifier> . get <identifiersep> request <identifiersep> url ( ) . to <identifiersep> string ( ) ; \n \t2 string query <identifiersep> string = <identifier> . get <identifiersep> query <identifiersep> string ( ) ; \n <ect>
\t6 if ( ( <identifier> != null ) == has <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t7 <identifier> . put ( property . get <identifiersep> name ( ) , new <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , property ) ) ; } \n \t5 } ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> . is <identifiersep> not <identifiersep> blank ( <identifier> ) ) { \n \t4 answer = <identifier> <identifiersep> client . <identifier> ( ) . in <identifiersep> <identifier> ( <identifier> ) . create ( <identifier> ) ; \n \t3 } else { \n \t4 answer = <identifier> <identifiersep> client . <identifier> ( ) . in <identifiersep> <identifier> ( get <identifiersep> <identifier> ( ) ) . create ( <identifier> ) ; } \n <ect>
\t2 host <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> = wait <identifiersep> <identifier> ( <number_literal> , <number_literal> , self . check <identifiersep> host <identifiersep> state <identifiersep> in <identifiersep> <identifier> , <string_literal> , <identifier> <identifiersep> host . id ) \n \t2 # the test <identifier> <identifier> failed <identifier> <identifier> we <identifier> try <identifier> <identifier> to get host <identifier> in <identifier> state \n \t2 no <identifiersep> of <identifiersep> <identifier> = self . no <identifiersep> of <identifiersep> v <identifiersep> <identifier> <identifiersep> on <identifiersep> host ( <identifier> <identifiersep> host . id ) \n \t2 no <identifiersep> of <identifiersep> <identifier> = no <identifiersep> of <identifiersep> <identifier> + self . no <identifiersep> of <identifiersep> v <identifiersep> <identifier> <identifiersep> on <identifiersep> host ( <identifier> <identifiersep> host . id ) \n <ect>
\t1 if ( <identifier> ) { \n \t1 return ; } \n \t1 if ( <identifier> != null ) { \n \t1 throw <identifier> ; } \n <ect>
\t1 try { \n \t1 <identifier> <identifier> = new <identifier> ( new import <identifiersep> <identifier> ( ) , conf , <identifier> ) ; \n \t1 <identifier> = <identifier> . run <identifiersep> <identifier> ( <identifier> , get <identifiersep> <identifier> ( true , import <identifiersep> <identifier> , conf ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 final state <identifiersep> <identifier> state <identifiersep> <identifier> , final <identifier> event , \n \t3 final state <identifiersep> <identifier> state <identifiersep> <identifier> ) { \n \t2 <identifier> . get ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) . <identifier> ( ) ; \n \t2 if ( <identifier> . get ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) . is <identifiersep> empty ( ) ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t2 if ( null != method <identifiersep> path ) { \n \t2 class < ? > return <identifiersep> type = method . get <identifiersep> return <identifiersep> type ( ) ; \n \t2 api <identifier> <identifiersep> api = <identifier> <identifiersep> utils . find <identifiersep> <identifier> ( return <identifiersep> type , api . class ) ; \n \t2 path <identifier> <identifiersep> api <identifiersep> path = <identifier> <identifiersep> utils . find <identifiersep> <identifier> ( return <identifiersep> type , path . class ) ; \n <ect>
\t2 && ! <identifier> . is <identifiersep> null <identifiersep> or <identifiersep> empty ( <identifier> . get <identifiersep> snapshot ( ) ) ) { \n \t1 string <identifier> = <identifier> <identifiersep> service . <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> snapshot ( ) , snapshot <identifiersep> id , null , <identifier> . get <identifiersep> pool ( ) ) ; \n \t1 return <identifier> ; \n \t1 } else { \n <ect>
\t4 <identifier> . set <identifiersep> metadata <identifiersep> <identifier> ( meta <identifiersep> data ) ; } \n \t3 meta <identifiersep> data . set <identifiersep> service ( service ) ; \n \t3 logger . info ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t4 input <identifiersep> manager . <identifier> <identifiersep> set ( input <identifiersep> list ) ; \n \t3 } else { \n \t4 input <identifiersep> manager . set ( input <identifiersep> list ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 log . info ( <string_literal> + node <identifiersep> name ) ; \n \t3 add <identifiersep> <identifier> ( node <identifiersep> name , node <identifiersep> data ) ; \n \t3 break ; \n \t2 case node <identifiersep> <identifier> : \n <ect>
\t2 <identifier> <identifiersep> path <identifiersep> <identifier> = true ; \n \t2 thread t = new thread ( new <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public void run ( ) { \n <ect>
\t1 string <identifier> <identifiersep> state = get <identifiersep> <identifier> <identifiersep> state <identifiersep> from <identifiersep> <identifier> <identifiersep> response ( response ) ; \n \t1 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( <identifier> <identifiersep> state ) && <string_literal> . equals ( <identifier> <identifiersep> state ) ) \n \t2 return true ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 string . format ( \n \t4 <string_literal> , \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> process ) , <string_literal> ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t3 return <identifier> <identifiersep> <identifier> ; } \n \t2 try { \n \t3 object bean = context . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> by <identifiersep> name ( <string_literal> + name ) ; \n \t3 if ( bean instanceof <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 <identifier> <identifier> = new abstract <identifiersep> <identifier> ( ) { \n \t5 <identifier> <identifiersep> boolean request <identifiersep> <identifier> = new <identifier> <identifiersep> boolean ( ) ; \n \t5 @ <identifier> \n \t5 public void on <identifiersep> failure ( exception e ) { \n <ect>
<comment> \n public void set <identifiersep> is <identifiersep> <identifier> <identifiersep> <identifier> ( boolean value ) { \n <ect>
\t1 int <identifier> <identifiersep> <identifier> <identifiersep> count = <identifier> <identifiersep> input <identifiersep> format . get <identifiersep> num <identifiersep> map <identifiersep> <identifier> ( job ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> count == 0 ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> count = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> count ; } \n \t1 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> count ) ; \n <ect>
\t4 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> number ( <identifier> <identifiersep> <identifier> <identifiersep> number <identifiersep> from <identifiersep> <identifier> ) ; \n \t4 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> <identifier> <identifiersep> name <identifiersep> from <identifiersep> <identifier> ) ) { \n \t5 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> <identifier> <identifiersep> name <identifiersep> from <identifiersep> <identifier> ) ; } \n \t4 if ( <identifier> <identifiersep> the <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 @ <identifier> \n \t2 public void run ( ) { \n \t2 for ( <identifier> <identifiersep> host <identifiersep> task task : <identifier> ) { \n \t3 try { \n <ect>
\t6 try ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = \n \t8 conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; ) { \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . execute <identifiersep> update ( ) ; \n \t6 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class <identifiersep> with <identifiersep> name ( <identifier> <identifiersep> name ) != null ) { \n \t3 try { \n \t4 <identifier> = <identifier> <identifiersep> with <identifiersep> name ( <identifier> <identifiersep> name ) ; \n \t4 if ( ! ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> name + <string_literal> + <identifier> <identifiersep> name + <string_literal> ) ; \n \t3 return false ; } \n \t2 <identifier> <identifier> = <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name , <identifier> . get <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
<comment> \n \t6 for ( <identifier> <identifier> <identifiersep> id : group . get <identifiersep> <identifier> ( ) ) { \n \t7 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t7 if ( <identifier> != null && ! has <identifiersep> <identifier> ( <identifier> ) && ! has <identifiersep> <identifier> ( <identifier> ) ) { \n <ect>
\t7 <identifier> <identifiersep> manager . send <identifiersep> <identifier> ( host , <string_literal> + host <identifiersep> <identifier> , \n \t9 string . format ( <string_literal> , host <identifiersep> <identifier> , <identifier> . get <identifiersep> not <identifiersep> <identifier> ( ) ) ) ; \n \t7 <identifier> <identifiersep> map . put ( host <identifiersep> ip , new date ( ) ) ; } } } \n \t3 } catch ( final throwable t ) { \n <ect>
\t1 if ( string <identifiersep> utils . is <identifiersep> empty ( <identifier> <identifiersep> query ) ) { \n \t1 <comment> \n \t1 <comment> \n <ect>
\t1 <comment> \n \t1 logger . warn ( <string_literal> + file , e ) ; \n \t1 return <identifier> . <identifier> ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 log . warn ( <string_literal> + list ) ; \n \t4 return null ; } } \n \t2 <identifier> <identifiersep> <identifier> <identifier> = this . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> ) ; \n <ect>
\t3 return new transaction <identifiersep> template ( <identifier> <identifiersep> manager ) . execute ( status - > { \n \t4 try { \n \t5 final object result = method . <identifier> ( <identifier> <identifiersep> lock , <identifier> ) ; \n \t5 <identifier> <identifiersep> lock . entity <identifiersep> manager . <identifier> ( ) ; \n <ect>
\t4 <identifier> <identifiersep> version <identifiersep> <identifier> <identifiersep> out <identifier> <identifiersep> output = <identifier> . from <identifiersep> json ( <identifier> . get <identifiersep> <identifier> <identifiersep> out ( ) , <identifier> <identifiersep> version <identifiersep> <identifier> <identifiersep> out . class ) ; \n \t4 if ( null != <identifier> <identifiersep> output . <identifier> <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> host . set <identifiersep> <identifier> <identifiersep> state ( <identifier> <identifiersep> state . failed ) ; } \n \t3 } catch ( json <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> nodes . add ( new <identifier> <identifiersep> node ( <string_literal> + instance . get <identifiersep> instance <identifiersep> name ( ) , address , empty <identifiersep> map ( ) , \n \t8 empty <identifiersep> set ( ) , version . current . <identifier> <identifiersep> <identifier> <identifiersep> version ( ) ) ) ; } \n \t4 } catch ( exception e ) { \n \t5 logger . warn ( <string_literal> , network <identifiersep> address , e . get <identifiersep> message ( ) ) ; } } } \n <ect>
\t1 thread response <identifiersep> thread = new thread ( ( ) - > { \n \t1 try { \n \t2 io <identifiersep> utils . <identifier> ( target <identifiersep> socket . get <identifiersep> input <identifiersep> stream ( ) , client <identifiersep> socket . get <identifiersep> output <identifiersep> stream ( ) ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 session <identifiersep> cache . <identifier> ( key ) ; \n \t2 session = session <identifiersep> cache . get ( key ) ; } \n \t2 session . <identifier> ( false ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 try { \n \t2 uri uri = new uri ( url <identifiersep> string ) ; \n \t2 table <identifiersep> path = uri . get <identifiersep> path ( ) ; \n \t1 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 this . i = i ; \n \t3 this . <identifier> = <identifier> ; \n \t3 this . total <identifiersep> <identifier> = <identifier> ; \n \t3 this . <identifier> = <identifier> ; \n <ect>
\t2 item . set <identifiersep> state ( <identifier> ) ; \n \t2 service . store ( item ) ; \n \t2 thread . <identifier> ( <number_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> = new date ( ) ; \n <ect>
\t3 { \n \t4 <comment> \n \t4 list < <identifier> < <identifier> <identifiersep> table <identifiersep> <identifier> , long > > <identifier> = size <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> <identifiersep> table <identifiersep> and <identifiersep> length <identifiersep> <identifier> ( <identifier> ) ; \n \t4 list < list < <identifier> <identifiersep> table <identifiersep> <identifier> > > <identifier> <identifiersep> <identifier> = size <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> options . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> options . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> options . <identifier> <identifiersep> <identifier> <identifiersep> table <identifiersep> size ) ; \n <ect>
\t4 <identifier> ( key ) ; \n \t4 <identifier> <identifiersep> <identifier> = true ; \n \t3 } catch ( data <identifiersep> format <identifiersep> exception <identifier> ) { \n \t4 log log = <identifier> <identifiersep> <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> context ( ) . log <identifiersep> manager ( ) . get <identifiersep> log ( <identifier> <identifiersep> set . class ) ; \n <ect>
\t7 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove ( to <identifiersep> delete ) ; \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> response <identifiersep> time <identifiersep> for <identifiersep> <identifier> ( ) ; \n \t7 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n \t8 log . info ( log . <identifier> <identifiersep> <identifier> , <string_literal> , i , to <identifiersep> delete ) ; \n <ect>
\t1 public static class <identifier> <identifiersep> to <identifiersep> x <identifiersep> <identifier> <identifiersep> <identifier> extends <identifier> { \n \t2 @ <identifier> \n \t2 public void <identifier> ( message message , data <identifiersep> type from , data <identifiersep> type to ) throws exception { \n \t3 assert <identifiersep> equals ( <string_literal> , message . get <identifiersep> body ( ) ) ; \n <ect>
\t2 list < snapshot <identifiersep> info > snapshot <identifiersep> <identifier> = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> get <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> <identifier> ( <string_literal> ) . get ( ) . get <identifiersep> <identifier> ( ) ; \n \t2 assert <identifiersep> that ( snapshot <identifiersep> <identifier> . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( snapshot <identifiersep> <identifier> . get ( 0 ) . state ( ) , equal <identifiersep> to ( snapshot <identifiersep> state . success ) ) ; \n \t2 assert <identifiersep> that ( snapshot <identifiersep> <identifier> . get ( 0 ) . <identifier> <identifiersep> <identifier> ( ) . size ( ) , equal <identifiersep> to ( 0 ) ) ; \n <ect>
\t5 log . debug ( <string_literal> + e ) ; } } \n \t2 final grid <identifiersep> update <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t2 <comment> \n <ect>
\t2 this . <identifier> <identifiersep> enabled = <identifier> <identifiersep> enabled ; \n \t2 if ( this . <identifier> <identifiersep> enabled ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> key <identifiersep> <identifier> , content <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 } else { \n <ect>
\t2 @ <identifier> \n \t2 public void on <identifiersep> message ( message message , channel channel ) throws exception { \n \t3 string value = new string ( message . get <identifiersep> body ( ) ) ; \n \t3 try { \n <ect>
\t4 public void cluster <identifiersep> state <identifiersep> <identifier> ( string source , cluster <identifiersep> state <identifier> <identifiersep> state , cluster <identifiersep> state new <identifiersep> state ) { \n \t5 listener . on <identifiersep> response ( new <identifier> <identifiersep> <identifier> <identifiersep> response ( snapshot , <identifier> <identifiersep> info ) ) ; } \n \t3 } ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 <comment> \n <ect>
\t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + type ) ; } \n \t2 string destination = <identifier> <identifiersep> message <identifiersep> header <identifiersep> <identifier> . get <identifiersep> destination ( <identifier> ) ; \n \t2 if ( destination == null ) { \n \t3 if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
<comment> \n \t1 public boolean put ( <identifier> key , <identifier> <identifiersep> entry data ) { \n \t2 if ( data == null ) return false ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , null , true ) \n \t4 } ) \n \t4 file <identifiersep> store . load <identifiersep> file <identifiersep> list ( start <identifiersep> path , <identifier> <identifiersep> <identifier> ) \n \t3 } catch ( e : throwable ) { \n <ect>
\t3 logger . debug ( <string_literal> , <identifier> <identifiersep> class ) ; \n \t3 return <identifier> <identifiersep> class ; } \n \t2 final list < <identifier> <identifiersep> context <identifiersep> class <identifiersep> <identifier> > <identifier> <identifiersep> context <identifiersep> class <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> context <identifiersep> class <identifiersep> <identifier> == null || <identifier> <identifiersep> context <identifiersep> class <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t6 command = new <identifier> ( false , <string_literal> , <identifier> <identifiersep> timeout , s <identifiersep> logger ) ; \n \t6 command . add ( snapshot <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ) ; \n \t6 command . add ( <identifier> <identifiersep> <identifier> <identifiersep> path ) ; \n \t6 result = command . execute ( ) ; \n <ect>
\t2 ex ) ; } \n \t1 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t1 log . info ( <string_literal> ) ; \n \t1 } else { \n <ect>
\t2 for ( thread t : load <identifiersep> <identifier> ) { \n \t3 try { \n \t4 t . <identifier> ( ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 if ( msg <identifiersep> <identifier> . get <identifiersep> message ( ) . get <identifiersep> key ( ) != null ) { \n \t4 msg . set <identifiersep> key ( msg <identifiersep> <identifier> . get <identifiersep> message ( ) . get <identifiersep> key ( ) ) ; } \n \t3 <comment> \n \t3 send <identifiersep> result = <identifier> . send ( msg ) ; \n <ect>
\t1 static { \n \t2 string value = system . get <identifiersep> property ( <identifier> <identifiersep> info <identifiersep> <identifier> <identifiersep> enabled <identifiersep> key , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> enabled = boolean . value <identifiersep> of ( value ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> enabled ) { \n <ect>
public get <identifiersep> <identifier> <identifiersep> state ( string <identifier> <identifiersep> uri ) { \n \t1 super ( <identifier> <identifiersep> uri ) ; } \n @ <identifier> \n public response <identifier> <identifiersep> handle ( http <identifiersep> request request ) throws json <identifiersep> exception { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> status ( context ) ) { \n \t3 long start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 while ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> num != 0 ) { \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> num < 0 ) { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> + account <identifiersep> id + <string_literal> , ex ) ; \n \t4 account <identifiersep> <identifier> <identifiersep> <identifier> = true ; } \n \t3 <comment> \n \t3 int num <identifiersep> <identifier> = <identifier> <identifiersep> security <identifiersep> group <identifiersep> dao . remove <identifiersep> by <identifiersep> account <identifiersep> id ( account <identifiersep> id ) ; \n <ect>
\t4 <identifier> = <identifier> <identifiersep> <identifier> . value <identifiersep> of ( <identifier> <identifiersep> options . get <identifiersep> <identifier> <identifiersep> value ( <identifier> ) ) ; } \n \t3 if ( <identifier> <identifiersep> options . has <identifiersep> <identifier> ( <identifier> ) ) { \n \t4 version = version . by <identifiersep> name ( <identifier> <identifiersep> options . get <identifiersep> <identifier> <identifiersep> value ( <identifier> ) ) ; } \n \t2 } catch ( parse <identifiersep> exception e ) { \n <ect>
\t1 public void <identifier> ( ) { \n \t2 try { \n \t3 super . close ( ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 @ <identifier> ( <identifier> <identifiersep> type . application <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t1 @ path ( <string_literal> ) \n \t1 public response json ( <identifier> <identifiersep> map < string , string > <identifier> <identifiersep> <identifier> ) { \n \t2 try { \n <ect>
<comment> \n \t1 private index <identifiersep> <identifier> <identifiersep> state <identifier> <identifiersep> state ( index <identifiersep> <identifier> <identifiersep> state new <identifiersep> state , string <identifier> ) { \n \t2 assert thread . <identifier> <identifiersep> lock ( <identifier> ) ; \n <ect>
\t3 if ( <identifier> . is <identifiersep> not <identifiersep> blank ( timeout <identifiersep> text ) ) { \n \t4 try { \n \t5 timeout = long . parse <identifiersep> long ( timeout <identifiersep> text ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 else { \n \t4 api <identifiersep> path <identifiersep> value = api <identifiersep> path . value ( ) ; } \n \t3 <identifier> <identifiersep> api <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> api <identifiersep> <identifier> ( return <identifiersep> type , <identifier> , api <identifiersep> path <identifiersep> value , method , method <identifiersep> path . value ( ) ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> is . contains <identifiersep> key ( return <identifiersep> type ) ) { \n <ect>
\t3 logger . debug ( <string_literal> , new <identifiersep> cluster <identifiersep> state . version ( ) , current <identifiersep> state . version ( ) ) ; \n \t3 return true ; } \n \t2 <comment> \n \t2 if ( current <identifiersep> state . nodes ( ) . get <identifiersep> <identifier> <identifiersep> node <identifiersep> id ( ) != null && new <identifiersep> cluster <identifiersep> state . version ( ) < current <identifiersep> state . version ( ) ) { \n <ect>
\t3 <identifier> . add ( date <identifiersep> time <identifiersep> authentication <identifiersep> request <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> location ( ) . is <identifiersep> enabled ( ) ) { \n \t3 <identifier> . add ( <identifier> <identifiersep> location <identifiersep> authentication <identifiersep> request <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t1 logger . error ( <string_literal> , e ) ; \n \t1 throw new runtime <identifiersep> exception ( <string_literal> , e ) ; } \n \t1 logger . debug ( <string_literal> ) ; } \n public void create <identifiersep> <identifier> ( ) { \n <ect>
\t2 string <identifier> = null ; \n \t2 try { \n \t3 <identifier> = <identifier> <identifiersep> bytes . to <identifiersep> string ( <identifier> <identifiersep> files . read ( <identifier> <identifiersep> file ) ) . <identifier> ( ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
\t1 public host <identifier> ( final <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> cmd cmd ) { \n \t2 final long host <identifiersep> id = cmd . get <identifiersep> id ( ) ; \n \t2 final host <identifiersep> vo host = <identifier> <identifiersep> host <identifiersep> dao . find <identifiersep> by <identifiersep> id ( host <identifiersep> id ) ; \n \t2 if ( host == null ) { \n <ect>
\t6 <identifier> ( list <identifiersep> host ) , \n \t6 1 , \n \t6 <string_literal> \n \t6 ) \n <ect>
\t2 <identifier> <identifiersep> utils . do <identifiersep> with <identifiersep> <identifier> ( bean . get <identifiersep> class ( ) , new <identifier> <identifiersep> utils . field <identifiersep> <identifier> ( ) { \n \t3 public void do <identifiersep> with ( field field ) throws illegal <identifiersep> argument <identifiersep> exception , illegal <identifiersep> access <identifiersep> exception { \n \t4 <identifier> <identifiersep> <identifier> <identifier> = field . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . class ) ; \n \t4 if ( <identifier> != null && field . get <identifiersep> type ( ) == string . class ) { \n <ect>
\t2 throw new no <identifiersep> such <identifiersep> entity <identifiersep> exception ( object <identifiersep> key ) ; \n \t1 } else { \n \t2 throw new <identifier> <identifiersep> no <identifiersep> such <identifiersep> entity <identifiersep> exception ( object <identifiersep> key ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t2 <string_literal> , 1 , <identifier> <identifiersep> <identifier> ) ; \n \t1 cluster . add <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t1 log . info ( <string_literal> + <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 public void do <identifiersep> set <identifiersep> <identifier> ( int write <identifiersep> <identifier> , boolean <identifier> ) \n \t3 throws <identifier> <identifiersep> connection <identifiersep> exception , <identifier> <identifiersep> exception , <identifier> <identifiersep> <identifier> <identifiersep> transaction <identifiersep> id <identifiersep> exception { \n \t2 <identifier> <identifiersep> request request = new write <identifiersep> <identifier> <identifiersep> request ( write <identifiersep> <identifier> , <identifier> ) ; \n \t2 request . set <identifiersep> unit <identifiersep> id ( get <identifiersep> id ( ) ) ; \n <ect>
\t2 } else if ( <identifier> <identifiersep> method . equals ( http <identifiersep> <identifier> <identifiersep> request . client <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 principal = super . get <identifiersep> principal ( <identifier> ) ; \n \t2 } else { \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t4 log . warn ( <string_literal> + query <identifiersep> <identifier> . get ( i ) ) ; \n \t4 continue ; } \n \t3 if ( <identifier> == <identifier> . <identifier> || <identifier> == <identifier> . <identifier> <identifiersep> <identifier> ) { \n \t4 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( 0 ) != <identifier> ) { \n \t3 logger . warn ( <string_literal> , node <identifiersep> id ) ; \n \t3 node . set <identifiersep> node <identifiersep> state ( <identifier> <identifiersep> <identifier> <identifiersep> node <identifiersep> state . failed ) ; \n \t2 } else { \n <ect>
\t2 final <identifier> <identifiersep> <identifier> <identifier> = find <identifiersep> <identifier> <identifiersep> <identifier> ( service , registered <identifiersep> service , authentication ) ; \n \t2 if ( <identifier> == null ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 return <identifier> . of ( true , null ) ; } \n <ect>
\t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + target . get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + handler . get <identifiersep> name ( ) , e ) ; \n \t3 throw new runtime <identifiersep> exception ( <string_literal> + <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
\t3 double value = provider . get <identifiersep> <identifier> <identifiersep> value ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t3 try { \n \t4 this . event <identifiersep> <identifier> . <identifier> <identifiersep> update ( <identifier> . get <identifiersep> name ( ) , new <identifier> <identifiersep> type ( value ) ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception exception ) { \n <ect>
\t6 } catch ( exception e ) { \n \t7 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> id , e ) ; } } \n \t5 <comment> \n \t5 list < <identifier> <identifiersep> vo > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . list <identifiersep> by <identifiersep> state ( <identifier> . state . <identifier> ) ; \n <ect>
<comment> \n \t1 public model load <identifiersep> model ( string <identifier> <identifiersep> or <identifiersep> uri ) \n \t1 { \n <ect>
\t3 <comment> \n \t3 exchange . get <identifiersep> out ( ) . get <identifiersep> <identifier> ( ) . put <identifiersep> all ( exchange . get <identifiersep> in ( ) . get <identifiersep> <identifier> ( ) ) ; \n \t3 exchange . get <identifiersep> out ( ) . set <identifiersep> body ( result ) ; \n \t2 } catch ( exception ex ) { \n <ect>
<comment> \n public response get ( web <identifiersep> resource resource ) throws io <identifiersep> exception { \n <ect>
\t5 } catch ( not <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t6 <comment> \n \t6 if ( log <identifiersep> <identifier> ) logger . <identifier> ( this , <string_literal> + msg + <string_literal> + source + <string_literal> + ex ) ; \n \t5 } catch ( <identifier> <identifiersep> send <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> long <identifiersep> exception ex ) { \n <ect>
\t3 log . warn ( <string_literal> , <identifier> <identifiersep> filter <identifiersep> debug <identifiersep> <identifier> . format <identifiersep> <identifier> ( <identifier> ) ) ; \n \t3 output . source <identifiersep> error ( data <identifiersep> channel <identifiersep> error . <identifier> ( ex ) ) ; \n \t3 throw ex ; \n \t2 } catch ( exception ex ) { \n <ect>
\t5 <comment> \n \t5 <comment> \n \t5 <comment> \n <ect>
\t2 { \n \t3 try \n \t3 { \n \t4 if ( ! <identifier> . <identifier> <identifiersep> <identifier> ( 1 , time <identifiersep> unit . <identifier> ) ) \n <ect>
\t4 continue ; <comment> \n \t3 try { \n \t4 target . <identifier> ( local <identifiersep> <identifier> , data , <identifier> , length ) ; } \n \t3 catch ( throwable t ) { \n <ect>
\t2 i <identifiersep> connection conn = null ; \n \t2 <identifier> <identifiersep> <identifier> node <identifiersep> port = task <identifiersep> to <identifiersep> node <identifiersep> port . get ( task <identifiersep> id ) ; \n \t2 if ( node <identifiersep> port == null ) { \n \t3 string error <identifiersep> msg = <string_literal> + task <identifiersep> id + <string_literal> ; \n <ect>
\t2 object <identifiersep> <identifier> . not <identifiersep> null ( get <identifiersep> <identifier> <identifiersep> context ( ) , <string_literal> ) ; \n \t2 abstract <identifiersep> <identifier> <identifiersep> endpoint answer = null ; \n \t2 uri <identifier> <identifiersep> uri = new uri ( uri <identifiersep> <identifier> . <identifier> <identifiersep> uri ( <identifier> ) ) ; \n \t2 string <identifier> = <identifier> <identifiersep> uri . get <identifiersep> <identifier> ( ) ; \n <ect>
\t4 final <identifier> <identifiersep> exception <identifier> = client != null \n \t5 ? client . create <identifiersep> <identifier> <identifiersep> exception ( response , input <identifiersep> stream ) : null ; \n \t4 if ( status == http <identifiersep> status . <identifier> <identifiersep> request <identifiersep> <number_literal> && <identifier> != null && is <identifiersep> <identifier> <identifiersep> session <identifiersep> error ( <identifier> ) ) { \n \t5 <comment> \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 this . <identifier> <identifiersep> import <identifiersep> process = null ; } \n \t1 if ( null != this . password <identifiersep> file && this . password <identifiersep> file . exists ( ) ) { \n \t1 if ( ! this . password <identifiersep> file . delete ( ) ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> list . add ( <identifier> <identifiersep> <identifier> <identifiersep> list . response <identifiersep> filter <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 filter . filter ( request <identifiersep> context , response <identifiersep> context ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> list . add ( <identifier> <identifiersep> <identifier> <identifiersep> list . response <identifiersep> filter <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t10 i + <string_literal> , \n \t10 <identifier> . get <identifiersep> <identifier> <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , \n \t10 <identifier> <identifiersep> method ( <identifier> . get <identifiersep> name ( ) ) } ) ; } \n \t6 } catch ( runtime <identifiersep> exception <identifier> ) { \n <ect>
\t2 set < string > <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> <identifiersep> <identifier> , code <identifiersep> <identifier> ) ; \n \t2 set < string > <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 <comment> \n \t2 for ( string <identifier> : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 if ( file . exists ( ) ) { \n \t4 if ( file . delete ( ) ) { \n \t5 delete <identifiersep> empty <identifiersep> <identifier> <identifiersep> <identifier> ( file ) ; \n \t4 } else { \n <ect>
\t1 <identifier> . execute <identifiersep> update ( get <identifiersep> <identifier> <identifiersep> table <identifiersep> <identifier> ( null <identifiersep> table <identifiersep> name , <identifier> <identifiersep> public ) ) ; \n \t1 <identifier> . execute <identifiersep> update ( get <identifiersep> <identifier> <identifiersep> table <identifiersep> <identifier> ( <identifier> <identifiersep> table <identifiersep> name , <identifier> <identifiersep> public ) ) ; \n \t1 <identifier> . execute <identifiersep> update ( get <identifiersep> <identifier> <identifiersep> table <identifiersep> <identifier> ( <identifier> <identifiersep> table <identifiersep> name , <identifier> <identifiersep> <identifier> ) ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 return <identifier> <identifiersep> to <identifiersep> <identifier> . get ( <identifier> ) ; \n \t1 } catch ( execution <identifiersep> exception e ) { \n \t2 logger . debug ( <string_literal> , <identifier> , e ) ; \n \t1 } catch ( <identifier> <identifiersep> execution <identifiersep> exception e ) { \n <ect>
\t2 if ( this . <identifier> <identifiersep> on . is <identifiersep> <identifier> ( <identifier> <identifiersep> on <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 logger . warn ( <string_literal> , this . <identifier> <identifiersep> on , <identifier> <identifiersep> on <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 return false ; } \n \t2 if ( this . <identifier> <identifiersep> on . is <identifiersep> <identifier> ( this . not <identifiersep> on <identifiersep> or <identifiersep> <identifier> ) ) { \n <ect>
\t1 this . data <identifiersep> <identifier> <identifiersep> config = data <identifiersep> <identifier> <identifiersep> config ; } \n @ <identifier> \n public list < <identifier> <identifiersep> <identifier> > list <identifiersep> <identifier> ( final i <identifiersep> <identifier> <identifiersep> session <identifier> <identifiersep> session , final boolean <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 assert . assert <identifiersep> true ( <identifier> . <identifier> <identifiersep> to ( <identifier> ) > 0 ) ; \n \t2 assert . assert <identifiersep> true ( <identifier> . <identifier> <identifiersep> to ( <identifier> ) < 0 ) ; \n \t2 assert . assert <identifiersep> true ( <identifier> . <identifier> <identifiersep> to ( <identifier> ) > 0 ) ; \n \t2 assert . assert <identifiersep> true ( <identifier> . <identifier> <identifiersep> to ( <identifier> ) > 0 ) ; \n <ect>
\t2 private boolean <identifier> = false ; \n \t2 public <identifier> <identifiersep> server <identifiersep> listener ( ) { \n \t3 super ( <string_literal> ) ; } \n \t2 public void <identifier> ( ) { \n <ect>
\t1 class <identifiersep> name ) ; \n \t1 system . out . <identifier> ( <string_literal> + <identifier> <identifiersep> file <identifiersep> name + <string_literal> \n \t1 + class <identifiersep> name ) ; } \n \t1 <comment> \n <ect>
\t5 logger . debug ( <string_literal> , value ) ; \n \t4 } else if ( <string_literal> . equals ( config <identifiersep> key ) ) { \n \t5 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( value ) ) { \n \t6 device <identifiersep> config . port = ( int ) long . parse <identifiersep> long ( value ) ; \n <ect>
\t2 get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> ( ( <identifier> <identifiersep> connection ) <identifier> ) ; } } \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> exception e ) { \n \t1 log . warn ( e . get <identifiersep> message ( ) , e ) ; } } \n protected void <identifier> <identifiersep> metadata <identifiersep> <identifier> ( ) { \n <ect>
\t4 return null ; } \n \t3 @ <identifier> \n \t3 public void <identifier> <identifiersep> <identifier> ( command message ) { \n \t4 if ( message instanceof exception <identifiersep> response ) { \n <ect>
\t4 target . <identifier> ( port ) ; } \n \t3 return target . to <identifiersep> string ( ) ; } \n \t2 catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
<comment> \n \t1 private boolean <identifier> <identifiersep> access <identifiersep> token <identifiersep> request ( final http <identifiersep> <identifier> <identifiersep> request request , final http <identifiersep> <identifier> <identifiersep> response response ) { \n \t2 final string <identifier> <identifiersep> type = request . get <identifiersep> <identifier> ( o <identifiersep> <identifier> . <identifier> <identifiersep> type ) ; \n \t2 if ( ! is <identifiersep> <identifier> <identifiersep> type <identifiersep> <identifier> ( <identifier> <identifiersep> type , o <identifiersep> <identifier> <identifiersep> <identifier> . values ( ) ) ) { \n <ect>
\t1 return <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> name ( host ) ; \n \t1 } catch ( exception e ) { \n \t1 if ( e instanceof interrupted <identifiersep> io <identifiersep> exception || e instanceof interrupted <identifiersep> exception ) { \n \t2 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; } \n <ect>
\t4 success = true ; } \n \t2 } catch ( throwable e ) { \n \t3 if ( e instanceof remote <identifiersep> exception ) { \n \t4 host <identifiersep> service . <identifier> <identifiersep> service <identifiersep> context ( context ) ; } \n <ect>
\t2 if ( result <identifiersep> set != null ) { \n \t3 try { \n \t4 result <identifiersep> set . close ( ) ; \n \t3 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t1 public void <identifier> ( ) throws exception { \n \t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t3 <comment> \n \t3 thread . <identifier> ( <identifier> ) ; \n <ect>
\t8 <identifier> <identifiersep> mode = true ; \n \t8 <identifier> <identifiersep> task task = new <identifier> <identifiersep> task ( ) { \n \t9 @ <identifier> \n \t9 public void run ( ) { \n <ect>
\t1 try { \n \t1 <identifier> <identifiersep> manager = <string_literal> + <identifier> <identifiersep> manager ; \n \t1 return ( <identifier> <identifiersep> storage <identifiersep> manager ) class <identifiersep> <identifier> . get <identifiersep> system <identifiersep> class <identifiersep> <identifier> ( ) . load <identifiersep> class ( <identifier> <identifiersep> manager ) . new <identifiersep> instance ( ) ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t7 if ( ! <identifier> . is <identifiersep> null <identifiersep> or <identifiersep> empty ( listener . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ) ) \n \t8 builder . with <identifiersep> <identifier> <identifiersep> <identifier> ( listener . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t7 <identifier> . <identifier> ( builder . build ( ) ) ; } \n \t5 } catch ( exception ex ) { \n <ect>
\t4 logger . warn ( msg , ex . get <identifiersep> target <identifiersep> exception ( ) ) ; } \n \t3 else { \n \t4 logger . warn ( msg + <string_literal> + ex . get <identifiersep> target <identifiersep> exception ( ) ) ; } } \n \t2 catch ( throwable ex ) { \n <ect>
\t2 <identifier> to = to <identifiersep> address . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> state <identifier> = get <identifiersep> <identifier> <identifiersep> state ( to ) ; \n \t2 if ( <identifier> != null ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 return null ; } \n \t1 @ <identifier> \n \t1 public synchronized response process <identifiersep> remove <identifiersep> connection ( connection <identifiersep> id id , long last <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ) \n \t3 throws interrupted <identifiersep> exception { \n <ect>
\t4 <identifier> . delete ( <identifier> . load ( entity . class , 0 ) ) ; <comment> \n \t4 <identifier> . <identifier> ( ) ; \n \t4 <identifier> ( <string_literal> ) ; } \n \t3 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 } else { \n \t1 log . info ( <string_literal> ) ; \n \t1 read <identifiersep> model = new <identifier> <identifiersep> model ( num <identifiersep> <identifier> , num <identifiersep> <identifier> , <identifier> , <identifier> , <identifier> <identifiersep> utils . get <identifiersep> <identifier> ( <identifier> ) , null , \n \t2 num <identifiersep> <identifier> <identifiersep> <identifier> , model <identifiersep> <identifier> ) ; } \n <ect>
\t4 logger . info ( <string_literal> , <identifier> , name ) ; \n \t4 ex . add <identifiersep> <identifier> ( <string_literal> , <identifier> , name ) ; } \n \t3 throw ex ; \n \t2 } else { \n <ect>
\t1 <identifier> <identifiersep> c \n \t1 } else { \n \t1 <comment> \n \t1 if ( ! has <identifiersep> <identifier> <identifiersep> a || ! has <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 if ( ! result ) \n \t4 <identifier> . add ( new <identifier> <identifiersep> error <identifiersep> update ( <string_literal> ) ) ; \n \t3 return <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public void <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> event event ) { \n \t2 <identifier> <identifiersep> channel <identifiersep> handler . <identifier> ( ) ; } \n \t1 @ listener \n \t1 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> event event ) { \n <ect>
\t4 for ( task task : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t5 if ( task instanceof java <identifiersep> <identifier> ) { \n \t6 add <identifiersep> <identifier> ( <identifier> , ( java <identifiersep> <identifier> ) task , <identifier> <identifiersep> <identifier> ) ; } } } \n \t2 } catch ( throwable e ) { \n <ect>
\t2 <identifier> <identifiersep> config <identifier> <identifiersep> config = new <identifier> <identifiersep> config . null <identifiersep> <identifier> <identifiersep> config ( 1 ) . <identifier> ( ) ; \n \t2 try { \n \t3 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> ( <identifier> <identifiersep> config . get <identifiersep> <identifier> ( ) . get <identifiersep> native <identifiersep> directory ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> timeout ( ) . get <identifiersep> time <identifiersep> to <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( ) > 0 ) { \n \t3 logger . debug ( <string_literal> , \n \t4 <identifier> . get <identifiersep> <identifier> <identifiersep> timeout ( ) . get <identifiersep> time <identifiersep> to <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( ) ) ; \n \t3 return new <identifier> <identifiersep> timeout <identifiersep> <identifier> <identifiersep> policy ( <identifier> . get <identifiersep> <identifier> <identifiersep> timeout ( ) . get <identifiersep> time <identifiersep> to <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( ) ) ; } \n <ect>
\t1 string <identifier> <identifiersep> name ) throws sql <identifiersep> exception , <identifier> <identifiersep> exception { \n \t1 if ( ! conf . get <identifiersep> boolean ( <identifier> <identifiersep> text <identifiersep> <identifier> <identifiersep> property , false ) ) { \n \t1 throw new <identifier> <identifiersep> exception ( <string_literal> + <string_literal> - <identifier> <string_literal> = true \\ <string_literal> + <string_literal> ) ; } \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> = <identifier> . new <identifiersep> <identifier> <identifiersep> thread <identifiersep> pool ( new <identifier> <identifiersep> thread <identifiersep> factory ( <string_literal> ) ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> server <identifiersep> socket = new server <identifiersep> socket ( port ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t5 return null ; } \n \t4 finally \n \t4 { \n \t5 if ( ! is <identifiersep> final ) \n <ect>
\t1 read <identifiersep> model = new <identifier> <identifiersep> model ( num <identifiersep> <identifier> , num <identifiersep> <identifier> , <identifier> , <identifier> , <identifier> <identifiersep> utils . get <identifiersep> <identifier> ( <identifier> ) , null , \n \t2 num <identifiersep> <identifier> <identifiersep> <identifier> , model <identifiersep> <identifier> ) ; } \n \t1 log . info ( <string_literal> ) ; \n \t1 model <identifiersep> <identifier> = new model <identifiersep> <identifier> ( read <identifiersep> model , null , num <identifiersep> <identifier> <identifiersep> <identifier> , num <identifiersep> <identifier> , num <identifiersep> <identifier> ) ; \n <ect>
\t2 socket = <identifier> . <identifier> ( ) ; \n \t2 do <identifiersep> <identifier> ( <identifier> ) ; } \n \t1 public void <identifier> <identifiersep> to ( string host , int port , string password ) throws <identifier> <identifiersep> host <identifiersep> exception , io <identifiersep> exception { \n \t2 <comment> \n <ect>
\t5 <identifier> <identifiersep> <identifier> . add <identifiersep> all ( result . get ( <identifier> . value ( ) ) ) ; } \n \t4 <identifier> <identifiersep> <identifier> . add ( provider ) ; \n \t4 <identifier> = provider ; } } \n \t2 if ( <identifier> == null ) { \n <ect>
\t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 logger . debug ( <string_literal> <ect>
\t2 connection <identifiersep> uri = <string_literal> ; \n \t2 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> connection <identifiersep> factory ( connection <identifiersep> uri ) ; \n \t2 <identifier> . start ( ) ; \n \t2 <identifier> <identifiersep> data <identifiersep> dir = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> directory ( ) ; \n <ect>
\t4 <identifier> <identifiersep> in = null ; \n \t4 <comment> \n \t4 <identifier> <identifiersep> success ( data , context ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t1 } catch ( exception e ) { \n \t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> exception ( e ) ) { \n \t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> > 0 ) { \n <ect>
<comment> \n \t1 public void add <identifiersep> <identifier> ( <identifier> <identifiersep> resource <identifier> ) { \n \t2 <comment> \n \t2 if ( <identifier> == null ) { \n <ect>
\t4 max <identifiersep> <identifier> = integer . parse <identifiersep> int ( <identifier> ) ; } \n \t3 cache <identifiersep> manager <identifier> = cache <identifiersep> manager . create ( ) ; \n \t3 cache cache = new cache ( <string_literal> , max <identifiersep> <identifier> , false , false , time <identifiersep> to <identifiersep> <identifier> , time <identifiersep> to <identifiersep> <identifier> ) ; \n \t3 <identifier> . add <identifiersep> cache ( cache ) ; \n <ect>
\t4 final response <identifiersep> status status = response . get <identifiersep> status ( ) ; \n \t4 if ( status . <identifier> <identifiersep> to ( response <identifiersep> status . <identifier> ) == 0 ) { \n \t5 logger . debug ( <string_literal> , status , response . get <identifiersep> <identifier> ( ) ) ; \n \t5 return true ; } \n <ect>
\t1 public <identifier> <identifiersep> ticket <identifiersep> <identifier> ( final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , final <identifier> <identifiersep> manager <identifier> <identifiersep> manager ) { \n \t2 super ( <identifier> <identifiersep> <identifier> ) ; \n \t2 this . storage = <identifier> . new <identifiersep> builder ( ) . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> cache <identifiersep> size ) . <identifier> <identifiersep> size ( max <identifiersep> cache <identifiersep> size ) \n \t3 . <identifier> <identifiersep> <identifier> ( new <identifier> <identifiersep> ticket <identifiersep> <identifier> <identifiersep> policy ( ) ) . <identifier> <identifiersep> listener ( new <identifier> <identifiersep> ticket <identifiersep> <identifier> <identifiersep> listener ( ) ) . build ( s - > { \n <ect>
\t1 public class get <identifiersep> <identifier> <identifiersep> task <identifiersep> type ( ) { \n \t2 return <identifier> <identifiersep> test <identifiersep> task . class ; } \n \t1 @ <identifier> \n \t1 public return <identifiersep> value process <identifiersep> task ( task task ) throws throwable { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <comment> \n \t2 <identifier> = send <identifiersep> find <identifiersep> <identifier> <identifiersep> request ( template , <identifier> <identifiersep> uri , <string_literal> , <string_literal> ) ; \n <ect>
\t4 <comment> \n \t4 send <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( new shutdown <identifiersep> info ( ) ) ; \n \t4 <identifier> <identifiersep> transport . stop ( ) ; \n \t3 } catch ( throwable e ) { \n <ect>
\t4 long <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <number_literal> * <identifier> ; \n \t4 <comment> \n \t4 for ( int i = 0 ; i < <identifier> <identifiersep> count ; i ++ ) { \n \t5 try { \n <ect>
\t2 } catch ( <identifier> <identifiersep> server <identifiersep> exception ex ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , ex ) ; \n \t3 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . <identifier> <identifiersep> error , ex . get <identifiersep> message ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 if ( service != null ) { \n \t3 final registered <identifiersep> service registered <identifiersep> service = this . <identifier> <identifiersep> manager . find <identifiersep> service <identifiersep> by ( service ) ; \n \t3 logger . debug ( <string_literal> , registered <identifiersep> service ) ; \n \t3 if ( registered <identifiersep> service == null || ! registered <identifiersep> service . get <identifiersep> access <identifiersep> <identifier> ( ) . is <identifiersep> service <identifiersep> access <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 try { \n \t3 <comment> \n \t3 <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> + \n \t4 <string_literal> ) ; \n <ect>
\t4 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; } \n \t2 return null ; } \n \t1 } catch ( <identifier> <identifiersep> service <identifiersep> exception e ) { \n <ect>
\t2 for ( task <identifiersep> data <identifiersep> output output : <identifier> ) { \n \t3 output . send <identifiersep> <identifier> ( ) ; } \n \t2 log . info ( <string_literal> ) ; } \n \t1 @ <identifier> public void source <identifiersep> error ( throwable <identifier> ) { \n <ect>
\t2 } else if ( result . contains ( <string_literal> ) || result . contains ( <string_literal> ) ) { \n \t3 event <identifiersep> <identifier> . <identifier> <identifiersep> update ( item <identifiersep> name , on <identifiersep> <identifier> <identifiersep> type . on ) ; \n \t3 logger . debug ( <string_literal> , item <identifiersep> name ) ; \n \t2 } else { \n <ect>
\t5 + <string_literal> , <string_literal> + vm . get <identifiersep> instance <identifiersep> name ( ) + <string_literal> + vm . get <identifiersep> id ( ) + <string_literal> + vm . get <identifiersep> host <identifiersep> id ( ) + <string_literal> ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 if ( server <identifiersep> state == state . <identifier> ) { \n \t4 if ( vm . get <identifiersep> host <identifiersep> id ( ) != null && vm . get <identifiersep> host <identifiersep> id ( ) != host <identifiersep> id ) { \n <ect>
\t1 class . for <identifiersep> name ( <string_literal> ) ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t1 <comment> \n \t1 } catch ( throwable t ) { \n <ect>
\t5 } else { \n \t6 throw ex ; } } \n \t4 if ( <identifier> <identifiersep> <identifier> ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> path <identifiersep> <identifier> . <identifier> ( native <identifiersep> base <identifiersep> dir ) ; } \n <ect>
\t3 map < service , map < <identifier> , string > > <identifier> = element . get <identifiersep> <identifier> ( ) ; \n \t3 provider <identifier> <identifiersep> provider = element . get <identifiersep> provider ( ) ; \n \t3 if ( <identifier> <identifiersep> provider != null ) { \n \t4 if ( s <identifiersep> provider <identifiersep> to <identifiersep> network <identifiersep> element <identifiersep> map . contains <identifiersep> key ( <identifier> <identifiersep> provider . get <identifiersep> name ( ) ) ) { \n <ect>
\t1 if ( this . <identifier> <identifiersep> file != null && this . <identifier> <identifiersep> file . exists ( ) ) { \n \t1 <comment> \n \t1 log . debug ( <string_literal> ) ; \n \t1 if ( ! this . <identifier> <identifiersep> file . delete ( ) ) { \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 try { \n \t4 <identifier> = message <identifiersep> <identifier> . get <identifiersep> instance ( <string_literal> ) ; \n \t3 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 first = last = null ; \n \t3 size . set ( 0 ) ; \n \t3 if ( check <identifiersep> lock ) { \n \t4 if ( ! in <identifiersep> <identifier> ) \n <ect>
<comment> \n \t2 private void process <identifiersep> <identifier> <identifiersep> message ( string msg ) { \n <ect>
\t1 else : \n \t2 <identifier> \n \t1 else : \n \t1 self . <identifier> = true \n <ect>
\t8 <identifier> ( vm , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> system <identifiersep> user ( ) . get <identifiersep> id ( ) , <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> system <identifiersep> account ( ) ) ; \n \t7 } catch ( exception e ) { \n \t8 s <identifiersep> logger . warn ( <string_literal> + vm , e ) ; } } \n \t5 } catch ( exception e ) { \n <ect>
\t4 <string_literal> , target ) , exception ) ; \n \t3 throw exception ; \n \t2 } finally { \n \t3 if ( success ) { \n <ect>
\t4 break ; \n \t3 } catch ( exception e ) { } } \n \t2 if ( instance == null ) { \n \t3 log . error ( <string_literal> + <identifier> . get <identifiersep> name ( ) ) ; \n <ect>
\t3 <comment> \n \t3 if ( <identifier> <identifiersep> to <identifiersep> all ) { \n \t4 <identifier> <identifiersep> current <identifiersep> <identifier> <identifiersep> map . put ( <identifier> . get <identifiersep> version ( ) , <identifier> ) ; \n <ect>
\t3 set < map . entry < string , job > > <identifier> = <identifier> . entry <identifiersep> set ( ) ; \n \t3 for ( map . entry < string , job > entry : <identifier> ) { \n \t4 string job <identifiersep> name = entry . get <identifiersep> key ( ) ; \n \t4 job job = entry . get <identifiersep> value ( ) ; \n <ect>
\t1 <comment> \n \t1 public class <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> handler extends task { \n \t2 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> handler ( task . type type , <identifier> <identifier> , byte [ ] data ) { \n \t3 super ( type , <identifier> , data ) ; \n <ect>
\t5 logger . warn ( <string_literal> , http <identifiersep> <identifier> . get <identifiersep> status <identifiersep> line ( ) ) ; \n \t5 return null ; } \n \t4 response = io <identifiersep> utils . to <identifiersep> string ( http <identifiersep> <identifier> . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) , <identifier> <identifiersep> <number_literal> <identifiersep> <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> ( url <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( <string_literal> ) ; \n \t2 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t3 if ( <identifier> . size ( ) > <identifier> . size ( ) ) { \n <ect>
\t6 update <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; } \n \t5 @ <identifier> \n \t5 public void <identifier> <identifiersep> <identifier> ( <identifier> update , <identifier> <identifiersep> id <identifier> <identifiersep> id ) { \n \t6 <comment> \n <ect>
\t3 <comment> \n \t3 if ( object != null && ! ( object . <identifier> <identifiersep> context ( ) . <identifier> <identifiersep> object <identifiersep> store ( ) instanceof <identifier> <identifiersep> object <identifiersep> store <identifiersep> <identifier> ) ) { \n \t4 log . warn ( <string_literal> ) ; } \n \t3 local <identifiersep> context = <identifier> . new <identifiersep> <identifier> <identifiersep> context ( object . <identifier> <identifiersep> context ( ) . <identifier> <identifiersep> object <identifiersep> store ( ) ) ; \n <ect>
\t2 try { \n \t3 <identifier> . start ( ) ; \n \t3 <identifier> <identifiersep> <identifier> = this . lock <identifiersep> <identifier> ( <identifier> , true ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t4 logger . info ( <string_literal> , <identifier> <identifiersep> response . get <identifiersep> <identifier> <identifiersep> shards ( ) , num <identifiersep> shards . num <identifiersep> <identifier> ) ; \n \t4 if ( <identifier> <identifiersep> response . get <identifiersep> <identifier> <identifiersep> shards ( ) == num <identifiersep> shards . num <identifiersep> <identifier> && ! <identifier> <identifiersep> failed ) { \n \t5 assert <identifiersep> <identifier> <identifiersep> and <identifiersep> log <identifiersep> on <identifiersep> failure ( num <identifiersep> <identifier> + num <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> response ) ; } \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> execution <identifiersep> exception ex ) { \n <ect>
\t2 } else { \n \t2 log . debug ( <string_literal> + <identifier> + <string_literal> ) ; } \n \t2 return boolean . true ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 case <identifier> : \n \t2 is <identifiersep> <identifier> = <identifier> . class . is <identifiersep> <identifier> <identifiersep> from ( instance . get <identifiersep> class ( ) ) ; \n \t2 break ; \n \t2 default : \n <ect>
\t2 assert <identifiersep> equals ( <number_literal> , entity <identifiersep> set <identifiersep> with <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . size ( ) ) ; \n \t2 log . info ( <string_literal> , entity <identifiersep> set . get <identifiersep> <identifier> ( ) ) ; \n \t2 client <identifiersep> entity = ( client <identifiersep> entity ) response <identifiersep> <identifier> . get ( <number_literal> ) . get <identifiersep> body ( ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( client <identifiersep> entity ) ; \n <ect>
\t3 try { \n \t4 if ( in != null ) { \n \t5 in . close ( ) ; } } \n \t3 catch ( io <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t2 path <identifier> <identifiersep> file = files . create <identifiersep> <identifier> <identifiersep> file ( <identifier> . get ( get <identifiersep> <identifier> <identifiersep> directory ( ) ) , <identifier> , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> file . to <identifiersep> file ( ) , <identifier> ) ; \n \t1 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 return false ; } \n \t1 public <identifier> <identifiersep> <identifier> attribute <identifiersep> list <identifiersep> <identifier> ( ) { \n \t2 return model ( ) . <identifier> <identifiersep> attribute <identifiersep> list <identifiersep> total <identifiersep> <identifier> ( ) ; } \n \t1 public int <identifier> <identifiersep> count ( ) { \n <ect>
\t2 while ( <identifier> <identifiersep> <identifier> . has <identifiersep> next ( ) ) { \n \t3 <identifier> <identifiersep> test <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . next ( ) ; \n \t3 logger . info ( <string_literal> + <identifier> + <string_literal> + <identifier> . get <identifiersep> format ( ) + <string_literal> ) ; \n \t3 if ( ! <identifier> . get <identifiersep> format ( ) . is <identifiersep> <identifier> ( ) || format <identifiersep> configuration . get <identifiersep> <identifier> ( ) . contains ( <identifier> . get <identifiersep> format ( ) . get ( ) ) ) { \n <ect>
\t3 for ( int <identifier> = 0 ; <identifier> < length ; <identifier> ++ ) { \n \t4 data [ i ++ ] = message [ <identifier> + <number_literal> ] ; } \n \t3 <identifier> <identifiersep> state . set <identifiersep> update <identifiersep> <identifier> ( data ) ; } \n <ect>
\t2 return this ; } \n \t1 @ <identifier> \n \t1 public void execute ( file <identifiersep> system file <identifiersep> system , path file <identifiersep> path ) throws io <identifiersep> exception { \n \t2 path <identifier> <identifiersep> path = new path ( destination , file <identifiersep> path . get <identifiersep> name ( ) ) ; \n <ect>
\t3 storage <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> id <identifiersep> <identifier> ( <identifier> <identifiersep> name ) : \n \t3 storage <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> name ) ; \n \t2 return <identifier> <identifiersep> cache . get ( <identifier> <identifiersep> id ) ; \n \t1 } else { \n <ect>
\t3 stop <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( ) ; } } \n \t1 private void stop <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( ) throws exception { \n \t2 logger . debug ( <string_literal> ) ; \n \t2 if ( ! this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t7 log . info ( <string_literal> ) ; \n \t7 return ( true ) ; } } \n \t4 } else if ( i < <identifier> <identifiersep> <identifier> . length ) { \n \t5 <comment> \n <ect>
\t3 volume <identifiersep> api <identifiersep> result <identifier> = new volume <identifiersep> api <identifiersep> result ( vo ) ; \n \t3 context . <identifier> . <identifier> ( <identifier> ) ; \n \t3 return null ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 case <identifier> : \n \t3 log . debug ( <string_literal> , e ) ; \n \t3 break ; \n \t2 default : \n <ect>
\t5 <identifier> = <identifier> ( r ) ; \n \t5 <comment> \n \t5 log . info ( <string_literal> , <identifier> <identifiersep> size ( r , <identifier> ) ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t2 string <identifier> <identifiersep> id = request . get <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> id . name ( ) ) ; \n \t2 string <identifier> <identifiersep> file <identifiersep> name = request . get <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> file <identifiersep> name . name ( ) ) ; \n \t2 <identifier> <identifiersep> file <identifiersep> name = <identifier> <identifiersep> file <identifiersep> name . <identifier> ( <identifier> <identifiersep> file <identifiersep> name . last <identifiersep> index <identifiersep> of ( <string_literal> ) + 1 , <identifier> <identifiersep> file <identifiersep> name . length ( ) ) ; \n \t2 string <identifier> <identifiersep> url = request . get <identifiersep> <identifier> ( <identifier> . data <identifiersep> <identifier> <identifiersep> url . name ( ) ) ; \n <ect>
\t3 do { \n \t4 log <identifiersep> files = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> log ( ) ; \n \t4 total <identifiersep> log <identifiersep> files += log <identifiersep> files ; } \n \t3 while ( log <identifiersep> files > 0 ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> id = id . get <identifiersep> <identifier> <identifiersep> id ( ) ; } \n \t1 public byte [ ] get <identifiersep> data ( ) { \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> cache && <identifier> <identifiersep> data <identifiersep> <identifier> == null ) { \n \t3 runtime <identifiersep> exception e = new runtime <identifiersep> exception ( <string_literal> ) ; \n <ect>
\t2 <identifier> . add <identifiersep> all ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception ex ) { \n \t1 return ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 try { <identifier> <identifiersep> context . <identifier> <identifiersep> service ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . job <identifiersep> queue ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> content <identifiersep> store . delete ( current <identifiersep> status . get <identifiersep> <identifier> <identifiersep> id ( ) , current <identifiersep> status . get <identifiersep> message <identifiersep> id ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> store <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
\t1 public boolean <identifier> <identifiersep> with ( path path ) { \n \t2 logger . info ( <string_literal> ) ; return false ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> <identifiersep> with ( string string ) { \n <ect>
\t2 cluster <identifiersep> state = cluster <identifiersep> state . builder ( cluster <identifiersep> state ) . build ( ) ; \n \t2 cluster <identifiersep> state new <identifiersep> state = <identifier> . <identifier> ( cluster <identifiersep> state , <string_literal> ) ; \n \t2 assert <identifiersep> that ( new <identifiersep> state , equal <identifiersep> to ( cluster <identifiersep> state ) ) ; \n \t2 cluster <identifiersep> state = new <identifiersep> state ; \n <ect>
\t6 long template <identifiersep> pool <identifiersep> <identifier> <identifiersep> id = template <identifiersep> pool <identifiersep> <identifier> . get <identifiersep> id ( ) ; \n \t6 template <identifiersep> pool <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> pool <identifiersep> dao . <identifier> <identifiersep> in <identifiersep> lock <identifiersep> table ( template <identifiersep> pool <identifiersep> <identifier> <identifiersep> id , <number_literal> ) ; \n \t6 try { \n \t7 if ( template <identifiersep> pool <identifiersep> <identifier> == null ) { \n <ect>
<comment> \n \t1 protected synchronized void add <identifiersep> <identifier> ( <identifier> <identifiersep> result result ) throws exception { \n \t2 string <identifier> = to <identifiersep> <identifier> ( result ) ; \n \t2 if ( <identifier> <identifiersep> map . contains <identifiersep> key ( <identifier> ) ) { \n <ect>
\t3 logger . trace ( <string_literal> , <identifier> <identifiersep> code ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> value = integer . parse <identifiersep> int ( <identifier> <identifiersep> code ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t4 return - 1 ; } \n \t3 if ( <identifier> + <identifier> > <identifier> . length ) { \n \t4 throw new index <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t2 msg . set <identifiersep> on <identifiersep> failed <identifiersep> send <identifiersep> job ( <identifier> <identifiersep> on <identifiersep> send <identifiersep> failed ) ; \n \t2 msg . set <identifiersep> on <identifiersep> <identifier> <identifiersep> job ( <identifier> <identifiersep> on <identifiersep> <identifier> ) ; \n \t2 msg . set <identifiersep> on <identifiersep> send <identifiersep> job ( <identifier> <identifiersep> on <identifiersep> send ) ; \n \t2 msg . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t5 if ( <identifier> <identifiersep> mode == <identifier> || <identifier> <identifiersep> mode == <identifier> ) { \n \t6 byte <identifiersep> array <identifiersep> input <identifiersep> stream <identifier> = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( data , <identifier> , <identifier> ) ; \n \t6 string line = data <identifiersep> <identifier> . read <identifiersep> line ( <identifier> ) ; \n \t6 if ( line == null ) { \n <ect>
\t4 check <identifiersep> <identifier> <identifiersep> metadata ( <identifier> <identifiersep> cluster , server <identifiersep> list ) ; \n \t3 } finally { \n \t4 stop <identifiersep> server ( server <identifiersep> list ) ; } \n \t2 } catch ( <identifier> <identifiersep> error <identifier> ) { \n <ect>
\t6 for ( <identifier> <identifier> <identifiersep> id : group . get <identifiersep> <identifier> ( ) ) { \n \t7 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t7 if ( <identifier> != null && ! <identifier> . is <identifiersep> <identifier> ( ) \n \t9 && ! <identifier> . get <identifiersep> <identifier> ( <identifier> ) . <identifier> ( <identifier> . get <identifiersep> <identifier> ( <identifier> ) ) ) { \n <ect>
\t3 <identifier> . update ( <identifier> ) ; } \n \t2 <comment> \n \t2 <comment> \n \t2 if ( ip <identifiersep> count == 0 ) { \n <ect>
\t3 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 log . info ( <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n \t2 } finally { \n <ect>
\t1 public string object <identifiersep> to <identifiersep> string ( final object in <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t1 { \n \t2 if ( in <identifiersep> <identifier> <identifiersep> <identifier> == null || ! ( in <identifiersep> <identifier> <identifiersep> <identifier> instanceof <identifier> ) ) \n \t2 { \n <ect>
\t2 } else if ( <identifier> <identifiersep> dir . exists ( ) && ! <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file . exists ( ) ) { \n \t3 <comment> \n \t3 new file ( <identifier> <identifiersep> dir , <string_literal> ) . create <identifiersep> new <identifiersep> file ( ) ; } \n \t2 if ( ! <identifier> <identifiersep> dir . is <identifiersep> directory ( ) ) { \n <ect>
\t2 if ( <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> output <identifiersep> <identifier> ( this ) ) { \n \t3 <comment> \n \t3 if ( <identifier> . remove ( <identifier> . get <identifiersep> <identifier> ( ) ) != null ) { \n <ect>
\t2 <identifier> . <identifier> ( message <identifiersep> service . get <identifiersep> <identifier> ( db ) . <identifier> ( ) ) ; } \n \t1 <comment> \n \t1 system . out . <identifier> ( <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 byte msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> ; \n \t3 org . apache . thrift . t <identifiersep> <identifier> msg ; \n \t3 table <identifiersep> exists <identifiersep> result result = new table <identifiersep> exists <identifiersep> result ( ) ; \n \t3 if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t3 { \n \t4 if ( failure <identifiersep> <identifier> . is <identifiersep> <identifier> ( <identifier> ) ) \n \t5 <identifier> <identifiersep> nodes . add ( <identifier> ) ; \n \t4 else \n <ect>
\t3 return ; } \n \t2 <identifier> <identifiersep> <identifier> . try <identifiersep> <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> filter ( <identifier> <identifiersep> file ) ; } \n \t1 static void try <identifiersep> set <identifiersep> max <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) { \n \t2 if ( ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 for ( t = 0 ; t < n <identifiersep> t ; t ++ ) \n \t4 <identifier> [ t ] [ m ] += <identifier> * <identifier> [ t ] ; \n \t3 <comment> \n \t3 <identifier> = <identifier> ; } \n <ect>
\t3 response = <identifier> <identifiersep> provider \n \t5 . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . <identifier> , request ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t3 log . warn ( <string_literal> , job <identifiersep> <identifier> ) ; \n \t3 return new <identifier> <identifiersep> <identifier> ( job <identifiersep> <identifier> , <string_literal> , null , null ) ; } \n \t2 <comment> \n \t2 if ( ! <identifier> <identifiersep> <identifier> ( job ) ) { \n <ect>
\t2 assert <identifiersep> <identifier> ( client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> put <identifiersep> <identifier> ( <string_literal> ) \n \t4 . set <identifiersep> type ( <string_literal> ) \n \t4 . set <identifiersep> <identifier> ( false ) \n \t4 . set <identifiersep> <identifier> ( <identifier> . builder ( ) . put ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> path ( ) ) ) ) ; \n <ect>
\t1 } else { \n \t2 last <identifiersep> <identifier> <identifiersep> id = <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> root , <identifier> , <identifier> <identifiersep> root ) ; } \n \t1 <identifier> <identifiersep> return <identifiersep> values ( <identifier> . as <identifiersep> list ( <identifier> <identifiersep> root . to <identifiersep> uri ( ) . to <identifiersep> string ( ) , string . value <identifiersep> of ( last <identifiersep> <identifier> <identifiersep> id ) ) , <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t5 } catch ( exception e ) { \n \t6 log . error ( <string_literal> + name , \n \t8 e ) ; } } } \n \t2 } catch ( runtime <identifiersep> exception ex ) { \n <ect>
\t3 for ( test <identifiersep> <identifier> <identifier> : test <identifiersep> context . get <identifiersep> <identifier> ( ) . values ( ) ) { \n \t4 try { \n \t5 if ( <identifier> != null ) <identifier> . execute <identifiersep> <identifier> ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> , e ) ; } \n \t2 <comment> \n <ect>
\t5 <identifier> <identifiersep> snapshot . get <identifiersep> <identifier> <identifiersep> end ( ) \n \t4 ) ; \n \t4 listener <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> <identifiersep> event ( <identifier> <identifiersep> event ) ; \n \t3 } catch ( final exception e ) { \n <ect>
<comment> \n \t1 private static input <identifiersep> stream to <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> result <identifier> <identifiersep> result ) throws file <identifiersep> not <identifiersep> found <identifiersep> exception { \n \t2 if ( <identifier> <identifiersep> result == null ) { \n <ect>
\t1 <identifier> ( conf ) ; \n \t1 <comment> \n \t1 <identifier> ( null ) ; } \n public <identifier> <identifiersep> base <identifiersep> data <identifiersep> model ( <identifier> <identifiersep> table <identifiersep> pool pool , string table <identifiersep> name , configuration conf ) throws io <identifiersep> exception { \n <ect>
\t10 thread . <identifier> ( <identifier> ) ; <comment> \n \t10 <comment> \n \t10 <comment> \n \t10 <comment> \n <ect>
\t8 if ( message == null ) break ; \n \t8 log . info ( <identifier> + <string_literal> + message . get <identifiersep> text ( ) + <string_literal> + message . get <identifiersep> destination ( ) + <string_literal> + message . get <identifiersep> message <identifiersep> id ( ) + <string_literal> + <identifier> . to <identifiersep> string ( message . get <identifiersep> <identifier> <identifiersep> path ( ) ) ) ; } } \n \t5 } else { \n \t6 total <identifiersep> count = count ; } \n <ect>
\t3 message message = request <identifiersep> consumer . <identifier> ( <number_literal> ) ; \n \t3 if ( message != null ) { \n \t4 on <identifiersep> message ( message ) ; \n \t3 } else { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> as <identifiersep> local <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 file <identifiersep> channel <identifier> = stream . get <identifiersep> channel ( ) ; \n \t3 <identifier> <identifiersep> byte <identifiersep> <identifier> <identifier> = <identifier> . map ( file <identifiersep> channel . map <identifiersep> mode . read <identifiersep> <identifier> , 0 , <identifier> . size ( ) ) ; \n \t3 <identifier> = <identifier> . default <identifiersep> <identifier> ( ) . <identifier> ( <identifier> ) . to <identifiersep> string ( ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t2 } catch ( final exception e ) { \n \t3 logger . warn ( <string_literal> , target <identifiersep> class , e ) ; \n \t3 throwable <identifier> = e . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> != null ) { \n <ect>
\t3 current <identifiersep> <identifier> = 0 ; \n \t3 <identifier> <identifiersep> byte = 0 ; } \n \t2 void <identifier> <identifiersep> start ( int <identifier> ) { \n \t3 if ( is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 <comment> \n \t1 try { \n \t2 <identifier> <identifiersep> date = <identifier> . parse ( <identifier> <identifiersep> values [ i ] ) ; \n \t1 } catch ( parse <identifiersep> exception ex ) { \n <ect>
\t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> config ) throws configuration <identifiersep> exception { \n \t2 if ( config == null ) { \n <ect>
\t1 { \n \t2 string resource <identifiersep> string = get <identifiersep> <identifier> <identifiersep> string ( key ) ; \n \t2 if ( resource <identifiersep> string == null ) \n \t2 { \n <ect>
\t2 <comment> \n \t2 assert ! <identifier> <identifiersep> manager . get <identifiersep> <identifier> ( <identifier> . <identifier> ) . is <identifiersep> shutdown ( ) ; \n \t2 <comment> \n \t2 if ( ! <identifier> . shutdown <identifiersep> <identifier> ( ) ) \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> index ( <identifier> . get <identifiersep> name ( ) , metadata . name , <identifier> <identifiersep> name ) ; } \n \t1 public static void <identifier> <identifiersep> <identifier> <identifiersep> index ( string <identifier> <identifiersep> name , string <identifier> <identifiersep> name , string . . . <identifier> <identifiersep> <identifier> ) \n \t1 { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> store <identifier> = <identifier> . <identifier> ( <identifier> <identifiersep> name ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> store ( <identifier> <identifiersep> name ) ; \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 logger . error ( string . format ( <string_literal> , node <identifiersep> id , \n \t5 <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <number_literal> ) ) ) ; \n \t3 return false ; } \n <ect>
\t6 public void add <identifiersep> to ( <identifier> <identifiersep> client client ) { \n \t7 client . add <identifiersep> listener ( new <identifier> <identifiersep> <identifier> <identifiersep> listener ( ) { \n \t8 @ <identifier> \n \t8 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> ) { \n <ect>
\t2 } catch ( final exception e ) { \n \t2 <identifier> . <identifier> ( - <number_literal> , new <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public void run ( ) { \n <ect>
\t2 if ( <identifier> instanceof <identifier> <identifiersep> service ) { \n \t3 assert <identifiersep> equals ( <string_literal> , ( ( <identifier> <identifiersep> service ) <identifier> ) . get <identifiersep> status ( ) . name ( ) ) ; } \n \t2 template . send <identifiersep> body ( <string_literal> , <string_literal> ) ; \n \t2 <identifier> . assert <identifiersep> is <identifiersep> <identifier> ( <number_literal> ) ; \n <ect>
\t7 break ; } } \n \t5 log . info ( <string_literal> + <identifier> . get <identifiersep> queue <identifiersep> name ( ) + <string_literal> + index + <string_literal> + <identifier> <identifiersep> size + <string_literal> ) ; \n \t5 connection . close ( ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 request . write <identifiersep> to ( out ) ; \n \t3 server . send ( <identifier> , out . <identifier> ( ) , 0 , out . <identifier> ( ) ) ; } \n \t2 catch ( exception ex ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( <identifier> <identifiersep> file , true ) ; \n \t3 try { \n \t4 <identifier> = context <identifiersep> provider . <identifier> <identifiersep> context ( <identifier> <identifiersep> file ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t3 return <identifier> ; } \n \t2 if ( property <identifiersep> uri == null || property <identifiersep> uri . is <identifiersep> empty ( ) ) { \n \t3 logger . error ( <string_literal> ) ; \n \t3 return <identifier> ; } \n <ect>
\t2 return <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> timeout ( ) ; } \n \t1 public void set <identifiersep> write <identifiersep> <identifier> <identifiersep> timeout ( long value ) \n \t1 { \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> write <identifiersep> <identifier> <identifiersep> timeout ( value ) ; \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t5 try { \n \t6 <identifier> . send ( message ) ; \n \t6 log . info ( <string_literal> + destination <identifiersep> name + <string_literal> + message . get <identifiersep> <identifier> <identifiersep> message <identifiersep> id ( ) + <string_literal> ) ; \n \t6 <identifier> . count <identifiersep> <identifier> ( ) ; \n <ect>
\t2 if ( listener != null ) { \n \t3 listener . on <identifiersep> service <identifiersep> add ( new <identifier> <identifiersep> event ( name ) ) ; } \n \t2 <identifier> <identifiersep> <identifier> . request <identifiersep> service <identifiersep> info ( type , name ) ; } \n \t1 public void remove <identifiersep> service ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , string type , string name ) { \n <ect>
\t1 cache ( 0 , <string_literal> ) . put ( <identifier> , <string_literal> ) ; \n \t1 cache ( 0 ) . put ( <identifier> , <string_literal> ) ; \n \t1 try { \n \t2 <identifier> ( 0 ) . <identifier> ( ) ; \n <ect>
\t4 char [ ] name = new char [ <number_literal> ] ; \n \t4 in . read ( name ) ; \n \t4 in . close ( ) ; \n \t4 string <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> name = new string ( name ) . <identifier> ( ) ; \n <ect>
\t4 <identifier> <identifiersep> key = <identifier> <identifiersep> key . <identifier> ( ' / ' , ' <identifiersep> ' ) ; } \n \t2 } else { \n \t3 <identifier> <identifiersep> key = <identifier> . get <identifiersep> attribute ( ) ; } \n <ect>
\t2 final security <identifiersep> <identifier> <identifiersep> context <identifier> <identifiersep> <identifier> = context . get <identifiersep> <identifier> ( security <identifiersep> <identifier> <identifiersep> context . class , true ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null && ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 if ( ! <identifier> ) { \n \t4 <identifier> <identifiersep> value = <identifier> ; \n \t4 <identifier> = true ; \n \t4 if ( log <identifiersep> debug ) \n <ect>
\t2 return return <identifiersep> meta <identifiersep> data ; } \n \t1 public long get <identifiersep> <identifier> ( string <identifier> , int <identifier> , long start <identifiersep> <identifier> <identifiersep> time ) { \n \t2 <identifier> <identifiersep> consumer <identifier> <identifiersep> consumer = find <identifiersep> <identifier> <identifiersep> consumer ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> consumer == null ) { \n <ect>
<comment> \n \t2 public void <identifier> ( ) throws throwable { \n <ect>
private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( client <identifiersep> <identifier> <identifiersep> manager . class ) ; \n protected static final error <identifiersep> <identifier> < ? > default <identifiersep> error <identifiersep> <identifier> = new <identifier> <identifiersep> error <identifiersep> <identifier> ( ) { \n \t1 @ <identifier> \n \t1 public boolean error ( message message , throwable throwable ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> exists <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t1 if ( ! is <identifiersep> <identifier> ) { \n \t1 throw new meta <identifiersep> exception ( <string_literal> + \n \t2 <string_literal> + string <identifiersep> utils . <identifier> <identifiersep> exception ( <identifier> ) ) ; } \n \t1 snapshot <identifiersep> <identifier> <identifiersep> conf ( ) ; \n <ect>
\t2 <comment> \n \t2 return <identifier> . to <identifiersep> string ( ) ; } \n \t1 public static string <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> string ( <identifier> < node , <identifier> <identifiersep> <identifier> > <identifier> ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 response response = client . target ( <identifier> <identifiersep> url ( <string_literal> , url <identifiersep> <identifier> + <identifier> ) ) . request ( ) \n \t5 . <identifier> ( entity . entity ( <identifier> <identifiersep> collection , <string_literal> ) ) ; \n \t3 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> request , response . get <identifiersep> status ( ) ) ; \n \t3 string entity = response . read <identifiersep> entity ( string . class ) ; \n <ect>
\t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + <identifier> . get <identifiersep> service <identifiersep> id ( ) \n \t4 + <string_literal> + <identifier> . get <identifiersep> client <identifiersep> id ( ) \n \t4 + <string_literal> ) ; } \n \t2 final <identifier> <identifiersep> json <identifiersep> web <identifiersep> key json <identifiersep> web <identifiersep> key = <identifier> . get ( ) ; \n <ect>
\t5 if ( task . get <identifiersep> state ( ) == job <identifiersep> task <identifiersep> state . <identifier> <identifiersep> no <identifiersep> <identifier> ) { \n \t6 job . set <identifiersep> task <identifiersep> state ( task , job <identifiersep> task <identifiersep> state . <identifier> ) ; \n \t6 queue <identifiersep> job <identifiersep> task <identifiersep> update <identifiersep> event ( job ) ; } } \n \t3 } catch ( exception ex ) { \n <ect>
\t1 return is <identifiersep> <identifier> ( command ) && io <identifiersep> <identifier> <identifiersep> handler . should <identifiersep> <identifier> <identifiersep> request ( command , response ) ; } \n private boolean is <identifiersep> <identifier> ( http <identifiersep> command command ) { \n \t1 string method = command . get <identifiersep> current <identifiersep> request ( ) . get <identifiersep> method ( ) ; \n \t1 if ( ! <identifier> <identifiersep> <identifier> . contains ( method ) ) { \n <ect>
\t3 <identifier> <identifiersep> client <identifiersep> factory <identifiersep> bean ( factory <identifiersep> bean , null ) ; \n \t3 return factory <identifiersep> bean . create ( ) ; } } \n \t1 void check <identifiersep> name ( object value , string name ) { \n \t2 if ( object <identifiersep> <identifier> . is <identifiersep> empty ( value ) ) { \n <ect>
\t1 run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> ) ; \n \t1 run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> ) ; \n \t1 run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> ) ; \n \t1 list < string > <identifier> = run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> ) ; \n <ect>
\t4 session new <identifiersep> session = ( entity <identifiersep> <identifier> != null ? \n \t6 <identifier> <identifiersep> session <identifiersep> factory ( ) . with <identifiersep> options ( ) . <identifier> ( entity <identifiersep> <identifier> ) . <identifier> <identifiersep> session ( ) : \n \t6 <identifier> <identifiersep> session <identifiersep> factory ( ) . <identifier> <identifiersep> session ( ) ) ; \n <ect>
\t3 <identifier> . <identifier> ( new <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> handler <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> != null ) \n \t4 try { \n \t5 <identifier> . close ( ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t4 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t5 name = <identifier> . get ( 0 ) . get <identifiersep> property ( abstract <identifiersep> node . name ) ; } } \n \t3 <identifier> . success ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 <comment> \n \t3 if ( time <identifiersep> set != null ) { \n \t4 <identifier> . set <identifiersep> time <identifiersep> in <identifiersep> millis ( time <identifiersep> set ) ; \n \t4 if ( ( time <identifiersep> read - time <identifiersep> set ) < = <number_literal> ) { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> <identifiersep> data ( <identifier> ) ; \n \t2 try { \n \t3 <identifier> . set <identifiersep> url ( new url ( <identifier> ) ) ; \n \t2 } catch ( <identifier> <identifiersep> url <identifiersep> exception <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> factory . <identifier> <identifiersep> <identifier> ( <identifier> [ 0 ] , new <identifier> <identifiersep> <identifier> ( resource ) ) ; \n \t4 if ( <identifier> . length > <number_literal> && <identifier> [ <number_literal> ] != null ) { \n \t5 url <identifier> = <identifier> . get <identifiersep> resource ( <identifier> [ <number_literal> ] . <identifier> ( ) ) ; \n \t5 if ( <identifier> == null ) { \n <ect>
\t2 if ( <identifier> . size ( ) > this . <identifier> <identifiersep> list . size ( ) ) throw new <identifier> <identifiersep> build <identifiersep> exception ( <string_literal> + this . <identifier> <identifiersep> list . size ( ) + <string_literal> + <identifier> . size ( ) ) ; \n \t2 <comment> \n \t2 if ( <identifier> . size ( ) < this . <identifier> <identifiersep> list . size ( ) ) { \n \t3 for ( <identifier> v : this . <identifier> <identifiersep> list ) { \n <ect>
\t2 } catch ( final <identifier> <identifiersep> metadata <identifiersep> exception e ) { \n \t2 if ( ! handle <identifiersep> exception ( e ) ) { \n \t3 logger . error ( <string_literal> + <identifier> <identifiersep> execution . get <identifiersep> <identifier> <identifiersep> name ( ) , e ) ; } } } \n \t1 } catch ( final <identifier> <identifiersep> metadata <identifiersep> exception e ) { \n <ect>
<comment> \n public <identifier> <identifiersep> connection <identifiersep> template create ( <identifier> <identifiersep> <identifier> <identifiersep> configuration <identifier> <identifiersep> <identifier> <identifiersep> configuration ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> config config ) { \n \t2 this . config = config ; \n \t2 create <identifiersep> <identifier> ( ) ; \n <ect>
\t6 element <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( server , input ) ; \n \t6 map < string , string > success = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( <identifier> , new string [ ] { <string_literal> } ) ; \n \t6 s <identifiersep> logger . info ( <string_literal> + success . get ( <string_literal> ) ) ; \n \t5 } else { \n <ect>
\t2 if ( <identifier> <identifiersep> token == null ) { \n \t3 logger . warn ( <string_literal> , token ) ; \n \t3 return false ; } \n \t2 if ( ! <identifier> <identifiersep> token . class . is <identifiersep> <identifier> <identifiersep> from ( <identifier> <identifiersep> token . get <identifiersep> class ( ) ) ) { \n <ect>
\t1 <identifier> <identifiersep> handler . log . info ( <string_literal> \n \t2 + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifiersep> handler . log . info ( <string_literal> \n \t2 + max <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 if ( <identifier> . get <identifiersep> send <identifiersep> stream <identifiersep> id ( ) > 0 ) { \n \t4 if ( <identifier> . get <identifiersep> options ( ) . get <identifiersep> answer <identifiersep> <identifier> ( ) ) \n \t5 <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t4 else if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t5 return true ; } \n \t3 } ; \n \t3 <identifier> <identifiersep> url <identifiersep> connection . set <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 exists <identifiersep> response = <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t4 . add <identifiersep> <identifier> ( <string_literal> ) . get ( ) ; \n \t2 assert <identifiersep> that ( exists <identifiersep> response . exists ( ) , equal <identifiersep> to ( true ) ) ; \n \t2 <comment> \n <ect>
\t1 if ( <identifier> . size ( ) > 0 ) { \n \t2 return ( string ) <identifier> . get <identifiersep> <identifier> ( <identifier> . size ( ) - 1 ) . get <identifiersep> value ( ) ; } \n \t1 } catch ( <identifier> <identifiersep> name <identifiersep> exception e ) { \n \t1 log . error ( e , e ) ; \n <ect>
\t2 cmd . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> address ( ) ) ; \n \t2 cmd . set <identifiersep> template <identifiersep> <identifier> ( template . get <identifiersep> <identifier> ( ) ) ; \n \t2 answer <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send ( <identifier> <identifiersep> vo . get <identifiersep> host <identifiersep> id ( ) , cmd ) ; \n \t2 if ( ! <identifier> . get <identifiersep> result ( ) ) { \n <ect>
\t4 logger . debug ( <string_literal> ) ; } \n \t3 return not <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t2 else { \n <ect>
\t5 count ++ ; \n \t5 log . info ( <string_literal> ) ; \n \t5 consumer <identifiersep> continue . <identifier> ( ) ; \n \t5 if ( <identifier> <identifiersep> all ) { \n <ect>
\t1 } finally { \n \t2 if ( <identifier> != null ) { \n \t2 <identifier> . close ( ) ; } } } \n \t1 <comment> \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t3 return ; \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 logger . info ( <string_literal> ) ; \n \t5 return ; } \n \t3 } catch ( exception e ) { \n \t4 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n <ect>
\t6 <identifier> <identifiersep> cluster <identifiersep> <identifier> <identifiersep> dao . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t6 <identifier> . <identifier> ( ) ; \n \t5 } catch ( exception e ) { \n \t6 <identifier> . <identifier> ( ) ; \n <ect>
\t2 log . debug ( <string_literal> , <string_literal> ) ; \n \t2 return null ; } \n \t1 @ <identifier> \n \t1 public url get <identifiersep> resource ( string name ) { \n <ect>
\t4 } else { \n \t5 if ( <identifier> <identifiersep> in <identifiersep> <identifier> . has <identifiersep> task ( id ) ) { \n \t6 logger . warn ( <string_literal> , id , <identifier> <identifiersep> id ) ; \n \t5 } else { \n <ect>
\t3 + default <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifiersep> timeout = default <identifiersep> <identifier> ; } \n \t1 <identifier> <identifiersep> timeout = context . get <identifiersep> integer ( config . <identifier> <identifiersep> timeout , default <identifiersep> <identifier> ) ; \n \t1 if ( <identifier> <identifiersep> timeout < 0 ) { \n <ect>
\t7 object value ) \n \t1 { \n \t2 if ( <identifier> ) return ; \n \t2 <comment> \n <ect>
\t4 boolean <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t4 if ( ! <identifier> ) { <comment> \n \t5 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t6 <comment> \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> ) ; } \n \t2 check <identifiersep> network <identifiersep> command <identifier> <identifiersep> cmd = new check <identifiersep> network <identifiersep> command ( network <identifiersep> info <identifiersep> list ) ; \n \t2 check <identifiersep> network <identifiersep> answer answer = ( check <identifiersep> network <identifiersep> answer ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> send ( host <identifiersep> id , <identifier> <identifiersep> cmd ) ; \n \t2 if ( answer == null ) { \n <ect>
\t4 if ( vm == null ) { \n \t5 s <identifiersep> logger . info ( <string_literal> + <identifier> . get <identifiersep> instance <identifiersep> id ( ) + <string_literal> ) ; \n \t5 <identifier> = true ; \n \t5 return ; } \n <ect>
\t1 @ <identifier> ( <string_literal> ) \n \t1 @ <identifier> ( application <identifiersep> xml <identifiersep> <identifier> ) \n \t1 public char <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> root <identifiersep> element xml <identifiersep> <identifier> ( char <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> root <identifiersep> element <identifier> ) { \n \t2 log . info ( <string_literal> + <identifier> . default <identifiersep> <identifier> ( ) ) ; \n <ect>
\t6 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n \t7 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> target <identifiersep> exception ( ) . to <identifiersep> string ( ) , e ) ; \n \t7 system . <identifier> ( <identifier> <identifiersep> status . error . value ( ) ) ; } \n \t5 } catch ( final class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> get <identifiersep> resource <identifiersep> <identifier> <identifiersep> response <identifier> = new <identifier> <identifiersep> get <identifiersep> resource <identifiersep> <identifier> <identifiersep> response ( ) ; \n \t2 <identifier> . set <identifiersep> resource <identifiersep> <identifier> ( <identifier> ) ; \n \t2 return <identifier> ; \n \t1 } catch ( meta <identifiersep> exception e ) { \n <ect>
\t6 <identifier> <identifiersep> port <identifiersep> config <identifiersep> <identifier> . add ( <identifier> <identifiersep> port <identifiersep> config <identifiersep> <identifier> ) ; \n \t6 <identifier> <identifiersep> object <identifiersep> <identifier> task = vm <identifiersep> <identifier> . get <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> client ( ) . get <identifiersep> service ( ) . <identifier> <identifiersep> <identifier> <identifiersep> port <identifiersep> task ( <identifier> <identifiersep> switch , <identifier> <identifiersep> port <identifiersep> config <identifiersep> <identifier> ) ; \n \t6 if ( ! vm <identifiersep> <identifier> . get <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> client ( ) . wait <identifiersep> for <identifiersep> task ( task ) ) { \n \t7 throw new exception ( <string_literal> + <identifier> <identifiersep> to . to <identifiersep> string ( ) ) ; } \n <ect>
\t5 logger . debug ( <string_literal> + <identifier> + <string_literal> ) ; } \n \t4 logger . debug ( ( system . current <identifiersep> time <identifiersep> millis ( ) - time ) + <string_literal> ) ; } \n \t3 return result ; \n \t2 } catch ( throwable e ) { \n <ect>
\t4 if ( listener != null ) { \n \t5 try { \n \t6 listener . run ( ) ; \n \t5 } catch ( exception <identifier> ) { \n <ect>
\t3 this . <identifier> <identifiersep> manager . <identifier> <identifiersep> level <identifiersep> <identifier> ( this ) ; } } \n \t1 private void <identifier> ( x <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> id <identifier> <identifiersep> id ) \n \t1 { \n \t2 if ( get <identifiersep> request ( ) . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 <identifier> . add ( item ) ; } \n \t2 } catch ( sql <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> , e ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t2 logger . info ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) , system . get <identifiersep> property ( <string_literal> ) , system . get <identifiersep> property ( <string_literal> ) ) ; \n \t2 logger . info ( <string_literal> , runtime . get <identifiersep> runtime ( ) . max <identifiersep> <identifier> ( ) / <identifier> <identifiersep> <identifier> ) ; \n \t2 logger . info ( <string_literal> , runtime . get <identifiersep> runtime ( ) . <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 if ( <identifier> <identifiersep> native <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> is <identifiersep> <identifier> ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t2 try { \n \t3 key <identifiersep> <identifier> = <identifier> . get <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> ( ) . create <identifiersep> key <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( <identifier> , key <identifiersep> name ) ; \n \t2 } catch ( illegal <identifiersep> state <identifiersep> exception e ) { \n \t3 logger . trace ( <string_literal> , key <identifiersep> name , <identifier> ) ; } } \n <ect>
\t1 <identifier> . <identifier> <identifiersep> <identifier> ( options ) ; \n \t1 } catch ( final <identifier> <identifiersep> execution <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t1 ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t4 input <identifiersep> stream is = method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) ; \n \t4 map < string , string > success = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( is , new string [ ] { <string_literal> } ) ; \n \t4 s <identifiersep> logger . info ( <string_literal> + success . get ( <string_literal> ) ) ; \n \t3 } else { \n <ect>
\t1 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> path . get <identifiersep> file <identifiersep> system ( conf ) ; \n \t1 <identifier> . <identifier> ( root <identifiersep> dir <identifiersep> path ) ; \n \t1 <identifier> . set <identifiersep> <identifier> ( root <identifiersep> dir <identifiersep> path , root <identifiersep> dir <identifiersep> <identifier> ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 for ( entry < string , <identifier> <identifiersep> <identifier> > entry : <identifier> <identifiersep> <identifier> . entry <identifiersep> set ( ) ) { \n \t4 <identifier> <identifiersep> <identifier> <identifier> = entry . get <identifiersep> value ( ) ; \n \t4 <comment> \n \t4 if ( ! get <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . contains ( <identifier> ) ) { \n <ect>
\t1 if ( file <identifiersep> count > 0 ) { \n \t2 log . debug ( <string_literal> , directory <identifiersep> name , service , stack , directory ) ; \n \t2 return directory ; } \n \t1 else { \n <ect>
\t4 if ( <identifier> <identifiersep> path . contains ( dir ) ) { \n \t5 is <identifiersep> <identifier> = true ; \n \t5 break ; } } \n \t3 if ( ! is <identifiersep> <identifier> ) { \n <ect>
\t4 task <identifiersep> name = task . get <identifiersep> class ( ) . get <identifiersep> name ( ) ; \n \t4 <identifier> <identifiersep> ex = e ; } } \n \t2 assert task <identifiersep> name != null ; \n <ect>
\t3 if ( value != null ) { \n \t4 try { \n \t5 mode = <identifier> <identifiersep> <identifier> <identifiersep> mode . value <identifiersep> of ( value . to <identifiersep> <identifier> <identifiersep> case ( ) ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n \t3 try { \n \t4 thread . <identifier> ( <number_literal> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 if ( ! x . is <identifiersep> <identifier> ( ) ) { \n \t3 log . warn ( <string_literal> + list ) ; \n \t3 return null ; } \n \t2 if ( ! <identifier> <identifiersep> value <identifiersep> <identifier> . is <identifiersep> <identifier> ( x ) ) { \n <ect>
\t5 if ( <identifier> <identifiersep> handler . class . is <identifiersep> <identifier> <identifiersep> from ( <identifier> ) ) { \n \t6 <identifier> <identifiersep> handler handler = new <identifiersep> class <identifiersep> instance ( <identifier> <identifiersep> handler . class , ( class < <identifier> <identifiersep> handler > ) <identifier> ) ; \n \t6 add <identifiersep> <identifier> ( <string_literal> + handler . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , \n \t8 new <identifier> <identifiersep> handler <identifiersep> <identifier> ( <identifier> <identifiersep> factory , handler , <string_literal> + handler . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , config ) ) ; \n <ect>
<comment> \n \t1 protected boolean <identifier> <identifiersep> <identifier> <identifiersep> http <identifiersep> request ( final authentication authentication , final http <identifiersep> <identifier> <identifiersep> request request ) { \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> properties . get <identifiersep> http <identifiersep> request <identifiersep> remote <identifiersep> address ( ) ) ) { \n \t3 if ( http <identifiersep> request <identifiersep> remote <identifiersep> address <identifiersep> <identifier> . <identifier> ( request . get <identifiersep> remote <identifiersep> <identifier> ( ) ) . find ( ) ) { \n <ect>
\t2 int type <identifiersep> code = - <number_literal> ; \n \t2 try { \n \t3 type <identifiersep> code = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type <identifiersep> value ( ) ; } \n \t2 catch ( exception e ) { \n <ect>
\t4 break ; } \n \t3 <identifier> <identifiersep> action <identifiersep> bean action <identifiersep> bean = new <identifier> <identifiersep> action <identifiersep> bean ( ) ; \n \t3 last <identifiersep> action <identifiersep> number ++ ; \n \t3 int timeout = job <identifiersep> bean . get <identifiersep> timeout ( ) ; \n <ect>
\t3 else \n \t4 continue ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( n ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) continue ; \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 throw new <identifier> <identifiersep> operation <identifiersep> exception ( <string_literal> ) ; <comment> \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> service new <identifiersep> <identifier> <identifiersep> service ( ) throws io <identifiersep> exception { \n <ect>
\t3 <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> factory . get <identifiersep> default <identifiersep> <identifier> ( ) ; \n \t3 set < job <identifiersep> key > job <identifiersep> <identifier> = <identifier> . get <identifiersep> job <identifiersep> <identifier> ( job <identifiersep> group <identifiersep> equals ( <identifier> <identifiersep> group ) ) ; \n \t3 if ( job <identifiersep> <identifier> . size ( ) > 0 ) { \n \t4 <identifier> . delete <identifiersep> <identifier> ( new array <identifiersep> list < job <identifiersep> key > ( job <identifiersep> <identifier> ) ) ; \n <ect>
\t5 <identifier> = get <identifiersep> <identifier> <identifiersep> server <identifiersep> socket <identifiersep> factory ( host <identifiersep> address ) ; \n \t4 } else { \n \t5 <comment> \n \t5 <comment> \n <ect>
\t2 uri uri ; \n \t2 try { \n \t3 uri = new uri ( url <identifiersep> <identifier> ) ; \n \t2 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 if ( <identifier> . get <identifiersep> id ( ) == <identifier> ) { \n \t6 <identifier> . remove <identifiersep> <identifier> ( <identifier> ) ; \n \t6 break ; } } \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t2 return <identifier> <identifiersep> dir ; } } \n \t1 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> dir ) ; } \n private file create <identifiersep> dir ( file dir , string debug <identifiersep> <identifier> ) { \n \t1 if ( ! dir . is <identifiersep> directory ( ) || ! dir . exists ( ) ) { \n <ect>
\t2 } ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> build <identifiersep> lock <identifiersep> request ( ) { \n \t2 do <identifiersep> in <identifiersep> <identifier> ( this : : entity <identifiersep> manager <identifiersep> factory , entity <identifiersep> manager - > { \n <ect>
\t4 list < string > <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> = <identifier> . new <identifiersep> array <identifiersep> list ( network . service . <identifier> . get <identifiersep> name ( ) , network . service . <identifier> . get <identifiersep> name ( ) , network . service . user <identifiersep> data . get <identifiersep> name ( ) ) ; \n \t4 list < string > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . list <identifiersep> <identifier> <identifiersep> for <identifiersep> network <identifiersep> <identifier> ( <identifier> . get <identifiersep> id ( ) ) ; \n \t4 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> . contains <identifiersep> all ( <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t1 private void <identifier> <identifiersep> close <identifiersep> result <identifiersep> set ( ) { \n \t2 try { \n \t3 result <identifiersep> set . close ( ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> system <identifier> = <identifier> . <identifier> ( <string_literal> ) ; \n \t2 assert <identifiersep> equals ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
<identifier> <identifier> <identifiersep> and <identifiersep> <identifier> ( self ) : \n \t1 <identifier> <identifiersep> response = self . <identifier> <identifiersep> with <identifiersep> server ( ) \n \t1 if <string_literal> in <identifier> <identifiersep> response : \n \t1 message = <identifier> <identifiersep> response [ <string_literal> ] \n <ect>
\t4 throw ex ; } \n \t3 <comment> \n \t3 else if ( ! this . task <identifiersep> <identifier> ) { \n \t4 if ( log . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t1 <identifier> . write ( content ) ; \n \t1 <identifier> . close ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 log . warn ( <string_literal> , m <identifiersep> <identifier> , \n \t3 m <identifiersep> timeout <identifiersep> <identifier> . to <identifiersep> millis ( m <identifiersep> timeout ) , timeout <identifiersep> exception ) ; \n \t1 } catch ( exception exception ) { \n \t2 is <identifiersep> <identifier> <identifiersep> <identifier> = false ; \n <ect>
\t4 success = false ; \n \t3 } else { \n \t4 if ( ! state <identifiersep> <identifier> . get <identifiersep> value ( ) \n \t8 . equals ( metadata <identifiersep> store . <identifier> <identifiersep> state . <identifier> <identifiersep> server . to <identifiersep> string ( ) ) ) { \n <ect>
\t2 if ( this . <identifier> == null ) \n \t2 { \n \t3 if ( <identifier> != null ) \n \t3 { \n <ect>
\t1 <identifier> <identifiersep> context <identifier> <identifiersep> context = null ; \n \t1 <comment> \n \t1 boolean execution <identifiersep> error = false ; \n \t1 try { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( count ) ; \n \t2 stop <identifiersep> <identifier> <identifier> = new stop <identifiersep> <identifier> ( ) ; \n \t2 execute ( count ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> connection . <identifier> ( ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <identifier> . get <identifiersep> action ( ) ) ; \n \t2 assert <identifiersep> true ( <identifier> . get <identifiersep> body ( ) . contains ( <string_literal> ) ) ; \n <ect>
<comment> \n \t1 protected <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ; \n \t1 public string get <identifiersep> xml <identifiersep> string ( context context , <identifier> <identifiersep> <identifier> <identifiersep> object <identifier> ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 <comment> \n \t2 return null ; } \n \t1 } ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> request . set <identifiersep> event <identifiersep> <identifier> ( event <identifiersep> type <identifiersep> list <identifiersep> test <identifiersep> case . create <identifiersep> <identifier> <identifiersep> event <identifiersep> type <identifiersep> list ( ) ) ; \n \t3 <identifier> <identifiersep> request . create ( test <identifiersep> <identifier> . <identifier> <identifiersep> context , <identifier> <identifiersep> request ) ; } \n \t2 <identifier> <identifiersep> list <identifier> <identifiersep> list = new <identifier> <identifiersep> list ( ) ; \n \t2 <identifier> <identifiersep> list <identifier> <identifiersep> response = <identifier> <identifiersep> list . get <identifiersep> all ( test <identifiersep> <identifier> . <identifier> <identifiersep> context ) ; \n <ect>
\t2 try { \n \t3 final <identifier> <identifiersep> get <identifiersep> <identifier> <identifier> <identifiersep> client = new <identifier> <identifiersep> get <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> id ) ; \n \t3 final <identifier> <identifiersep> get <identifiersep> <identifier> <identifiersep> result [ ] <identifier> = <identifier> <identifiersep> client . execute ( ) . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> == null || <identifier> . length == 0 ) { \n <ect>
\t2 this . task <identifiersep> <identifier> <identifiersep> <identifier> = task <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public void shutdown ( ) { \n \t2 if ( is <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> set ( false , true ) ) { \n <ect>
\t1 <comment> \n \t1 if ( result != null ) { \n \t1 <identifier> . found <identifiersep> property ( <identifier> , <identifier> , name , result ) ; } \n \t1 } catch ( illegal <identifiersep> access <identifiersep> exception ex ) { \n <ect>
\t2 protected void <identifier> <identifiersep> property <identifiersep> <identifier> ( method method , string property <identifiersep> value , string property <identifiersep> default <identifiersep> value , object bean , string bean <identifiersep> name ) { \n \t3 class < ? > [ ] <identifier> <identifiersep> <identifier> = method . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 if ( <identifier> <identifiersep> <identifier> . length != 1 ) { \n <ect>
\t4 runtime <identifiersep> exception exception = new runtime <identifiersep> exception ( message ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> . <identifier> || ! <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> version . equals ( <string_literal> ) ) { \n \t5 throw exception ; \n \t4 } else { \n <ect>
\t3 <identifier> . <identifier> ( 1 ) \n \t1 else : \n \t2 <identifier> <identifiersep> file = <identifier> ( <string_literal> ) \n \t2 if not <identifier> <identifiersep> file : \n <ect>
\t3 current <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> file ( ) ; \n \t3 current <identifiersep> <identifier> . <identifier> ( ) ; } \n \t2 int index = <identifier> . size ( ) ; \n \t2 if ( max <identifiersep> total <identifiersep> size <identifiersep> bytes > 0 && index * max <identifiersep> <identifier> <identifiersep> size <identifiersep> bytes > max <identifiersep> total <identifiersep> size <identifiersep> bytes ) { \n <ect>
\t3 run ( ) ; } } \n \t1 public void <identifier> ( ) { \n \t2 if ( status == status . <identifier> ) { \n \t3 return ; } \n <ect>
\t2 <comment> \n \t2 final transaction <identifiersep> <identifier> <identifier> = transaction <identifiersep> <identifier> . current <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . start ( ) ; \n \t2 if ( ! <identifier> <identifiersep> config <identifiersep> dao . update ( name , <identifier> , value ) ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> dao . update ( config . get <identifiersep> id ( ) , config ) ; } } \n \t3 s <identifiersep> logger . debug ( <string_literal> + cmd ) ; \n \t3 return answer ; \n \t2 } catch ( final exception e ) { \n <ect>
\t3 int <identifier> = 0 ; \n \t3 try { \n \t4 while ( ! success ) { \n <ect>
\t3 logger . debug ( <string_literal> , db <identifiersep> name ) ; \n \t2 } else { \n \t3 <identifier> <identifiersep> db <identifiersep> name = <identifier> . get <identifiersep> authentication <identifiersep> <identifier> <identifiersep> name ( ) ; \n \t3 db <identifiersep> name = <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ; \n <ect>
\t2 <identifier> <identifiersep> list . add ( <identifier> . get <identifiersep> out <identifiersep> file ( ) . to <identifiersep> uri ( ) ) ; \n \t2 byte [ ] <identifier> <identifiersep> bytes = files . <identifier> ( <identifier> . get <identifiersep> out <identifiersep> file ( ) , <identifier> . <identifier> ( ) ) . as <identifiersep> bytes ( ) ; \n \t2 string <identifier> = base <identifiersep> <identifier> . <identifier> ( ) . <identifier> <identifiersep> case ( ) . <identifier> ( <identifier> <identifiersep> bytes ) ; \n \t2 current <identifiersep> <identifier> . put ( <identifier> <identifiersep> cache <identifiersep> <identifier> <identifiersep> <identifier> + <identifier> . get <identifiersep> out <identifiersep> file ( ) . get <identifiersep> name ( ) , <identifier> ) ; \n <ect>
\t4 assert <identifier> == <identifier> ; \n \t4 assert <identifier> == <identifier> ; \n \t4 assert <identifier> == <identifier> ; \n \t4 assert <identifier> == <identifier> ; \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + name + <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> vm <identifiersep> <identifier> = <identifier> <identifiersep> vm <identifiersep> cache . get ( name ) ; \n \t2 if ( vm <identifiersep> <identifier> != null ) { \n <ect>
\t1 @ test \n \t1 public void <identifier> <identifiersep> log <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 logger logger = <identifier> . get <identifiersep> logger ( <identifier> <identifiersep> test . class ) ; \n \t2 <identifier> <identifiersep> log <identifiersep> message ( log <identifiersep> level . debug , <string_literal> ) ; \n <ect>
\t2 if ( task <identifiersep> <identifier> == null ) { \n \t3 task <identifiersep> <identifier> = new <identifier> <identifiersep> thread <identifiersep> pool <identifiersep> task <identifiersep> <identifier> ( get <identifiersep> <identifier> <identifiersep> context ( ) , consumer , consumer . get <identifiersep> endpoint ( ) . get <identifiersep> endpoint <identifiersep> uri ( ) ) ; \n \t3 task <identifiersep> <identifier> . <identifier> <identifiersep> properties <identifiersep> set ( ) ; \n \t3 <identifier> <identifiersep> task <identifiersep> <identifier> = true ; } \n <ect>
\t3 client ( ) . <identifier> <identifiersep> index ( <string_literal> , <string_literal> , integer . to <identifiersep> string ( i ) ) . set <identifiersep> source ( <string_literal> , <string_literal> + i ) . execute ( ) . action <identifiersep> get ( ) ; } \n \t2 logger . info ( <string_literal> ) ; \n \t2 client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> <identifier> ( ) . execute ( ) . action <identifiersep> get ( ) ; \n \t2 assert <identifiersep> that ( client ( ) . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> size ( 0 ) . execute ( ) . action <identifiersep> get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 <identifier> <identifiersep> count count ; \n \t3 count = new <identifier> <identifiersep> count ( <identifier> , data <identifiersep> store <identifiersep> source . server , action . get <identifiersep> <identifier> , <string_literal> + thread . current <identifiersep> thread ( ) . get <identifiersep> name ( ) , <identifier> . thread <identifiersep> <identifier> <identifiersep> time ( ) ) ; \n \t3 this . queue . put ( count ) ; \n \t2 } catch ( throwable ex ) { \n <ect>
\t6 s <identifiersep> logger . debug ( <string_literal> + ( ( <identifier> <identifiersep> command ) cmd ) . get <identifiersep> <identifier> ( ) ) ; \n \t6 system . <identifier> ( 1 ) ; \n \t6 return ; \n \t5 } else if ( cmd instanceof <identifier> <identifiersep> command ) { \n <ect>
\t5 logger . info ( <string_literal> , command <identifiersep> to <identifiersep> send . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> string ( ) ) ; } \n \t3 } else { \n \t4 logger . info ( <string_literal> ) ; } \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 try { \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> = new byte [ in . <identifier> ( ) ] ; \n \t3 in . read ( <identifier> ) ; } \n \t2 catch ( io <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 thread . <identifier> ( <number_literal> ) ; \n \t2 do <identifiersep> send <identifiersep> <identifier> ( <string_literal> , <number_literal> , <number_literal> , default <identifiersep> task <identifiersep> <identifier> <identifiersep> type . thread <identifiersep> pool ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 long number <identifiersep> <identifier> <identifiersep> <identifier> = current <identifiersep> thread <identifiersep> count ( ) - <identifier> <identifiersep> thread <identifiersep> count ; \n <ect>
\t1 @ <identifier> \n \t1 public void on <identifiersep> <identifier> <identifiersep> message ( final <identifier> <identifiersep> request <identifier> , long message , final boolean <identifier> , boolean first ) { \n \t2 int size = ( int ) ( ( message > > <number_literal> ) & <identifier> ) ; \n <ect>
\t4 <identifier> <identifiersep> version <identifiersep> test . <identifier> <identifiersep> <identifier> . add ( <identifier> ) ; \n \t4 return false ; } \n \t3 if ( <identifier> . <identifier> ( response <identifiersep> <identifier> . get ( 0 ) ) ) { \n \t4 try { \n <ect>
\t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n \t5 <identifier> <identifiersep> log . info ( <string_literal> + <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void stop ( <identifier> <identifiersep> context <identifier> ) throws exception { \n \t2 context = null ; \n <ect>
\t3 return response ; \n \t2 case <identifier> <identifiersep> <identifier> : \n \t3 <comment> \n \t3 host <identifiersep> request <identifiersep> <identifier> . remove ( ) ; \n <ect>
\t3 if ( lock ( <identifier> <identifiersep> action . get <identifiersep> job <identifiersep> id ( ) ) ) { \n \t4 <identifier> ( store ) ; } \n \t3 else { \n \t4 queue <identifiersep> <identifier> ( new <identifier> <identifiersep> action <identifiersep> input <identifiersep> check <identifiersep> command ( action <identifiersep> id ) , lock <identifiersep> failure <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t5 config . set <identifiersep> <identifier> <identifiersep> location ( null ) ; } \n \t4 if ( <identifier> == null ) { \n \t5 log . info ( <string_literal> , <identifier> <identifiersep> string ) ; \n \t4 } else { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> stream != null ) { \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> stream , <identifier> <identifiersep> properties . get <identifiersep> property ( <string_literal> ) ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t5 s <identifiersep> logger . warn ( <string_literal> + vm + <string_literal> + state . <identifier> + <string_literal> ) ; \n \t5 return false ; } } \n \t3 if ( vm . get <identifiersep> last <identifiersep> host <identifiersep> id ( ) != null ) { \n \t4 if ( ! send <identifiersep> stop ( <identifier> , <identifier> , <identifier> ) ) { \n <ect>
\t4 current <identifiersep> info = info ; \n \t3 } else if ( <identifier> <identifiersep> name . equals ( <string_literal> ) ) { \n \t4 <identifier> <identifiersep> info < <identifier> <identifiersep> service > info = new <identifier> <identifiersep> info < <identifier> <identifiersep> service > ( ) ; \n \t4 <identifier> <identifiersep> info ( <identifier> , <identifier> <identifiersep> service . class , info ) ; \n <ect>
\t3 <comment> \n \t3 final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> storage <identifiersep> pool <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( template <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> pool , 0 ) ; \n \t3 return <identifier> <identifiersep> <identifier> ; \n \t2 } catch ( final <identifier> <identifiersep> runtime <identifiersep> exception e ) { \n <ect>
\t2 if ( field == null ) { \n \t3 return ; } \n \t2 uri <identifiersep> field <identifier> = field . get <identifiersep> <identifier> ( uri <identifiersep> field . class ) ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t4 send <identifiersep> update ( <identifier> , <identifier> , <identifier> <identifiersep> type . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> update ) ; \n \t4 send <identifiersep> update ( <identifier> , <identifier> , <identifier> <identifiersep> type . volume <identifiersep> <identifier> , update <identifiersep> volume <identifiersep> <identifier> ) ; \n \t4 send <identifiersep> update ( <identifier> , <identifier> , <identifier> <identifiersep> type . volume <identifiersep> db , update <identifiersep> volume <identifiersep> db ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 return <identifier> <identifiersep> <identifier> . from <identifiersep> java <identifiersep> key ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> security <identifiersep> exception <identifier> ) { \n \t3 <identifier> <identifiersep> log . error ( <string_literal> + <identifier> <identifiersep> name , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 url <identifier> <identifiersep> url ; \n \t4 try { \n \t5 <identifier> <identifiersep> url = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . configuration ( ) . get <identifiersep> <identifier> <identifiersep> url ( ) ; \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> exception e ) { \n <ect>
\t4 return ; \n \t3 try { \n \t4 <identifier> . run ( ) ; } \n \t3 catch ( throwable t ) { \n <ect>
\t5 if ( exception instanceof <identifier> <identifiersep> <identifier> <identifiersep> exception ) { \n \t6 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> job <identifiersep> id + <string_literal> ) ; \n \t6 throw ( <identifier> <identifiersep> <identifier> <identifiersep> exception ) exception ; } \n \t5 else if ( exception instanceof <identifier> <identifiersep> operation <identifiersep> exception ) { \n <ect>
\t3 new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( configuration ) . run <identifiersep> <identifier> ( new string [ ] { <identifier> <identifiersep> file , utils , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> } ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n \t3 <comment> \n \t1 private void test <identifiersep> <identifier> <identifiersep> check ( ) throws exception { \n <ect>
\t5 try { \n \t6 if ( volume . get <identifiersep> state ( ) != volume . state . <identifier> ) { \n \t7 <identifier> <identifiersep> storage <identifiersep> <identifier> . <identifier> <identifiersep> volume ( volume ) ; } \n \t5 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t1 path import <identifiersep> dir = new path ( base <identifiersep> dir , <string_literal> ) ; \n \t1 for ( path p : new path [ ] { <identifier> <identifiersep> dir , import <identifiersep> dir } ) { \n \t1 assert <identifiersep> true ( <string_literal> + base <identifiersep> dir , <identifier> . <identifier> ( p ) ) ; } \n \t1 log . info ( <string_literal> , <identifier> <identifiersep> dir ) ; \n <ect>
\t2 local <identifiersep> logger . error ( <string_literal> + \\ \n \t2 <string_literal> , e ) } } \n \t1 for ( snapshot <identifiersep> info snapshot : <identifier> <identifiersep> to <identifiersep> update ) { \n \t2 if ( snapshot . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) == null ) { \n <ect>
\t4 local <identifiersep> session session = load ( <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . put ( session . session <identifiersep> id , session ) ; } \n \t3 catch ( illegal <identifiersep> argument <identifiersep> exception | null <identifiersep> <identifier> <identifiersep> exception e ) \n \t3 { \n <ect>
\t3 byte msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> ; \n \t3 org . apache . thrift . t <identifiersep> <identifier> msg ; \n \t3 <identifier> <identifiersep> result result = new <identifier> <identifiersep> result ( ) ; \n \t3 if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
public void <identifier> <identifiersep> <identifier> ( ) { \n \t1 try { \n \t1 manager . close ( ) ; \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t4 || ! attributes . contains <identifiersep> key ( <identifier> <identifiersep> directory <identifiersep> properties . get <identifiersep> <identifier> <identifiersep> attribute <identifiersep> name ( ) ) \n \t4 || ! attributes . contains <identifiersep> key ( <identifier> <identifiersep> directory <identifiersep> properties . get <identifiersep> password <identifiersep> attribute <identifiersep> name ( ) ) ) { \n \t3 logger . warn ( <string_literal> , <identifier> ) ; \n \t3 throw new account <identifiersep> not <identifiersep> found <identifiersep> exception ( ) ; } \n <ect>
\t2 cache <identifiersep> configuration cache <identifiersep> configuration = new cache <identifiersep> configuration ( <string_literal> + get <identifiersep> id ( ) ) ; \n \t2 try { \n \t3 this . <identifier> <identifiersep> <identifier> <identifiersep> cache = this . cache <identifiersep> manager . create <identifiersep> new <identifiersep> cache ( cache <identifiersep> configuration ) ; \n \t2 } catch ( cache <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . check <identifiersep> not <identifiersep> null ( config ) ; \n \t2 <identifier> . check <identifiersep> not <identifiersep> null ( num <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 this . config = config ; \n \t2 if ( config . get <identifiersep> boolean ( <identifier> <identifiersep> server <identifiersep> options . <identifier> <identifiersep> server <identifiersep> web <identifiersep> <identifier> <identifiersep> enabled ) && <identifier> <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> enabled ( config ) ) { \n <ect>
\t3 if ( a <identifiersep> host == null ) { \n \t4 return null ; } \n \t3 return a <identifiersep> host . instance <identifiersep> array ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t7 + <string_literal> + <identifier> <identifiersep> <identifier> ) ; } \n \t3 long <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == - 1 ) \n \t3 { \n <ect>
\t3 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> id + <string_literal> + <identifier> <identifiersep> id + <string_literal> + cluster <identifiersep> id + <string_literal> + url . get <identifiersep> host ( ) ) ; \n \t2 if ( <identifier> <identifiersep> id == null ) { \n <ect>
\t6 return <identifier> ; } \n \t4 } else { \n \t5 s <identifiersep> logger . debug ( <string_literal> + cluster <identifiersep> id ) ; } \n \t3 } else { \n <ect>
\t4 <identifier> . get ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n \t3 } catch ( execution <identifiersep> exception <identifier> ) { \n \t4 <comment> \n \t3 } catch ( timeout <identifiersep> exception e ) { \n <ect>
\t3 <identifier> [ ] <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( context ) ; \n \t3 if ( <identifier> == null || <identifier> . length == 0 ) { \n \t4 <comment> \n \t4 <comment> \n <ect>
\t2 try { \n \t3 <comment> \n \t3 file store <identifiersep> <identifier> <identifiersep> directory = file <identifiersep> store . get <identifiersep> <identifier> <identifiersep> file ( ) ; \n \t3 if ( store <identifiersep> <identifier> <identifiersep> directory != null && ! store <identifiersep> <identifier> <identifiersep> directory . exists ( ) ) { \n <ect>
\t2 out ) ; \n \t1 long header <identifiersep> size = out . get <identifiersep> <identifier> ( ) - <identifier> <identifiersep> header ; \n \t1 this . <identifier> <identifiersep> length += <identifier> <identifiersep> <identifier> <identifiersep> size + header <identifiersep> size ; \n \t1 this . <identifier> <identifiersep> length += <identifier> <identifiersep> <identifier> <identifiersep> size + header <identifiersep> size ; \n <ect>
\t5 . get ( ) \n \t5 . is <identifiersep> <identifier> ( ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> cluster ( ) . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 for ( int i = 0 ; i < message <identifiersep> count ; ++ i ) { \n \t3 log . debug ( <string_literal> , i ) ; \n \t3 <comment> \n \t3 object response = template . request <identifiersep> body <identifiersep> and <identifiersep> header ( source <identifiersep> uri , <identifier> <identifiersep> message <identifiersep> <identifier> . <identifier> <identifiersep> message ( i ) , <string_literal> , string . format ( <string_literal> , i ) ) ; \n <ect>
\t2 <identifier> = <identifier> + <string_literal> ; \n \t2 json = <identifier> + <string_literal> ; \n \t2 <identifier> = <identifier> + <string_literal> ; \n \t2 data = <string_literal> item <identifiersep> <identifier> \\ <string_literal> int \\ <string_literal> + <identifier> <identifiersep> file <identifiersep> name <identifiersep> item <identifiersep> <identifier> + <string_literal> n \\ <string_literal> int \\ <string_literal> + <identifier> <identifiersep> file <identifiersep> name <identifiersep> <identifier> <identifiersep> count + <string_literal> ; \n <ect>
\t1 <comment> \n \t1 log . debug ( <string_literal> , resource ) ; \n \t1 final string resource <identifiersep> path = <identifier> <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> path ( resource . get <identifiersep> uri ( ) ) \n \t2 + default <identifiersep> <identifier> <identifiersep> stream <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ; \n <ect>
\t4 set <identifiersep> value <identifiersep> <identifier> <identifiersep> request ( true ) ; \n \t4 <identifier> . <identifier> ( ) ; } } } \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> < string , ? > config ) throws configuration <identifiersep> exception { \n <ect>
\t2 <identifier> . get <identifiersep> system <identifiersep> <identifier> ( ) . get <identifiersep> store <identifiersep> <identifier> ( ) . set <identifiersep> <identifier> ( <number_literal> * <number_literal> * <number_literal> ) ; \n \t2 log . info ( to <identifiersep> string ( ) + <string_literal> ) ; \n \t2 <identifier> . start ( ) ; \n \t2 <identifier> . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 this . factory = factory ; } \n \t1 @ <identifier> \n \t1 @ application <identifiersep> <identifier> \n \t1 public message <identifiersep> <identifier> get <identifiersep> instance ( ) { \n <ect>
\t1 for ( file <identifiersep> object <identifier> : files ) { \n \t1 try { \n \t2 <identifier> . <identifier> ( <string_literal> ) . <identifier> ( <identifier> . get <identifiersep> url ( ) . to <identifiersep> string ( ) ) . <identifier> ( <string_literal> ) ; \n \t1 } catch ( file <identifiersep> system <identifiersep> exception e ) { \n <ect>
\t3 if ( output . length ( ) > 0 ) { \n \t4 logger . debug ( <string_literal> + output ) ; } \n \t3 process . wait <identifiersep> for ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = new string <identifiersep> builder ( ) ; \n \t2 for ( string s : <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( s ) . <identifier> ( <string_literal> ) ; } \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> name ) ; \n <ect>
\t3 if ( <identifier> && ! <identifier> ) { \n \t4 throw new <identifier> <identifiersep> exception ( ex ) ; } } \n \t2 @ <identifier> \n \t2 public void <identifier> <identifiersep> error ( <identifier> <identifiersep> parse <identifiersep> exception ex ) throws <identifier> <identifiersep> exception { \n <ect>
\t3 string [ ] <identifier> = <identifier> [ i ] . <identifier> ( <string_literal> ) ; \n \t3 if ( <identifier> . length == <number_literal> ) { \n \t4 <identifier> . put ( <identifier> [ 0 ] , <identifier> [ 1 ] ) ; \n \t3 } else { \n <ect>
\t1 logger . error ( <string_literal> , e ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 logger . error ( <string_literal> , e ) ; \n \t1 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . put ( <string_literal> , <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . process ( <identifier> , path , out , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 final service current <identifiersep> service = web <identifiersep> utils . get <identifiersep> service ( request <identifiersep> context ) ; \n \t2 final web <identifiersep> application <identifiersep> service service = this . service <identifiersep> factory . create <identifiersep> service ( entity <identifiersep> id ) ; \n \t2 registered <identifiersep> service registered <identifiersep> service = this . <identifier> <identifiersep> manager . find <identifiersep> service <identifiersep> by ( service ) ; \n \t2 if ( registered <identifiersep> service == null ) { \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 if ( is <identifiersep> new <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> ) ) { \n \t3 <identifier> . add ( new <identifier> <identifiersep> <identifier> ( <identifier> , true ) ) ; \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t1 public void wait ( <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 if ( wait <identifiersep> <identifier> == null ) { \n \t3 return ; } \n \t2 for ( wait <identifiersep> <identifier> wait <identifiersep> <identifier> : wait <identifiersep> <identifier> ) { \n <ect>
\t1 if ( ! is <identifiersep> <identifier> ( ) ) { \n \t2 for ( final <identifier> <identifier> <identifiersep> task : <identifier> <identifiersep> <identifier> ) try { \n \t2 <identifier> <identifiersep> task . run ( ) ; \n \t2 } catch ( final runtime <identifiersep> exception e ) { \n <ect>
\t4 { \n \t5 queue . close ( ) ; } \n \t4 catch ( io <identifiersep> exception e ) \n \t4 { \n <ect>
\t1 return this . s . equals ( that . to <identifiersep> string ( ) ) ; } \n \t1 @ <identifier> public int <identifier> <identifiersep> to ( <identifier> that ) { \n \t1 return this . s . <identifier> <identifiersep> to ( that . s ) ; } } \n @ test public void test <identifiersep> <identifier> <identifiersep> model ( ) throws exception { \n <ect>
\t2 <comment> \n \t2 log . error ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n \t2 <comment> \n <ect>
\t6 entry = entry . <identifier> ( ) ; \n \t6 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( entry , true ) ; } } } \n \t3 <identifier> <identifiersep> file ( ) ; <comment> \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . put <identifiersep> string <identifiersep> to <identifiersep> file ( <identifier> <identifiersep> api , log <identifiersep> file , <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> api <identifiersep> exception e ) { \n \t3 throw new service <identifiersep> <identifier> <identifiersep> exception ( e ) ; } \n \t2 job . set <identifiersep> log <identifiersep> file ( log <identifiersep> file ) ; \n <ect>
\t3 try { \n \t4 get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> all ( ) \n \t3 } catch ( runtime <identifiersep> exception ex ) { \n \t4 <comment> \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t5 <identifier> . set <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t4 data <identifiersep> source <identifiersep> utils . <identifier> <identifiersep> connection <identifiersep> <identifier> <identifiersep> transaction ( <identifier> , <identifier> <identifiersep> object . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> level ( ) ) ; } \n \t3 catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 text file = new text ( ) ; \n \t2 metadata <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . get <identifiersep> file ( entry . get <identifiersep> key ( ) , file ) ; \n \t2 <identifier> id = <identifier> ( new path ( file . to <identifiersep> string ( ) ) ) ; \n \t2 <identifier> . remove ( id ) ; \n <ect>
\t3 <comment> \n \t3 string current <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( current <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 @ <identifier> \n \t4 public void handle <identifiersep> transaction <identifiersep> failure ( security <identifiersep> context security <identifiersep> context , throwable t ) { \n \t5 logger . warn ( <string_literal> , t . get <identifiersep> message ( ) ) ; } \n \t3 } ) ; \n <ect>
\t4 if ( <identifier> != null ) \n \t5 send <identifiersep> <identifier> ( <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , false , <string_literal> ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 node = <identifier> . read <identifiersep> <identifier> ( source <identifiersep> file ) ; \n \t3 static <identifiersep> data <identifiersep> source provider = static <identifiersep> data <identifiersep> source . from <identifiersep> json ( node , source <identifiersep> file . to <identifiersep> uri ( ) ) ; \n \t3 return provider ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task ( <number_literal> ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> m <identifiersep> bean ( <string_literal> , <string_literal> , this ) ; \n \t3 } catch ( exception e ) { \n <ect>
public void context <identifiersep> <identifier> ( <identifier> <identifiersep> context <identifiersep> event <identifier> ) { \n \t1 <identifier> <identifiersep> context <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t1 object <identifier> = <identifier> . get <identifiersep> attribute ( <string_literal> ) ; <comment> \n \t1 if ( <identifier> != null ) { \n <ect>
\t5 int <identifier> = get <identifiersep> <identifier> <identifiersep> level ( conf , <number_literal> ) ; \n \t5 byte <identifier> = <identifier> ( <identifier> , <identifier> ) ; \n \t5 msg m = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> message ( ( byte ) <identifier> , get <identifiersep> on <identifiersep> cmd ( ) , <identifier> , s <identifiersep> get <identifiersep> group ( conf ) ) ; \n \t5 <identifier> . <identifier> <identifiersep> message ( m , m <identifiersep> <identifier> ) ; \n <ect>
\t1 public void close ( ) throws io <identifiersep> exception \n \t1 { \n \t2 { \n <ect>
\t6 try { \n \t7 map < byte <identifiersep> array , list < <identifier> < byte [ ] > > > <identifier> <identifiersep> <identifier> = this . store <identifiersep> client . get <identifiersep> all <identifiersep> with <identifiersep> <identifier> <identifiersep> timeout ( this . request <identifiersep> object ) ; \n \t7 if ( <identifier> <identifiersep> <identifier> == null \n \t7 || <identifier> <identifiersep> <identifier> . values ( ) . size ( ) == 0 ) { \n <ect>
\t3 for ( int i = 1 ; i < = all ; ++ i ) { \n \t4 <identifier> <identifiersep> <identifier> . add ( <string_literal> + i ) ; } \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> all ( <identifier> <identifiersep> <identifier> . to <identifiersep> array ( new string [ <identifier> <identifiersep> <identifier> . size ( ) ] ) ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 if ( authentication == null ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 return null ; } \n \t2 if ( attribute <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 <identifier> . start ( ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 if ( i <identifier> <number_literal> == 0 ) { \n \t4 <identifier> . stop ( ) ; \n <ect>
\t6 catch ( exception t ) { \n \t7 log . warn ( <string_literal> + <identifier> , t ) ; } } } \n \t4 catch ( exception e ) { \n \t5 <comment> \n <ect>
\t5 public int <identifier> ( application <identifiersep> <identifier> <identifier> , application <identifiersep> <identifier> <identifier> ) { \n \t6 return <identifier> . get <identifiersep> application <identifiersep> id ( ) . <identifier> <identifiersep> to ( <identifier> . get <identifiersep> application <identifiersep> id ( ) ) * - 1 ; } \n \t4 } ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> id = <identifier> . get ( 0 ) . get <identifiersep> application <identifiersep> id ( ) ; \n <ect>
\t3 } finally { \n \t4 <comment> \n \t4 stop <identifiersep> server ( server <identifiersep> list ) ; } \n \t2 } catch ( <identifier> <identifiersep> error <identifier> ) { \n <ect>
\t2 { \n \t3 user <identifiersep> log . info ( <string_literal> ) ; \n \t3 check <identifiersep> <identifier> <identifiersep> store <identifiersep> id <identifiersep> and <identifiersep> <identifier> <identifiersep> store <identifiersep> id ( store <identifiersep> id , <identifier> <identifiersep> uri , <identifier> ) ; \n \t3 check <identifiersep> data <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( <identifier> <identifiersep> uri , <identifier> <identifiersep> client , store <identifiersep> id , <identifier> <identifiersep> id <identifiersep> store ) ; \n <ect>
\t3 return <identifier> . handle ( provider <identifiersep> info . class , ex , <string_literal> , type , name ) ; } } \n \t1 @ <identifier> \n \t1 public boolean has ( class type ) { \n \t2 if ( debug ) logger . debug ( context <identifiersep> <identifier> , <string_literal> , <string_literal> , type ) ; \n <ect>
\t3 <identifier> <identifiersep> model <identifiersep> <identifier> target <identifiersep> stream <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> by <identifiersep> id <identifiersep> dao . execute ( stream <identifiersep> <identifier> <identifiersep> id ) ; \n \t3 return is <identifiersep> stream <identifiersep> <identifier> <identifiersep> <identifier> ( target <identifiersep> stream <identifiersep> <identifier> , <identifier> <identifiersep> type ) ; } \n \t2 catch ( exception ex ) \n \t2 { \n <ect>
\t4 if ( ( <identifier> <identifiersep> time - last <identifiersep> <identifier> <identifiersep> time ) / <number_literal> < ( <identifier> <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> 1 * <number_literal> ) ) { \n \t5 log . debug ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t5 <identifier> <identifiersep> remove <identifiersep> <identifier> . add ( <identifier> <identifiersep> id ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t1 try { \n \t2 entity = <identifier> <identifiersep> <identifier> <identifiersep> metadata <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( entity ) ; \n \t1 } catch ( exception e ) { \n \t2 <comment> \n <ect>
\t3 logger . error ( e . get <identifiersep> message ( ) , e ) ; } \n \t2 return null ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> location <identifiersep> response <identifier> ( final double <identifier> , final double <identifier> ) { \n <ect>
<comment> \n \t4 logger . info ( <string_literal> , string <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> last ( <identifier> , <string_literal> ) ) ; \n \t4 logger . info ( <string_literal> , object <identifiersep> utils . default <identifiersep> if <identifiersep> null ( v . get <identifiersep> default <identifiersep> value ( ) , <string_literal> ) ) ; \n <ect>
<comment> \n @ <identifier> \n public void <identifier> <identifiersep> node ( string id ) { \n \t1 check <identifiersep> not <identifiersep> null ( id , <string_literal> ) ; \n <ect>
\t2 super ( ) ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> vm , host host ) { \n \t2 if ( host . get <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> type . <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( ) ; } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> stop ( service <identifiersep> <identifier> <identifier> ) throws exception { \n <ect>
\t2 final string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t2 final count <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = \n \t4 <identifier> <identifiersep> request ( http <identifiersep> client , <string_literal> + port + <string_literal> , <identifier> , session <identifiersep> id ) ; \n \t2 <identifier> . <identifier> ( ) ; \n <ect>
\t1 { \n \t2 <identifier> <identifiersep> <identifier> . on <identifiersep> error ( e ) ; } \n \t1 catch ( throwable ex ) \n \t1 { \n <ect>
\t2 stop <identifiersep> <identifier> <identifier> = new stop <identifiersep> <identifier> ( ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ; } \n <ect>
\t1 try { \n \t1 log . trace ( <string_literal> , listener . get <identifiersep> class ( ) . get <identifiersep> name ( ) , <identifier> <identifiersep> event ) ; \n \t1 listener . on <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> event , <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
private void <identifier> <identifiersep> <identifier> <identifiersep> data ( long host <identifiersep> id ) { \n \t1 try { \n \t1 <identifier> <identifiersep> data ( host <identifiersep> id ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void execute ( ) { \n \t2 if ( ! this . <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
public void null <identifiersep> <identifier> <identifiersep> set ( final <identifier> <identifiersep> <identifier> <identifier> , final object <identifier> , final int <identifier> ) throws <identifier> <identifiersep> exception , \n \t1 sql <identifiersep> exception { \n \t1 <comment> \n \t1 if ( empty <identifiersep> string <identifiersep> user <identifiersep> type . debug ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( consumer , cache <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> service = <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> service <identifiersep> manager ( ) . new <identifiersep> <identifier> <identifiersep> thread <identifiersep> <identifier> ( this , <string_literal> ) ; \n \t2 <identifier> <identifiersep> service . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 log . error ( <string_literal> + <identifier> + <string_literal> + e . get <identifiersep> message ( ) , e ) ; } } \n \t2 this . <identifier> = false ; <comment> \n \t2 this . service <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 this . <identifier> <identifiersep> service <identifiersep> manager = null ; \n <ect>
\t3 try { \n \t4 <identifier> = c . get ( i ) ; \n \t4 <identifier> . <identifier> <identifiersep> <identifier> ( r ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 cache <identifiersep> enabled = is <identifiersep> cache <identifiersep> enabled <identifiersep> by <identifiersep> default ( ) ; } \n \t2 if ( cache <identifiersep> enabled ) { \n \t3 cache = create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map ( ) ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 if ( <identifier> . get <identifiersep> table ( ) != null ) { \n \t4 if ( <identifier> . get <identifiersep> table ( ) . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> table ( ) ) { \n \t5 <identifier> . <identifier> <identifiersep> table ( user <identifiersep> id ) ; } \n \t3 } else { \n <ect>
<comment> \n \t1 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( end <identifiersep> <identifier> - 1 ) ; \n <ect>
\t5 <comment> \n \t5 <identifier> <identifiersep> metadata <identifiersep> manager <identifier> = new <identifier> <identifiersep> metadata <identifiersep> manager ( context <identifiersep> <identifier> ) ; \n \t5 <identifier> . <identifier> ( new user <identifiersep> config <identifiersep> metadata ( context <identifiersep> <identifier> ) , new update <identifiersep> <identifier> ( ) ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 if ( ! event <identifiersep> handler . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t7 <comment> \n \t7 <comment> \n \t7 <comment> \n <ect>
\t3 <comment> \n \t2 <comment> \n \t3 <identifier> ( <identifier> <identifiersep> context , <identifier> <identifiersep> config , <identifier> , <identifier> , <identifier> , length ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 return new xml <identifiersep> <identifier> <identifiersep> bean <identifiersep> factory ( manager , <identifier> , <identifier> ) ; } \n \t1 set < <identifier> <identifiersep> bean < ? > > <identifier> <identifiersep> from ( string path ) throws <identifier> <identifiersep> exception , io <identifiersep> exception { \n \t2 url url = get <identifiersep> resource ( path ) ; \n \t2 if ( url == null ) { \n <ect>
\t6 logger . debug ( <string_literal> + user <identifiersep> id + <string_literal> + table . get <identifiersep> id ( ) ) ; } \n \t5 user <identifiersep> <identifier> <identifiersep> map . remove ( user <identifiersep> id ) ; \n \t4 } else if ( table . get <identifiersep> state ( ) != table <identifiersep> state . <identifier> ) { \n \t5 if ( table . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 if ( <identifier> <identifiersep> file == null || ! <identifier> <identifiersep> file . exists ( ) ) { \n \t3 <identifier> <identifiersep> file = new file ( <string_literal> ) ; } \n \t2 assert ( <identifier> <identifiersep> file != null ) ; \n \t2 if ( ! <identifier> <identifiersep> file . exists ( ) ) { \n <ect>
\t4 in = new file <identifiersep> input <identifiersep> stream ( <identifier> . get <identifiersep> file ( ) ) ; \n \t4 out = new file <identifiersep> output <identifiersep> stream ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> file ( in , out ) ; } \n \t3 catch ( io <identifiersep> exception io ) { \n <ect>
\t2 return <identifier> . get <identifiersep> <identifier> ( ) ; } \n \t1 public int get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> count ( ) { \n \t2 if ( <identifier> . get <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> <identifier> ) { \n \t3 return ( ( <identifier> <identifiersep> <identifier> ) <identifier> . get <identifiersep> <identifier> ( ) ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> count ( <identifier> ) ; } \n <ect>
\t6 log . debug ( <string_literal> + element . id + <string_literal> ) ; } } \n \t4 else if ( element == <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 state = s ; \n \t2 <identifier> <identifiersep> state = m <identifiersep> state ; \n \t2 listener . <identifier> ( this ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 return ; } \n \t3 <comment> \n \t3 long [ ] <identifier> <identifiersep> <identifier> <identifiersep> long = <identifier> . bytes <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> long . length < <number_literal> ) { \n <ect>
\t2 <identifier> = ( <identifier> ) <identifier> . create <identifiersep> <identifier> ( ) . <identifier> ( new string <identifiersep> <identifier> ( <identifier> . to <identifiersep> string ( ) ) ) ; \n \t2 byte <identifiersep> array <identifiersep> output <identifiersep> stream <identifier> = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; \n \t2 <identifier> <identifiersep> stream <identifier> = new <identifier> <identifiersep> stream ( <identifier> ) ; \n \t2 <identifier> . <identifier> ( <identifier> , <identifier> ) ; \n <ect>
\t3 <identifier> . assert <identifiersep> no <identifiersep> <identifier> ( ) ; \n \t3 logger . info ( <string_literal> , wait <identifiersep> for ) ; \n \t3 <identifier> <identifiersep> <identifier> = total <identifiersep> num <identifiersep> <identifier> - wait <identifiersep> for ; \n \t3 <identifier> . continue <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 return null ; } \n \t2 try { \n \t3 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> bytes ( <identifier> ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 catch ( <identifier> <identifiersep> <identifier> <identifiersep> not <identifiersep> <identifier> <identifiersep> exception e ) \n \t3 { \n \t4 try \n \t4 { \n <ect>
\t4 if ( key . <identifier> ( ) instanceof abstract <identifiersep> <identifier> <identifiersep> session ) { \n \t5 ( ( abstract <identifiersep> <identifier> <identifiersep> session ) key . <identifier> ( ) ) . on <identifiersep> exception ( e ) ; } \n \t4 <identifier> . close <identifiersep> <identifier> <identifiersep> key ( key ) ; \n \t4 <identifier> . <identifier> <identifiersep> exception ( e ) ; \n <ect>
\t2 <identifier> <identifiersep> sql <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> db <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> sql <identifiersep> <identifier> ( ) ; } \n \t1 private void <identifier> <identifiersep> sql <identifiersep> <identifier> ( ) { \n <ect>
\t3 public void run ( ) { \n \t4 do { \n \t5 try { \n \t6 if ( count ++ <identifier> log <identifiersep> <identifier> == 0 ) { \n <ect>
\t5 msg . transport <identifiersep> failed ( t . get <identifiersep> <identifier> ( ) ) ; \n \t4 else if ( ( <identifier> == null ) || ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) > <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ) \n \t5 <identifier> = <identifier> ; \t1 \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 <identifier> <identifiersep> resource <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> resource <identifiersep> count ( <identifier> <identifiersep> on <identifiersep> <identifier> . get <identifiersep> account <identifiersep> id ( ) , resource <identifiersep> type . <identifier> <identifiersep> storage , new long ( <identifier> <identifiersep> on <identifiersep> <identifier> . get <identifiersep> size ( ) ) ) ; } \n \t3 <comment> \n \t3 list < volume <identifiersep> info > cache <identifiersep> <identifier> = <identifier> <identifiersep> factory . list <identifiersep> volume <identifiersep> on <identifiersep> cache ( volume . get <identifiersep> id ( ) ) ; \n \t3 for ( volume <identifiersep> info <identifier> <identifiersep> on <identifiersep> cache : cache <identifiersep> <identifier> ) { \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> info out = <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> client , target ) ; \n \t3 if ( out == null ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 <identifier> <identifiersep> item <identifiersep> <identifier> <identifiersep> final ( <identifier> . <identifier> ) ; \n \t3 context <identifiersep> <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n <ect>
\t3 return true ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 log . debug ( <string_literal> + context . <identifier> ( resource <identifiersep> account <identifiersep> number , resource <identifiersep> name ) + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> event <identifiersep> <identifier> . <identifier> <identifiersep> remove ( property ) ; \n \t3 <identifier> <identifiersep> log . debug ( <string_literal> , path ) ; } \n \t2 break ; \n \t2 default : \n <ect>
\t5 if ( <identifier> . <identifier> ( ) . <identifier> <identifiersep> node ( n . id ( ) ) ) \n \t6 <identifier> . error ( log , <string_literal> + \n \t7 <string_literal> + n . id ( ) + <string_literal> + msg + <string_literal> + e . get <identifiersep> message ( ) + ' ] ' ) ; \n <ect>
\t3 content <identifiersep> <identifier> . put <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> utils . account <identifiersep> <identifier> <identifiersep> path ( <identifier> . <identifier> , <identifier> . account <identifiersep> <identifier> ) ) \n \t3 <identifier> . for <identifiersep> <identifier> <identifier> @ { \n \t4 <identifier> <identifier> <identifiersep> <identifier> <identifiersep> name = it . <identifier> <identifiersep> name \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> name . is <identifiersep> null <identifiersep> or <identifiersep> blank ( ) ) { \n <ect>
\t5 + <string_literal> \n \t5 + <string_literal> \n \t5 + <string_literal> ) \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 @ <identifier> \n \t1 public void channel <identifiersep> <identifier> ( channel channel ) { \n \t2 <comment> \n \t2 <comment> \n <ect>
\t3 client . <identifier> <identifiersep> delete ( index <identifiersep> name , <identifier> <identifiersep> name , name ) \n \t5 . set <identifiersep> <identifier> ( true ) \n \t5 . execute ( ) . action <identifiersep> get ( ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t2 long <identifier> <identifiersep> value = node <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 string from <identifiersep> key = utils . get <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> ( path ) ; \n \t2 string to <identifiersep> key = utils . get <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> ( path ) ; \n \t2 set < string > <identifier> = <identifier> . new <identifiersep> <identifier> <identifiersep> set ( ) ; \n <ect>
\t6 try { \n \t7 <identifier> [ 0 ] = <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> name ( value ) ; \n \t6 } catch ( <identifier> <identifiersep> host <identifiersep> exception <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> map . put <identifiersep> if <identifiersep> <identifier> ( command <identifiersep> to <identifiersep> send . get <identifiersep> message <identifiersep> id ( ) , <identifier> ) ; \n \t4 <identifier> <identifiersep> count <identifiersep> map . put <identifiersep> if <identifiersep> <identifier> ( command <identifiersep> to <identifiersep> send . get <identifiersep> message <identifiersep> id ( ) , <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> ( command <identifiersep> to <identifiersep> send ) ; \n \t4 boolean <identifier> = <identifier> . <identifier> ( timeout <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t1 logger . error ( <string_literal> ) ; \n \t1 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t1 security <identifiersep> type security <identifiersep> type = <identifier> . get <identifiersep> if <identifiersep> <identifier> ( security <identifiersep> type . class , security <identifiersep> type <identifiersep> string ) . or <identifiersep> null ( ) ; \n \t1 if ( security <identifiersep> type == null ) { \n <ect>
\t4 int <identifier> <identifiersep> index = <identifier> <identifiersep> text . index <identifiersep> of ( ' . ' ) ; \n \t4 <identifier> = <identifier> + <string_literal> + <identifier> <identifiersep> number ( double . parse <identifiersep> double ( <identifier> <identifiersep> text . <identifier> ( <identifier> <identifiersep> index + 1 ) ) ) + <string_literal> ; } \n \t3 break ; \n \t2 default : \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t4 log . debug ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t4 <identifier> <identifiersep> <identifier> . remove ( <identifier> <identifiersep> id ) ; \n \t3 <comment> \n \t3 } else if ( <identifier> <identifiersep> xml <identifiersep> file . exists ( ) && <identifier> <identifiersep> xml <identifiersep> file . length ( ) == 0 ) { \n <ect>
\t5 output <identifiersep> object . put ( json <identifiersep> <identifier> . <identifier> . name ( ) , <string_literal> ) ; \n \t5 <identifier> . <identifier> ( output <identifiersep> object . to <identifiersep> string ( ) ) ; \n \t4 } catch ( json <identifiersep> exception e ) { \n \t5 <comment> \n <ect>
\t3 this . event = event ; \n \t3 this . <identifier> . count <identifiersep> <identifier> ( ) ; } \n \t2 @ <identifier> <identifiersep> listener ( id = <string_literal> , <identifier> = <string_literal> ) \n \t2 public string <identifier> <identifiersep> <identifier> ( string <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> send <identifiersep> on = send <identifiersep> on ; } \n \t2 public void run <identifiersep> job ( ) { \n \t3 <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t1 super . handle <identifiersep> message ( msg ) \n \t1 <comment> \n \t1 <identifier> <identifiersep> files <identifiersep> path <identifier> { \n \t2 case <identifier> ( file <identifiersep> path ) = > \n <ect>
\t1 if ( ! <identifier> . is <identifiersep> enabled ( <identifier> <identifiersep> queue . class ) ) { \n \t2 return false ; } \n \t1 create <identifiersep> queue <identifiersep> if <identifiersep> not <identifiersep> <identifier> ( ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t2 <identifier> <identifiersep> exception , file <identifiersep> not <identifiersep> found <identifiersep> exception { \n \t2 <comment> \n \t2 file dir = new file ( <identifier> <identifiersep> dir , <identifier> ) ; \n \t2 if ( ! dir . exists ( ) && ! dir . <identifier> ( ) ) { \n <ect>
\t8 <identifier> . get <identifiersep> address ( ) ) ; } \n \t4 } else if ( cmd == on <identifiersep> <identifier> <identifiersep> type . <identifier> ) { \n \t5 logger . info ( <string_literal> , <identifier> ( ) , <identifier> . get <identifiersep> address ( ) ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 log . error ( <identifier> . get <identifiersep> message ( <string_literal> ) , <identifier> <identifiersep> <identifier> <identifiersep> policy . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , t ) ; } \n \t2 try { \n \t3 return new default <identifiersep> <identifier> <identifiersep> policy ( ) . get <identifiersep> new <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 catch ( throwable t ) { \n <ect>
\t4 <identifier> <identifiersep> log . warn ( <string_literal> + type + <string_literal> ) ; \n \t3 return ; } \n \t2 if ( type == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> && ! config <identifiersep> update <identifiersep> handler . <identifier> <identifiersep> <identifier> <identifiersep> update ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 <identifier> . execute <identifiersep> update ( ) ; \n \t1 conn . <identifier> ( ) ; \n \t1 return conn ; \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) { \n \t6 <comment> \n \t6 <comment> \n \t6 <identifier> <identifiersep> log . debug ( <identifier> ( ) + <string_literal> + <identifier> . <identifier> ( <identifier> ) ) ; \n <ect>
\t4 put <identifiersep> method . <identifier> <identifiersep> connection ( ) ; \n \t4 s <identifiersep> logger . error ( <string_literal> + error <identifiersep> message ) ; \n \t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception ( <string_literal> + error <identifiersep> message ) ; } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t5 <identifier> . set <identifiersep> <identifier> <identifiersep> state ( server <identifiersep> state . <identifier> ) ; \n \t5 log . info ( <string_literal> ) ; \n \t5 v = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> for <identifiersep> <identifier> ( ) ; \n \t5 if ( v == null ) { \n <ect>
\t3 execute ( <string_literal> ) ; \n \t2 } catch ( throwable e ) { \n \t3 <comment> \n \t2 execute ( sql ) ; \n <ect>
<comment> \n \t1 public void stop ( ) { \n \t2 if ( ! <identifier> ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 for ( int i = 0 ; i < <identifier> <identifiersep> count ; i ++ ) \n \t2 { \n \t3 <identifier> <identifier> = <identifier> . next ( ) ; \n <ect>
\t8 <identifier> [ this . <identifier> ] == <identifier> ) { \n \t9 <identifier> . <identifier> ( i , 1 ) ; } } } \n \t4 } else if ( <identifier> . remove <identifiersep> event <identifiersep> listener ) { \n \t5 <identifier> . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . <identifier> ] , false ) ; \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 try { \n \t3 index <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 string key = <identifier> + <identifier> + name ; \n \t3 string <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( key ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t4 if ( ! <identifier> ) { \n \t5 <comment> \n \t5 final long <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> and <identifiersep> add ( <identifier> <identifiersep> <identifier> ) ; \n \t5 if ( <identifier> > max <identifiersep> <identifier> ) { \n <ect>
<comment> \n \t1 public static void <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> cache ( <identifier> <identifiersep> context <identifier> <identifiersep> context , configuration conf ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 log . warn ( <string_literal> ) ; } } \n \t1 public void process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> event <identifier> <identifiersep> <identifier> <identifiersep> event ) { \n <ect>
\t4 if ( <identifier> == null ) { \n \t5 <identifier> = property . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ; } \n \t4 <comment> \n \t4 <comment> \n <ect>
\t3 return new update <identifiersep> <identifier> ( new error <identifiersep> update ( <string_literal> ) ) ; \n \t2 string <identifier> <identifiersep> id = <identifier> <identifiersep> manager . instance ( ) . <identifier> <identifiersep> <identifier> <identifiersep> id ( <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> id ) ; \n \t2 <identifier> <identifier> = <identifier> <identifiersep> manager . instance ( ) . get <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t7 logger . info ( <string_literal> + <identifier> <identifiersep> number <identifiersep> of <identifiersep> bytes <identifiersep> <identifier> . get <identifiersep> value ( ) ) ; \n \t7 assert <identifiersep> equals ( <string_literal> , read <identifiersep> size , <identifier> <identifiersep> number <identifiersep> of <identifiersep> bytes <identifiersep> <identifier> . get <identifiersep> value ( ) ) ; \n \t7 <comment> \n \t7 assert <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , <identifier> . instance . <identifier> <identifiersep> file <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; \n <ect>
@ ignore ( <string_literal> ) \n \t1 @ test ( timeout = <number_literal> * <number_literal> * <number_literal> ) \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws throwable { \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n <ect>
\t3 class < ? extends x <identifiersep> <identifier> <identifiersep> url <identifiersep> factory > url <identifiersep> factory <identifiersep> class = this . factory <identifiersep> map . get ( mode ) ; \n \t3 <identifier> = url <identifiersep> factory <identifiersep> class . new <identifiersep> instance ( ) ; \n \t3 <identifier> . <identifier> ( context ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 this . principal <identifiersep> <identifier> <identifiersep> <identifier> = principal <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public <identifier> < authentication > get <identifiersep> <identifier> <identifiersep> authentication ( ) { \n \t2 if ( this . <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task <identifier> <identifiersep> task = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task ( this , <identifier> <identifiersep> <identifier> , log ) ; \n \t2 <identifier> <identifiersep> task . run ( ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) throws io <identifiersep> exception { \n <ect>
\t3 file <identifier> <identifiersep> path = new file ( context . get <identifiersep> files <identifiersep> dir ( ) , <string_literal> ) ; \n \t3 file <identifier> <identifiersep> xml = new file ( <identifier> <identifiersep> path , <identifier> <identifiersep> id + <string_literal> ) ; \n \t3 <comment> \n \t3 if ( ! <identifier> <identifiersep> xml . delete ( ) ) { \n <ect>
\t5 <identifier> <identifiersep> config <identifiersep> options . application <identifiersep> <identifier> <identifiersep> port ) ; \n \t3 <identifier> <identifiersep> system = <identifier> <identifiersep> <identifier> . start <identifiersep> <identifier> <identifiersep> system ( config , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> port <identifiersep> <identifier> , log ) ; \n \t3 final string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> utils . get <identifiersep> address ( <identifier> <identifiersep> system ) . host ( ) . get ( ) ; \n \t3 final int <identifier> <identifiersep> port = ( integer ) <identifier> <identifiersep> utils . get <identifiersep> address ( <identifier> <identifiersep> system ) . port ( ) . get ( ) ; \n <ect>
\t1 } ) ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n \t1 throw e ; \n \t1 } catch ( exception e ) { \n <ect>
\t4 . filter ( v - > values . contains ( v . get <identifiersep> id ( ) ) ) \n \t4 . find <identifiersep> <identifier> ( ) ; \n \t2 if ( provider . is <identifiersep> <identifier> ( ) ) { \n \t3 return collection <identifiersep> utils . <identifier> <identifiersep> set ( new event ( this , provider . get ( ) . get <identifiersep> id ( ) ) ) ; } \n <ect>
\t3 string <identifier> <identifiersep> port = <identifier> <identifiersep> map . get ( <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> port ) ; \n \t3 if ( <identifier> <identifiersep> port == null ) { \n \t4 <identifier> <identifiersep> failure ( t , <string_literal> ) ; \n \t4 return ; } \n <ect>
\t3 log . info ( <string_literal> , cache <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 } else { \n \t3 if ( success <identifiersep> <identifier> . exists ( ) ) { \n \t4 success <identifiersep> <identifier> . delete ( ) ; } \n <ect>
\t4 <identifier> <identifiersep> command . add ( <string_literal> , snapshot <identifiersep> <identifier> . get <identifiersep> path ( ) ) ; \n \t4 <identifier> <identifiersep> command . add ( <string_literal> , snapshot <identifiersep> name ) ; \n \t4 final string result = <identifier> <identifiersep> command . execute ( ) ; \n \t4 if ( result != null ) { \n <ect>
\t5 cmd <identifiersep> <identifier> . add ( <string_literal> ) ; \n \t5 try { \n \t6 <identifier> <identifiersep> process ( cmd <identifiersep> <identifier> , <identifier> ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <string_literal> + thread . get <identifiersep> name + ' \\ <identifier> + <identifier> . <identifier> <identifiersep> string ( <string_literal> ) \n \t2 } . <identifier> <identifiersep> string ( <string_literal> ) \n \t1 <identifier> ! <identifier> <identifiersep> message ( new stack <identifiersep> trace ( instance <identifiersep> id , stack <identifiersep> trace <identifiersep> <identifier> ) ) } \n \t1 catch { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> dir ( ) ; \n \t1 run ( <string_literal> + db <identifiersep> name + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> result ( 0 , 0 , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> id = get <identifiersep> result ( 0 , 1 , true , <identifier> ) ; \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> configuration <identifiersep> dao . <identifier> ( configuration ) ; \n \t4 s <identifiersep> logger . info ( <string_literal> + provider <identifiersep> url + ( <identifier> <identifiersep> id == null ? <string_literal> : <string_literal> + <identifier> <identifiersep> id ) ) ; \n \t4 return create <identifiersep> <identifier> <identifiersep> configuration <identifiersep> response ( configuration ) ; \n \t3 } catch ( <identifier> <identifiersep> exception | io <identifiersep> exception e ) { \n <ect>
\t4 try ( input <identifiersep> stream input = request . get <identifiersep> input <identifiersep> stream ( ) ) { \n \t5 input . read ( <identifier> , 0 , ( int ) ( <identifier> <identifiersep> to <identifiersep> read - <identifier> > <identifier> . length ? <identifier> . length : <identifier> <identifiersep> to <identifiersep> read - <identifier> ) ) ; \n \t4 } catch ( io <identifiersep> exception ex ) { \n \t5 throw new <identifier> <identifiersep> exception ( <string_literal> , ex ) ; } } \n <ect>
\t2 <identifier> <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( test <identifiersep> user <identifiersep> id , <identifier> <identifiersep> <identifier> . get <identifiersep> item <identifiersep> id ( ) ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> user <identifiersep> exception <identifier> ) { \n \t2 <comment> \n \t2 <comment> \n <ect>
\t2 assert connection != null ; \n \t2 <identifier> <identifiersep> meta <identifiersep> data meta <identifiersep> data = connection . get <identifiersep> meta <identifiersep> data ( ) ; \n \t2 <identifier> <identifiersep> type <identifier> <identifiersep> type = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> type ( meta <identifiersep> data ) ; \n <ect>
\t2 meta <identifiersep> store <identifiersep> service . stop ( ) ; \n \t1 } catch ( exception e ) { \n \t2 <comment> \n \t2 <comment> \n <ect>
\t2 text <identifiersep> message msg = create <identifiersep> message ( ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> queue ( ) ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 msg . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to ( <identifier> <identifiersep> queue ) ; } \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( name ) && <identifier> . contains <identifiersep> key ( name ) ) { \n \t3 final <identifier> <identifiersep> policy policy = <identifier> . get ( name ) ; \n \t3 logger . debug ( <string_literal> , policy , name ) ; \n \t3 return <identifier> . of ( policy ) ; } \n <ect>
\t3 } else { \n \t4 runtime . get <identifiersep> runtime ( ) . <identifier> ( command <identifiersep> line ) ; \n \t4 logger . info ( <string_literal> , command <identifiersep> line ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 list < <identifier> <identifiersep> <identifier> > <identifier> = \n \t2 org . apache . <identifier> . config . configuration <identifiersep> <identifier> . get <identifiersep> <identifier> ( \n \t3 conf , <identifier> <identifiersep> <identifier> <identifiersep> key , <identifier> <identifiersep> <identifier> . class ) ; \n \t1 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> ) { \n <ect>
\t4 if ( start <identifiersep> connection ) { \n \t5 <identifier> <identifiersep> to <identifiersep> close . start ( ) ; } \n \t4 session <identifiersep> to <identifiersep> <identifier> = session <identifiersep> to <identifiersep> close ; } \n <ect>
\t6 { \n \t7 object <identifiersep> map <identifier> <identifiersep> map = <identifier> . get <identifiersep> object ( ) ; \n \t7 if ( <identifier> <identifiersep> map == null ) \n \t7 { \n <ect>
\t1 public < t > t instance <identifiersep> for ( class < t > <identifier> ) { \n \t1 <identifier> < ? > [ ] <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 <identifier> < ? > default <identifiersep> <identifier> = find <identifiersep> default <identifiersep> <identifier> ( <identifier> ) ; \n \t1 if ( default <identifiersep> <identifier> != null ) { \n <ect>
\t2 stream <identifiersep> <identifier> <identifier> = null ; \n \t2 result result ; \n \t2 try { \n <ect>
\t1 try { \n \t2 <identifier> . close ( ) ; \n \t1 } catch ( throwable t ) { \n \t2 log . error ( <string_literal> + <identifier> ) ; } } \n <ect>
\t1 try ( <identifier> <identifiersep> file . <identifier> <identifier> = \n \t3 <identifier> <identifiersep> file . create <identifiersep> <identifier> ( <identifier> , conf , out <identifiersep> file , text . class , cluster <identifiersep> <identifier> . class ) ) { \n \t2 for ( integer key : max <identifiersep> <identifier> . key <identifiersep> set ( ) ) { \n \t2 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> . get ( key ) , <identifier> <identifiersep> <identifier> . get ( key ) ) ; } \n <ect>
\t2 answer = <identifier> . get <identifiersep> answer ( <string_literal> ) ; \n \t2 if ( answer != null && answer instanceof get <identifiersep> <identifier> <identifiersep> r <identifiersep> version <identifiersep> answer ) { \n \t3 final get <identifiersep> <identifier> <identifiersep> r <identifiersep> version <identifiersep> answer version <identifiersep> answer = ( get <identifiersep> <identifier> <identifiersep> r <identifiersep> version <identifiersep> answer ) answer ; \n \t3 if ( answer == null || ! answer . get <identifiersep> result ( ) ) { \n <ect>
\t2 string <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> <identifiersep> name ( name ) ; \n \t2 if ( ! <identifier> . contains <identifiersep> key ( <identifier> <identifiersep> name ) ) { \n \t3 <identifier> <identifiersep> connection <identifiersep> pool <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifier> ; \n \t3 try { \n <ect>
\t3 if ( <identifier> <identifiersep> msg . <identifier> <identifiersep> task <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t4 try { \n \t5 <identifier> <identifiersep> process . write <identifiersep> task <identifiersep> <identifier> ( out <identifiersep> <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> config <identifier> <identifiersep> config = entry . get <identifiersep> value ( ) ; \n \t3 try ( <identifier> <identifiersep> <identifier> <identifier> = files . new <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> path <identifiersep> for <identifiersep> <identifier> <identifiersep> config ( <identifier> <identifiersep> config <identifiersep> id ) , <identifier> <identifiersep> <identifier> . <identifier> ) ) { \n \t4 <identifier> <identifiersep> config . <identifier> ( <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 } else if ( pool . get <identifiersep> type ( ) == storage <identifiersep> pool <identifiersep> type . <identifier> ) { \n \t4 return new answer ( cmd , false , \n \t6 <string_literal> ) ; \n \t3 } else if ( pool . get <identifiersep> type ( ) == storage <identifiersep> pool <identifiersep> type . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t5 this . <identifier> . <identifier> ( ) ; } \n \t3 } else { \n \t4 get <identifiersep> <identifier> ( ) . set <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null ) \n \t3 return false ; \n \t2 int <identifier> = get <identifiersep> <identifier> <identifiersep> index ( <identifier> <identifiersep> <identifier> <identifiersep> unit ) ; \n \t2 if ( <identifier> != - 1 ) { \n <ect>
\t2 assert <identifiersep> <identifier> ( <identifier> <identifiersep> create ( <string_literal> , <number_literal> , <identifier> . builder ( ) . put ( <string_literal> , <string_literal> ) ) ) ; \n \t2 num <identifiersep> shards num <identifiersep> shards = get <identifiersep> num <identifiersep> shards ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 cluster <identifiersep> <identifier> <identifiersep> response cluster <identifiersep> <identifier> = client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( <identifier> . <identifier> ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> <identifiersep> status ( ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> <identifiersep> shards ( num <identifiersep> shards . num <identifiersep> <identifier> * <number_literal> ) . execute ( ) . action <identifiersep> get ( ) ; \n <ect>
\t2 conn . set <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 conn . set <identifiersep> <identifier> ( configuration . is <identifiersep> <identifier> ( ) ) ; \n \t2 conn . set <identifiersep> <identifier> ( true ) ; \n <ect>
\t3 this . version = version ; \n \t2 } else if ( this . version != version ) { \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + this . version + <string_literal> + version ) ; } } \n \t1 void <identifier> <identifiersep> size <identifiersep> read ( int <identifier> <identifiersep> size ) { \n <ect>
<comment> \n \t1 public void test <identifiersep> <identifier> <identifiersep> listener ( ) throws exception { \n \t2 <comment> \n \t2 for ( int i = 0 ; i < <identifier> ; i ++ ) { \n <ect>
\t1 public set < event > <identifier> <identifiersep> <identifier> ( final request <identifiersep> context context ) { \n \t2 final registered <identifiersep> service service = <identifier> <identifiersep> registered <identifiersep> service <identifiersep> in <identifiersep> request <identifiersep> context ( context ) ; \n \t2 final authentication authentication = web <identifiersep> utils . get <identifiersep> authentication ( context ) ; \n \t2 if ( service == null || authentication == null ) { \n <ect>
\t1 else : \n \t1 logger . info ( <identifier> - <identifier> - <identifier> not found <identifier> <identifier> . ' <identifier> file <identifiersep> <identifier> ) \n <identifier> put <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> ignore ( <identifier> ) : \n \t1 if not <identifier> <identifiersep> <identifier> in <identifier> . config : \n <ect>
\t3 if ( not <identifiersep> <identifier> != null ) \n \t4 not <identifiersep> <identifier> . add ( node ) ; \n \t3 return ; } \n \t2 if ( id == node <identifiersep> id . node <identifiersep> id <identifiersep> <identifier> ) { \n <ect>
\t2 if ( entry . get <identifiersep> <identifier> <identifiersep> name ( ) != null && <identifier> . contains <identifiersep> key ( entry . get <identifiersep> <identifier> <identifiersep> name ( ) ) ) { \n \t3 string [ ] new <identifiersep> property = <identifier> . get ( entry . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 log . info ( <string_literal> + entry . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + new <identifiersep> property [ 0 ] + <string_literal> ) ; \n \t3 static <identifiersep> <identifier> <identifiersep> property <identifiersep> entry . update ( new <identifiersep> property [ 1 ] , new <identifiersep> property [ 0 ] , entry . get <identifiersep> value ( ) ) ; \n <ect>
\t2 <identifier> . put ( <string_literal> , <identifier> ) ; \n \t2 <identifier> . put ( <string_literal> , false ) ; \n \t2 service <identifiersep> <identifier> <identifier> = context . get <identifiersep> <identifier> <identifiersep> context ( ) . <identifier> <identifiersep> service ( <identifier> . class . get <identifiersep> name ( ) , <identifier> <identifiersep> client <identifiersep> <identifier> , <identifier> ) ; \n \t2 <identifier> . <identifier> ( as <identifiersep> <identifier> ( <identifier> ) ) ; \n <ect>
\t2 } catch ( security <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 return null ; \n \t2 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n <ect>
\t3 list < string > <identifier> ; \n \t3 try { \n \t4 <identifier> = files . read <identifiersep> all <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> config . <identifier> <identifiersep> config <identifiersep> file . to <identifiersep> path ( ) ) ; \n \t3 } catch ( io <identifiersep> exception io ) { \n <ect>
\t3 <identifier> <identifiersep> service . execute ( new <identifier> <identifiersep> job <identifiersep> update <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> job ) ) ; \n \t3 <comment> \n \t3 <identifier> <identifiersep> db <identifiersep> x <identifiersep> <identifier> . write <identifiersep> <identifier> <identifiersep> event ( <identifier> <identifiersep> action . get <identifiersep> <identifier> <identifiersep> xml ( ) , <identifier> <identifiersep> action . get <identifiersep> id ( ) , status . <identifier> , \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> <identifiersep> action ) ; \n <ect>
\t4 <identifier> <identifiersep> is <identifiersep> <identifier> = false ; } \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 logger . warn ( <string_literal> , <identifier> . get <identifiersep> message ( ) , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 { \n \t4 server <identifiersep> socket . close ( ) ; } \n \t3 catch ( io <identifiersep> exception <identifier> ) \n \t3 { \n <ect>
\t1 <identifier> = new output <identifiersep> stream <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n \t2 if ( e instanceof interrupted <identifiersep> io <identifiersep> exception ) { \n \t3 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; } \n <ect>
\t1 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifier> , <identifier> not <identifiersep> <identifier> ) throws api <identifiersep> exception , <identifier> <identifiersep> exception { \n \t2 log . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) + <string_literal> \n \t4 + not <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) . equals ( not <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ) ) { \n <ect>
<comment> \n \t1 public object handle ( message <identifier> ) throws exception { \n \t2 if ( server <identifiersep> <identifier> == null ) { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 final <identifier> <identifiersep> command <identifier> = <identifier> <identifiersep> resource . get <identifiersep> current <identifiersep> status ( get <identifiersep> id ( ) ) ; \n \t3 final request request = new request ( <identifier> <identifiersep> id , - 1 , <identifier> , false ) ; \n \t3 request . set <identifiersep> <identifier> ( get <identifiersep> next <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 s <identifiersep> logger . info ( ex ) ; \n \t3 s <identifiersep> logger . trace ( ex ) ; \n \t3 throw new server <identifiersep> api <identifiersep> exception ( base <identifiersep> cmd . <identifier> <identifiersep> <identifier> <identifiersep> error , ex . get <identifiersep> message ( ) ) ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 boolean <identifier> = is <identifiersep> <identifier> ( <identifier> ) ; \n \t3 if ( <identifier> ) { \n \t4 <identifier> = <identifier> < = 0 || not <identifiersep> <identifier> ( <identifier> , ip <identifiersep> set , <identifier> ) ; \n \t4 if ( ( ! <identifier> ) && <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 log . warn ( <identifier> <identifiersep> <identifier> <identifiersep> utils . class , <string_literal> ) ; \n \t3 return 0 ; } \n \t2 if ( <identifier> == null ) \n \t2 { \n <ect>
\t3 file device = new file ( <identifier> <identifiersep> port ) ; \n \t3 if ( device . <identifier> <identifiersep> read ( ) ) { \n \t4 <identifier> = device . get <identifiersep> <identifier> <identifiersep> path ( ) ; } \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t6 <identifier> <identifiersep> to <identifiersep> <identifier> . set <identifiersep> state ( <identifier> <identifiersep> <identifier> . state . <identifier> ) ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . update ( <identifier> <identifiersep> to <identifiersep> <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> to <identifiersep> <identifier> ) ; \n \t6 s <identifiersep> logger . trace ( <string_literal> + <identifier> <identifiersep> to <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; } } \n \t3 } catch ( exception ex ) { \n <ect>
\t3 <identifier> ++ ; } \n \t2 <identifier> ++ ; <comment> \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) { \n \t3 <identifier> <identifiersep> log . debug ( <string_literal> + <identifier> + <string_literal> + <identifier> ) ; \n <ect>
\t4 return - <number_literal> ; } \n \t3 <comment> \n \t3 if ( ! ( <identifier> . get <identifiersep> int <identifiersep> value ( <string_literal> , <string_literal> ) == 1 ) ) { \n \t4 if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t3 try { \n \t4 if ( <identifier> != null ) { \n \t5 <identifier> . close ( ) ; } \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <identifier> . <identifier> . api . <identifier> . <identifier> . model . <identifier> <identifiersep> list <identifier> = request <identifiersep> body ( <string_literal> , file <identifiersep> id ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <identifier> . get ( <string_literal> ) ) ; \n <ect>
\t2 try { \n \t3 <comment> \n \t3 shutdown <identifiersep> <identifier> . shutdown <identifiersep> <identifier> ( this , get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( throwable e ) { \n <ect>
<number_literal> <string_literal> \n <number_literal> + content <identifiersep> length + <string_literal> \n <number_literal> + <identifier> . get <identifiersep> message ( ) ) ; } \n \t2 } else { \n <ect>
\t8 + name + <string_literal> + e . to <identifiersep> string ( ) ) ; } } } \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> type <identifiersep> info ( ) throws configuration <identifiersep> exception { \n \t2 string type <identifiersep> info = get <identifiersep> property ( null , <string_literal> ) ; \n \t2 if ( type <identifiersep> info == null ) { \n <ect>
\t2 this . <identifier> = <identifier> ; } \n \t1 protected boolean <identifier> <identifiersep> <identifier> ( ) { \n \t2 <identifier> = <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 if ( <identifier> <identifiersep> context != null ) { \n \t5 try { \n \t6 <identifier> <identifiersep> context . close ( ) ; \n \t5 } catch ( throwable t ) { \n <ect>
\t3 public void run ( ) { \n \t4 try { \n \t5 process <identifiersep> <identifier> ( ) ; } \n \t4 catch ( exception ex ) { \n <ect>
\t5 <string_literal> ) ; } \n \t2 <comment> \n \t2 if ( ! new <identifiersep> service <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) && vm <identifiersep> instance . get <identifiersep> service <identifiersep> <identifier> <identifiersep> id ( ) == new <identifiersep> service <identifiersep> <identifier> . get <identifiersep> id ( ) ) { \n <ect>
\t3 if ( <identifier> <identifiersep> server <identifiersep> socket != null ) { \n \t4 try { \n \t5 <identifier> <identifiersep> server <identifiersep> socket . close ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . <identifier> ( new values ( <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> ) ) ; } \n \t1 public void <identifier> ( ) { \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 in = new file ( file <identifiersep> to <identifiersep> <identifier> ) ; \n \t4 if ( ! in . exists ( ) ) { \n \t5 log . warn ( <string_literal> + <identifier> <identifiersep> file ) ; } } \n \t3 if ( ! in . <identifier> <identifiersep> read ( ) ) { \n <ect>
\t3 read <identifiersep> url <identifiersep> file ( ) ; \n \t3 <comment> \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t2 try { \n \t3 if ( send <identifiersep> start <identifiersep> of <identifiersep> <identifier> ) { \n \t4 output <identifiersep> stream . write ( start <identifiersep> of <identifiersep> <identifier> ) ; \n \t3 } else { \n <ect>
\t1 public void thread <identifiersep> <identifier> ( ) { \n \t2 try { \n \t3 listener . thread <identifiersep> <identifier> ( ) ; \n \t2 } catch ( remote <identifiersep> exception <identifier> ) { \n <ect>
\t1 <comment> \n \t1 log . error ( <string_literal> ) ; \n \t1 log . error ( <string_literal> ) ; \n \t1 log . error ( <string_literal> ) ; \n <ect>
\t1 <identifier> . close ( ) ; \n \t1 log . info ( <string_literal> ) ; \n \t1 set < string > files <identifiersep> <identifier> = conn <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> files ( <identifier> <identifiersep> <identifier> ) , \n \t2 files <identifiersep> <identifier> = conn <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> files ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n \t4 return num <identifiersep> <identifier> == listener . count ; } \n \t2 } ) ) ; \n <ect>
\t3 if ( ! <identifier> . equals ( user <identifiersep> info . get ( <string_literal> ) ) ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + <string_literal> + url ) ; \n \t4 return - 1 ; } \n \t2 } else { \n <ect>
\t2 logger log = logger <identifiersep> factory . get <identifiersep> logger ( test <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n \t2 log . trace ( <string_literal> ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n <ect>
\t2 event <identifiersep> list . add ( event ) ; \n \t2 log . info ( <string_literal> + event ) ; } \n \t1 public void process <identifiersep> read ( @ <identifier> @ <identifier> <identifiersep> process @ <identifier> <identifiersep> read ( context = <string_literal> ) string event ) { \n \t2 event <identifiersep> list . add ( event ) ; \n <ect>
\t3 } else { \n \t4 logger . warn ( string . format ( <string_literal> , \n \t6 event . get <identifiersep> node <identifiersep> id ( ) , item . get <identifiersep> name ( ) , <identifier> ) ) ; } \n \t2 } else { \n <ect>
\t3 <identifier> <identifiersep> resource <identifiersep> <identifier> <identifiersep> map . put ( resource . resource <identifiersep> type . <identifier> , long . parse <identifiersep> long ( <identifier> <identifiersep> config <identifiersep> dao . get <identifiersep> value ( config . default <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> . key ( ) ) ) ) ; \n \t3 <identifier> <identifiersep> resource <identifiersep> <identifier> <identifiersep> map . put ( resource . resource <identifiersep> type . <identifier> <identifiersep> storage , long . parse <identifiersep> long ( <identifier> <identifiersep> config <identifiersep> dao . get <identifiersep> value ( config . default <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> storage . key ( ) ) ) ) ; \n \t3 <identifier> <identifiersep> resource <identifiersep> <identifier> <identifiersep> map . put ( resource . resource <identifiersep> type . <identifier> <identifiersep> storage , long . parse <identifiersep> long ( <identifier> <identifiersep> config <identifiersep> dao . get <identifiersep> value ( config . default <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> storage . key ( ) ) ) ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 if ( name == null || start == null || end == null || <identifier> == null || <identifier> == null || host <identifiersep> id == null || <identifier> == null || password == null ) { \n \t4 logger . warn ( <string_literal> ) ; \n \t3 } else { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> manager . create ( name , start , end , <identifier> , <identifier> , host <identifiersep> id , <identifier> , password , out <identifiersep> file ) ; \n <ect>
\t2 if ( <identifier> == 0 ) { \n \t3 log . debug ( <string_literal> , port ) ; \n \t3 super . stop ( ) ; \n \t2 } else { \n <ect>
\t3 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t3 list < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 { \n \t2 try ( transaction <identifiersep> log <identifiersep> catch <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = transaction <identifiersep> log <identifiersep> factory . create ( store <identifiersep> dir , <identifier> , <identifier> <identifiersep> cache , config , \n \t4 log <identifiersep> provider , from <identifiersep> <identifier> <identifiersep> id , as <identifiersep> <identifier> <identifiersep> of <identifiersep> store <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> store <identifiersep> dir ) ) \n \t2 { \n <ect>
\t4 logger . error ( <string_literal> , item . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , \n \t6 status <identifiersep> address . get <identifiersep> address <identifiersep> type ( ) ) ; \n \t4 break ; \n \t3 case output : \n <ect>
\t2 } catch ( throwable t ) { \n \t3 logger . error ( <string_literal> , t ) ; \n \t3 return false ; } \n \t2 if ( string <identifiersep> utils . is <identifiersep> empty ( name ) ) { \n <ect>
\t2 byte [ ] <identifier> = { } ; \n \t2 try { \n \t3 <identifier> = message <identifiersep> <identifier> . get <identifiersep> instance ( <string_literal> ) . <identifier> ( bytes ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 throw new illegal <identifiersep> state <identifiersep> exception ( format ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> command . get <identifiersep> process <identifiersep> id ( ) . get <identifiersep> key ( ) ) , e ) ; } } \n private static void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> data ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n \t1 <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . for <identifiersep> <identifier> ( <identifier> <identifiersep> dir - > { \n \t1 if ( <identifier> <identifiersep> dir . exists ( ) ) { \n <ect>
\t2 <identifier> = new <identifier> <identifiersep> string <identifiersep> object ( name , get <identifiersep> handle ) ; \n \t2 log . info ( <string_literal> , <identifier> . get <identifiersep> base <identifiersep> name ( ) ) ; \n \t2 assert . assert <identifiersep> false ( <identifier> <identifiersep> <identifier> . local <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> handle , <identifier> ) ) ; \n \t2 thread . <identifier> ( <number_literal> ) ; <comment> \n <ect>
\t3 boolean success = false ; \n \t3 try { \n \t4 success = <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> path , <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> method method = <identifier> . parse ( <identifier> , http <identifiersep> method . get , request ) ; \n \t3 execute <identifiersep> method ( method , result . <identifier> ( <identifier> ( ) ) . <identifier> <identifiersep> to ( method . get <identifiersep> <identifier> ( ) . get <identifiersep> type ( ) ) ) ; \n \t2 } catch ( <identifier> <identifiersep> not <identifiersep> found <identifiersep> exception | method <identifiersep> not <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( id , <identifier> <identifiersep> <identifier> <identifiersep> action . <identifier> ) ; } \n \t4 } else { \n \t5 s <identifiersep> logger . debug ( <string_literal> + id + <string_literal> ) ; } \n \t3 } catch ( final exception e ) { \n <ect>
\t2 ) ; \n \t2 try { \n \t2 file <identifiersep> system . close <identifiersep> all <identifiersep> for <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception exception ) { \n <ect>
\t3 <identifier> . <identifier> ( <string_literal> ) ; \n \t3 string <identifier> = <identifier> . to <identifiersep> string ( ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> root <identifiersep> x <identifiersep> path = <identifier> ; \n <ect>
public void <identifier> <identifiersep> first ( ) { \n \t1 try { \n \t1 <identifier> ( ) ; \n \t1 } catch ( x <identifiersep> path <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 log . debug ( <string_literal> ) ; \n \t4 result <identifiersep> <identifier> <identifiersep> manager . shutdown ( ) ; } \n \t3 catch ( throwable t ) { \n <ect>
\t3 } else if ( <identifier> <identifiersep> as <identifiersep> <identifier> ) { \n \t4 <comment> \n \t4 <comment> \n \t4 <identifier> [ i ] = new string <identifiersep> <identifier> ( <identifier> . get ( i ) , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 try { \n \t4 channel . send <identifiersep> response ( e ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n \t4 <identifier> . add <identifiersep> <identifier> ( e ) ; \n <ect>
\t1 double time <identifiersep> <identifier> = ( system . <identifier> <identifiersep> time ( ) - start <identifiersep> time ) / <number_literal> . 0 ; \n \t1 log . debug ( <string_literal> + <identifier> + <string_literal> + time <identifiersep> <identifier> + <string_literal> ) ; \n \t1 return result ; \n \t1 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 } else { \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> list . size ( ) ; i ++ ) { \n \t4 if ( ! <identifier> <identifiersep> list . get ( i ) . equals ( <identifier> <identifiersep> list . get ( i ) ) ) { \n \t5 status = false ; \n <ect>
\t2 <identifier> <identifiersep> storage <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( vm . get <identifiersep> id ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < t > <identifier> = get <identifiersep> vm <identifiersep> <identifier> ( vm ) ; \n \t2 <identifier> . <identifier> <identifiersep> <identifier> ( vm ) ; \n <ect>
\t2 char <identifiersep> <identifier> end = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( p . <identifier> ( 0 ) , type , true ) ; \n \t2 <identifier> = p . <identifier> ( end . <identifier> ( ) - p . <identifier> ( ) ) ; \n \t2 if ( p . char <identifiersep> <identifier> ( ) != type ) { \n <ect>
\t7 continue ; } \n \t6 <comment> \n \t6 found <identifiersep> all <identifiersep> <identifier> & = <identifier> <identifiersep> <identifier> <identifiersep> node <identifiersep> <identifier> . contains ( <identifier> <identifiersep> <identifier> ) ; } } \n \t4 if ( ! found <identifiersep> all <identifiersep> <identifier> ) { \n <ect>
\t5 directory <identifiersep> lock . <identifier> ( ) ; } \n \t3 } else { \n \t4 throw <identifier> . <identifier> ( new store <identifiersep> exception ( <string_literal> + lock <identifiersep> timeout <identifiersep> <identifier> + <string_literal> ) ) ; } \n \t2 } catch ( final interrupted <identifiersep> exception e ) { \n <ect>
\t1 <identifier> <identifiersep> log . warn ( <string_literal> , e ) ; \n \t1 throw e ; } \n \t1 catch ( runtime <identifiersep> exception e ) \n \t1 { \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
<comment> \n \t1 @ test ( timeout = <number_literal> ) <comment> \n \t1 public void test <identifiersep> task <identifiersep> manager <identifiersep> failure ( ) throws exception { \n \t2 <identifier> <identifiersep> true ( <string_literal> , ! is <identifiersep> new <identifiersep> mode ) ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 throw new io <identifiersep> exception ( e ) ; } \n \t1 return conn <identifiersep> manager ; } \n \t1 <comment> \n \t1 for ( manager <identifiersep> factory factory : <identifier> ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) ) ) ; \n \t2 cluster <identifiersep> info <identifiersep> service <identifier> = new cluster <identifiersep> info <identifiersep> service ( ) { \n \t3 @ <identifier> \n \t3 public cluster <identifiersep> info get <identifiersep> cluster <identifiersep> info ( ) { \n <ect>
\t1 <identifier> . set <identifiersep> input <identifiersep> format ( input <identifiersep> format . get <identifiersep> class ( ) ) ; \n \t1 file <identifiersep> status [ ] list <identifiersep> status = list <identifiersep> status ( <identifier> , dir ) ; \n \t1 for ( file <identifiersep> status status : list <identifiersep> status ) { \n \t2 log . info ( <string_literal> + status . get <identifiersep> <identifier> <identifiersep> size ( ) ) ; \n <ect>
\t5 template <identifiersep> data <identifiersep> store <identifiersep> vo <identifier> <identifiersep> <identifier> <identifiersep> store = template <identifiersep> data <identifiersep> store <identifiersep> dao . find <identifiersep> by <identifiersep> store <identifiersep> template ( data <identifiersep> store . get <identifiersep> id ( ) , <identifier> <identifiersep> id ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> store != null ) { \n \t6 return template <identifiersep> data <identifiersep> store <identifiersep> dao . remove ( <identifier> <identifiersep> <identifier> <identifiersep> store . get <identifiersep> id ( ) ) ; \n \t5 } else { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 int number = 0 ; \n \t2 for ( <identifier> <identifiersep> nodes <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 if ( <identifier> == null ) continue ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> throwable ( <identifier> ) ; \n \t5 if ( <identifier> instanceof <identifier> <identifiersep> error ) \n \t5 { \n \t6 if ( <identifier> != e ) <comment> \n <ect>
\t4 <identifier> <identifiersep> properties . get <identifiersep> authentication <identifiersep> method <identifiersep> name ( ) , \n \t4 authentication . get <identifiersep> attributes ( ) , false \n \t2 ) ; \n \t2 if ( <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> method ) { \n <ect>
\t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t4 <identifier> ( <string_literal> ) ; } \n \t3 <comment> \n \t3 try ( final <identifier> <identifier> = <identifier> . <identifier> ( ) ) { \n <ect>
\t4 consumer = <identifier> . create <identifiersep> consumer ( <identifier> ) ; \n \t4 while ( <identifier> < message <identifiersep> count ) { \n \t5 message msg = consumer . <identifier> ( <number_literal> ) ; \n \t5 if ( msg != null ) { \n <ect>
\t4 session . <identifier> <identifiersep> session ( ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n \t5 <identifier> <identifiersep> log . info ( <string_literal> + session ) ; \n \t3 } catch ( <identifier> <identifiersep> session <identifiersep> exception <identifier> ) { \n <ect>
\t1 read <identifiersep> <identifier> . <identifier> ( configuration , null , <identifier> ) ; \n \t1 return new <identifier> <identifiersep> <identifier> < group > ( <identifier> <identifiersep> file <identifiersep> path , read <identifiersep> <identifier> ) ; } \n private < t extends t <identifiersep> base < ? , ? > > path create <identifiersep> file ( t . . . t <identifiersep> <identifier> ) throws io <identifiersep> exception , interrupted <identifiersep> exception , t <identifiersep> exception { \n \t1 final path file <identifiersep> to <identifiersep> create = new path ( <string_literal> + t <identifiersep> <identifier> [ 0 ] . get <identifiersep> class ( ) + <string_literal> ) ; \n <ect>
\t3 final service service = web <identifiersep> utils . get <identifiersep> service ( context ) ; \n \t3 final authentication <identifier> = ticket <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> authentication <identifiersep> from ( ticket <identifiersep> <identifier> <identifiersep> ticket <identifiersep> id ) ; \n \t3 final registered <identifiersep> service registered <identifiersep> service = this . <identifier> <identifiersep> manager . find <identifiersep> service <identifiersep> by ( service ) ; \n \t3 if ( <identifier> != null && registered <identifiersep> service != null ) { \n <ect>
\t3 <string_literal> ; \n \t2 if ( source <identifiersep> <identifier> != null ) { \n \t3 if ( source <identifiersep> <identifier> . int <identifiersep> value ( ) < 0 ) source <identifiersep> <identifier> = default <identifiersep> source <identifiersep> <identifier> <identifiersep> size ; \n \t3 query <identifiersep> string += <string_literal> + string . value <identifiersep> of ( source <identifiersep> <identifier> . int <identifiersep> value ( ) + <string_literal> ) ; } \n <ect>
\t2 <identifier> <identifiersep> element <identifier> <identifiersep> <identifier> ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) == <identifier> <identifiersep> <identifier> . i ) { \n \t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t3 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) != <identifier> <identifiersep> <identifier> . m ) { \n <ect>
\t6 v = <identifier> <identifiersep> snapshot . get <identifiersep> <identifier> ( ) ; \n \t5 } else { \n \t6 v = 0 ; } \n \t5 log . info ( <string_literal> , <identifier> <identifiersep> type , v , name ) ; } } \n <ect>
\t3 if ( <identifier> . length == <number_literal> ) { \n \t4 type <identifiersep> token value <identifiersep> type = type <identifiersep> token . of ( <identifier> [ 1 ] ) ; \n \t4 <identifier> = value <identifiersep> type . get <identifiersep> <identifier> <identifiersep> type ( ) . equals ( string . class ) ; } } \n \t2 if ( ! <identifier> ) { \n <ect>
\t9 if ( ! <identifier> . delete ( path , true ) ) { \n \t10 throw new io <identifiersep> exception ( ) ; } } \n \t8 log . debug ( <string_literal> + path ) ; } \n \t7 catch ( exception ex ) { \n <ect>
\t2 { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 if ( <identifier> == null ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> id ( ) + <string_literal> ) ; \n \t4 continue ; } \n \t3 if ( ! <identifier> . get <identifiersep> result ( ) ) { \n <ect>
\t2 assert . assert <identifiersep> equals ( 1 , <identifier> . size ( ) ) ; \n \t2 method = <identifier> . get ( 0 ) ; \n \t2 list < <identifier> <identifiersep> result > list = <identifier> <identifiersep> java <identifiersep> <identifier> <identifiersep> <identifier> . parse <identifiersep> <identifier> <identifiersep> consumer <identifiersep> <identifier> ( method , true , true ) ; \n \t2 for ( <identifier> <identifiersep> result result : list ) { \n <ect>
\t3 this . <identifier> . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 throw new <identifier> <identifiersep> exception ( e . get <identifiersep> message ( ) ) ; } \n \t2 if ( ! <identifier> . is <identifiersep> shutdown ( ) ) { \n <ect>
\t2 } else { \n \t3 if ( ! <identifier> <identifiersep> r ( ) . is <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> <identifiersep> r ( ) . send <identifiersep> error ( <identifier> ) ; \n \t3 } else { \n <ect>
<comment> \n private long create <identifiersep> or <identifiersep> get <identifiersep> list <identifiersep> <identifier> ( long <identifier> ) { \n \t1 if ( <identifier> . has <identifiersep> list ( <identifier> ) ) { \n <ect>
\t1 <identifier> = <identifier> . run ( [ <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> , ' - <identifier> , <identifier> ( <identifier> ) ] ) \n \t1 if <identifier> [ <identifier> <identifiersep> <identifier> ] != 0 : \n \t2 <identifier> exception ( <string_literal> + <identifier> [ <identifier> ] + <identifier> [ <identifier> ] ) \n \t1 else : \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> id ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 s <identifiersep> logger . trace ( <string_literal> + <identifier> <identifiersep> id + <string_literal> ) ; \n \t3 return true ; } \n <ect>
\t5 } else { \n \t6 logger . warn ( <string_literal> { } . { } \\ <string_literal> , type <identifiersep> name , enum <identifiersep> property <identifiersep> name ) ; \n \t6 return <string_literal> + type <identifiersep> name + <string_literal> + enum <identifiersep> property <identifiersep> name ; } \n \t4 } else { \n <ect>
\t2 for ( local <identifiersep> port <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t3 try { \n \t4 <identifier> . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 test test = <identifier> <identifiersep> <identifier> . <identifier> ( test . class ) ; \n \t2 try { \n \t3 test . exception ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( ! <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . is <identifiersep> <identifier> ( ) ) { \n \t4 if ( ! <identifier> <identifiersep> <identifier> . has <identifiersep> <identifier> ( ) ) { \n \t5 <identifier> <identifiersep> <identifier> ++ ; } } } \n \t2 if ( <identifier> <identifiersep> <identifier> < <number_literal> && table <identifiersep> state != table <identifiersep> state . <identifier> ) { \n <ect>
\t2 if ( ( <identifier> == null ) || ( <identifier> . length < 1 ) ) \n \t3 return ( null ) ; \n \t2 <comment> \n <ect>
\t4 uri <identifier> <identifiersep> dir <identifiersep> uri = get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> dir ( ) . to <identifiersep> uri ( ) ; \n \t4 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) map < string , object > <identifier> = ( map < string , object > ) data . get ( <string_literal> ) ; \n \t4 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t5 uri <identifier> <identifiersep> path = <identifier> <identifiersep> dir <identifiersep> uri . <identifier> ( file . to <identifiersep> uri ( ) ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . parse <identifiersep> int ( <identifier> . get ( config . start <identifiersep> <identifier> . key ( ) ) , <number_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . parse <identifiersep> int ( <identifier> . get ( <string_literal> ) , <number_literal> ) ; \n \t2 <identifier> <identifiersep> host <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . parse <identifiersep> int ( <identifier> . get ( <string_literal> ) , <number_literal> ) ; \n \t2 <identifier> <identifiersep> storage <identifiersep> pool <identifiersep> <identifier> <identifiersep> wait <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . parse <identifiersep> int ( <identifier> . get ( <string_literal> ) , <number_literal> ) ; \n <ect>
\t4 <identifier> <identifiersep> context . get <identifiersep> service <identifiersep> <identifier> ( \n \t5 <identifier> <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , null ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 <identifier> . <identifier> = this . <identifier> ; \n \t3 <identifier> . <identifier> <identifiersep> <identifier> = this . <identifier> <identifiersep> <identifier> ; \n \t2 } catch ( exception e ) { \n \t3 <comment> \n <ect>
\t2 final ticket ticket = get <identifiersep> ticket ( ticket <identifiersep> id ) ; \n \t2 if ( ticket != null ) { \n \t3 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket ) ; \n \t3 if ( metadata == null ) { \n <ect>
\t3 element root = result . get <identifiersep> <identifier> ( ) . get <identifiersep> root <identifiersep> element ( ) ; \n \t3 root . <identifier> ( ) ; \n \t3 return root ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . <identifier> ( <identifier> <identifiersep> header ) ; \n \t2 <identifier> . <identifier> ( <string_literal> + request <identifiersep> service . get <identifiersep> current <identifiersep> request <identifiersep> id ( ) ) ; \n \t2 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> . set <identifiersep> status ( http <identifiersep> <identifier> <identifiersep> response . <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + error <identifiersep> message ) ; \n \t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception ( <string_literal> + error <identifiersep> message ) ; } \n \t3 return get <identifiersep> method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> string ( ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t4 ( <identifier> <identifiersep> object <identifiersep> builder < body > ) builder <identifiersep> factory . get <identifiersep> builder ( body . default <identifiersep> element <identifiersep> name ) ; \n \t2 final body body = body <identifiersep> builder . build <identifiersep> object ( \n \t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , body . default <identifiersep> element <identifiersep> local <identifiersep> name , <identifier> <identifiersep> <number_literal> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( ! body . get <identifiersep> <identifier> <identifiersep> xml <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t3 is <identifiersep> <identifier> = false ; } \n \t2 public void set <identifiersep> <identifier> ( string <identifier> <identifiersep> string ) { \n \t3 string [ ] <identifier> = <identifier> <identifiersep> string . <identifier> ( <string_literal> ) ; \n \t3 if ( <identifier> . length != <number_literal> ) { <comment> \n <ect>
\t1 } catch ( throwable e ) { \n \t1 try { \n \t2 stop ( ) ; \n \t1 } catch ( interrupted <identifiersep> exception <identifier> ) { \n <ect>
\t4 { \n \t5 <identifier> . close ( ) ; } } \n \t3 catch ( exception e ) \n \t3 { \n <ect>
\t9 if ( <identifier> . get <identifiersep> <identifier> ( ) > <number_literal> ) { \n <number_literal> s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) + <string_literal> ) ; } \n \t9 } else { \n <ect>
\t1 string <identifier> <identifiersep> <identifier> <identifiersep> host = find <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> host ( ) ; \n \t1 <identifier> <identifiersep> uri = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> uri ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> host , port ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> uri = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> uri ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> host , port ) ; \n \t1 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( <identifier> <identifiersep> <identifier> <identifiersep> host ) ) { \n <ect>
\t2 <identifier> s = null ; \n \t2 try { \n \t3 <identifier> = conn . storage <identifiersep> pool <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> string ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 @ test \n \t1 public void <identifier> <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception { \n \t2 <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n <ect>
\t2 if ( <identifier> != null ) { \n \t3 map < <identifier> <identifiersep> <identifier> , set < <identifier> > > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t3 for ( map . entry < <identifier> <identifiersep> <identifier> , set < <identifier> > > entry : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . entry <identifiersep> set ( ) ) { \n \t4 log . error ( <identifier> + <string_literal> + entry . get <identifiersep> key ( ) ) ; \n <ect>
\t4 <identifier> <identifiersep> logger . debug ( error ) ; } \n \t3 return error ; \n \t2 } catch ( security <identifiersep> exception ex ) { \n <ect>
\t5 while ( ( bytes <identifiersep> read = config <identifiersep> stream . read ( <identifier> ) ) != - 1 ) { \n \t6 out . write ( <identifier> , 0 , bytes <identifiersep> read ) ; } \n \t5 output = out . to <identifiersep> string ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> . name ( ) ) ; } \n \t4 catch ( exception <identifier> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 log . warn ( <string_literal> , \n \t6 transaction <identifiersep> key , <identifier> , <identifier> ) ; \n \t3 } else { \n <ect>
\t5 if ( ! store . is <identifiersep> <identifier> ( ) ) { \n \t6 try { \n \t7 store . close <identifiersep> <identifier> ( ) ; } \n \t6 catch ( runtime <identifiersep> exception <identifier> ) { \n <ect>
\t3 return true ; } } \n \t1 private public <identifiersep> key find <identifiersep> key <identifiersep> for <identifiersep> server <identifiersep> token ( input <identifiersep> stream <identifier> <identifiersep> <identifier> <identifiersep> input <identifiersep> stream , list < string > <identifier> <identifiersep> <identifier> ) { \n \t2 string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> context . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> to ( string . class , <identifier> <identifiersep> <identifier> <identifiersep> input <identifiersep> stream ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 assert <identifiersep> equals ( 1 , msg <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) ) ; \n \t2 assert <identifiersep> equals ( 1 , msg <identifiersep> <identifier> . size ( ) ) ; \n <ect>
\t1 public void <identifier> ( ) { \n \t2 final password <identifiersep> <identifier> <identifiersep> properties <identifier> = <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> . is <identifiersep> enabled ( ) ) { \n \t3 if ( ! <identifier> <identifiersep> manager . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 <identifier> <identifiersep> node <identifiersep> id node <identifiersep> id = entity <identifiersep> <identifier> . get <identifiersep> node <identifiersep> id <identifiersep> for <identifiersep> task <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t1 if ( node <identifiersep> id == null ) { \n \t1 if ( <identifier> <identifiersep> node != null ) { \n \t2 node <identifiersep> id = <identifier> <identifiersep> node <identifiersep> id . get <identifiersep> instance ( <identifier> <identifiersep> node . get <identifiersep> host ( ) , <identifier> <identifiersep> node . get <identifiersep> <identifier> <identifiersep> port ( ) ) ; } \n <ect>
\t6 case http <identifiersep> <identifier> . <identifier> . content <identifiersep> length : \n \t7 content <identifiersep> length = long . parse <identifiersep> long ( entry . get <identifiersep> value ( ) ) ; \n \t7 break ; } } \n \t4 logger . info ( <string_literal> + <identifier> ) ; \n <ect>
\t3 <identifier> . <identifier> ( ) . <identifier> ( ) . send ( config <identifiersep> <identifier> . instance . get <identifiersep> <identifier> <identifiersep> account ( ) \n \t5 + ( config <identifiersep> <identifier> . instance . get <identifiersep> <identifier> <identifiersep> account ( ) . <identifier> <identifiersep> with ( <string_literal> ) ? <string_literal> : <string_literal> ) , message ) . execute ( ) ; \n \t3 return true ; \n \t2 } catch ( <identifier> <identifiersep> exception | io <identifiersep> exception ex ) { \n <ect>
\t2 final boolean <identifier> ; \n \t2 final <identifier> <identifiersep> file <identifiersep> header . <identifier> <identifiersep> <identifier> header <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t2 final boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> || <identifier> <identifiersep> <identifier> == <identifier> <identifiersep> file <identifiersep> header . <identifier> <identifiersep> <identifier> . <identifier> || <identifier> <identifiersep> <identifier> || <identifier> != null ) { \n <ect>
\t1 @ test \n \t1 public void should <identifiersep> <identifier> <identifiersep> a <identifiersep> <identifier> <identifiersep> line <identifiersep> message <identifiersep> to <identifiersep> a <identifiersep> <identifier> <identifiersep> line ( ) \n \t1 { \n \t2 <comment> \n <ect>
\t5 . log ( <string_literal> ) ; \n \t3 throw new <identifier> <identifiersep> to <identifiersep> process <identifiersep> exception ( ) ; } \n \t2 <identifier> <identifiersep> type type <identifiersep> <identifier> = as <identifiersep> <identifier> ( type <identifiersep> <identifier> . get ( 0 ) ) ; \n \t2 if ( type <identifiersep> <identifier> . as <identifiersep> element ( ) . get <identifiersep> <identifier> ( ) != element <identifiersep> <identifier> . interface ) { \n <ect>
\t1 public void update ( <identifier> <identifiersep> object object ) throws io <identifiersep> exception { \n \t2 logger . info ( <string_literal> , object . to <identifiersep> string ( ) , object . build ( ) ) ; \n \t2 data . put ( object , object . build ( ) ) ; \n \t2 <identifier> ++ ; \n <ect>
\t3 <comment> \n \t3 service <identifiersep> action <identifiersep> <identifier> . execute ( current <identifiersep> context , <identifier> <identifiersep> <identifier> <identifiersep> action ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 create <identifiersep> snapshot <identifiersep> response create <identifiersep> snapshot <identifiersep> response = client . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> create <identifiersep> snapshot ( <string_literal> , <string_literal> ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( true ) . set <identifiersep> <identifier> ( <string_literal> ) . get ( ) ; \n \t2 assert <identifiersep> that ( create <identifiersep> snapshot <identifiersep> response . get <identifiersep> snapshot <identifiersep> info ( ) . <identifier> <identifiersep> shards ( ) , <identifier> <identifiersep> <identifier> ( 0 ) ) ; \n \t2 assert <identifiersep> that ( create <identifiersep> snapshot <identifiersep> response . get <identifiersep> snapshot <identifiersep> info ( ) . <identifier> <identifiersep> shards ( ) , equal <identifiersep> to ( create <identifiersep> snapshot <identifiersep> response . get <identifiersep> snapshot <identifiersep> info ( ) . total <identifiersep> shards ( ) ) ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> mode . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t4 log . info ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> stream <identifiersep> path = true ; \n \t3 } else { \n <ect>
\t2 check <identifiersep> argument ( <identifier> > 0 ) ; \n \t2 check <identifiersep> argument ( <identifier> < = <identifier> . size ( ) ) ; \n \t2 check <identifiersep> argument ( <identifier> . size ( ) < = <number_literal> ) ; <comment> \n \t2 if ( <identifier> . size ( ) > <number_literal> ) { \n <ect>
\t4 if ( <identifier> <identifiersep> stream != null ) { \n \t5 try { \n \t6 <identifier> <identifiersep> stream . close ( ) ; } \n \t5 catch ( io <identifiersep> exception io ) { \n <ect>
private void delete <identifiersep> table <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifier> , string table <identifiersep> name ) { \n \t1 try { \n \t1 <identifier> . execute ( <string_literal> + table <identifiersep> name ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> = socket <identifiersep> access . do <identifiersep> <identifier> ( ( ) - > client . <identifier> <identifiersep> <identifier> ( build <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> request ( ) ) ) ; \n \t2 } catch ( <identifier> <identifiersep> client <identifiersep> exception e ) { \n \t3 logger . info ( <string_literal> , e . get <identifiersep> message ( ) ) ; \n <ect>
\t3 <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> destination ( ) . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 session <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n \t3 if ( <identifier> == null ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t3 try { \n \t4 <identifier> <identifiersep> properties . set <identifiersep> <identifier> <identifiersep> <identifier> ( integer . parse <identifiersep> int ( <identifier> <identifiersep> <identifier> ) ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t1 int error <identifiersep> code = <identifier> . wait <identifiersep> for ( ) ; \n \t1 output . <identifier> ( ) ; \n \t1 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> name + <string_literal> + <identifier> <identifiersep> file <identifiersep> name ) ; \n \t1 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> name + <string_literal> + <identifier> <identifiersep> file <identifiersep> name + <string_literal> + output . get <identifiersep> return <identifiersep> value ( ) ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> . shutdown ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t3 if ( source <identifiersep> node == null ) { \n \t4 logger . trace ( <string_literal> , <identifier> <identifiersep> routing . <identifier> <identifiersep> id ( ) ) ; \n \t4 return ; } } \n \t2 try { \n <ect>
\t2 <comment> \n \t2 for ( long <identifier> : group <identifiersep> <identifier> . values ( ) ) { \n <ect>
\t2 public void on <identifiersep> close ( web <identifiersep> socket <identifier> , int code , string <identifier> ) { \n \t3 log . info ( <string_literal> ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> error ( throwable t ) { \n <ect>
\t2 <comment> \n \t2 log . info ( <string_literal> \n \t3 + <string_literal> \n \t3 + <string_literal> ) ; } \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> <identifiersep> port ( ) == null ) { \n \t3 <identifier> . set <identifiersep> <identifier> <identifiersep> port ( - 1 ) ; } } \n \t2 <identifier> . <identifier> ( ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> db <identifiersep> properties . get <identifiersep> endpoint ( ) ) ) { \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> db <identifiersep> properties . get <identifiersep> endpoint ( ) ) ; \n \t3 client . set <identifiersep> endpoint ( <identifier> <identifiersep> db <identifiersep> properties . get <identifiersep> endpoint ( ) ) ; } \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> db <identifiersep> properties . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t3 final <identifier> <identifiersep> result group <identifiersep> result = response . get <identifiersep> result ( ) ; \n \t3 for ( final <identifier> <identifiersep> entry entry : group <identifiersep> result . get <identifiersep> <identifier> ( ) ) { \n \t4 final <identifier> <identifiersep> attribute group <identifiersep> attribute = entry . get <identifiersep> attribute ( this . group <identifiersep> attribute <identifiersep> name ) ; \n \t4 if ( group <identifiersep> attribute == null ) { \n <ect>
\t2 try { \n \t3 thread . <identifier> ( check <identifiersep> <identifier> ) ; \n \t3 return false ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 while ( new <identifiersep> <identifier> <identifiersep> enum . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) \n \t2 { \n \t3 string group <identifiersep> name = new <identifiersep> <identifier> <identifiersep> enum . next <identifiersep> element ( ) ; \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> <identifiersep> request . get <identifiersep> <identifier> ( ) ) || ! string <identifiersep> utils . equals ( <identifier> <identifiersep> request . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> <identifier> ( ) ) ) { \n \t3 logger . warn ( <string_literal> , <identifier> <identifiersep> request . get <identifiersep> <identifier> ( ) , <identifier> ) ; \n \t3 throw new <identifier> <identifiersep> service <identifiersep> exception ( <identifier> <identifiersep> service <identifiersep> exception . code <identifiersep> <identifier> <identifiersep> service , string <identifiersep> utils . empty ) ; } \n \t2 if ( ! string <identifiersep> utils . equals ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t5 queue <identifiersep> <identifier> <identifiersep> source ( request ) ; } \n \t4 break ; \n \t3 case transaction <identifiersep> log : \n \t4 queue <identifiersep> <identifier> <identifiersep> source ( request ) ; \n <ect>
\t1 set <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t1 if ( <identifier> != null ) { \n \t1 <identifier> . close ( ) ; } \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> client . close ( ) ; \n <ect>
\t2 int <identifier> <identifiersep> length = to <identifiersep> be <identifiersep> <identifier> . length ( ) ; \n \t2 for ( int <identifier> = <identifier> <identifiersep> length ; <identifier> > 0 ; <identifier> -- ) { \n \t3 if ( <identifier> < <identifier> <identifiersep> length ) { \n \t4 current <identifiersep> <identifier> = to <identifiersep> be <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> length - <identifier> , <identifier> <identifiersep> length ) ; \n <ect>
\t4 response <identifiersep> body <identifiersep> <identifier> = byte <identifiersep> <identifier> . to <identifiersep> byte <identifiersep> array ( method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) ) ; \n \t3 } catch ( http <identifiersep> exception e ) { \n \t4 logger . error ( <string_literal> , e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 private void start <identifiersep> web <identifiersep> server ( ) { \n \t2 log . info ( <string_literal> ) ; \n \t2 this . http <identifiersep> server . start ( ) ; } \n \t1 private void start <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> thread ( ) { \n <ect>
\t6 . get <identifiersep> state ( ) ) { \n \t6 case <identifier> : \n \t7 <comment> \n \t7 <comment> \n <ect>
\t6 break ; } \n \t5 if ( <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t6 <comment> \n \t6 <identifier> . <identifier> ( c ) ; \n <ect>
\t1 log . info ( <string_literal> + \n \t2 ( <identifier> == null ? <string_literal> : <identifier> ) ) ; } \n void <identifier> <identifiersep> host <identifiersep> request <identifiersep> failed ( host <identifiersep> <identifier> <identifiersep> status status , throwable <identifier> , <identifier> <identifiersep> state <identifier> <identifiersep> state ) { \n \t1 string error <identifiersep> message = string <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> root <identifiersep> <identifier> ( <identifier> ) . get <identifiersep> message ( ) , <string_literal> ) ; \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> . <identifier> ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 count = 0 ; } \n \t3 } catch ( throwable t ) { \n \t4 logger . warn ( <string_literal> , t ) ; } } \n \t2 shutdown ( ) ; \n <ect>
\t3 { \n \t4 logger . warn ( <string_literal> ) ; } } \n \t2 catch ( throwable t ) \n \t2 { \n <ect>
\t2 int <identifier> = size ( get <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> ( ) ) ; \n \t2 if ( current > 0 ) { \n \t3 log . info ( <string_literal> + current + <string_literal> + get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 } else { \n <ect>
\t5 int <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> in <identifiersep> <identifier> = <identifier> <identifiersep> provider . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time ( <identifier> ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> in <identifiersep> <identifier> > 0 ) { \n \t6 if ( ! m <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> read ( <identifier> , \n \t8 <identifier> <identifiersep> provider . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time ( <identifier> ) ) ) { \n <ect>
\t8 <identifier> <identifiersep> thread <identifiersep> event <identifiersep> <identifier> . this , <identifier> <identifiersep> state , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t7 break ; } } \n \t5 <comment> \n \t5 if ( success && <identifier> <identifiersep> shutdown <identifiersep> start <identifiersep> time == 0 ) { \n <ect>
\t3 <identifier> <identifiersep> log . debug ( <string_literal> , path ) ; } \n \t2 else \n \t2 { \n \t3 <identifier> <identifiersep> event <identifiersep> <identifier> . <identifier> <identifiersep> remove ( property ) ; \n <ect>
\t5 time <identifiersep> unit . <identifier> . <identifier> ( <number_literal> ) ; \n \t5 <identifier> <identifiersep> connection . close ( ) ; \n \t4 } catch ( exception e ) { \n \t5 log . error ( <string_literal> , e ) ; } } \n <ect>
\t1 public synchronized boolean shutdown ( ) { \n \t2 if ( channel == null ) { \n \t3 return false ; } \n \t2 address address = channel . get <identifiersep> address ( ) ; \n <ect>
\t1 if ( ! get <identifiersep> and <identifiersep> set <identifiersep> <identifier> ( true ) ) { \n \t1 <identifier> . new <identifiersep> thread ( new <identifier> ( ) { \n \t2 @ <identifier> \n \t2 public void run ( ) { \n <ect>
\t1 <comment> \n \t1 status <identifiersep> cmd . set <identifiersep> <identifier> <identifiersep> state ( <identifier> . get <identifiersep> <identifier> <identifiersep> state ( ) ) ; \n \t1 status <identifiersep> cmd . set <identifiersep> has <identifiersep> <identifier> <identifiersep> <identifier> ( config <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> ) ) ; \n \t1 if ( get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . should <identifiersep> send <identifiersep> execution <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> name ) ) { \n <ect>
\t2 return <identifier> <identifiersep> <identifier> <identifiersep> level . <identifier> <identifiersep> <identifier> ; \n \t1 case ignore : \n \t2 return null ; \n \t1 default : \n <ect>
\t1 public void <identifier> ( ) { \n \t2 try { \n \t3 configuration . <identifier> ( ) ; \n \t2 } catch ( configuration <identifiersep> exception e ) { \n <ect>
\t2 files <identifiersep> to <identifiersep> remove . add ( entry . get <identifiersep> key ( ) ) ; \n \t2 file <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new file <identifiersep> <identifier> ( <identifier> <identifiersep> path , new path ( <identifier> <identifiersep> path ) ) ; \n \t2 files <identifiersep> to <identifiersep> add . put ( <identifier> <identifiersep> <identifier> , entry . get <identifiersep> value ( ) ) ; \n \t2 <identifier> . <identifier> . put ( <identifier> <identifiersep> <identifier> , entry . get <identifiersep> value ( ) ) ; \n <ect>
\t2 snapshot <identifiersep> info . set <identifiersep> volume <identifiersep> id ( volume <identifiersep> id ) ; \n \t2 snapshot <identifiersep> info . set <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 snapshot <identifiersep> info . set <identifiersep> size <identifiersep> <identifier> ( source <identifiersep> volume <identifiersep> info . get <identifiersep> size ( ) ) ; \n \t2 snapshot <identifiersep> info . set <identifiersep> status ( storage <identifiersep> properties . status . <identifier> . to <identifiersep> string ( ) ) ; \n <ect>
\t2 <identifier> <identifier> ; \n \t2 try { \n \t3 <identifier> = execute ( template <identifiersep> name ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t7 case <identifier> : \n \t8 <identifier> <identifiersep> value <identifiersep> <identifier> = device . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> ( - 1 ) ; \n \t8 break ; \n \t7 default : \n <ect>
\t5 continue ; } \n \t4 <comment> \n \t4 boolean success = remove <identifiersep> entry ( <identifier> , key ) != null ; \n \t4 if ( success ) \n <ect>
\t2 } else { \n \t3 log <identifiersep> failure <identifiersep> and <identifiersep> wait ( action , io <identifiersep> exception , <identifier> , e ) ; } } \n \t1 @ <identifier> \n \t1 public synchronized void <identifier> <identifiersep> lock ( ) throws exception { \n <ect>
\t2 final <identifier> < <identifier> <identifiersep> registered <identifiersep> service , <identifier> <identifiersep> registered <identifiersep> service <identifiersep> service <identifiersep> provider <identifiersep> metadata <identifiersep> <identifier> > <identifier> = get <identifiersep> registered <identifiersep> service <identifiersep> and <identifiersep> <identifier> ( <identifier> <identifiersep> request ) ; \n \t2 final <identifier> <identifiersep> registered <identifiersep> service <identifiersep> service <identifiersep> provider <identifiersep> metadata <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> value ( ) ; \n \t2 final string <identifier> = string <identifiersep> utils . default <identifiersep> if <identifiersep> blank ( <identifier> <identifiersep> request . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> uri ) ; \n \t2 logger . debug ( <string_literal> , <identifier> , <identifier> <identifiersep> request . get <identifiersep> <identifier> ( ) . get <identifiersep> value ( ) ) ; \n <ect>
\t3 . execute ( new web <identifiersep> socket <identifiersep> <identifier> <identifiersep> handler . builder ( ) . add <identifiersep> web <identifiersep> socket <identifiersep> listener ( new web <identifiersep> socket <identifiersep> listener ( ) { \n \t4 @ <identifier> \n \t4 public void on <identifiersep> text <identifiersep> <identifier> ( string message , boolean final <identifiersep> <identifier> , int <identifier> ) { \n \t5 <identifier> . add ( message ) ; \n <ect>
\t3 if ( count == 1 ) { \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> file ( get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file ( ) , <identifier> <identifiersep> <identifier> <identifiersep> file ) ; \n \t4 return <identifier> <identifiersep> <identifier> <identifiersep> file ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> == null ) { \n \t4 <identifier> = request <identifiersep> utils . application <identifiersep> class ( factory <identifiersep> class ) ; } \n \t3 factory = ( <identifier> <identifiersep> config <identifiersep> factory ) <identifier> . new <identifiersep> instance ( ) ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t2 if ( this . lock <identifiersep> file != null ) { \n \t3 this . lock <identifiersep> file . <identifier> ( ) ; } \n \t2 this . lock <identifiersep> file = null ; \n \t2 this . <identifier> = false ; \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> + private <identifiersep> ip + <string_literal> + <identifier> <identifiersep> result . get <identifiersep> <identifier> ( ) ) ; } \n \t2 if ( <identifier> . equals ( <string_literal> ) || <identifier> . equals ( <string_literal> ) ) { \n \t3 string result = <identifier> <identifiersep> result . get <identifiersep> <identifier> ( ) ; \n \t3 if ( result == null || result . is <identifiersep> empty ( ) ) { \n <ect>
\t4 public void execute ( string context <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> context <identifier> <identifiersep> context ) \n \t5 throws exception { \n \t5 <comment> \n \t5 string <identifier> <identifiersep> <identifier> <identifiersep> value = <identifier> <identifiersep> context . <identifier> <identifiersep> property <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 true ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 try { \n \t4 pool . execute <identifiersep> with <identifiersep> <identifier> ( <identifier> <identifiersep> operation , run <identifiersep> <identifier> . get ( ) ) ; \n <ect>
\t5 byte <identifiersep> array <identifiersep> <identifier> <identifiersep> access <identifiersep> <identifier> t = new byte <identifiersep> array <identifiersep> <identifier> <identifiersep> access <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . to <identifiersep> byte <identifiersep> array ( ) ) ; \n \t5 t . set <identifiersep> read <identifiersep> <identifier> ( ) ; \n \t5 return t ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 sql <identifiersep> <identifier> [ exception <identifiersep> to <identifiersep> throw ] ) ; } \n \t1 conn . <identifier> ( ) ; \n \t1 thread . failed <identifiersep> <identifier> = false ; \n \t1 } catch ( sql <identifiersep> exception <identifier> <identifiersep> sql <identifiersep> ex ) { \n <ect>
\t5 { \n \t6 if ( <identifier> . get <identifiersep> index <identifiersep> type ( ) != null ) \n \t7 throw new <identifier> <identifiersep> request <identifiersep> exception ( <string_literal> ) ; \n <ect>
\t3 <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t3 if ( ! <identifier> . next ( ) ) { \n \t4 s <identifiersep> logger . error ( <string_literal> ) ; \n \t3 } else if ( <identifier> . get <identifiersep> string ( 1 ) != null || <identifier> . get <identifiersep> string ( <number_literal> ) != null ) { \n <ect>
\t4 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> ) ; } \n \t2 } else { \n \t3 s <identifiersep> logger . info ( <string_literal> ) ; \n \t3 if ( <identifier> . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
\t3 try { \n \t4 <identifier> . connection <identifiersep> pool <identifiersep> <identifier> ( event ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
@ <identifier> \n public void handle <identifiersep> event ( service <identifiersep> <identifier> <identifiersep> host <identifiersep> event event ) \n \t1 throws <identifier> <identifiersep> state <identifiersep> <identifier> <identifiersep> exception { \n <ect>
\t6 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t6 <identifier> . put ( thread . current <identifiersep> thread ( ) , e ) ; } \n \t5 assert <identifiersep> true ( <string_literal> , first ) ; \n \t5 if ( <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) == total <identifiersep> message <identifiersep> count ) { \n <ect>
\t3 log . warn ( <string_literal> , \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> byte <identifiersep> count ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) , \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> byte <identifiersep> count ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) ; } \n \t2 if ( <identifier> && ! <identifier> ) { \n <ect>
\t2 if ( json . contains <identifiersep> key ( <string_literal> ) ) { \n \t2 json <identifiersep> array <identifier> = ( json <identifiersep> array ) json . get ( <string_literal> ) ; \n \t2 if ( <identifier> . size ( ) > 0 ) return true ; } } \n \t1 } catch ( <identifier> <identifiersep> http <identifiersep> exception e ) { \n <ect>
\t3 public void on <identifiersep> failure ( string source , exception e ) { \n \t4 failure . set ( e ) ; \n \t4 <identifier> . count <identifiersep> <identifier> ( ) ; } \n \t2 } ) ; \n <ect>
\t2 final <identifier> <identifiersep> map < string , state > <identifier> = new <identifier> <identifiersep> map < string , state > ( ) ; \n \t2 synchronized ( <identifier> <identifiersep> <identifier> ) { \n \t3 new <identifiersep> <identifier> = get <identifiersep> all <identifiersep> <identifier> ( ) ; \n \t3 if ( new <identifiersep> <identifier> == null ) { \n <ect>
\t2 return <string_literal> ; } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> start ( ) { \n <ect>
\t4 node <identifiersep> model . add <identifiersep> <identifier> ( source , target , <identifier> ) ; } } \n \t2 logger . debug ( <string_literal> + this . <identifier> . size ( ) + <string_literal> ) ; \n \t2 int model <identifiersep> num = 1 ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < node , <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> model : this . <identifier> ) { \n <ect>
\t1 if ( conn != null ) { \n \t1 try { \n \t2 conn . close ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 try { \n \t1 if ( <identifier> <identifiersep> server != null && <identifier> <identifiersep> server . is <identifiersep> registered ( get <identifiersep> m <identifiersep> bean <identifiersep> object <identifiersep> name ( ) ) ) { \n \t2 <identifier> <identifiersep> server . <identifier> <identifiersep> m <identifiersep> bean ( get <identifiersep> m <identifiersep> bean <identifiersep> object <identifiersep> name ( ) ) ; } \n \t1 } catch ( final <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 string [ ] <identifier> <identifiersep> <identifier> = { <string_literal> , new file ( <identifier> <identifiersep> dir , <string_literal> ) . get <identifiersep> <identifier> <identifiersep> path ( ) , <string_literal> , <string_literal> , \n \t4 <string_literal> , <string_literal> } ; \n \t2 <identifier> <identifiersep> log <identifiersep> <identifier> log <identifiersep> <identifier> = new <identifier> <identifiersep> log <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <comment> \n \t3 context . set <identifiersep> current <identifiersep> user ( <identifier> ) ; \n \t3 request . get <identifiersep> session ( ) . set <identifiersep> attribute ( <string_literal> , true ) ; \n \t3 <identifier> <identifiersep> service <identifiersep> factory . get <identifiersep> instance ( ) . get <identifiersep> authentication <identifiersep> service ( ) . <identifier> <identifiersep> e <identifiersep> <identifier> ( context , request , <identifier> ) ; \n <ect>
\t1 public string get <identifiersep> <identifier> ( ) { \n \t2 string data <identifiersep> path = <identifier> <identifiersep> meta . get <identifiersep> local <identifiersep> dir ( ) ; \n \t2 file <identifier> = new file ( data <identifiersep> path + <string_literal> + start <identifiersep> type + <string_literal> ) ; \n \t2 if ( <identifier> . list <identifiersep> files ( ) == null || <identifier> . list <identifiersep> files ( ) . length == 0 ) { \n <ect>
\t2 job <identifier> <identifiersep> job = get <identifiersep> job <identifiersep> by <identifiersep> operation <identifiersep> id ( <identifier> <identifiersep> <identifier> <identifiersep> query . operation <identifiersep> id ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> id <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> query <identifiersep> id ( <identifier> <identifiersep> <identifier> <identifiersep> query ) ; \n \t2 <identifier> <identifiersep> job = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> query , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> job ) ; \n \t2 } catch ( item <identifiersep> not <identifiersep> found item <identifiersep> not <identifiersep> found ) { \n <ect>
\t4 try { \n \t5 int value = integer . parse <identifiersep> int ( property ) ; \n \t5 this . set <identifiersep> <identifier> <identifiersep> size ( value ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 logger . error ( <string_literal> ) ; \n \t4 return ; } } \n \t2 if ( <identifier> <identifiersep> list . get <identifiersep> length ( ) > 1 ) \n \t2 { \n <ect>
\t4 log . warn ( <string_literal> , get <identifiersep> name ( ) ) ; \n \t4 <identifier> <identifiersep> <identifier> ( null , null , false ) ; \n \t3 } else if ( ( start <identifiersep> time > 0 ) || ( <identifier> <identifiersep> start <identifiersep> time > 0 ) || ( <identifier> <identifiersep> start <identifiersep> time > 0 ) ) { \n \t4 <comment> \n <ect>
\t4 } else { \n \t5 <comment> \n \t5 if ( meta <identifiersep> size > max <identifiersep> metadata <identifiersep> size ) { \n \t6 if ( log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 assert . assert <identifiersep> equals ( i . double <identifiersep> value ( ) / <number_literal> , has <identifiersep> <identifier> . get ( i . to <identifiersep> string ( ) ) ) ; } \n \t2 assert . assert <identifiersep> equals ( <identifier> <identifiersep> default , has <identifiersep> <identifier> . get ( <string_literal> ) ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) { \n <ect>
\t4 if ( response <identifiersep> code == <number_literal> ) { \n \t5 input <identifiersep> stream input = method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) ; \n \t5 element <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( server , input ) ; \n \t5 map < string , string > values = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( <identifier> , new string [ ] { <string_literal> } ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> token . <identifier> ( <identifier> ) ) { \n \t3 <identifier> = true ; \n \t3 log . debug ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t3 for ( string id : this . address <identifiersep> <identifier> ) { \n \t4 if ( this . <identifier> . address ( ) . delete ( <identifier> . get <identifiersep> id ( ) , id ) . is <identifiersep> success ( ) ) { \n \t5 log . info ( <string_literal> , <identifier> . get <identifiersep> id ( ) , id ) ; \n \t4 } else { \n <ect>
\t3 <identifier> . error ( e ) ; \n \t3 <identifier> ( ) ; } } \n \t1 protected void <identifier> ( ) { \n \t2 if ( <identifier> < = 0 ) { \n <ect>
\t2 return <identifier> . to <identifiersep> array ( new string [ <identifier> . size ( ) ] ) ; } \n \t1 public void execute ( ) throws exception { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> thread . set <identifiersep> <identifier> ( true ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> thread . start ( ) ; \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> user <identifiersep> <identifier> <identifiersep> create <identifiersep> and <identifiersep> delete <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> <identifiersep> to <identifiersep> client <identifiersep> <identifier> ( <string_literal> , <string_literal> ) ; \n \t2 client <identifiersep> <identifier> . create <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t2 } catch ( interrupted <identifiersep> exception <identifier> ) { \n \t3 log . warn ( <string_literal> + <identifier> , <identifier> ) ; \n \t3 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n \t2 } catch ( execution <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 public void build <identifiersep> <identifier> ( destination client , client <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 <identifier> <identifier> = client . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t1 @ <identifier> \n \t1 public boolean <identifier> <identifiersep> <identifier> ( @ <identifier> <identifiersep> null final <identifier> <identifier> , @ <identifier> <identifiersep> null final password <identifiersep> <identifier> <identifiersep> bean bean ) { \n \t2 final <identifier> <identifiersep> password <identifiersep> <identifier> c = ( <identifier> <identifiersep> password <identifiersep> <identifier> ) <identifier> ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( c . get <identifiersep> password ( ) ) || string <identifiersep> utils . is <identifiersep> blank ( bean . get <identifiersep> password ( ) ) ) { \n <ect>
\t4 <identifier> <identifier> = <identifier> . create <identifiersep> <identifier> ( ) ; \n \t4 log . info ( <string_literal> ) ; \n \t4 <comment> \n \t4 thread . <identifier> ( max <identifiersep> last <identifiersep> <identifier> <identifiersep> <identifier> + <number_literal> ) ; \n <ect>
\t6 + <string_literal> ) ; } \n \t3 properties <identifier> = new properties ( ) ; \n \t3 <identifier> <identifiersep> <identifier> . load <identifiersep> properties ( <identifier> , property <identifiersep> stream ) ; \n \t3 property <identifiersep> stream . close ( ) ; \n <ect>
\t2 default <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context default <identifiersep> context = new default <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( context ) ; \n \t2 if ( <identifier> <identifiersep> type == <identifier> <identifiersep> <identifier> <identifiersep> context . <identifier> <identifiersep> type <identifiersep> <identifier> ) { \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> ( default <identifiersep> context ) ; } \n <ect>
\t1 user <identifiersep> entity user <identifiersep> entity ; \n \t1 try { \n \t2 user <identifiersep> entity = create <identifiersep> user ( user <identifiersep> name , user <identifiersep> name , user <identifiersep> name , true ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 final string <identifier> <identifiersep> handle = ( string ) <identifier> <identifiersep> map . get ( <identifier> <identifiersep> id <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t4 if ( <identifier> <identifiersep> handle != null ) { \n \t5 return server <identifiersep> manager . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . load ( <identifier> <identifiersep> handle ) ; } } \n \t2 } catch ( final message <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 logger . info ( <string_literal> ) ; \n \t3 device <identifiersep> info <identifiersep> <identifier> <identifier> <identifiersep> info <identifiersep> <identifier> = client . get <identifiersep> device <identifiersep> info ( ) ; \n \t3 if ( <identifier> <identifiersep> info <identifiersep> <identifier> == null ) { \n <ect>
\t2 else { \n \t3 throw new <identifier> <identifiersep> exception ( error <identifiersep> code . <identifier> , action <identifiersep> id , <identifier> <identifiersep> action . get <identifiersep> status <identifiersep> <identifier> ( ) , <identifier> <identifiersep> action . is <identifiersep> <identifier> ( ) ) ; } } \n \t1 @ <identifier> \n \t1 protected void execute ( ) throws command <identifiersep> exception { \n <ect>
\t3 boolean is <identifiersep> stream <identifiersep> cache = <identifier> <identifiersep> context <identifiersep> <identifier> . parse <identifiersep> boolean ( <identifier> <identifiersep> context , get <identifiersep> stream <identifiersep> cache ( ) ) ; \n \t3 if ( is <identifiersep> stream <identifiersep> cache != null ) { \n \t4 <identifier> <identifiersep> context . set <identifiersep> stream <identifiersep> <identifier> ( is <identifiersep> stream <identifiersep> cache ) ; \n \t4 if ( is <identifiersep> stream <identifiersep> cache ) { \n <ect>
\t3 while ( <identifier> . has <identifiersep> next ( ) ) \n \t4 logger . debug ( <string_literal> + <identifier> . next ( ) . <identifier> . name + <string_literal> ) ; \n \t3 if ( <identifier> . group != null && <identifier> . group . <identifier> <identifiersep> <identifier> ) \n \t3 { \n <ect>
\t4 <identifier> . write ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> output <identifiersep> <identifier> , null <identifiersep> <identifier> . get ( ) , new text ( key <identifiersep> bytes ) , file <identifiersep> name ) ; } } \n \t2 <identifier> <identifiersep> count ++ ; } \n \t1 private void log <identifiersep> a <identifiersep> <identifier> <identifiersep> <identifier> ( string value ) { \n \t2 if ( <identifier> <identifiersep> count < <number_literal> ) { \n <ect>
\t3 { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> set . <identifier> <identifiersep> <identifier> <identifiersep> status ( current <identifiersep> status , message ) ; } \n \t3 catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) \n \t3 { \n <ect>
\t2 return new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> nodes ) ; } \n \t1 private boolean size <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> nodes . size ( ) >= max <identifiersep> size ) { \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 assert <identifiersep> true ( values . has <identifiersep> next ( ) ) ; \n \t2 <identifier> final <identifiersep> values = values . next ( ) ; \n \t2 int total <identifiersep> <identifier> = data <identifiersep> type . to <identifiersep> integer ( final <identifiersep> values . get ( 0 ) ) ; \n \t2 int in <identifiersep> <identifier> <identifiersep> <identifier> = data <identifiersep> type . to <identifiersep> integer ( final <identifiersep> values . get ( 1 ) ) ; \n <ect>
\t3 update ( <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t3 return <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 double <identifier> <identifiersep> <identifier> = double . max <identifiersep> value ; \n \t1 while ( <identifier> < max <identifiersep> <identifier> && <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> <identifiersep> error <identifiersep> <identifier> ) { \n \t1 <identifier> <identifiersep> <identifier> ( ) ; \n \t1 if ( <identifier> ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t3 for ( url url : <identifier> ) { \n \t4 if ( url . get <identifiersep> path ( ) . contains ( <string_literal> ) ) { \n \t5 log . error ( <string_literal> ) ; \n \t5 log . error ( <string_literal> + this . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; \n <ect>
\t1 if ( <identifier> <identifiersep> type . <identifier> <identifiersep> <identifier> . equals ( <identifier> . get <identifiersep> <identifier> <identifiersep> type ( ) ) ) { \n \t2 <identifier> = <identifier> <identifiersep> <identifier> ( ( base <identifiersep> <identifier> ) <identifier> , <identifier> , <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } } \n \t1 return <identifier> ; } \n private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t1 <comment> \n \t1 string <identifier> = double . to <identifiersep> string ( <identifier> <identifiersep> <identifier> ) ; \n \t1 log . info ( <string_literal> , input , <identifier> <identifiersep> in , output ) ; \n <ect>
\t3 try ( set <identifiersep> thread <identifiersep> name <identifier> = new set <identifiersep> thread <identifiersep> name ( <string_literal> , \n \t5 system . <identifier> <identifiersep> <identifier> <identifiersep> code ( default <identifiersep> <identifier> . this ) , <identifier> . get <identifiersep> id ( ) ) ) { \n \t4 <identifier> . execute ( context ) ; \n \t3 } catch ( execute <identifiersep> exception e ) { \n <ect>
\t4 try { \n \t5 log . info ( <string_literal> ) ; \n \t5 key <identifiersep> <identifier> result = <identifier> . <identifier> <identifiersep> key ( password ) ; \n \t5 time <identifiersep> <identifier> <identifiersep> <identifier> = ( int ) ( system . current <identifiersep> time <identifiersep> millis ( ) - start ) ; \n <ect>
\t3 key <identifiersep> file = new file ( <string_literal> ) ; } \n \t2 if ( ! key <identifiersep> file . exists ( ) ) { \n \t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( string . format ( <string_literal> ) ) ; } \n \t2 if ( ! key <identifiersep> file . exists ( ) ) { \n <ect>
\t3 { \n \t4 <identifier> . <identifier> ( <identifier> , target ) ; } \n \t3 catch ( operation <identifiersep> failed <identifiersep> exception ex ) \n \t3 { \n <ect>
\t4 if ( <identifier> >= <identifier> ) { \n \t5 logger . debug ( <identifier> ( node . <identifier> ) + <string_literal> ) ; \n \t5 break ; } \n <comment> \n <ect>
\t6 element <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( server , input ) ; \n \t6 map < string , string > success = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( <identifier> , new string [ ] { <string_literal> } ) ; \n \t6 s <identifiersep> logger . info ( cmd <identifiersep> name + <string_literal> + success . get ( <string_literal> ) ) ; \n \t5 } else { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ; \n \t1 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t1 return <identifier> <identifiersep> handler . <identifier> ( conf , <identifier> ) ; \n \t1 } else { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> bean = new data <identifiersep> <identifier> <identifiersep> bean ( get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> data <identifiersep> <identifier> ( ) ) ; \n \t3 m <identifiersep> bean <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> ( <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> bean , <identifier> <identifiersep> server <identifiersep> bean ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t4 <identifier> <identifier> = this . get <identifiersep> <identifier> ( null , item ) ; \n \t4 <identifier> . put ( item , <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t2 if ( cluster <identifiersep> command <identifiersep> <identifier> != null ) { \n \t3 try { \n \t4 cluster <identifiersep> command <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 public string get <identifiersep> name ( ) { \n \t3 return <string_literal> ; } \n \t2 @ <identifier> \n \t2 protected void do <identifiersep> run <identifiersep> cache <identifiersep> command ( <identifier> <identifiersep> session session , cache < string , session <identifiersep> entity <identifiersep> <identifier> > cache ) { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t4 if ( ! <identifier> . has <identifiersep> <identifier> ( ) || <identifier> . get <identifiersep> <identifier> ( ) > this . max <identifiersep> <identifier> ) { \n <ect>
\t2 <comment> \n \t2 try { \n \t2 conn . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 for ( int index = 0 ; ! stop <identifiersep> <identifier> && index < <identifier> . length ; index ++ ) { \n \t3 final uri url = <identifier> [ index ] ; \n \t3 final element item = this . <identifier> <identifiersep> cache . get ( url ) ; \n \t3 if ( item != null ) { \n <ect>
\t2 xml <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> test ( <string_literal> , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> to <identifiersep> string ( ) throws exception { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> conn ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t2 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; } } \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 try { \n \t3 write <identifiersep> model ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 return this . class <identifiersep> map <identifiersep> <identifier> <identifiersep> <identifier> . key <identifiersep> set ( ) ; } \n \t1 public model class <identifiersep> map <identifiersep> <identifier> ( string class <identifiersep> map <identifiersep> name ) { \n \t2 return class <identifiersep> map <identifiersep> <identifier> ( class <identifiersep> map <identifiersep> name , <identifier> . no <identifiersep> <identifier> ) ; } \n \t1 public model class <identifiersep> map <identifiersep> <identifier> ( string class <identifiersep> map <identifiersep> name , int <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> map ) { \n <ect>
\t4 logger . info ( <string_literal> + ip + <string_literal> + port + \n \t6 <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t3 if ( ip == null || <identifier> . get <identifiersep> <identifier> ( ) == 0 ) \n \t3 { \n <ect>
\t1 } else { \n \t2 result result = new result ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> ( ) . <identifier> ( result , self ( ) ) ; } \n \t1 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 if ( <identifier> . start <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , log ) ) \n \t3 { \n \t4 <identifier> . set <identifiersep> next <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t1 ** / \n \t1 <comment> \n \t1 run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> , conf <identifiersep> for <identifiersep> <identifier> ) ; \n \t1 <identifier> = run <identifiersep> <identifier> <identifiersep> on <identifiersep> <identifier> ( <string_literal> + table . <identifier> + <string_literal> , conf <identifiersep> for <identifiersep> <identifier> ) ; \n <ect>
\t2 <comment> \n \t2 if ( this . get <identifiersep> version ( ) > <number_literal> ) { \n \t3 for ( map . entry < <identifier> <identifiersep> type , <identifier> > entry : this . <identifier> . entry <identifiersep> set ( ) ) { \n \t4 return this . get <identifiersep> message ( entry . get <identifiersep> value ( ) . get <identifiersep> <identifier> <identifiersep> type ( ) ) ; } } \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> cluster ( ) . start <identifiersep> nodes ( <number_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 create <identifiersep> index <identifiersep> and <identifiersep> index <identifiersep> data ( 1 , 1 ) ; \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 log . debug ( ex , ex ) ; \n \t1 return false ; \n \t1 } catch ( exception ex ) { \n <ect>
\t1 try { \n \t2 <identifier> . <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> address <identifier> = <identifier> . <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> address . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 e <identifiersep> <identifier> = new org . <identifier> . <identifier> . <identifier> <identifiersep> address ( <identifier> . get <identifiersep> bytes ( ) ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t4 } catch ( not <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n \t5 if ( log <identifiersep> <identifier> ) logger . <identifier> ( this , <string_literal> + <identifier> ) ; \n \t5 return ; \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> long <identifiersep> exception <identifier> ) { \n <ect>
\t1 protected void close <identifiersep> <identifier> <identifiersep> db ( ) { \n \t2 if ( <identifier> <identifiersep> db != null ) { \n \t3 <identifier> <identifiersep> db . close ( ) ; \n \t2 } else { \n <ect>
\t2 try { \n \t3 if ( get <identifiersep> m <identifiersep> bean <identifiersep> server ( ) . is <identifiersep> registered ( <identifier> ) ) { \n \t4 get <identifiersep> m <identifiersep> bean <identifiersep> server ( ) . <identifier> <identifiersep> m <identifiersep> bean ( <identifier> ) ; } \n \t2 } catch ( throwable t ) { \n <ect>
\t4 throw new transport <identifiersep> exception ( <string_literal> ) ; } \n \t3 <identifier> ( <number_literal> ) ; } \n \t2 @ <identifier> \n \t2 public void close ( ) { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> + job . get <identifiersep> id ( ) + <string_literal> ) ; \n \t4 try { \n \t5 <identifier> <identifiersep> queue <identifiersep> <identifier> . return <identifiersep> item ( item . get <identifiersep> id ( ) ) ; \n \t4 } catch ( exception <identifier> ) { \n <ect>
\t2 if ( self . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> bean != null ) { \n \t3 try { \n \t4 m <identifiersep> bean <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> ( self . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> bean ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n \t3 log . info ( <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> info = build <identifiersep> <identifier> <identifiersep> info ( ) ; \n \t2 if ( <identifier> <identifiersep> info != null && <identifier> <identifiersep> info . is <identifiersep> empty ( ) ) { \n \t2 <identifier> <identifiersep> info = null ; \n <ect>
\t6 if ( ! new file ( <identifier> ) . exists ( ) ) { \n \t7 s <identifiersep> logger . warn ( <string_literal> + <identifier> ) ; \n \t7 continue ; } \n <ect>
\t2 list < client <identifiersep> <identifier> > <identifier> = <identifier> . create <identifiersep> provider <identifiersep> <identifier> ( <identifier> <identifiersep> context ) ; \n \t2 if ( <identifier> != null ) { \n \t3 <identifier> <identifiersep> resource provider <identifiersep> <identifier> = <identifier> <identifiersep> client . <identifier> ( <identifier> . provider <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t3 for ( client <identifiersep> <identifier> client : <identifier> ) { \n <ect>
\t3 <comment> \n \t3 c . <identifier> ( ) ; \n \t3 break ; \n \t2 } else { \n <ect>
\t2 { \n \t3 @ <identifier> \n \t3 protected void channel <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context channel <identifiersep> handler <identifiersep> context , get <identifiersep> index <identifiersep> files <identifiersep> request snapshot <identifiersep> request ) \n \t3 { \n <ect>
\t1 { \n \t2 try { \n \t3 return context . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , context ) . get <identifiersep> version ( ) ; \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 load <identifiersep> node ( current <identifiersep> node , property <identifiersep> name , <identifier> ) ; } } \n \t3 return <identifier> ; } \n \t2 catch ( <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 assert <identifiersep> equals ( 1 , <identifier> . size ( data <identifiersep> store . get <identifiersep> all <identifiersep> <identifier> ( ) ) ) ; \n \t2 data <identifiersep> store . delete <identifiersep> <identifier> ( new data <identifiersep> <identifier> ( id ) ) ; \n \t2 <identifier> = data <identifiersep> store . get <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( new data <identifiersep> <identifier> ( id ) ) ; \n \t2 assert <identifiersep> null ( <identifier> ) ; \n <ect>
\t4 if ( <identifier> . is <identifiersep> <identifier> ( ) ) \n \t5 <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> <identifiersep> log <identifiersep> <identifier> first ; \n \t3 if ( ( first = <identifier> <identifiersep> <identifier> . <identifier> ( ) ) != null && first . id < = last . id ) \n <ect>
\t1 check <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 log . info ( <string_literal> ) ; \n \t1 return check <identifiersep> result ; } \n \t1 catch ( throwable ex ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> ( p . get <identifiersep> data ( ) , <identifier> ) ; \n \t4 <comment> \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . remove ( ) ; \n \t4 try { \n \t5 entry . get <identifiersep> value ( ) . on <identifiersep> <identifier> <identifiersep> end ( interrupted ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t1 public void <identifier> ( byte [ ] <identifier> <identifiersep> <identifier> , string <identifier> <identifiersep> password ) { \n \t2 s <identifiersep> logger . info ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 <comment> \n <ect>
\t3 wait <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> task ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 throw <identifier> ; \n \t2 } catch ( throwable t ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> security <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t3 <comment> \n \t3 current <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 current <identifiersep> <identifier> . put <identifiersep> all ( public <identifiersep> <identifier> ) ; \n \t2 } catch ( http <identifiersep> client <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 public void run ( ) { \n \t4 try { \n \t5 <identifier> <identifiersep> send <identifiersep> <identifier> ( ) ; \n \t4 } catch ( throwable t ) { \n <ect>
\t2 else \n \t2 { \n \t3 string <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> == null ) \n <ect>
\t1 <identifier> <identifiersep> is <identifiersep> shutdown = false ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> logger = new <identifier> <identifiersep> <identifier> <identifiersep> logger ( <identifier> <identifiersep> log , error <identifiersep> <identifier> <identifiersep> <identifier> , config . get <identifiersep> <identifier> ( ) ) ; \n \t1 if ( <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> < <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) \n \t1 { \n <ect>
\t2 grid <identifiersep> test <identifiersep> utils . run <identifiersep> <identifier> <identifiersep> <identifier> ( new <identifier> < void > ( ) { \n \t3 @ <identifier> public void <identifier> ( ) throws exception { \n \t4 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> <identifiersep> thread && ! failed ; i ++ ) { \n \t5 if ( i <identifier> <number_literal> == 0 ) \n <ect>
\t3 <identifier> . <identifier> ( source , result ) ; \n \t3 return result . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ; \n \t2 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception | <identifier> <identifiersep> exception | io <identifiersep> exception \n \t4 | <identifier> <identifiersep> factory <identifiersep> configuration <identifiersep> error | <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifier> = ( <identifier> <identifiersep> <identifier> ) <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> version ( ) ; \n \t4 <identifier> . count <identifiersep> entry ( <identifier> . get <identifiersep> first ( ) . length ( ) , <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> value ( ) . length \n <number_literal> + <identifier> . size <identifiersep> in <identifiersep> bytes ( ) ) ; \n \t4 if ( count <identifier> <number_literal> == 0 ) \n <ect>
\t2 close <identifiersep> java <identifiersep> <identifier> ( out ) ; } \n \t1 protected void <identifier> <identifiersep> dao ( table <identifiersep> <identifier> table , java <identifiersep> <identifier> out ) { \n \t2 <identifier> <identifiersep> key <identifiersep> <identifier> key = table . get <identifiersep> <identifier> <identifiersep> key ( ) ; \n \t2 if ( key == null ) { \n <ect>
\t4 } catch ( exception e ) { \n \t5 <comment> \n \t5 if ( error <identifiersep> wait <identifiersep> time == 1 ) { \n \t6 logger . warn ( <string_literal> , e ) ; } \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> on <identifiersep> filter ( <identifier> <identifiersep> <identifier> ) \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , code ) \n \t2 } catch ( e : <identifier> <identifiersep> error ) { \n <ect>
\t2 if ( is <identifiersep> <identifier> == true && <identifier> <identifiersep> <identifier> <identifiersep> map . size ( ) == 0 ) { \n \t3 s <identifiersep> logger . error ( <string_literal> ) ; \n \t3 system . <identifier> ( 1 ) ; } \n \t2 if ( is <identifiersep> <identifier> == true && <identifier> <identifiersep> <identifier> <identifiersep> map . size ( ) != <number_literal> ) { \n <ect>
\t4 set <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 @ <identifier> \n \t3 public void run ( ) { \n \t4 try { \n <ect>
\t5 <comment> \n \t5 set <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t5 break ; \n \t4 } catch ( throwable e ) { \n <ect>
\t2 } finally { \n \t3 synchronized ( this ) { \n \t4 <identifier> . remove ( <identifier> ) ; \n \t4 try { \n <ect>
\t6 <identifier> <identifiersep> entry <identifiersep> list . add ( entry ) ; \n \t6 if ( <identifier> <identifiersep> entry <identifiersep> list . size ( ) > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t7 <identifier> <identifiersep> entry <identifiersep> list . <identifier> ( ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 close <identifiersep> data <identifiersep> source ( get <identifiersep> data <identifiersep> source ( ) ) ; } \n \t1 public void <identifier> ( ) { \n \t2 transaction <identifiersep> context c = null ; \n \t2 try { \n <ect>
\t3 <comment> \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( account <identifiersep> id ) ; \n \t3 } catch ( <identifier> <identifiersep> runtime <identifiersep> exception ex ) { \n <ect>
\t2 for ( int i = 0 ; i < <identifier> ; i ++ ) { \n \t3 if ( i <identifier> <number_literal> == 0 ) \n \t4 logger . debug ( <string_literal> , i ) ; \n \t3 session ( ) . execute ( <identifier> <identifiersep> <identifier> . <identifier> ( <string_literal> , integer . to <identifiersep> string ( i ) , <string_literal> ) ) ; } \n <ect>
\t1 public < t , <identifier> > field <identifiersep> <identifier> < t , <identifier> > create <identifiersep> field <identifiersep> <identifier> ( class < t > <identifier> <identifiersep> type , field field , class < <identifier> > field <identifiersep> type ) throws <identifier> <identifiersep> field <identifiersep> exception { \n \t2 try { \n \t3 return new <identifier> <identifiersep> <identifier> <identifiersep> field <identifiersep> <identifier> < > ( <identifier> <identifiersep> type , field , field <identifiersep> type ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception | <identifier> <identifiersep> field <identifiersep> exception e ) { \n <ect>
\t4 <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t4 <identifier> . set <identifiersep> long ( 1 , account <identifiersep> id ) ; \n \t4 <identifier> . set <identifiersep> long ( <number_literal> , count ) ; \n \t4 <identifier> . execute <identifiersep> update ( ) ; \n <ect>
<comment> \n @ <identifier> \n public string create <identifiersep> snapshot ( final string <identifier> <identifiersep> name , final string <identifier> <identifiersep> name , final string <identifier> <identifiersep> pool <identifiersep> name ) { \n <ect>
\t1 try { \n \t2 execution <identifiersep> <identifier> . <identifier> <identifiersep> job ( <identifier> ) ; \n \t2 log . debug ( <string_literal> , <identifier> . get <identifiersep> next <identifiersep> <identifier> <identifiersep> time ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( start <identifiersep> <identifier> != null && ! start <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t4 start <identifiersep> <identifier> . remove ( <identifier> <identifiersep> <identifier> . event <identifiersep> node ( ) . id ( ) ) ; \n \t4 if ( start <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 node node = <identifier> . get <identifiersep> <identifier> <identifiersep> element ( ) ; \n \t2 logger . info ( <string_literal> + node . get <identifiersep> node <identifiersep> name ( ) ) ; \n \t2 node <identifiersep> list <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> element ( ) . get <identifiersep> <identifier> <identifiersep> nodes ( ) ; \n \t2 node = <identifier> . item ( 0 ) ; \n <ect>
\t3 synchronized ( this ) \n \t3 { \n \t4 if ( is <identifiersep> <identifier> <identifiersep> request <identifiersep> <identifier> ) \n \t4 { \n <ect>
\t2 <comment> \n \t2 final string new <identifiersep> <identifier> <identifiersep> node = <identifier> <identifiersep> cluster ( ) . get <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> <identifier> . get ( 0 ) ) ; \n \t2 logger . info ( <string_literal> , new <identifiersep> <identifier> <identifiersep> node ) ; \n \t2 <comment> \n <ect>
\t2 get <identifiersep> handler ( ) . handle <identifiersep> event ( event ) ; } } \n \t1 public void shutdown ( ) { \n \t1 synchronized ( <identifier> <identifiersep> lock ) { \n \t2 if ( state == state . shutdown ) { \n <ect>
\t3 log . debug ( <string_literal> + get <identifiersep> session <identifiersep> id <identifiersep> value <identifiersep> from <identifiersep> state ( store ) ) ; \n \t3 <comment> \n \t3 execute <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t3 string <identifier> <identifiersep> id = process <identifiersep> <identifier> <identifiersep> <identifier> ( store , server <identifiersep> a . to <identifiersep> string ( ) , server <identifiersep> <identifier> . to <identifiersep> string ( ) ) ; \n <ect>
\t3 <identifier> . <identifier> ( ) ; \n \t3 log . debug ( <string_literal> ) ; \n \t2 } catch ( exception ex ) { \n \t3 try { \n <ect>
\t4 if ( n == 0 ) { \n \t5 n = - 1 ; } \n \t3 } else if ( java <identifiersep> <identifier> . db . is <identifiersep> run <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> <identifiersep> enabled = false ; \n <ect>
\t7 <identifier> . state = <identifier> . state . <identifier> ; } \n \t5 } else { \n \t6 s <identifiersep> logger . info ( <string_literal> + info . get <identifiersep> name ( ) ) ; \n \t6 <identifier> ( info . <identifier> , info . instance ) ; \n <ect>
\t3 log . error ( <string_literal> + configuration <identifiersep> manager . get <identifiersep> property ( <string_literal> ) + \n \t6 <string_literal> + \n \t6 <string_literal> ) ; } \n \t2 if ( ! <identifier> . exists ( ) && ! <identifier> . <identifier> ( ) ) { \n <ect>
\t3 case <identifier> <identifiersep> <identifier> . task <identifiersep> <identifier> : { \n \t4 task <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> thread <identifiersep> <identifier> <identifiersep> time ( time <identifiersep> utils . current <identifiersep> time <identifiersep> <identifier> ( ) ) ; \n \t4 break ; } \n \t3 default : { \n <ect>
\t1 int <identifier> = get <identifiersep> config ( ) . get <identifiersep> int ( model <identifiersep> <identifier> <identifiersep> name ) ; \n \t1 log . debug ( <string_literal> + model <identifiersep> <identifier> <identifiersep> name + <string_literal> + <identifier> ) ; \n \t1 for ( int <identifier> = 1 ; <identifier> < = <identifier> ; <identifier> ++ ) { \n \t1 string <identifier> = get <identifiersep> config ( ) . get <identifiersep> string ( model <identifiersep> <identifier> <identifiersep> name + <string_literal> + <identifier> ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> ( ) . remove <identifiersep> <identifier> ( this , \n \t5 property <identifiersep> <identifier> <identifiersep> <identifier> , null ) ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> ( this , property <identifiersep> <identifier> , \n \t4 property <identifiersep> <identifier> <identifiersep> <identifier> , context ) ; \n <ect>
\t3 <comment> \n \t3 try { \n \t4 <identifier> . close ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> class . get <identifiersep> <identifier> ( item . class , event <identifiersep> <identifier> . class ) ; \n \t4 <identifier> = <identifier> . new <identifiersep> instance ( item , event <identifiersep> <identifier> ) ; \n \t4 add <identifiersep> <identifier> ( item , <identifier> <identifiersep> address , <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> count > 0 ) { \n \t3 return ; } \n \t2 network <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> map . remove ( <identifier> <identifiersep> uri ) ; \n \t2 <identifier> . stop ( ) ; \n <ect>
\t4 if ( <identifier> . <identifier> ) { \n \t5 log . error ( <string_literal> + <identifier> . <identifier> <identifiersep> name ) ; \n \t5 <identifier> ( ) ; } } \n \t3 if ( ! <identifier> && <identifier> . throws <identifiersep> exception ) { \n <ect>
\t1 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> field <identifiersep> set ( ) { \n \t2 return true ; } \n \t1 public <identifier> <identifiersep> length <identifiersep> class <identifier> <identifiersep> length <identifiersep> class ( ) { \n \t2 if ( ! location . is <identifiersep> <identifier> ( get <identifiersep> location ( ) ) ) { \n <ect>
\t1 snapshot <identifiersep> <identifier> . <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t1 <comment> \n \t1 <identifier> <identifiersep> manager . execute <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t1 } else { \n <ect>
public void <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t1 <identifier> db = new <identifier> ( <string_literal> , <string_literal> , <string_literal> , empty <identifiersep> <identifier> ) ; \n \t1 <identifier> <identifiersep> client . create <identifiersep> <identifier> ( db ) ; \n \t1 <identifier> <identifiersep> client . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t3 } catch ( final configuration <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t4 return null ; } \n \t3 if ( ! resource . start ( ) ) { \n <ect>
\t5 client . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t4 <identifier> . count <identifiersep> <identifier> ( ) ; } \n \t3 @ <identifier> \n \t3 public void on <identifiersep> failure ( throwable throwable ) { \n <ect>
\t4 <identifier> <identifiersep> state . update <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state ( <identifier> <identifiersep> state <identifiersep> <identifier> ) ; } } } \n \t1 private boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> ) { \n \t3 return true ; } \n <ect>
\t1 write <identifiersep> <identifier> <identifiersep> factory ( <identifier> , client <identifiersep> listener . <identifier> <identifiersep> factory <identifiersep> name ( ) , <identifier> <identifiersep> factory <identifiersep> <identifier> ) ; } \n @ <identifier> \n public void write <identifiersep> <identifier> <identifiersep> <identifier> ( byte <identifiersep> <identifier> <identifier> , long <identifier> , time <identifiersep> unit <identifier> <identifiersep> time <identifiersep> unit , long max <identifiersep> <identifier> , time <identifiersep> unit max <identifiersep> <identifier> <identifiersep> time <identifiersep> unit ) { \n \t1 if ( ! <identifier> <identifiersep> utils . is <identifiersep> int <identifiersep> <identifier> ( <identifier> ) ) { \n <ect>
\t2 if ( ! <identifier> <identifiersep> service . is <identifiersep> shutdown ( ) ) { \n \t2 <identifier> <identifiersep> service . shutdown <identifiersep> <identifier> ( ) ; } } } \n \t1 return result ; } \n private synchronized void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t1 @ <identifier> ( <string_literal> ) \n \t1 @ <identifier> <identifiersep> type ( <string_literal> ) \n \t1 @ path ( <string_literal> ) \n \t1 public list < context <identifiersep> <identifier> <identifiersep> <identifier> > get <identifiersep> list ( ) { \n <ect>
\t1 <comment> \n \t1 if ( ! <identifier> ) { \n \t1 <comment> \n \t1 <comment> \n <ect>
\t1 entity <identifiersep> transaction db = <identifier> . get ( volume <identifiersep> info . class ) ; \n \t1 try { \n \t1 log . info ( <string_literal> ) ; \n \t1 volume <identifiersep> info <identifier> <identifiersep> entity = <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 logger . debug ( ex . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> request + <string_literal> + \n \t7 <string_literal> + ex . get <identifiersep> message ( ) + <string_literal> + \n \t7 <string_literal> + char <identifiersep> <identifier> . to <identifiersep> string ( new input <identifiersep> stream <identifiersep> <identifier> ( <identifier> <identifiersep> request . get <identifiersep> content <identifiersep> stream ( ) ) ) ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
private void <identifier> <identifiersep> from <identifiersep> file ( ) throws io <identifiersep> exception { \n \t1 file <identifier> <identifiersep> file = new file ( <identifier> <identifiersep> <identifier> ) ; \n \t1 if ( <identifier> <identifiersep> file . is <identifiersep> file ( ) ) { \n \t1 string <identifier> <identifiersep> <identifier> = read <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> string ( <identifier> <identifiersep> file ) ; \n <ect>
\t2 logger . info ( <string_literal> + <identifier> + <string_literal> + metadata <identifiersep> dir <identifiersep> path ) ; \n \t2 file metadata <identifiersep> dir = new file ( metadata <identifiersep> dir <identifiersep> path ) ; \n \t2 if ( metadata <identifiersep> dir . exists ( ) && ! metadata <identifiersep> dir . is <identifiersep> directory ( ) ) \n \t2 { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n <ect>
\t2 string directory = to <identifiersep> file . get <identifiersep> <identifier> ( ) ; \n \t2 boolean <identifier> = file <identifiersep> <identifier> . is <identifiersep> <identifier> ( to <identifiersep> file ) ; \n \t2 if ( directory != null ) { \n \t3 if ( ! build <identifiersep> directory ( directory , <identifier> ) ) { \n <ect>
\t2 double <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - start ; \n \t2 stop <identifiersep> <identifier> ( ) ; \n \t2 log . info ( <string_literal> + <identifier> + <string_literal> ) ; \n \t2 log . info ( <string_literal> + ( to <identifiersep> send * <number_literal> / <identifier> ) + <string_literal> ) ; \n <ect>
\t3 native . <identifier> ( <string_literal> ) ; \n \t3 <identifier> = true ; } \n \t2 catch ( no <identifiersep> class <identifiersep> <identifier> <identifiersep> found <identifiersep> error e ) \n \t2 { \n <ect>
\t4 log . error ( <string_literal> , <identifier> <identifiersep> class , <identifier> ) ; \n \t3 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n \t4 log . error ( <string_literal> , <identifier> <identifiersep> class , <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 new <identifiersep> <identifier> = data . new <identifiersep> <identifier> . filter <identifiersep> not ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> . get <identifiersep> id == <identifier> . <identifier> <identifiersep> id ( ) ) ) \n \t1 case event ( msg : <identifier> , <identifier> <identifiersep> <identifier> ) = > \n \t1 <comment> \n \t1 for ( task < - msg . <identifier> . as <identifiersep> <identifier> ) { \n <ect>
<number_literal> key , \n <number_literal> value , \n <number_literal> <identifier> ) ; \n <ect>
\t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n \t5 <identifier> = false ; \n <ect>
\t9 <identifier> . <identifier> ( ) ; } \n \t8 else { \n \t9 <comment> \n <ect>
\t2 return <identifier> <identifiersep> <identifier> <identifiersep> uri ; } \n \t1 @ <identifier> \n \t1 public void create <identifiersep> connection <identifiersep> factory ( string name ) { \n \t2 try { \n <ect>
\t2 create <identifiersep> index ( index <identifiersep> name ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 final string index <identifiersep> <identifier> = <identifier> <identifiersep> index ( index <identifiersep> name ) . get <identifiersep> <identifier> ( ) ; \n <ect>
\t2 try { \n \t3 <identifier> . get <identifiersep> class <identifiersep> <identifier> ( ) . load <identifiersep> class ( <identifier> <identifiersep> <identifier> <identifiersep> factory <identifiersep> class ) ; \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> unit ) ) { \n <ect>
\t4 if ( user != null && user . get <identifiersep> <identifier> ( ) != null && user . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t5 try { \n \t6 <identifier> <identifiersep> template <identifiersep> provider . set <identifiersep> <identifier> ( <identifier> ) . set <identifiersep> user ( user ) . send <identifiersep> event ( event ) ; \n \t5 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 system . <identifier> . <identifier> ( <string_literal> + <identifier> ) ; \n \t5 <identifier> <identifiersep> <identifier> = true ; \n \t5 continue ; \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 while ( true ) { \n \t1 try { \n \t2 if ( <identifier> . is <identifiersep> <identifier> ( ) ) \n \t2 break ; \n <ect>
\t6 log . debug ( <string_literal> , \n \t8 <identifier> . <identifier> ( <identifier> * <number_literal> ) / <number_literal> . 0 , time <identifiersep> unit . <identifier> . to <identifiersep> <identifier> ( next <identifiersep> <identifier> ) ) ; \n \t6 set <identifiersep> long <identifiersep> <identifier> ( <identifier> <identifiersep> collection <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , next <identifiersep> <identifier> ) ; } \n \t4 } else { \n <ect>
\t1 @ <identifier> \n \t1 public < t > <identifier> < t > to ( class < t > <identifier> ) { \n \t2 class < ? extends <identifier> < ? > > <identifier> <identifiersep> type = find <identifiersep> <identifier> <identifiersep> type <identifiersep> from <identifiersep> cache ( <identifier> ) ; \n \t2 check <identifiersep> state ( ! <identifier> <identifiersep> type . equals ( null <identifiersep> <identifier> . class ) , <string_literal> , <identifier> . get <identifiersep> name ( ) ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 <string_literal> + <identifier> <identifiersep> id + <string_literal> + e . get <identifiersep> message ( ) , \n \t4 context ) ; \n \t2 } finally { \n \t3 process <identifiersep> finally ( context ) ; } \n <ect>
\t1 { \n \t2 uri uri ; \n \t2 if ( ( uri = process <identifiersep> <identifier> <identifiersep> <identifier> ( target , data ) ) != null ) \n \t2 { \n <ect>
\t3 log . error ( e . get <identifiersep> message ( ) , e ) ; \n \t3 try { \n \t4 <identifier> . true <identifiersep> close ( ) ; } \n \t3 catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> message <identifier> <identifiersep> message = create <identifiersep> <identifier> <identifiersep> message ( message ) ; \n \t3 transport . send ( <identifier> <identifiersep> message ) ; } \n \t2 catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void do <identifiersep> stop ( ) throws exception { \n \t2 <comment> \n \t2 if ( create <identifiersep> <identifier> && <identifier> != null ) { \n <ect>
\t7 return boolean . false ; } \n \t6 if ( <identifier> <identifier> num <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == 0 ) { \n \t7 close ( false ) ; \n \t7 <identifier> ( ) ; \n <ect>
\t5 break ; } \n \t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception | <identifier> <identifiersep> exception | io <identifiersep> exception | x <identifiersep> path <identifiersep> <identifier> <identifiersep> exception | <identifier> <identifiersep> exception ex ) { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> failure ( ) ; \n \t5 task <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task ( ) ; \n \t4 } catch ( exception e <identifiersep> <identifier> ) { \n <ect>
<comment> \n \t1 private <identifier> < json <identifiersep> web <identifiersep> key <identifiersep> set > build <identifiersep> json <identifiersep> web <identifiersep> key <identifiersep> set ( ) { \n \t2 try { \n <ect>
\t1 { \n \t2 <identifier> <identifiersep> group root <identifiersep> group \n \t3 = this . <identifier> <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list <identifiersep> root ( ) ; \n \t2 logger . debug ( <string_literal> ) ; \n <ect>
\t3 if ( file <identifiersep> path . is <identifiersep> file ( ) && file <identifiersep> path . exists ( ) && file <identifiersep> path . <identifier> <identifiersep> read ( ) && file <identifiersep> path . length ( ) > 0 ) { \n \t4 final registered <identifiersep> service <identifier> = <identifier> . from ( file <identifiersep> path ) ; \n \t4 logger . info ( <string_literal> , <identifier> . get <identifiersep> name ( ) , file <identifiersep> path . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 } else { \n <ect>
\t3 if ( ! result . first ( ) ) { \n \t4 return null ; } \n \t3 return result . <identifier> ( ) ; \n \t2 } catch ( final throwable e ) { \n <ect>
\t2 <comment> \n \t2 final <identifier> <identifiersep> <identifier> <identifiersep> map < string , string > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . new <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map ( <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( ! <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> name ( \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> path , new <identifier> <identifiersep> set < string > ( <identifier> <identifiersep> <identifier> . key <identifiersep> set ( ) ) ) ) { \n <ect>
\t3 long last <identifiersep> <identifier> <identifiersep> time = <identifier> . get <identifiersep> time <identifiersep> of <identifiersep> last <identifiersep> message <identifiersep> <identifier> ( ) ; \n \t3 long time <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - last <identifiersep> <identifier> <identifiersep> time ; \n \t3 if ( time <identifiersep> <identifier> > max <identifiersep> time <identifiersep> <identifier> <identifiersep> last <identifiersep> <identifier> ) { \n \t4 if ( ! <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( <identifier> ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> <identifiersep> <identifier> . update <identifiersep> <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> <identifier> ( load <identifiersep> <identifier> <identifiersep> id ) ; } } \n \t2 if ( <identifier> ) { \n \t3 try { \n \t4 if ( ! <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> config ( load <identifiersep> <identifier> <identifiersep> id ) ) { \n <ect>
\t9 if ( is <identifiersep> <identifier> ( ) ) { \n \t10 <identifier> . <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> ( new <identifiersep> id ) ; \n \t9 } else { \n \t10 <identifier> . id = new <identifiersep> id ; \n <ect>
\t2 <identifier> <identifiersep> and <identifiersep> key . get <identifiersep> <identifier> ( ) , \n \t2 <identifier> <identifiersep> and <identifiersep> key . get <identifiersep> key ( ) , \n \t2 ( int ) max <identifiersep> content <identifiersep> length ) ; \n \t1 } catch ( exception ex ) { \n <ect>
<comment> \n \t1 public void process <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t5 } catch ( <identifier> <identifiersep> exception e ) { \n \t6 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t5 } ; \n \t4 } catch ( exception e ) { \n <ect>
public synchronized void on <identifiersep> task <identifiersep> end ( <identifier> <identifiersep> listener <identifiersep> task <identifiersep> end task <identifiersep> end ) { \n \t1 int <identifier> <identifiersep> id = task <identifiersep> end . <identifier> <identifiersep> id ( ) ; \n \t1 integer job <identifiersep> id = <identifier> <identifiersep> id <identifiersep> to <identifiersep> job <identifiersep> id . get ( <identifier> <identifiersep> id ) ; \n \t1 if ( job <identifiersep> id == null ) { \n <ect>
\t2 update <identifiersep> <identifier> ( ) ; \n \t2 long update <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 <identifier> <identifiersep> time <identifiersep> <identifier> = ( update <identifiersep> <identifier> - add <identifiersep> nodes <identifiersep> <identifier> ) / <identifier> ; \n \t2 logger . debug ( <string_literal> + <identifier> <identifiersep> time <identifiersep> <identifier> ) ; \n <ect>
\t4 <identifier> ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 logger . info ( e . get <identifiersep> message ( ) ) ; } \n \t3 set <identifiersep> <identifier> <identifiersep> <identifier> ( ( <identifier> <identifiersep> manager != null ) && <identifier> <identifiersep> manager . is <identifiersep> <identifier> ( ) ) ; \n <ect>
\t5 <identifier> . set <identifiersep> <identifier> ( true ) ; } } \n \t2 } ) ; \n \t2 <identifier> . set <identifiersep> status <identifiersep> code ( 0 , <identifier> . get <identifiersep> string ( <string_literal> ) , <string_literal> ) ; \n \t2 <identifier> <identifiersep> configuration . load <identifiersep> <identifier> <identifiersep> <identifier> ( configuration ) ; \n <ect>
\t6 map < string , string > success = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( <identifier> , new string [ ] { <string_literal> } ) ; \n \t3 <comment> \n \t6 s <identifiersep> logger . info ( <string_literal> + success . get ( <string_literal> ) ) ; \n \t5 } else { \n <ect>
\t3 <comment> \n \t3 thread . <identifier> ( thread <identifiersep> local <identifiersep> <identifier> . current ( ) . next <identifiersep> int ( <number_literal> ) ) ; \n \t3 context . start ( ) ; \n \t3 context <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t5 logger . debug ( <string_literal> , e ) ; } \n \t4 try { \n \t5 <identifier> <identifiersep> volume <identifiersep> service . <identifier> <identifiersep> access ( <identifier> <identifiersep> volume <identifiersep> info , <identifier> <identifiersep> host , <identifier> <identifiersep> volume <identifiersep> info . get <identifiersep> data <identifiersep> store ( ) ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t2 byte [ ] new <identifiersep> <identifier> = { ( byte ) remove <identifiersep> node <identifiersep> <identifier> , ( byte ) <number_literal> } ; \n \t2 new <identifiersep> message . set <identifiersep> message <identifiersep> <identifier> ( new <identifiersep> <identifier> ) ; \n \t2 return new <identifiersep> message ; } \n \t1 public <identifier> <identifiersep> message do <identifiersep> request <identifiersep> stop ( ) { \n <ect>
\t3 return n ; } \n \t2 catch ( t <identifiersep> exception ex ) { \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> , ex ) ; } \n \t2 catch ( <identifier> <identifiersep> thrift <identifiersep> exception ex ) { \n <ect>
\t2 } catch ( io <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> , e ) ; \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> unit <identifiersep> resource <identifiersep> exception ( <string_literal> , e ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> send ) { \n <ect>
\t2 return m <identifiersep> current <identifiersep> <identifier> <identifiersep> cache . get ( key ) ; \n \t1 } catch ( execution <identifiersep> exception execution <identifiersep> exception ) { \n \t2 throwable <identifier> = execution <identifiersep> exception . get <identifiersep> <identifier> ( ) ; \n \t2 if ( ! ( <identifier> instanceof <identifier> <identifiersep> not <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ) ) { \n <ect>
\t3 } else if ( <identifier> <identifiersep> not <identifiersep> <identifier> . length >= <number_literal> ) { \n \t4 <identifier> . <identifier> ( <identifier> ( <string_literal> , new string [ ] { <string_literal> , <string_literal> } , \n \t6 new string [ ] { integer . to <identifiersep> string ( <identifier> . <identifier> ( <identifier> <identifiersep> not <identifiersep> <identifier> [ 0 ] ) ) , integer . to <identifiersep> string ( <identifier> . <identifier> ( <identifier> <identifiersep> not <identifiersep> <identifier> [ 1 ] ) ) } ) ) ; \n \t4 if ( <identifier> <identifiersep> not <identifiersep> <identifier> . length > <number_literal> ) \n <ect>
\t3 if ( cluster != null ) \n \t4 log . debug ( <string_literal> + this . to <identifiersep> string ( ) + \n \t6 <string_literal> + cluster ) ; \n \t3 else \n <ect>
\t4 store <identifiersep> transaction new <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> . get <identifiersep> time ( ) ) ; \n \t4 store . <identifier> ( <identifier> . to <identifiersep> lock <identifiersep> key ( <identifier> . get <identifiersep> key ( ) , <identifier> . get <identifiersep> <identifier> ( ) ) , <identifier> <identifiersep> list . < entry > of ( ) , <identifier> , new <identifiersep> <identifier> ) ; \n \t4 return ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
private boolean do <identifiersep> <identifier> ( t item ) \n { \n \t1 if ( item == null ) \n \t1 { \n <ect>
\t5 <comment> \n \t5 continue ; } \n \t4 if ( collection . <identifier> <identifiersep> <identifier> ( ) ) { \n \t5 <comment> \n <ect>
\t3 if ( m <identifiersep> <identifier> <identifiersep> out <identifiersep> stream <identifiersep> <identifier> != null ) { \n \t4 m <identifiersep> <identifier> <identifiersep> out <identifiersep> stream <identifiersep> <identifier> . shutdown ( ) ; \n \t4 m <identifiersep> <identifier> <identifiersep> out <identifiersep> stream <identifiersep> <identifier> = null ; } \n \t3 m <identifiersep> <identifier> <identifiersep> listener . shutdown ( ) ; \n <ect>
\t4 = header <identifiersep> factory \n \t5 . create <identifiersep> <identifier> <identifiersep> header ( <string_literal> , content <identifiersep> <identifier> <identifiersep> type ) ; } \n \t2 catch ( parse <identifiersep> exception e ) \n \t2 { \n <ect>
\t4 final class < ? > type = <identifier> . load <identifiersep> class ( <identifier> ) ; \n \t4 if ( <identifier> <identifiersep> type . is <identifiersep> <identifier> <identifiersep> from ( type ) ) { \n \t5 this . <identifier> . add ( type ) ; } } \n \t3 catch ( throwable t ) { \n <ect>
\t3 return new file ( index <identifiersep> <identifier> . get <identifiersep> out <identifiersep> dir ( ) , out <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> . local <identifiersep> index <identifiersep> root <identifiersep> dir ) ; } } \n \t1 private string <identifier> <identifiersep> in <identifiersep> read <identifiersep> write <identifiersep> mode <identifiersep> and <identifiersep> create <identifiersep> check <identifiersep> <identifier> ( index <identifiersep> options index <identifiersep> <identifier> ) throws exception { \n \t2 string <identifier> = index <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t2 if ( conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> < = 0 ) \n \t3 throw new configuration <identifiersep> exception ( <string_literal> + conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> , false ) ; \n \t2 logger . info ( <string_literal> , conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ) ; \n \t2 if ( conf . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> == 0 ) \n <ect>
\t4 log . error ( <string_literal> , e . get <identifiersep> message ( ) ) ; } \n \t3 <comment> \n \t3 <comment> \n <ect>
\t4 <comment> \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> host . get <identifiersep> account <identifiersep> id ( ) != null || ( account <identifiersep> id == null && ! <identifier> <identifiersep> id <identifiersep> in <identifiersep> <identifier> <identifiersep> list ) || \n \t5 ( account <identifiersep> id != null && ! ( <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> host . get <identifiersep> <identifier> <identifiersep> id ( ) . equals ( <identifier> <identifiersep> id ) || <identifier> <identifiersep> id <identifiersep> in <identifiersep> <identifier> <identifiersep> list ) ) ) { \n \t5 host <identifiersep> <identifier> <identifiersep> vo <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( host . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> long <identifiersep> stream <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 c . <identifier> ( <identifier> <identifiersep> update <identifiersep> factory . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , get <identifiersep> super <identifiersep> <identifier> ( <identifier> ) , <identifier> . get <identifiersep> context <identifiersep> id ( ) ) ) ; \n \t3 c . add ( new <identifier> <identifiersep> <identifier> <identifiersep> update ( <identifier> , <identifier> <identifiersep> id ) ) ; \n \t3 c . add ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> update ( <identifier> <identifiersep> id ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 this . private <identifiersep> file <identifiersep> channel = null ; \n \t4 <comment> \n \t4 file . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 if ( this . <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> bytes != 0 \n \t2 && this . bytes <identifiersep> <identifier> > this . <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> bytes ) { \n <ect>
\t2 self . public <identifiersep> ip <identifiersep> <identifier> = public <identifiersep> ip <identifiersep> <identifier> . create ( \n \t9 self . <identifier> , \n \t9 self . <identifier> [ <string_literal> ] \n \t7 ) \n <ect>
\t2 <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) && shutdown <identifiersep> <identifier> <identifiersep> thread != null \n \t4 && ! is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 runtime . get <identifiersep> runtime ( ) . remove <identifiersep> shutdown <identifiersep> <identifier> ( shutdown <identifiersep> <identifier> <identifiersep> thread ) ; } \n <ect>
\t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> <identifier> <identifiersep> principal . get <identifiersep> <identifier> <identifiersep> instance ( ) . get <identifiersep> <identifier> ( ) . is <identifiersep> <identifier> ( ) ) \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> <identifier> <identifiersep> principal . get <identifiersep> <identifier> <identifiersep> instance ( ) . stop <identifiersep> <identifier> ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) \n \t4 { \n <ect>
\t1 private void <identifier> ( string uri <identifiersep> <identifier> ) { \n \t2 try { \n \t3 root <identifiersep> url <identifiersep> <identifier> . <identifier> <identifiersep> by <identifiersep> <identifier> ( uri <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t7 <identifier> . remove <identifiersep> from <identifiersep> <identifier> <identifiersep> config ( conn , key ) ; \n \t7 break ; } } } } \n \t3 return new <identifier> <identifiersep> answer ( command ) ; \n \t2 } catch ( final xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 assert <identifiersep> equals ( <string_literal> , get <identifiersep> msg <identifiersep> <identifier> ( ) + max <identifiersep> <identifier> , max <identifiersep> msg ) ; } \n <comment> \n protected void <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> value ) throws io <identifiersep> exception , sql <identifiersep> exception { \n \t1 connection conn = get <identifiersep> connection ( ) ; \n <ect>
\t1 public void delete <identifiersep> job <identifiersep> output ( string <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 try { \n \t3 store . delete <identifiersep> resource ( path <identifiersep> of <identifiersep> job <identifiersep> output ( <identifier> ) ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
<number_literal> @ <identifier> <identifiersep> <identifier> ( name = <string_literal> ) string <identifier> <identifiersep> url , @ <identifier> <identifiersep> <identifier> ( name = <string_literal> ) string <identifier> , \n <number_literal> @ <identifier> <identifiersep> <identifier> ( name = <string_literal> ) string <identifier> , @ <identifier> <identifiersep> <identifier> ( name = <string_literal> ) string password , \n <number_literal> @ <identifier> <identifiersep> <identifier> ( name = <string_literal> ) int timeout <identifiersep> millis , @ <identifier> <identifiersep> <identifier> ( name = <string_literal> ) int <identifier> ) { \n \t2 if ( group <identifiersep> <identifier> . get ( group ) == null ) { \n <ect>
\t4 <identifier> . add ( path , <identifier> ) ; } \n \t3 if ( ! first ) { \n \t4 <comment> \n \t4 <comment> \n <ect>
\t1 private string <identifier> <identifiersep> class ( <identifier> <identifier> ) { \n \t2 string result = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 if ( result == null ) { \n \t3 result = <identifier> <identifiersep> utils . <identifier> ( <identifier> . get <identifiersep> url ( ) ) ; \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; } \n \t2 catch ( interrupted <identifiersep> exception e ) { \n \t3 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n <ect>
\t4 final public <identifiersep> ip public <identifiersep> ip = public <identifiersep> ip . create <identifiersep> from <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( user <identifiersep> ip , <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( user <identifiersep> ip . get <identifiersep> <identifier> <identifiersep> id ( ) ) ) ; \n \t4 public <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> . add ( public <identifiersep> ip ) ; } } \n \t2 try { \n \t3 if ( ! <identifier> <identifiersep> ip <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> ip <identifiersep> <identifier> ( network , true , true , public <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ) ) { \n <ect>
\t1 protected void <identifier> <identifiersep> <identifier> ( map < string , list < <identifier> <identifiersep> info < <identifier> > > > map ) { \n \t2 set < map . entry < string , list < <identifier> <identifiersep> info < <identifier> > > > > <identifier> = map . entry <identifiersep> set ( ) ; \n \t2 for ( map . entry < string , list < <identifier> <identifiersep> info < <identifier> > > > entry : <identifier> ) { \n \t3 for ( <identifier> <identifiersep> info < <identifier> > info : entry . get <identifiersep> value ( ) ) { \n <ect>
\t3 return <identifier> <identifiersep> <identifier> != null ? <identifier> <identifiersep> <identifier> . get ( task <identifiersep> id ) : null ; } \n \t2 public void update <identifiersep> <identifier> ( int task <identifiersep> id , transaction <identifiersep> state state ) { \n \t3 map < integer , transaction <identifiersep> state > <identifier> <identifiersep> <identifier> = <identifier> . get ( task <identifiersep> to <identifiersep> <identifier> <identifiersep> id . get ( task <identifiersep> id ) ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> . put ( task <identifiersep> id , state ) != null ) { \n <ect>
\t1 session <identifiersep> state <identifier> = session <identifiersep> state . get ( ) ; \n \t1 try { \n \t1 <identifier> . load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> . get <identifiersep> path ( ) ) ; } \n \t3 try { \n \t4 file <identifiersep> utils . <identifier> <identifiersep> delete <identifiersep> on <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 final string client <identifiersep> thread <identifiersep> name = get <identifiersep> client <identifiersep> thread <identifiersep> name ( socket ) ; \n \t4 new thread ( new <identifiersep> socket <identifiersep> node , client <identifiersep> thread <identifiersep> name ) . start ( ) ; } \n \t2 } catch ( exception e ) { \n \t3 if ( <identifier> ) { \n <ect>
\t2 return ticket ; } \n \t1 @ <identifier> \n \t1 public void add <identifiersep> ticket ( final ticket ticket ) { \n \t2 this . entity <identifiersep> manager . <identifier> ( ticket ) ; \n <ect>
\t1 boolean <identifier> <identifiersep> native = false ; \n \t1 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> file <identifiersep> format <identifiersep> utils . get <identifiersep> from <identifiersep> path <identifiersep> <identifier> ( \n \t2 path <identifiersep> to <identifiersep> <identifier> <identifiersep> info , <identifier> . get <identifiersep> path ( ) , null ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) \n \t1 { \n <ect>
\t2 <identifier> . get <identifiersep> <identifier> <identifiersep> response <identifiersep> <identifier> ( ) . read <identifiersep> <identifier> <identifiersep> ip ( ip , 0 ) ; \n \t2 int port = <identifier> . get <identifiersep> <identifier> <identifiersep> response <identifiersep> <identifier> ( ) . read <identifiersep> <identifier> <identifiersep> port ( ) ; \n \t2 if ( ( ! is <identifiersep> <identifier> ( ip , port ) ) || ( ! is <identifiersep> <identifier> ( <identifier> . get <identifiersep> ip ( ) , <identifier> . get <identifiersep> port ( ) ) ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 for ( string <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 if ( is <identifiersep> network <identifiersep> a <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> ( <identifier> , <identifier> ) ) { \n \t4 return true ; } } \n \t2 <comment> \n <ect>
\t1 return true ; } \n \t1 if ( ! <identifier> <identifiersep> dir ) { \n \t1 <comment> \n \t1 <comment> \n <ect>
\t1 private void check <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final connection conn ) { \n \t2 final map < string , string > api <identifiersep> map = properties <identifiersep> <identifier> . process <identifiersep> config <identifiersep> file ( new string [ ] { <string_literal> } ) ; \n \t2 if ( api <identifiersep> map == null || api <identifiersep> map . is <identifiersep> empty ( ) ) { \n <ect>
\t3 throw new <identifier> <identifiersep> exception ( metadata . name ( ) , <string_literal> ) ; } \n \t2 path location <identifiersep> file = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> file ( location ) ; \n \t2 if ( location <identifiersep> file == null ) { \n \t3 if ( <identifier> . <identifier> <identifiersep> files ( ) . length > 0 ) { \n <ect>
\t3 volume <identifiersep> manager . remove ( found <identifiersep> <identifier> <identifiersep> volume <identifiersep> info ) ; \n \t3 volume <identifiersep> manager . <identifier> ( ) ; \n \t3 break ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> ip ( ip <identifiersep> id , <identifier> <identifiersep> user <identifiersep> id , <identifier> ) ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + ip <identifiersep> id + <string_literal> ) ; \n \t4 success = false ; } \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 logger . info ( <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> type ) ; \n \t2 response response = target . request ( ) . <identifier> ( entity . entity ( <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> type , <string_literal> ) ) ; \n \t2 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , response . get <identifiersep> status ( ) ) ; \n \t2 string entity = response . read <identifiersep> entity ( string . class ) ; \n <ect>
\t4 } else { \n \t5 <identifier> <identifiersep> max <identifiersep> <identifier> <identifiersep> number ( <identifier> <identifiersep> client , current <identifiersep> <identifier> <identifiersep> number ) ; \n \t5 return <identifier> <identifiersep> <identifier> . first ( ) + 1 ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t2 int x = context . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . next <identifiersep> boolean ( ) ? 1 : 0 ; \n \t2 remove <identifiersep> <identifier> <identifiersep> with <identifiersep> object < t > <identifier> = <identifier> <identifiersep> <identifier> [ x ] ; \n \t2 remove <identifiersep> <identifier> <identifiersep> with <identifiersep> object < t > first <identifiersep> <identifier> = <identifier> ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 node <identifiersep> list <identifier> <identifiersep> <identifier> = \n \t5 x <identifiersep> path <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <string_literal> \n \t7 + <identifier> . get <identifiersep> element ( ) . get <identifiersep> <identifier> ( ) . to <identifiersep> <identifier> <identifiersep> case ( ) ) ; \n \t3 if ( <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> factory . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> options , new handler < <identifier> <identifiersep> result < <identifier> > > ( ) { \n \t5 @ <identifier> \n \t5 public void handle ( <identifier> <identifiersep> result < <identifier> > event ) { \n \t6 if ( event . <identifier> ( ) != null ) { \n <ect>
\t4 if ( e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { \n \t5 <comment> \n \t5 logger . warn ( <string_literal> + <identifier> <identifiersep> url + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t4 } else { \n <ect>
\t4 <comment> \n \t4 context <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> value ( <identifier> <identifiersep> context <identifiersep> <identifier> <identifiersep> map . context <identifiersep> <identifier> . <identifier> <identifiersep> port , port ) ; \n \t4 logger . info ( <string_literal> + port ) ; \n \t4 context <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> value ( <identifier> <identifiersep> context <identifiersep> <identifier> <identifiersep> map . context <identifiersep> <identifier> . <identifier> <identifiersep> host , host ) ; \n <ect>
\t2 return null ; } \n \t1 if ( ! read <identifiersep> start <identifiersep> data ) { \n \t2 log . warn ( <string_literal> + <identifier> <identifiersep> id ) ; } \n \t1 if ( ! read <identifiersep> <identifier> <identifiersep> data ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> session <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> session ( ) ; \n \t4 return <identifier> . <identifier> <identifiersep> <identifier> ( name ) ; \n \t3 } catch ( <identifier> <identifiersep> session <identifiersep> exception <identifier> ) { \n <ect>
\t4 log . info ( <string_literal> , <identifier> ) ; \n \t4 first <identifiersep> event <identifiersep> <identifier> = true ; } \n \t2 } catch ( <identifier> <identifiersep> failed <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t2 dao . set <identifiersep> <identifier> <identifiersep> field ( <identifier> <identifiersep> field ) ; \n \t2 dao . set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 dao . set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 dao . set <identifiersep> count <identifiersep> values ( null ) ; \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> result <identifier> <identifiersep> user ( <identifier> <identifier> , test <identifiersep> user user , int target <identifiersep> length , long <identifiersep> list <identifier> , context context ) { \n \t2 long <identifiersep> set <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( context . <identifier> , <identifier> , user ) ; \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 try { \n \t3 meta <identifiersep> <identifier> . <identifier> ( true ) ; \n \t3 meta <identifiersep> <identifier> . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 msg = <identifier> . <identifier> ( <number_literal> ) ; \n \t5 log . info ( <string_literal> + msg ) ; \n \t5 if ( msg != null ) { \n \t6 <identifier> <identifiersep> <identifier> . add ( msg ) ; } \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> time <identifier> = <identifier> <identifiersep> time . <identifier> ( ) ; \n \t2 long t = <identifier> . get <identifiersep> time ( ) ; \n \t2 int <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> manager . max <identifiersep> <identifier> ; \n <ect>
\t3 try { \n \t4 s <identifiersep> logger . debug ( <string_literal> + access <identifiersep> key + <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> cache . put ( new element ( access <identifiersep> key , <identifier> <identifiersep> <identifier> ) ) ; \n \t3 } catch ( final exception e ) { \n <ect>
\t2 if ( log <identifiersep> <identifier> ) logger . <identifier> ( this , <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 <comment> \n \t2 int <identifier> <identifiersep> length = <identifier> <identifiersep> size <identifiersep> <identifier> + <identifier> <identifiersep> size + <identifier> <identifiersep> length + <identifier> <identifiersep> length * <number_literal> ; \n \t2 if ( <identifier> . length < <identifier> <identifiersep> length + <number_literal> ) { \n <ect>
\t2 { \n \t3 return ; } \n \t2 if ( ! failure <identifiersep> <identifier> . instance . is <identifiersep> <identifier> ( endpoint ) ) \n \t2 { \n <ect>
\t4 . add <identifiersep> as <identifiersep> new ( meta <identifiersep> data . index ( <string_literal> ) ) \n \t4 . build ( ) ; \n \t2 cluster <identifiersep> state cluster <identifiersep> state = cluster <identifiersep> state . builder ( cluster <identifiersep> name . cluster <identifiersep> name <identifiersep> <identifier> . get <identifiersep> default ( <identifier> . empty ) ) . meta <identifiersep> data ( meta <identifiersep> data ) \n \t4 . routing <identifiersep> table ( routing <identifiersep> table ) . build ( ) ; \n <ect>
\t3 throwable <identifier> = exception ; \n \t3 while ( <identifier> != null && <identifier> instanceof io <identifiersep> exception ) { \n \t4 string message = <identifier> . get <identifiersep> message ( ) ; \n \t4 if ( message != null && message . contains ( no <identifiersep> <identifier> <identifiersep> message ) ) { \n <ect>
\t5 thread . <identifier> ( <number_literal> ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { } } \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> pool . shutdown ( ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 job <identifiersep> pool . shutdown ( ) ; \n <ect>
\t1 list < list < string > > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> of <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 int num <identifiersep> <identifier> = <identifier> <identifiersep> of <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> num <identifiersep> <identifier> ( ) ; \n \t1 <comment> \n \t1 if ( ! check <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map ( ) , true ) ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 connection . close ( ) ; \n \t2 super . <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifiersep> manager <identifier> = get <identifiersep> service <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> object ( <identifier> <identifiersep> manager . context <identifiersep> <identifier> <identifiersep> name ) ; \n \t3 return <identifier> . get <identifiersep> storage <identifiersep> manager ( ) . execute ( this , cmd ) ; \n \t2 } catch ( throwable e ) { \n \t3 if ( e instanceof remote <identifiersep> exception ) { \n <ect>
\t1 while ( true ) { \n \t1 try { \n \t2 log . debug ( <string_literal> , task <identifiersep> name , time <identifiersep> <identifier> ) ; \n \t2 t task <identifiersep> result = <identifier> . get ( time <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> table . delete ( <identifier> , <identifier> <identifiersep> table . <identifier> <identifiersep> <identifier> <identifiersep> for ( <identifier> ) ) ; } \n \t3 catch ( throwable t ) \n \t3 { \n <ect>
\t2 <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t2 <identifier> . next ( ) ; \n \t2 max <identifiersep> <identifier> = <identifier> . get <identifiersep> float ( 1 ) ; \n \t1 } catch ( sql <identifiersep> exception <identifier> ) { \n <ect>
\t4 if ( update <identifiersep> <identifier> ) \n \t5 update <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t3 catch ( x <identifiersep> <identifier> <identifiersep> exception e ) \n \t3 { \n <ect>
\t1 result = ( <identifier> <identifiersep> <identifier> <identifiersep> session ) session ; \n \t1 if ( result . is <identifiersep> <identifier> <identifiersep> by ( this ) ) { \n \t2 return result ; } \n \t1 <comment> \n <ect>
\t2 if ( registered <identifiersep> service == null ) { \n \t3 logger . warn ( <string_literal> ) ; \n \t3 return false ; } \n \t2 final web <identifiersep> application <identifiersep> service service = web <identifiersep> application <identifiersep> service <identifiersep> service <identifiersep> factory . create <identifiersep> service ( registered <identifiersep> service . get <identifiersep> service <identifiersep> id ( ) ) ; \n <ect>
\t4 if ( file . exists ( ) ) { \n \t5 file <identifiersep> input <identifiersep> stream file <identifiersep> input <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( file ) ; \n \t5 <identifier> <identifiersep> data = new <identifier> <identifiersep> data ( <identifier> <identifiersep> <identifier> , file <identifiersep> input <identifiersep> stream ) ; \n \t4 } else { \n <ect>
\t2 public void on <identifiersep> <identifier> <identifiersep> timeout ( ) { \n \t3 listener . on <identifiersep> response ( new cluster <identifiersep> <identifier> <identifiersep> response ( false , cluster <identifiersep> state <identifiersep> to <identifiersep> send , new routing <identifiersep> <identifier> ( ) ) ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> failure ( string source , exception e ) { \n <ect>
\t5 <identifier> <identifiersep> file . delete ( ) ; \n \t5 if ( ! <identifier> ) continue ; \n \t5 throw new <identifier> <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } \n \t4 if ( this . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> class <identifiersep> name ) ) { \n <ect>
\t2 } finally { \n \t3 try { \n \t4 <identifier> <identifiersep> stream . close ( ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 } else if ( this . <identifier> . length == <identifier> <identifiersep> state <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 <comment> \n \t4 <comment> \n \t2 } else { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> message . get <identifiersep> from ( ) == null || <identifier> <identifiersep> message . get <identifiersep> from ( ) . is <identifiersep> empty ( ) ) { \n \t3 string <identifier> = get <identifiersep> configuration ( ) . get <identifiersep> default <identifiersep> from ( ) ; \n \t3 <identifier> <identifiersep> message . set <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t1 @ <identifier> \n \t1 protected void run <identifiersep> task ( list < string > <identifier> ) throws exception { \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> url + <string_literal> + user ) ; \n \t2 log . info ( <string_literal> + destination ) ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> . resource <identifiersep> service . get <identifiersep> <identifier> <identifiersep> url ( \n \t6 <string_literal> ) ) ) ; \n \t2 } catch ( io <identifiersep> exception e ) \n \t2 { \n <ect>
\t1 private void write <identifiersep> out <identifiersep> <identifier> <identifiersep> class ( byte [ ] <identifier> <identifiersep> <identifier> , file file ) { \n \t2 try { \n \t3 if ( file . delete ( ) ) { \n \t4 if ( ! file . create <identifiersep> new <identifiersep> file ( ) ) { \n <ect>
\t3 try { \n \t4 while ( <identifier> . <identifier> ( ) ) { \n \t5 <identifier> . <identifier> ( <identifier> . read <identifiersep> line ( ) ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 int num <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) . size ( ) ; \n \t2 for ( int i = 0 ; i < num <identifiersep> <identifier> ; i ++ ) { \n \t3 transaction <identifiersep> input <identifier> <identifiersep> in = <identifier> . get <identifiersep> input ( i ) ; \n \t3 if ( <identifier> <identifiersep> in . get <identifiersep> <identifier> <identifiersep> output ( ) == null ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> resource . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> local . class ) ) ; \n <ect>
\t3 log . debug ( <string_literal> , config . get <identifiersep> registered <identifiersep> <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ) ; \n \t3 log . debug ( <string_literal> , config . get <identifiersep> registered <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( ) . entry <identifiersep> set ( ) . to <identifiersep> string ( ) ) ; \n \t3 log . debug ( <string_literal> , config . get <identifiersep> registered <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . entry <identifiersep> set ( ) . to <identifiersep> string ( ) ) ; \n <ect>
\t3 case delete <identifiersep> <identifier> : \n \t4 handle <identifiersep> delete <identifiersep> <identifier> <identifiersep> request ( <identifier> . lock <identifiersep> name , <identifier> . <identifier> ) ; \n \t4 break ; \n \t3 default : \n <ect>
\t6 else \n \t7 <identifier> . entry <identifiersep> <identifier> ( this , <identifier> , <identifier> , options ) ; } } \n \t4 return true ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <identifier> . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t2 } catch ( <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 protected <identifier> < <identifier> <identifiersep> registered <identifiersep> service , <identifier> <identifiersep> registered <identifiersep> service <identifiersep> service <identifiersep> provider <identifiersep> metadata <identifiersep> <identifier> > get <identifiersep> registered <identifiersep> service <identifiersep> and <identifiersep> <identifier> ( final <identifier> <identifiersep> request request ) { \n \t2 final string <identifier> = <identifier> <identifiersep> id <identifiersep> p <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> request ( request ) ; \n \t2 logger . debug ( <string_literal> , <identifier> ) ; \n \t2 final <identifier> <identifiersep> registered <identifiersep> service registered <identifiersep> service = <identifier> <identifiersep> <identifier> <identifiersep> registered <identifiersep> service ( <identifier> ) ; \n <ect>
\t3 try { \n \t4 policy <identifiersep> <identifier> = file <identifiersep> utils . read <identifiersep> file <identifiersep> to <identifiersep> string ( get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> file ( <string_literal> ) ) ; \n \t4 return policy <identifiersep> <identifier> ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 device <identifiersep> token = <identifier> <identifiersep> request . execute ( ) . parse <identifiersep> as ( device <identifiersep> token . class ) ; \n \t5 if ( device <identifiersep> token . access <identifiersep> token != null ) { \n \t7 logger . debug ( <string_literal> ) ; \n <ect>
\t4 return ; } \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> . no <identifiersep> access <identifiersep> token ( ) ) { \n \t4 if ( ! <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> access <identifiersep> token ( ) ) { \n <ect>
\t1 else { \n \t2 add <identifiersep> object <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } } \n public void remove <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . <identifier> object ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> <identifiersep> model ) ; \n \t3 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t2 logger . info ( <string_literal> + this . <identifier> <identifiersep> builder . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> set ( ) . size ( ) ) ; \n \t2 logger . info ( <string_literal> + this . <identifier> <identifiersep> builder . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> set ( ) . size ( ) ) ; \n <ect>
\t2 for ( <identifier> <identifier> : <identifier> . key <identifiersep> set ( ) ) { \n \t3 if ( <identifier> . get ( <identifier> ) != null ) { \n \t4 to <identifiersep> <identifier> . add ( <identifier> ) ; } } \n \t2 for ( <identifier> <identifier> : to <identifiersep> <identifier> ) { \n <ect>
\t1 } catch ( exception e ) { \n \t1 try { \n \t2 config = <identifier> . <identifier> ( new <identifier> <identifiersep> <identifier> <identifiersep> factory <identifiersep> configuration ( ) ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t4 logger . debug ( <string_literal> , result ) ; \n \t4 if ( result != null && ! <identifier> . is <identifiersep> <identifier> <identifiersep> from ( result . get <identifiersep> class ( ) ) ) { \n \t5 throw new class <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + result + <string_literal> + result . get <identifiersep> class ( ) + <string_literal> + <identifier> ) ; } \n \t4 return ( t ) result ; } \n <ect>
\t2 synchronized ( <identifier> ) { \n \t3 store = <identifier> . get ( node . get <identifiersep> id ( ) ) ; \n \t3 if ( store == null ) { \n <ect>
\t3 return null ; } \n \t2 list < long > <identifier> <identifiersep> <identifier> = find <identifiersep> host <identifiersep> by <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) , <identifier> . get <identifiersep> id ( ) ) ; \n \t2 for ( long host <identifiersep> id : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 protected set < event > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider ( final request <identifiersep> context context , final registered <identifiersep> service service , \n <number_literal> final principal principal , \n <number_literal> final collection < <identifier> <identifiersep> authentication <identifiersep> provider > <identifier> ) { \n \t2 final <identifier> <identifiersep> authentication <identifiersep> provider provider = <identifier> . <identifier> ( ) . next ( ) ; \n <ect>
\t7 if ( debug ) system . out . <identifier> ( <string_literal> + <identifier> + <string_literal> ) ; \n \t7 thread . <identifier> ( <identifier> ) ; } \n \t5 } catch ( channel <identifiersep> exception x ) { \n \t6 if ( debug ) log . error ( <string_literal> + x . get <identifiersep> message ( ) , x ) ; \n <ect>
\t2 return this . <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) . to <identifiersep> string ( ) ; } \n \t1 @ <identifier> \n \t1 public string <identifier> <identifiersep> <identifier> <identifiersep> value ( final <identifier> <identifier> , final http <identifiersep> <identifier> <identifiersep> request request ) { \n \t2 final string <identifier> <identifiersep> value = this . <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> . get <identifiersep> value ( ) ) . to <identifiersep> string ( ) ; \n <ect>
\t1 } finally { \n \t1 try { \n \t2 session . get <identifiersep> transport ( ) . close ( ) ; \n \t1 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 return path ; \n \t1 } else { \n \t1 return path + file . <identifier> ; } } \n private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> path ( string path ) throws exception { \n <ect>
\t5 if ( connection <identifiersep> <identifier> != null ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> connection <identifiersep> <identifier> = connection <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t6 <identifier> <identifiersep> connection <identifiersep> <identifier> . set <identifiersep> object <identifiersep> for <identifiersep> key ( <string_literal> , <string_literal> ) ; \n \t6 connection <identifiersep> <identifier> = <identifier> <identifiersep> connection <identifiersep> <identifier> ; } \n <ect>
\t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n <ect>
\t4 <comment> \n \t4 object value = e <identifiersep> key <identifiersep> <identifier> <identifiersep> config . get <identifiersep> value <identifiersep> of <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , provider . get <identifiersep> item <identifiersep> <identifier> ( item <identifiersep> name ) ) ; \n \t4 if ( value == null ) { \n \t5 <comment> \n <ect>
\t2 } else { \n \t2 input <identifiersep> size = <identifier> . get <identifiersep> conf ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> data <identifiersep> size ( ) ; } \n \t2 <identifier> = ( int ) <identifier> . <identifier> ( ( double ) input <identifiersep> size / max <identifiersep> <identifier> <identifiersep> size ) ; } \n <ect>
\t2 grid <identifiersep> cache <identifiersep> <identifier> <identifiersep> check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < <identifier> , v > <identifier> = ( grid <identifiersep> cache <identifiersep> <identifier> <identifiersep> check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < <identifier> , v > ) <identifier> . <identifier> ( ) . \n \t3 < boolean > <identifier> ( <identifier> . version ( ) , <identifier> . <identifier> <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 thread . <identifier> ( <number_literal> ) ; } } \n \t1 <comment> \n \t1 <comment> \n \t1 log . error ( <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; \n <ect>
\t2 assert <identifiersep> cache <identifiersep> <identifier> ( cache , 1 , <number_literal> * <number_literal> , 1 , 1 ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , \n \t3 get <identifiersep> <identifier> ( id <identifiersep> <identifier> + 0 , cache . get <identifiersep> if <identifiersep> <identifier> ( id <identifiersep> <identifier> + 0 ) ) , \n \t3 cache . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> current <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 <identifier> . close ( ) ; } \n \t2 <identifier> . close ( ) ; \n \t2 final <identifier> <identifiersep> <identifier> <identifiersep> format <identifier> <identifiersep> format = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . file <identifiersep> context . <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 state = ( transaction <identifiersep> state ) event . get <identifiersep> event <identifiersep> value ( ) . get ( 0 ) ; \n \t3 <identifier> <identifiersep> status = state . <identifier> ; \n \t3 <identifier> <identifiersep> state ( state ) ; \n \t3 <comment> \n <ect>
\t6 object <identifier> = class <identifiersep> <identifier> . new <identifiersep> instance ( <string_literal> ) ; \n \t6 method execute = <identifier> . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> method ( <string_literal> , string [ ] . class ) ; \n \t6 execute . <identifier> ( <identifier> , ( object ) <identifier> <identifiersep> <identifier> ) ; \n \t5 } catch ( throwable e ) { \n <ect>
\t1 <identifier> m = new <identifier> ( <string_literal> ) ; \n \t1 m . put ( <string_literal> , <string_literal> , <string_literal> ) ; \n \t1 <identifier> . add <identifiersep> <identifier> ( m ) ; \n \t1 <identifier> . close ( ) ; \n <ect>
\t3 public test <identifiersep> response new <identifiersep> instance ( ) { \n \t4 return new test <identifiersep> response ( ) ; } \n \t3 @ <identifier> \n \t3 public void handle <identifiersep> response ( test <identifiersep> response response ) { \n <ect>
\t3 if ( <identifier> . is <identifiersep> local ( ) || <identifier> . is <identifiersep> <identifier> ( ) || ( <identifier> != null && ( <identifier> . <identifier> ( ) || <identifier> . <identifier> ( ) ) && <identifier> . local ( ) ) ) \n \t4 <identifier> . <identifier> <identifiersep> <identifier> ( ) . on <identifiersep> entry <identifiersep> update ( this , key , <identifier> , value <identifiersep> bytes <identifiersep> <identifier> ( ) , <identifier> , <identifier> <identifiersep> bytes ) ; \n \t3 <identifier> . data <identifiersep> <identifier> ( ) . on <identifiersep> entry <identifiersep> <identifier> ( key , false ) ; } \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class <identifier> <identifiersep> command <identifiersep> class = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> command <identifiersep> class ) node \n \t5 . get <identifiersep> command <identifiersep> class ( command <identifiersep> class . <identifier> <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> <identifiersep> command <identifiersep> class != null && <identifier> <identifiersep> command <identifiersep> class . is <identifiersep> <identifier> ( ) == false ) { \n \t4 <comment> \n <ect>
\t3 } else { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t3 <identifier> ( false , true ) ; \n \t3 <identifier> <identifiersep> empty <identifiersep> check ( ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 try { \n \t4 <identifier> . <identifier> <identifiersep> context ( ) . <identifier> ( ) . read <identifiersep> lock ( ) ; } \n \t3 catch ( illegal <identifiersep> state <identifiersep> exception ignore ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( id . to <identifiersep> string ( ) , ( <identifier> <identifiersep> <identifier> <identifiersep> event ) <identifier> <identifiersep> <identifier> <identifiersep> class . new <identifiersep> instance ( ) , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t5 <identifier> <identifiersep> <identifier> . set <identifiersep> send <identifiersep> event <identifiersep> mode ( info . event <identifiersep> mode ( ) ) ; \n \t5 logger . debug ( <string_literal> , id ) ; \n \t4 } catch ( <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t2 cluster <identifiersep> <identifier> = <identifier> <identifiersep> set \n \t3 . <identifier> <identifiersep> of ( <identifier> ( filter ( cluster <identifiersep> <identifier> , in ( <identifier> <identifiersep> <identifier> ) ) , <identifier> <identifiersep> <identifier> <identifiersep> query , property <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> query ) . get ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 if ( <identifier> . is <identifiersep> client ( ) ) { \n \t1 logger . debug ( <string_literal> ) ; \n \t1 <identifier> = <identifier> . create ( message <identifiersep> <identifier> . class ) ; } \n \t1 else { \n <ect>
\t1 { \n \t2 if ( <identifier> . is <identifiersep> client ( ) ) \n \t2 { \n \t3 return ; } \n <ect>
\t4 final java . <identifier> . date date = new java . <identifier> . date ( ) ; \n \t4 final long long <identifiersep> date = date . get <identifiersep> time ( ) ; \n \t4 final float <identifier> <identifiersep> in <identifiersep> <identifier> = ( t . get <identifiersep> <identifier> ( long <identifiersep> date ) ) ; \n \t4 <identifier> <identifiersep> in <identifiersep> <identifier> = <identifier> <identifiersep> in <identifiersep> <identifier> / ( <number_literal> * <number_literal> * <number_literal> ) ; \n <ect>
\t1 <identifier> current <identifiersep> <identifier> = get <identifiersep> client <identifiersep> <identifier> ( ) . find ( config . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> web <identifiersep> context , <identifier> ) \n \t1 logger . debug ( <string_literal> , current <identifiersep> <identifier> ) \n \t1 <identifier> action = try { \n \t2 if ( start <identifiersep> authentication ( <identifier> <identifiersep> web <identifiersep> context , current <identifiersep> <identifier> ) ) { \n <ect>
\t3 super ( <identifier> ) ; } \n \t2 <comment> \n \t2 @ <identifier> public <identifier> execute ( ) { \n <ect>
\t3 } else { \n \t5 log . debug ( <string_literal> ) ; } \n <ect>
\t4 return null ; } \n \t3 final abstract <identifiersep> resource resource <identifiersep> from = resource <identifiersep> utils . get <identifiersep> resource <identifiersep> from ( <identifier> <identifiersep> file ) ; \n \t3 final file the <identifiersep> <identifier> <identifiersep> file = resource <identifiersep> from . get <identifiersep> file ( ) ; \n \t3 if ( the <identifiersep> <identifier> <identifiersep> file . exists ( ) ) { \n <ect>
\t1 @ action <identifiersep> <identifier> ( text = <string_literal> , <identifier> = <string_literal> ) \n \t1 public static object [ ] <identifier> <identifiersep> read <identifiersep> event ( \n \t3 @ <identifier> <identifiersep> <identifier> ( name = <string_literal> , text = <string_literal> ) int event <identifiersep> index ) { \n \t2 if ( ! <identifier> <identifiersep> is <identifiersep> <identifier> ( ) ) { \n <ect>
<comment> \n \t2 public void run ( ) { \n \t3 string local <identifiersep> address = client <identifiersep> socket . get <identifiersep> local <identifiersep> address ( ) . to <identifiersep> string ( ) ; \n \t3 string remote <identifiersep> address = client <identifiersep> socket . get <identifiersep> remote <identifiersep> socket <identifiersep> address ( ) . to <identifiersep> string ( ) ; \n <ect>
\t4 if ( ! <identifier> ) { \n \t5 if ( <identifier> <identifiersep> <identifier> != null ) \n \t6 logger . <identifier> ( this , <string_literal> + <identifier> <identifiersep> routing <identifiersep> to + <string_literal> ) ; \n \t5 else \n <ect>
\t5 <comment> \n \t4 } finally { \n \t5 id = null ; } \n \t3 } else if ( <identifier> . get ( ) ) { \n <ect>
\t5 final <identifier> <identifiersep> vo <identifier> = ( <identifier> <identifiersep> vo ) <identifier> ; \n \t5 if ( ! remove <identifiersep> group ( <identifier> ) ) { \n \t6 log . warn ( string . format ( <string_literal> , <identifier> . get <identifiersep> path ( ) , <identifier> . get <identifiersep> id ( ) ) ) ; } \n \t4 } catch ( final exception e ) { \n <ect>
\t5 <identifier> <identifiersep> state . add <identifiersep> <identifier> ( <identifier> ) ; \n \t5 <identifier> ++ ; \n \t4 } else if ( ! should <identifiersep> store <identifiersep> to ( ( <identifier> <identifiersep> info ) <identifier> ) ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t5 io <identifiersep> session . close <identifiersep> <identifier> ( ) ; \n \t4 } else { \n \t5 session <identifiersep> log . on <identifiersep> error <identifiersep> event ( <string_literal> + e . get <identifiersep> message ( ) ) ; } } \n \t2 } else { \n <ect>
\t5 file <identifiersep> utils . write <identifiersep> byte <identifiersep> array <identifiersep> to <identifiersep> file ( log <identifiersep> file , <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n \t5 logger . error ( <string_literal> , <identifier> <identifiersep> address . get <identifiersep> <identifier> ( ) . get <identifiersep> name ( ) , \n \t7 log <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n <ect>
\t3 <comment> \n \t3 resource <identifiersep> manager <identifiersep> exception exception = new resource <identifiersep> manager <identifiersep> exception ( <string_literal> + \n \t4 <string_literal> , e ) ; \n \t4 on <identifiersep> <identifier> <identifiersep> error ( exception ) ; \n <ect>
\t3 log . debug ( <string_literal> , key ) ; \n \t3 <identifier> <identifiersep> client . shutdown ( ) ; \n \t3 <identifier> <identifiersep> client <identifiersep> cache . remove ( key ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public void run ( ) { \n \t2 try { \n \t2 <identifier> . <identifier> ( <string_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( port <identifiersep> state == port <identifiersep> state . <identifier> ) { \n \t4 <comment> \n \t4 logger . info ( <string_literal> ) ; \n \t3 } else { \n <ect>
\t3 <comment> \n \t4 try { \n \t5 from = process <identifiersep> <identifier> ( ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 <identifier> . put ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> ) ; } \n \t2 } else { \n \t3 if ( <identifier> . remove ( <identifier> . get <identifiersep> <identifier> ( ) ) != null ) { \n <ect>
\t2 if ( <identifier> <identifiersep> uri == null ) { \n \t3 log . warn ( <string_literal> , <identifier> ) ; \n \t3 return null ; } \n \t2 if ( ! <identifier> <identifiersep> uri . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
\t4 final exchange exchange = queue . <identifier> ( get <identifiersep> <identifier> <identifiersep> endpoint ( ) . get <identifiersep> config ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , time <identifiersep> unit . <identifier> ) ; \n \t4 <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( queue , exchange ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public boolean remove ( <identifier> <identifiersep> uri id ) { \n \t2 <identifier> <identifier> = get ( id ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t7 write <identifiersep> message ( command ) ; \n \t7 wait <identifiersep> on <identifiersep> <identifier> <identifiersep> response = true ; \n \t7 wait <identifiersep> timeout = 0 ; \n \t6 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 logger . error ( <string_literal> ) ; \n \t4 return null ; } \n \t3 object object = map <identifiersep> element ( node . get <identifiersep> node <identifiersep> name ( ) ) ; \n \t3 if ( object == null ) { \n <ect>
\t5 . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; <comment> \n \t3 <comment> \n \t3 <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( <string_literal> + connection <identifiersep> name + <string_literal> ) ; \n \t3 <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( <string_literal> + connection <identifiersep> name + <string_literal> ) ; \n <ect>
\t4 return <identifier> <identifiersep> <identifier> . result ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t3 return <identifier> <identifiersep> <identifier> . no <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( exception ex ) \n \t2 { \n <ect>
\t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 public boolean <identifier> <identifiersep> <identifier> ( class < ? > <identifier> , list < ? > db <identifiersep> list , list < ? > <identifier> <identifiersep> list ) throws exception { \n \t2 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . log ( <string_literal> + get <identifiersep> class <identifiersep> name ( <identifier> ) + <string_literal> ) ; \n <ect>
\t5 message . <identifier> <identifiersep> <identifier> <identifiersep> version = <identifier> <identifiersep> <identifier> <identifiersep> version ; } \n \t3 return message ; } \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> exception <identifiersep> handler == null || ! <identifier> <identifiersep> exception <identifiersep> handler . <identifier> ( e ) ) \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t3 } else \n \t4 <identifier> ( <identifier> , <string_literal> ) ; } } \n \t1 private void <identifier> ( command <identifier> , string <identifier> ) throws exception { \n <ect>
\t1 public string get <identifiersep> name ( ) { \n \t2 return <identifier> <identifiersep> name ; } \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final byte [ ] <identifier> <identifiersep> <identifier> , final string <identifier> <identifiersep> password , final string <identifier> <identifiersep> password ) { \n \t2 final object resource = this ; \n <ect>
\t3 logger . warn ( <string_literal> , new <identifiersep> name ) ; \n \t3 if ( new <identifiersep> name != null ) { \n \t4 if ( ! <identifier> <identifiersep> name . equals <identifiersep> ignore <identifiersep> case ( new <identifiersep> name ) ) { \n \t5 <identifier> <identifiersep> new <identifiersep> <identifier> . add ( new item <identifiersep> vo ( <identifier> <identifiersep> name , new <identifiersep> name ) ) ; \n <ect>
\t2 out . <identifier> ( 1 ) . <identifier> ( <string_literal> ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> method <identifiersep> table <identifiersep> <identifier> <identifiersep> function ( java <identifiersep> <identifier> out , table <identifiersep> <identifier> function , string java <identifiersep> method <identifiersep> name ) { \n \t2 <comment> \n \t2 if ( function . get <identifiersep> <identifier> ( ) . size ( ) > <number_literal> ) { \n <ect>
\t2 try { \n \t3 method method = class <identifiersep> <identifier> . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> method ( <string_literal> , new class [ ] { java . <identifier> . url . class } ) ; \n \t3 method . set <identifiersep> <identifier> ( true ) ; \n \t3 method . <identifier> ( class <identifiersep> <identifier> , new object [ ] { <identifier> } ) ; \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> service . load <identifiersep> <identifier> ( <identifier> ) ; \n \t4 <identifier> <identifiersep> package . get <identifiersep> instance ( ) . set <identifiersep> test <identifiersep> <identifier> <identifiersep> file ( <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t4 load . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( 1 , <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> context ( ) . delete <identifiersep> object ( <identifier> ) ; \n \t5 <identifier> <identifiersep> context ( ) . <identifier> <identifiersep> <identifier> ( ) ; \n \t4 } catch ( throwable e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = load <identifiersep> configuration ( config <identifiersep> to <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> != null && ! current <identifiersep> configuration . equals ( <identifier> ) ) { \n \t3 log . info ( <string_literal> + config <identifiersep> to <identifiersep> <identifier> + <string_literal> + new date ( last <identifiersep> <identifier> ) ) ; \n \t3 log . debug ( <string_literal> + filter <identifiersep> <identifier> ( current <identifiersep> configuration ) ) ; \n <ect>
\t4 <identifier> <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list <identifiersep> root ( ) \n \t5 . get <identifiersep> group ( test <identifiersep> group <identifiersep> <identifier> ) ) ; } \n \t2 catch ( operation <identifiersep> failed <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( class <identifiersep> <identifier> ) ; } \n \t1 private static class < ? > load <identifiersep> <identifier> ( <identifier> <identifier> ) { \n \t2 try { \n \t3 class <identifiersep> <identifier> . add <identifiersep> url ( new file ( <identifier> <identifiersep> <identifier> + ' / ' + <identifier> . get <identifiersep> <identifier> ( ) ) . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ) ; \n <ect>
\t2 node <identifiersep> list state <identifiersep> list = <identifier> . get <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> ( <identifier> <identifiersep> value , \n \t3 state <identifiersep> element ) ; \n \t2 if ( state <identifiersep> list . get <identifiersep> length ( ) == 0 ) \n \t2 { \n <ect>
\t3 system <identifiersep> info . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) / <identifier> ) ; \n \t3 system <identifiersep> info . set <identifiersep> system ( <identifier> <identifiersep> system . is <identifiersep> <identifier> ? system <identifiersep> info . system . <identifier> : system <identifiersep> info . system . <identifier> ) ; \n \t3 system <identifiersep> info . set <identifiersep> <identifier> <identifiersep> values ( get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> data ( ) ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t5 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> node <identifiersep> id ) ; } \n \t4 s <identifiersep> logger . info ( <string_literal> + <identifier> . get <identifiersep> name ( ) ) ; \n \t4 success = true ; \n \t4 return result ; } \n <ect>
\t2 map < ? , ? > map = null ; \n \t2 try { \n \t3 map = <identifier> . read <identifiersep> value ( json , map . class ) ; \n \t2 } catch ( exception e ) { \n <ect>
host <identifiersep> update <identifiersep> <identifier> <identifiersep> cmd = <string_literal> + \\ \n \t7 <string_literal> + \\ \n \t7 <string_literal> + config <identifiersep> <identifier> . server <identifiersep> out <identifiersep> file + <string_literal> \n <identifier> update <identifiersep> host <identifiersep> <identifier> ( <identifier> , options ) : \n <ect>
\t3 parse <identifiersep> result = parse <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> data ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> file , file <identifiersep> number ) ; \n \t3 if ( ! parse <identifiersep> result ) { \n \t4 <identifier> <identifiersep> error = true ; } \n \t2 } catch ( <identifier> <identifiersep> parse <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> <identifier> . do <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( context , new do <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t4 @ <identifier> \n \t4 public void execute ( string context <identifiersep> name , \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> context <identifier> <identifiersep> context ) throws exception { \n <ect>
\t3 <identifier> . <identifier> ( <identifier> <identifiersep> key ) ; \n \t3 byte [ ] <identifier> <identifiersep> <identifier> = <identifier> . do <identifiersep> final ( data . get <identifiersep> bytes ( ) ) ; \n \t3 return <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t5 files <identifiersep> <identifier> . <identifier> <identifiersep> delete ( <identifier> ) ; \n \t5 <identifier> <identifiersep> list . get <identifiersep> list ( ) . remove ( <identifier> <identifiersep> info ) ; \n \t5 <identifier> <identifiersep> list . set <identifiersep> <identifier> ( null ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> properties <identifiersep> set ( ) throws <identifier> <identifiersep> exception { \n \t2 if ( <identifier> ++ > 0 ) { \n \t3 return ; } \n <ect>
\t5 thread <identifiersep> <identifier> <identifiersep> stack <identifiersep> transaction . set ( <identifier> ) ; \n \t4 } else { \n \t5 thread <identifiersep> transaction . set ( <identifier> ) ; } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . execute ( ( ) - > next <identifiersep> filter . on <identifiersep> error ( \n \t4 new timeout <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> request <identifiersep> timeout + <string_literal> ) , \n \t4 request <identifiersep> context , <identifier> <identifiersep> <identifier> ) ) ; \n \t3 } catch ( <identifier> <identifiersep> execution <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . put ( <string_literal> , ( byte ) <identifier> ) ; \n \t2 <identifier> . put ( <string_literal> , ( byte ) <identifier> ) ; \n \t2 byte code = <identifier> . get ( action ) ; \n \t2 if ( code == null ) { \n <ect>
\t2 } else { \n \t3 last <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; } \n \t2 if ( log <identifiersep> stream == null ) { \n <ect>
\t2 <identifier> <identifier> = new <identifier> ( <identifier> ) ; \n \t2 collection < package <identifiersep> <identifier> > <identifier> = <identifier> . <identifier> ( get <identifiersep> <identifier> ( ) . key <identifiersep> set ( ) , false ) ; \n \t2 <identifier> . remove <identifiersep> all ( get <identifiersep> <identifier> ( ) . key <identifiersep> set ( ) ) ; \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 connection . start ( ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t3 text <identifiersep> message message = session . create <identifiersep> text <identifiersep> message ( <identifier> . get <identifiersep> name ( ) ) ; \n \t3 <identifier> . send ( message ) ; \n <ect>
\t1 final properties <identifier> = new <identifiersep> default <identifiersep> properties ( ) ; \n \t1 if ( <identifier> != null ) { \n \t2 <identifier> . put <identifiersep> all ( <identifier> ) ; } \n \t1 } catch ( final exception e ) { \n <ect>
\t5 if ( <identifier> . <identifier> ( ) ) { \n \t6 s <identifiersep> logger . warn ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> ip ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> ip ( ) ) ; \n \t6 break ; } \n \t5 <identifier> [ 0 ] = <identifier> <identifiersep> <identifier> <identifiersep> api . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( command . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> [ 0 ] ) ; \n <ect>
\t1 public void <identifier> <identifiersep> <identifier> ( list < xml <identifiersep> <identifier> > xml <identifiersep> <identifier> , list < i <identifiersep> <identifier> > <identifier> , string output <identifiersep> directory ) { \n \t2 try { \n \t3 <identifier> = create <identifiersep> <identifier> ( output <identifiersep> directory ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 if ( ! connection . is <identifiersep> <identifier> ( ) ) { \n \t5 <identifier> = false ; \n \t5 get <identifiersep> connection ( ) ; } \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t5 try { \n \t6 <identifier> <identifiersep> <identifier> . <identifier> ( conn ) ; \n \t5 } catch ( final exception e ) { \n <ect>
\t5 log . debug ( message , <string_literal> ) ; \n \t4 break ; \n \t3 case log <identifiersep> info : \n <ect>
<comment> \n <ect>
\t4 <identifier> . put <identifiersep> all ( <identifier> <identifiersep> properties ( <identifier> ) ) ; \n \t3 } else { \n \t4 final properties <identifier> = new properties ( ) ; \n \t4 <identifier> . load ( files . new <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . to <identifiersep> path ( ) , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> ) ) ; \n <ect>
\t4 if ( <identifier> ) { \n \t5 break ; } \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> list <identifiersep> file . get <identifiersep> name ( ) . equals ( <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> . in <identifiersep> <identifier> <identifiersep> file <identifiersep> name ) ) { \n \t5 continue ; } \n <ect>
\t4 if ( <identifier> <identifiersep> utils . execute <identifiersep> password <identifiersep> <identifier> <identifiersep> operation ( <identifier> , factory , c . get <identifiersep> password ( ) , bean . get <identifiersep> password ( ) , \n \t5 properties . get <identifiersep> <identifier> ( ) . get <identifiersep> type ( ) ) ) { \n \t5 logger . debug ( <string_literal> , <identifier> ) ; \n \t5 return true ; } \n <ect>
\t1 <identifier> . <identifier> ( <string_literal> ) . <identifier> ( info . get ( 0 ) ) . <identifier> ( ' , ' ) ; \n \t1 <identifier> . <identifier> ( <string_literal> ) . <identifier> ( info . get ( 1 ) ) . <identifier> ( ' , ' ) ; \n \t1 <identifier> . <identifier> ( <string_literal> ) . <identifier> ( info . get ( <number_literal> ) ) . <identifier> ( ' ] ' ) ; \n \t1 <identifier> . <identifier> ( ' \\ <identifier> ) ; } \n <ect>
\t3 if ( <identifier> != null && <identifier> . <identifier> ( ) ) { \n \t4 task = new task ( <identifier> , <identifier> ) ; \n \t4 s <identifiersep> <identifier> . execute ( task ) ; } \n \t3 while ( true ) { \n <ect>
<comment> \n \t1 public void on <identifiersep> success ( stream <identifiersep> state state ) \n \t1 { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 file <identifier> <identifiersep> file = new file ( dir , <string_literal> ) ; \n \t4 try { \n \t5 io <identifiersep> <identifier> . write <identifiersep> <identifier> ( <identifier> <identifiersep> file , <string_literal> ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 string job <identifiersep> name = <identifier> <identifiersep> job . class . get <identifiersep> <identifier> <identifiersep> name ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifiersep> <identifier> ( ) . with <identifiersep> <identifier> ( job <identifiersep> name + <string_literal> , job <identifiersep> group ) . start <identifiersep> <identifier> ( ) \n \t4 . with <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> builder . <identifier> <identifiersep> <identifier> ( <string_literal> ) ) . build ( ) ; \n \t2 <identifier> ( job <identifiersep> name , <identifier> <identifiersep> job . class , <identifier> <identifiersep> <identifier> , new job <identifiersep> data <identifiersep> map ( ) ) ; \n <ect>
\t6 log . debug ( <string_literal> + config . get <identifiersep> id ( ) ) ; } } } \n \t3 <identifier> . <identifier> ( ) ; } \n \t2 catch ( exception ex ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t2 log . debug ( <string_literal> + <identifier> <identifiersep> format ) ; \n \t2 if ( <identifier> <identifiersep> format != 1 ) { \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 int <identifier> = <identifier> . read <identifiersep> short ( ) ; \n <ect>
\t1 { \n \t2 string <identifier> <identifiersep> value = options . get ( <identifier> <identifiersep> <identifier> <identifiersep> key ) ; \n \t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> value == null ? default <identifiersep> <identifier> <identifiersep> <identifier> : time <identifiersep> unit . value <identifiersep> of ( <identifier> <identifiersep> value ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> != default <identifiersep> <identifier> <identifiersep> <identifier> ) \n <ect>
\t2 } catch ( throwable e ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } catch ( throwable <identifier> ) { \n <ect>
\t1 public <identifier> find <identifiersep> <identifier> ( string <identifier> ) throws exception { \n \t2 log . debug ( <string_literal> , <identifier> ) ; \n \t2 return map . get ( <identifier> ) ; } \n \t1 public <identifier> find <identifiersep> <identifier> ( string <identifier> ) throws exception { \n <ect>
\t4 logger . error ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t2 } ; } \n \t1 private void <identifier> <identifiersep> context <identifiersep> for <identifiersep> session <identifiersep> <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> factory <identifier> ) { \n \t2 if ( ! is <identifiersep> session <identifiersep> <identifier> <identifiersep> enabled ( ) ) { \n <ect>
\t1 @ <identifier> \n \t1 public boolean execute <identifiersep> user <identifiersep> request ( long host <identifiersep> id , event event ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( event == event . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 this . <identifier> <identifiersep> handler = <identifier> <identifiersep> handler ; } \n public boolean should <identifiersep> <identifier> <identifiersep> request ( http <identifiersep> command command , http <identifiersep> response response ) { \n \t1 close <identifiersep> client <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> content <identifiersep> stream ( response ) ; \n \t1 if ( ! command . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this . default <identifiersep> group <identifiersep> id , \n \t6 message <identifiersep> handler , config <identifiersep> with <identifiersep> <identifier> <identifiersep> config , <identifier> ) ; \n \t4 message <identifiersep> handler . start <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t3 } else { \n <ect>
\t3 <identifier> [ 0 ] . send ( new <identifier> [ ] { <identifier> } , new test <identifiersep> msg ( ) , 0 ) ; \n \t3 boolean last = ( i == n - 1 ) ; \n \t3 if ( ! last && <identifier> > 0 ) { \n \t4 thread . <identifier> ( <identifier> ) ; } } \n <ect>
\t2 } catch ( execution <identifiersep> exception e ) { \n \t3 if ( e . get <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> exception ) { \n \t4 <identifier> <identifiersep> exception exception = ( <identifier> <identifiersep> exception ) e . get <identifiersep> <identifier> ( ) ; \n <ect>
\t1 @ <identifier> public void send <identifiersep> <identifier> ( ) { \n \t2 log . info ( <string_literal> ) ; \n \t2 for ( task <identifiersep> data <identifiersep> output output : <identifier> ) { \n \t3 output . send <identifiersep> <identifier> ( ) ; } \n <ect>
\t3 if ( <identifier> . filter ( <identifier> , ex ) ) { \n \t3 try { \n \t4 <identifier> . <identifier> ( <identifier> ) ; \n \t3 } catch ( exception <identifier> ) { \n <ect>
class <identifier> <identifiersep> <identifier> implements <identifier> { \n \t1 @ <identifier> \n \t1 public void run ( ) { \n \t1 if ( ! <identifier> <identifiersep> host <identifiersep> queue . is <identifiersep> empty ( ) ) { \n <ect>
\t1 if ( m <identifiersep> configuration . get <identifiersep> <identifier> <identifiersep> user ( ) . is <identifiersep> empty ( ) ) { \n \t1 m <identifiersep> logger . info ( <string_literal> ) ; \n \t1 return ; } \n \t1 if ( m <identifiersep> configuration . get <identifiersep> <identifier> <identifiersep> password ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n \t4 <identifier> <identifiersep> log . debug ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . load ( <identifier> , <string_literal> , true ) ; \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 string value = ( string ) <identifier> . get <identifiersep> value ( ) ; \n \t5 try { \n \t6 <identifier> = <identifier> + key + <string_literal> + url <identifiersep> <identifier> . <identifier> ( value , <string_literal> ) + <string_literal> ; \n \t5 } catch ( exception ex ) { \n <ect>
\t2 return <identifier> . <identifier> <identifiersep> with <identifiersep> timeout ( c , 1 , time <identifiersep> unit . <identifier> ) ; \n \t1 } else { \n \t2 return <identifier> . get <identifiersep> value ( ) ; } \n \t1 } catch ( time <identifiersep> <identifier> . <identifier> <identifiersep> timeout <identifiersep> exception e ) { \n <ect>
\t7 break ; } } \n \t5 log . info ( <string_literal> + <identifier> . get <identifiersep> queue <identifiersep> name ( ) + <string_literal> + index + <string_literal> + <identifier> <identifiersep> size + <string_literal> ) ; \n \t5 connection . close ( ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t6 answer = ( <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> answer ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> send ( <identifier> <identifiersep> device . get <identifiersep> <identifier> <identifiersep> host <identifiersep> id ( ) , <identifier> <identifiersep> delete <identifiersep> cmd ) ; \n \t6 if ( answer == null || ! answer . get <identifiersep> result ( ) ) { \n \t7 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> config . get <identifiersep> id ( ) + <string_literal> + answer . get <identifiersep> <identifier> ( ) ) ; } \n \t5 } catch ( exception e ) { \n <ect>
\t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> + e . get <identifiersep> message ( ) + <string_literal> , e ) ; \t1 \n \t3 throw e ; \t2 } \n \t2 catch ( exception e ) { \n <ect>
\t4 if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { \n \t5 logger . error ( <string_literal> ) ; \n \t5 logger . error ( <string_literal> ) ; \n \t5 logger . error ( <string_literal> ) ; \n <ect>
\t2 ex <identifiersep> <identifier> = null ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex <identifiersep> this ) { \n \t2 ex <identifiersep> <identifier> = ex <identifiersep> this ; } \n \t1 if ( ex <identifiersep> <identifier> == null && command <identifiersep> output . return <identifiersep> value == 0 ) { \n <ect>
\t1 if ( <identifier> <identifiersep> bytes == null ) \n \t1 { \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( command <identifiersep> string ) . <identifier> ( ) ) { \n \t4 command = command <identifiersep> string . <identifier> ( 0 , <number_literal> ) ; \n \t4 value = command <identifiersep> string . <identifier> ( <number_literal> , command <identifiersep> string . length ( ) ) . <identifier> ( ) ; } \n <ect>
\t4 success = true ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 <comment> \n \t3 if ( ! success ) { \n <ect>
\t7 break ; \n \t6 default : \n \t7 break ; } } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 { \n \t7 <identifier> <identifiersep> lock . <identifier> <identifiersep> all ( ) ; } } \n \t5 catch ( exception e ) \n \t5 { \n <ect>
\t7 <identifier> <identifiersep> value ) ; \n \t5 all <identifiersep> <identifier> . put ( abstract <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> string <identifiersep> value ( format . format ( <identifier> <identifiersep> value ) ) , \n \t7 <identifier> <identifiersep> value ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 catch ( exception e ) { \n \t3 <comment> \n \t3 if ( string <identifiersep> utils . is <identifiersep> blank ( get <identifiersep> value ( ) ) ) { \n \t4 return null ; } \n <ect>
\t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 wait . wait <identifiersep> for ( new wait . <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t4 result = <identifier> . <identifier> ( ) . set <identifiersep> <identifier> <identifiersep> provider ( <identifier> ) . set <identifiersep> remote ( endpoint . get <identifiersep> remote <identifiersep> name ( ) ) . <identifier> ( ) ; \n \t3 } else { \n \t4 result = <identifier> . <identifier> ( ) . set <identifiersep> remote ( endpoint . get <identifiersep> remote <identifiersep> name ( ) ) . <identifier> ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
public create <identifiersep> storage <identifiersep> volume <identifiersep> response <identifiersep> type create <identifiersep> storage <identifiersep> volume ( create <identifiersep> storage <identifiersep> volume <identifiersep> type request ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t1 final long action <identifiersep> start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 create <identifiersep> storage <identifiersep> volume <identifiersep> response <identifiersep> type <identifier> = ( create <identifiersep> storage <identifiersep> volume <identifiersep> response <identifiersep> type ) request . get <identifiersep> <identifier> ( ) ; \n \t1 if ( ! storage <identifiersep> properties . <identifier> <identifiersep> storage ) { \n <ect>
\t3 public exchange do <identifiersep> in <identifiersep> transaction ( transaction <identifiersep> status status ) { \n \t4 exchange result = null ; \n \t4 final string key = <identifier> <identifiersep> id ; \n \t4 try { \n <ect>
\t2 <identifier> <identifiersep> <identifier> total <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( 0 ) ; \n \t2 <identifier> <identifiersep> <identifier> . add ( new <identifier> <identifiersep> <identifier> <identifiersep> vo ( ) ) ; <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> = <identifier> <identifiersep> <identifier> . get ( 0 ) ; \n <ect>
\t1 m . put ( log <identifiersep> entry . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , log <identifiersep> entry . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , log <identifiersep> entry . get <identifiersep> value ( ) ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifier> = conn . create <identifiersep> <identifier> <identifiersep> <identifier> ( metadata <identifiersep> table . name , new <identifier> <identifiersep> <identifier> <identifiersep> config ( ) ) ; \n \t1 <identifier> . add <identifiersep> <identifier> ( m ) ; \n \t1 <identifier> . close ( ) ; \n <ect>
string get <identifiersep> set <identifiersep> <identifier> <identifiersep> sql ( ) { \n \t1 return set <identifiersep> <identifier> <identifiersep> sql ; } \n @ <identifier> \n public long <identifiersep> <identifier> <identifiersep> <identifier> get <identifiersep> user <identifiersep> i <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception { \n <ect>
\t1 <identifier> <identifiersep> state = <identifier> <identifiersep> state . start ; \n \t1 logger . debug ( <string_literal> ) ; } \n @ <identifier> \n public synchronized void stop ( ) { \n <ect>
\t5 logger . error ( <string_literal> , <identifier> <identifiersep> string , <identifier> . port , e . get <identifiersep> message ( ) ) ; \n \t5 return ; } \n \t4 <comment> \n \t4 <identifier> <identifiersep> message <identifier> = <identifier> . <identifier> <identifiersep> queue . <identifier> ( 1 , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> ( channel , <identifier> ) ; \n \t4 } catch ( throwable t ) { \n <ect>
\t2 <identifier> r ; \n \t2 try { \n \t3 r = <identifier> . from <identifiersep> string ( check <identifiersep> not <identifiersep> null ( <identifier> ) ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> class ( ) ; \n \t3 build <identifiersep> <identifier> <identifiersep> with <identifiersep> stream = new build <identifiersep> <identifier> <identifiersep> with <identifiersep> stream ( ) ; \n \t3 build <identifiersep> <identifier> <identifiersep> with <identifiersep> stream . <identifier> ( ) ; \n \t3 build <identifiersep> <identifier> <identifiersep> with <identifiersep> stream . build ( ) ; \n <ect>
\t3 <identifier> <identifiersep> local <identifiersep> user <identifiersep> password <identifiersep> result result = new <identifier> <identifiersep> local <identifiersep> user <identifiersep> password <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t5 } catch ( io <identifiersep> exception e ) { \n \t6 if ( exception == null ) { <comment> \n \t7 exception = e ; \n \t6 } else { \n <ect>
\t5 } else { \n \t6 return <identifier> ; } \n \t4 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t5 <comment> \n <ect>
\t2 info . size = <identifier> <identifiersep> storage . get <identifiersep> size ( <identifier> <identifiersep> path ) ; \n \t2 try { \n \t3 info . <identifier> <identifiersep> size = get <identifiersep> template <identifiersep> <identifier> <identifiersep> size ( <identifier> <identifiersep> file ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> command = new <identifier> ( <string_literal> , wait , s <identifiersep> logger ) ; \n \t4 command . add ( <string_literal> ) ; \n \t4 command . add ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> name ) ; \n \t4 command . set <identifiersep> <identifier> <identifiersep> dir ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> storage <identifiersep> dir + <string_literal> + snapshot <identifiersep> dir ) ; \n <ect>
\t2 <identifier> p = null ; \n \t2 try { \n \t2 p = <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 if ( p == null && <identifier> . <identifier> <identifiersep> name != null ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> client . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 <comment> \n <ect>
\t3 <comment> \n \t3 try { \n \t4 if ( out == null ) { \n <ect>
\t1 try ( <identifier> s = conn . create <identifiersep> <identifier> ( metadata <identifiersep> table . name , <identifier> . empty ) ) { \n \t1 s . set <identifiersep> <identifier> ( metadata <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t1 for ( entry < key , value > metadata : s ) { \n \t2 <identifier> . add ( metadata ) ; \n <ect>
\t4 } finally { \n \t5 lock . <identifier> ( ) ; } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t2 for ( int last <identifiersep> index = uri . last <identifiersep> index <identifiersep> of ( ' / ' ) ; last <identifiersep> index > ( - 1 ) ; last <identifiersep> index = uri . last <identifiersep> index <identifiersep> of ( ' / ' , last <identifiersep> index - 1 ) ) { \n \t3 string key = uri . <identifier> ( 0 , last <identifiersep> index ) ; \n \t3 action <identifiersep> <identifier> <identifiersep> factory action <identifiersep> <identifier> <identifiersep> factory = action <identifiersep> <identifier> <identifiersep> <identifier> . get ( key ) ; \n \t3 if ( action <identifiersep> <identifier> <identifiersep> factory != null ) { \n <ect>
\t3 <comment> \n \t3 if ( create <identifiersep> <identifier> ) { \n \t4 create <identifiersep> <identifier> <identifiersep> <identifier> ( host <identifiersep> name ) ; } \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 error ++ ; \n \t3 } else if ( ( api . get <identifiersep> response <identifiersep> type ( ) != response <identifiersep> type . error ) && ( api . get <identifiersep> response <identifiersep> code ( ) == <number_literal> ) ) { \n \t4 <comment> \n \t4 if ( api . set <identifiersep> <identifier> ( this . get <identifiersep> <identifier> ( ) ) == false ) { \n <ect>
\t6 <identifier> <identifiersep> error = ( string ) message . get ( error <identifiersep> field ) ; \n \t6 <identifier> <identifiersep> exception = get <identifiersep> failure ( message ) ; \n \t5 } else if ( <identifier> ) { \n \t6 <identifier> = false ; \n <ect>
public static <identifier> < string > add ( <identifier> <identifiersep> <identifier> task ) throws thread <identifiersep> pool <identifiersep> not <identifiersep> <identifier> <identifiersep> exception { \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> pool != null && ! <identifier> <identifiersep> <identifier> <identifiersep> pool . is <identifiersep> shutdown ( ) ) { \n \t1 return <identifier> <identifiersep> <identifier> <identifiersep> pool . <identifier> ( task ) ; \n \t1 } else { \n <ect>
<comment> \n \t1 public <identifier> new <identifiersep> <identifier> ( final <identifier> <identifiersep> date <identifiersep> time not <identifiersep> <identifier> , final <identifier> <identifiersep> date <identifiersep> time not <identifiersep> on <identifiersep> or <identifiersep> <identifier> , final string . . . <identifier> <identifiersep> uri ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t5 <identifier> < string , channel , event <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = s <identifiersep> <identifier> . get ( <identifier> <identifiersep> id ) ; \n \t5 <identifier> <identifiersep> <identifier> . <identifier> ( null ) ; \n \t5 s <identifiersep> <identifier> . put ( <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> ) ; } \n \t4 <identifier> <identifiersep> connection ( ) ; <comment> \n <ect>
\t4 <identifier> . add <identifiersep> and ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> . null ) ; \n \t4 <identifier> . add <identifiersep> and ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> . <identifier> , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> vm ) ; \n \t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> instance <identifiersep> dao . <identifier> ( <identifier> , null ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> == null || ( <identifier> <identifiersep> <identifier> . size ( ) == 0 ) ) { \n <ect>
\t6 logger . info ( <string_literal> , url ) ; \n \t6 add <identifiersep> <identifier> ( url , <identifier> ) ; \n \t6 list <identifiersep> of <identifiersep> <identifier> . add ( <identifier> ) ; } \n \t4 } catch ( final exception e ) { \n <ect>
\t5 current <identifiersep> <identifier> <identifiersep> value ) ; \n \t4 <identifier> <identifiersep> <identifier> . put ( session <identifiersep> state , current <identifiersep> <identifier> ) ; } } } } \n \t2 <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get ( session <identifiersep> state ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t1 } else if ( type . is <identifiersep> <identifier> <identifiersep> <identifier> ( session <identifiersep> <identifier> . class ) ) { \n \t2 logger . debug ( <string_literal> , type . get <identifiersep> name ( ) ) ; \n \t2 this . session <identifiersep> <identifier> . put ( <identifier> <identifiersep> type , type ) ; \n \t1 } else if ( type . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . class ) ) { \n <ect>
\t1 consumer = null ; } \n \t1 source <identifiersep> <identifier> . stop ( ) ; } \n @ <identifier> <identifiersep> for <identifiersep> <identifier> \n <identifier> <identifiersep> message <identifiersep> consumer create <identifiersep> consumer ( ) throws <identifier> <identifiersep> exception { \n <ect>
\t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } \n \t2 service <identifiersep> <identifier> <identifiersep> vo <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( vm . get <identifiersep> service <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> local <identifiersep> storage ( ) ) { \n <ect>
\t5 p . add <identifiersep> last ( new line <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <number_literal> ) ) ; \n \t5 p . add <identifiersep> last ( test <identifiersep> handler ) ; } \n \t3 } ) ; \n \t3 boolean <identifier> = <identifier> . <identifier> ( destination ) . channel ( ) . close <identifiersep> <identifier> ( ) . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> security <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t1 r = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( new file <identifiersep> input <identifiersep> stream ( <identifier> ) ) ) ; \n \t1 for ( string <identifier> <identifiersep> line : <identifier> <identifiersep> <identifier> ) { \n \t2 assert <identifiersep> equals ( <identifier> <identifiersep> line , r . read <identifiersep> line ( ) ) ; } \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 @ <identifier> \n \t1 public boolean <identifier> <identifiersep> user ( string user <identifiersep> id , string password , string <identifier> <identifiersep> <identifier> , object <identifier> , object <identifier> ) { \n \t2 if ( string <identifiersep> utils . is <identifiersep> empty ( password ) || ! ( ( <identifier> <identifiersep> password <identifiersep> <identifier> ) <identifier> ) . is <identifiersep> password <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , password , <identifier> ) ) { \n <ect>
\t3 return false ; } \n \t2 <comment> \n \t2 <comment> \n \t2 if ( pool . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null ) { \n <ect>
\t7 logger . error ( <string_literal> , item <identifiersep> name ) ; } } \n \t4 } else { \n \t5 logger . error ( <string_literal> ) ; } \n \t3 } catch ( <identifier> <identifiersep> <identifier> e ) { \n <ect>
\t1 <identifier> on <identifiersep> group <identifiersep> <identifier> ( <identifier> <identifiersep> name : string , t : task ) : string ? { \n \t2 <identifier> <identifier> = try { \n \t3 <identifier> . get ( <identifier> <identifiersep> name ) . <identifier> ( ) \n \t2 } catch ( e : <identifier> <identifiersep> error ) { \n <ect>
\t4 logger . debug ( <string_literal> , ex ) ; } } \n \t2 try { \n \t3 <identifier> . close ( ) ; } \n \t2 catch ( throwable ex ) { \n <ect>
\t2 assert c != null ; \n \t2 if ( <identifier> <identifiersep> lock . <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 try { \n <ect>
\t1 resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( ! <identifier> <identifiersep> handle ( network , service . <identifier> ) ) { \n \t3 return false ; } \n \t2 if ( network . get <identifiersep> <identifier> <identifiersep> uri ( ) == null ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> result <identifiersep> cache <identifier> <identifiersep> result <identifiersep> cache = <identifier> <identifiersep> result <identifiersep> cache ( ) ; \n \t2 if ( <identifier> <identifiersep> result <identifiersep> cache != null ) { \n \t3 <identifier> <identifiersep> result <identifiersep> cache . set <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> , <identifier> ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size ( ) > 0 && <identifier> . count ( ) > 0 ) { \n <ect>
\t1 boolean success = false ; \n \t1 list < m <identifiersep> <identifier> <identifiersep> <identifier> > m <identifiersep> security <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list = null ; \n \t1 try { \n \t1 <identifier> <identifiersep> transaction ( ) ; \n <ect>
\t1 <identifier> . table <identifiersep> <identifier> ( ) . set <identifiersep> property ( test <identifiersep> table , property . table <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> key ( ) , \n \t2 <string_literal> ) ; } \n @ test \n public void test ( ) throws exception { \n <ect>
\t1 <comment> \n public void on <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( int number <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t1 <comment> \n public void on <identifiersep> exception ( exception e ) { \n <ect>
\t2 return short . value <identifiersep> of ( ( string ) answer ) ; \n \t1 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n \t2 <comment> \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public final void on <identifiersep> error ( ) \n \t1 { \n <ect>
\t4 logger . warn ( <string_literal> , e ) ; } } } \n \t1 private boolean is <identifiersep> job <identifiersep> pool <identifiersep> <identifier> ( ) { \n \t2 map < string , <identifier> > <identifier> <identifiersep> <identifier> = context . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . size ( ) >= job <identifiersep> <identifier> <identifiersep> config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 command = new <identifier> <identifiersep> action <identifiersep> x <identifiersep> command ( action <identifiersep> id , <identifier> <identifiersep> status , action <identifiersep> data , <identifier> <identifiersep> <identifier> ) ; } \n \t2 else { \n \t3 command = new <identifier> <identifiersep> action <identifiersep> command ( action <identifiersep> id , <identifier> <identifiersep> status , action <identifiersep> data , <identifier> <identifiersep> <identifier> ) ; } \n \t2 if ( ! <identifier> . get ( ) . get ( <identifier> <identifiersep> queue <identifiersep> service . class ) . queue ( command ) ) { \n <ect>
\t3 assert <identifiersep> null ( <string_literal> , e ) ; } \n \t2 return conf ; } \n \t1 @ <identifier> <identifiersep> class \n \t1 public static void set <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t3 return msg ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> message && <identifier> <identifiersep> <identifier> ) { \n \t3 byte [ ] <identifier> = <identifier> . <identifier> ( ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + user <identifiersep> vm . get <identifiersep> host <identifiersep> name ( ) + <string_literal> + host . get <identifiersep> name ( ) , e ) ; \n \t3 return ; } \n \t2 if ( network <identifiersep> <identifier> <identifiersep> answer != null ) { \n \t3 if ( ! network <identifiersep> <identifier> <identifiersep> answer . get <identifiersep> result ( ) ) { \n <ect>
\t3 if ( id == id <identifiersep> update <identifiersep> <identifier> ) { \n \t4 if ( <identifier> != null ) { \n \t5 <identifier> . read <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> , <identifier> ) ; } \n \t3 } else { \n <ect>
\t3 string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> default <identifiersep> <identifier> ( ) ; \n \t3 data <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = data <identifiersep> <identifier> <identifiersep> <identifier> . value <identifiersep> of ( <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . set <identifiersep> data <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 < input type = <string_literal> <identifier> - model = <string_literal> / > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > log < / <identifier> > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > warn < / <identifier> > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > info < / <identifier> > \n <ect>
\t3 logger . error ( <string_literal> ) ; \n \t3 throw new authentication <identifiersep> exception ( ) ; } \n \t2 final set < event > provider <identifiersep> found = check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> request ( context , service , authentication ) ; \n \t2 if ( provider <identifiersep> found != null && ! provider <identifiersep> found . is <identifiersep> empty ( ) ) { \n <ect>
\t2 task <identifiersep> list , \n \t2 load <identifiersep> <identifier> <identifiersep> service <identifiersep> properties . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config , \n \t2 load <identifiersep> <identifier> <identifiersep> service <identifiersep> properties . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config ) ; \n \t1 <identifier> <identifiersep> client . start ( ) ; \n <ect>
\t5 final map < string , attributes > <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t5 attributes <identifier> = <identifier> . get ( <string_literal> ) ; \n \t5 <identifier> <identifiersep> version = <identifier> . get <identifiersep> value ( <string_literal> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t1 public void <identifier> <identifiersep> field <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( string field <identifiersep> name , object value , object target ) \n \t1 { \n \t2 { \n <ect>
\t2 + <string_literal> , property . instance <identifiersep> <identifier> ) ; } \n \t1 log . error ( <string_literal> , instance <identifiersep> <identifier> <identifiersep> dir ) ; \n \t1 log . error ( <string_literal> , instance <identifiersep> <identifier> <identifiersep> uri , instance <identifiersep> <identifier> <identifiersep> uri ) ; \n \t1 log . error ( <string_literal> , instance <identifiersep> <identifier> <identifiersep> dir , instance <identifiersep> <identifier> <identifiersep> dir ) ; \n <ect>
\t2 double value = 0 ; \n \t2 try { \n \t3 value = double . parse <identifiersep> double ( num ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . debug ( <string_literal> , name ) ; \n \t2 try { \n \t3 <identifier> . on <identifiersep> data ( name , <identifier> ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> <identifiersep> context ) ; \n \t2 this . <identifier> <identifiersep> address = <identifier> <identifiersep> address ; \n \t2 <identifier> <identifiersep> <identifier> . store ( new <identifier> <identifiersep> info ( <identifier> <identifiersep> address , <identifier> <identifiersep> context , token , <identifier> ) ) ; } \n \t1 public void on <identifiersep> <identifier> ( string <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> status status ) { \n <ect>
\t3 key <identifiersep> manager . close <identifiersep> default <identifiersep> key <identifiersep> manager ( ) ; } \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> update <identifiersep> <identifier> <identifiersep> name ( ) throws exception { \n <ect>
\t1 public task <identifiersep> base <identifiersep> <identifier> ( string <identifier> <identifiersep> id , string <identifier> <identifiersep> id , int task <identifiersep> id ) { \n \t2 this . <identifier> <identifiersep> id = <identifier> <identifiersep> id ; \n \t2 this . <identifier> <identifiersep> id = <identifier> <identifiersep> id ; \n \t2 this . task <identifiersep> id = task <identifiersep> id ; \n <ect>
\t2 try { \n \t3 connection ( ) . <identifier> ( <string_literal> ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) \n \t2 { \n <ect>
\t10 for ( <identifier> <identifier> <identifiersep> id : group . get <identifiersep> <identifier> ( ) ) { \n <number_literal> group . add <identifiersep> <identifier> ( <identifier> <identifiersep> id , <identifier> <identifiersep> id , <identifier> ) ; } } \n \t9 <identifier> . <identifier> <identifiersep> event ( <identifier> <identifiersep> event . get <identifiersep> event ( <identifier> <identifiersep> event . event <identifiersep> type . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> id , <identifier> <identifiersep> id ) ) ; \n \t9 <identifier> <identifiersep> node new <identifiersep> node = new <identifier> <identifiersep> node ( node , <identifier> , <identifier> <identifiersep> id ) ; \n <ect>
\t5 data <identifiersep> to <identifiersep> send = new json <identifiersep> object ( ) . put ( <string_literal> , <identifier> ) . to <identifiersep> string ( ) ; \n \t4 } else if ( type . equals ( <string_literal> ) ) { \n \t5 data <identifiersep> to <identifiersep> send = send <identifiersep> <identifier> <identifiersep> state ( object , item <identifiersep> type , service , command ) ; \n \t4 } else { \n <ect>
\t2 <identifier> <identifiersep> service . instance ( ) . <identifier> <identifiersep> version ( endpoint ) ; \n \t2 <identifier> <identifiersep> endpoint ( endpoint ) ; \n \t2 <identifier> <identifiersep> service . instance ( ) . <identifier> <identifiersep> connection <identifiersep> pool ( endpoint ) ; \n <ect>
\t2 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + config . get <identifiersep> <identifier> <identifiersep> mode ( ) ) ; } \n \t1 <comment> \n \t1 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> factory ( ) . create ( config ) ; \n \t1 config . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n <ect>
\t4 <identifier> <identifiersep> command <identifiersep> <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> public <identifiersep> ip <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> vo , public <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> address ) ; } } } \n \t1 @ <identifier> \n \t1 public boolean start <identifiersep> <identifier> <identifiersep> <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> connection conn , final <identifier> <identifiersep> <identifier> <identifier> ) throws resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( <identifier> . get <identifiersep> state ( ) != state . <identifier> ) { \n <ect>
\t2 } else if ( <string_literal> . equals ( <identifier> <identifiersep> command ) ) { \n \t3 try { \n \t4 do <identifiersep> parse <identifiersep> <identifier> ( request , response , <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> service <identifiersep> exception e ) { \n <ect>
\t4 info . <identifier> <identifiersep> size = <identifier> <identifiersep> <identifier> . parse <identifiersep> long ( <identifier> <identifiersep> <identifier> . get <identifiersep> property ( format . get <identifiersep> file <identifiersep> <identifier> ( ) + <string_literal> ) , - 1 ) ; \n \t4 <identifier> <identifiersep> <identifier> . add ( info ) ; \t3 \n \t4 if ( ! check <identifiersep> format <identifiersep> <identifier> ( info ) ) { \n \t5 <identifier> <identifiersep> is <identifiersep> <identifier> = true ; \n <ect>
\t2 try { \n \t3 <identifier> = new file <identifiersep> input <identifiersep> stream ( <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> = create <identifiersep> manager ( <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t4 update <identifiersep> <identifier> <identifiersep> run <identifiersep> status = true ; } \n \t3 <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> check ( store , <identifier> <identifiersep> <identifier> , builder , <identifier> <identifiersep> <identifier> , \n \t5 <identifier> . <identifier> , name ) ; \n \t3 if ( index <identifiersep> update . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t6 consumer . stop ( ) ; \n \t5 } ) ; } } } \n \t2 catch ( interrupted <identifiersep> exception e ) { \n \t3 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n <ect>
\t3 try { \n \t4 <identifier> . command <identifiersep> <identifier> ( event ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> version <identifiersep> <identifier> ( this , <identifier> <identifiersep> current <identifiersep> uri , update <identifiersep> type . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <string_literal> , new <identifiersep> version , msg ) ; } \n \t2 } else { \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t5 if ( <identifier> <identifiersep> job . is <identifiersep> <identifier> ( ) ) { \n \t6 return new execute <identifiersep> result ( execute <identifiersep> result . state . <identifier> , <string_literal> ) ; } \n \t4 } catch ( exception ex ) { \n \t5 string <identifiersep> builder log = new string <identifiersep> builder ( ) ; \n <ect>
\t3 return <identifier> <identifiersep> <identifier> <identifiersep> class . new <identifiersep> instance ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 log <identifiersep> log . warn ( <string_literal> , e ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t3 log . error ( <string_literal> , local <identifiersep> <identifier> ) ; \n \t2 else { \n \t3 long time = system . <identifier> <identifiersep> time ( ) - <identifier> . start <identifiersep> time ; \n \t3 if ( time < = 0 ) \n <ect>
public class <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> token <identifiersep> <identifier> extends base <identifiersep> <identifier> <identifiersep> time <identifiersep> token <identifiersep> <identifier> { \n \t1 private final <identifier> <identifiersep> cache < string , collection < <identifier> <identifiersep> time <identifiersep> token > > storage ; \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t6 if ( on <identifiersep> create <identifiersep> job != null ) \n \t7 <identifier> <identifiersep> context . job <identifiersep> queue ( ) . add <identifiersep> job ( on <identifiersep> create <identifiersep> job ) ; \n \t6 return ; <comment> \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t5 if ( c . <identifier> . size ( ) > 0 && c . is <identifiersep> <identifier> ( ) ) \n \t6 load <identifiersep> <identifier> ( new byte <identifiersep> <identifier> <identifiersep> array <identifiersep> input <identifiersep> stream ( c . <identifier> ) , <identifier> , as <identifiersep> string ) ; } \n \t4 catch ( exception e ) { \n \t5 <comment> \n <ect>
\t1 @ <identifier> \n \t1 public void debug ( logger logger ) { \n \t2 logger . debug ( <string_literal> ) ; \n \t2 logger . trace ( <string_literal> , this . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 return true } \n \t2 return try { \n \t3 <identifier> <identifiersep> <identifier> ! ! . <identifier> <identifiersep> write ( <identifier> <identifiersep> item ) \n \t2 } catch ( e : exception ) { \n <ect>
\t4 try { \n \t5 start <identifiersep> <identifier> <identifiersep> connection ( conn . get <identifiersep> id ( ) ) ; \n \t4 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( conn . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n <ect>
\t3 map < string , map < string , object > > <identifier> <identifiersep> <identifier> = cluster <identifiersep> to <identifiersep> service <identifiersep> <identifier> . get ( <identifier> <identifiersep> cluster <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) \n \t3 { \n \t3 <comment> \n <ect>
\t2 for ( <identifier> <identifier> : this . <identifier> ) { \n \t3 try { \n \t4 <identifier> . <identifier> ( ) ; } \n \t3 catch ( throwable ex ) { \n <ect>
* log . info ( <string_literal> + map . key <identifiersep> of ( <number_literal> . 0 ) ) ; \n * <comment> \n * map . <identifier> ( ) ; \n * log . info ( <string_literal> + map ) ; \n <ect>
\t2 <identifier> . add ( <identifier> ) ; \n \t2 try { \n \t3 return <identifier> <identifiersep> <identifier> . build <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , store <identifiersep> password ) ; \n \t2 } catch ( key <identifiersep> store <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> . equals ( get <identifiersep> <identifier> <identifiersep> token ( ) , new <identifiersep> job <identifiersep> <identifier> <identifiersep> id ) ) { \n \t3 log . info ( <string_literal> , new <identifiersep> job <identifiersep> <identifier> <identifiersep> id ) ; \n \t3 return <identifier> . get ( ) ; } \n \t2 set <identifiersep> new <identifiersep> <identifier> <identifiersep> token ( new <identifiersep> job <identifiersep> <identifier> <identifiersep> id ) ; \n <ect>
\t3 string <identifier> = response . get <identifiersep> header <identifiersep> string ( <string_literal> ) ; \n \t3 if ( <identifier> != null ) { \n \t4 <comment> \n \t4 int integer <identifiersep> <identifier> = integer . parse <identifiersep> int ( <identifier> ) ; \n <ect>
\t1 public static void local <identifiersep> <identifier> ( string path ) throws io <identifiersep> exception { \n \t2 log . debug ( <string_literal> + path ) ; \n \t2 file <identifiersep> utils . <identifier> <identifiersep> <identifier> ( new file ( path ) ) ; } \n \t1 public static void <identifier> ( string path ) { \n <ect>
\t1 super ( event ) ; } \n @ <identifier> \n public void handle ( context <identifier> <identifiersep> context ) throws exception { \n \t1 create <identifiersep> table <identifiersep> message <identifier> = <identifier> . get <identifiersep> create <identifiersep> table <identifiersep> message ( event . get <identifiersep> message ( ) ) ; \n <ect>
\t2 native <identifiersep> io . <identifier> . get <identifiersep> cache <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( <identifier> , \n \t3 <identifier> , get <identifiersep> <identifier> ( ) , get <identifiersep> count ( ) , \n \t3 native <identifiersep> io . <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t1 } catch ( throwable t ) { \n <ect>
\t3 assert <identifiersep> true ( state . meta <identifiersep> data ( ) . has <identifiersep> index ( name ) ) ; } \n \t2 cluster <identifiersep> state <identifier> <identifiersep> state = state ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 state = cluster . <identifier> <identifiersep> <identifier> <identifiersep> shards ( state , state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n <ect>
\t4 logger . info ( <string_literal> ) ; } } \n \t2 for ( string c : <identifier> ) { \n \t3 attribute p = new attribute ( get <identifiersep> id ( c , attribute <identifiersep> name <identifiersep> <identifier> ) , c , io <identifiersep> type . output ) ; \n \t3 <identifier> . get <identifiersep> <identifier> ( ) . add ( p ) ; } \n <ect>
\t1 <comment> \n \t1 return ; } \n \t1 if ( null == <identifier> ) { \n \t1 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t6 if ( n < 0 ) { \n \t7 if ( n == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> socket . <identifier> <identifiersep> http <identifiersep> <identifier> <identifiersep> socket <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t8 log . info ( <string_literal> ) ; \n \t8 return ; } \n <ect>
\t4 return <identifier> <identifiersep> <identifier> ; \n \t3 case <identifier> <identifiersep> state <identifiersep> <identifier> <identifiersep> name : \n \t4 <identifier> <identifiersep> state <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> state <identifiersep> <identifier> <identifiersep> factory ( ) . create <identifiersep> from <identifiersep> config ( config ) ; \n \t4 if ( logger != null ) { \n <ect>
\t6 message = object <identifiersep> message ; \n \t5 } else { \n \t6 message = session . create <identifiersep> text <identifiersep> message ( text ) ; } \n \t5 <identifier> . send ( message ) ; \n <ect>
\t3 } else if ( ( this . <identifier> <identifiersep> properties . get ( password ) == null ) && this . password != null ) { \n \t4 logger . warn ( <string_literal> ) ; \n \t4 this . <identifier> <identifiersep> properties . set <identifiersep> property ( password , this . password ) ; \n \t3 } else if ( this . password != null && ! this . <identifier> <identifiersep> properties . get ( password ) . equals ( this . password ) ) { \n <ect>
\t3 <identifier> . send ( ) \n \t2 } catch ( e : <identifier> <identifiersep> exception ) { \n \t3 <identifier> out = response . <identifier> \n \t3 out . write ( <string_literal> ) \n <ect>
\t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t2 check <identifiersep> <identifier> <identifiersep> state next <identifiersep> state = <identifier> <identifiersep> <identifier> <identifiersep> state . next <identifiersep> state ( true ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> state != next <identifiersep> state ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> state ( next <identifiersep> state ) ; \n \t2 } else { \n <ect>
\t4 ( operation <identifiersep> mode <identifiersep> <identifier> ? <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . operation <identifiersep> mode <identifiersep> <identifier> \n \t6 : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . operation <identifiersep> mode <identifiersep> <identifier> ) ) ; \n \t2 string response = <identifier> <identifiersep> <identifier> <identifiersep> session . execute <identifiersep> request ( operation <identifiersep> mode <identifiersep> <identifier> <identifiersep> request , <string_literal> ) ; \n \t2 if ( ! response . contains ( <string_literal> <identifier> \\ <string_literal> ) ) { \n <ect>
\t1 log . info ( <string_literal> , <identifier> ) ; \n \t1 <identifier> . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> wait ( integer . parse <identifiersep> int ( <identifier> ) , time <identifiersep> unit . <identifier> ) ; } \n @ <identifier> ( <string_literal> ) \n public void <identifier> <identifiersep> on <identifiersep> element <identifiersep> by <identifiersep> x <identifiersep> path ( @ <identifier> ( <string_literal> ) string x <identifiersep> path ) { \n <ect>
\t2 string key = <identifier> . get <identifiersep> interface ( ) . get <identifiersep> name ( ) + <string_literal> + <identifier> . get <identifiersep> method <identifiersep> name ( ) ; \n \t2 if ( ! <identifier> . contains ( key ) ) { \n \t3 <identifier> . add ( key ) ; \n \t3 if ( <identifier> . get <identifiersep> url ( ) . get <identifiersep> method <identifiersep> <identifier> ( <identifier> . get <identifiersep> method <identifiersep> name ( ) , <identifier> . <identifier> <identifiersep> key , false ) ) { \n <ect>
\t5 for ( <identifier> <identifier> : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t6 if ( <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) { \n \t7 <identifier> . add ( <identifier> ) ; } } \n \t4 } catch ( throwable e ) { \n <ect>
\t6 if ( <identifier> == true || entry . get <identifiersep> value ( ) . get <identifiersep> command <identifiersep> <identifier> ( ) . size ( ) == 0 ) { \n \t7 result . add ( this . get <identifiersep> <identifier> <identifiersep> channel <identifiersep> <identifier> <identifiersep> get <identifiersep> message ( entry . get <identifiersep> value ( ) ) ) ; } } } \n \t4 break ; \n \t3 default : \n <ect>
\t4 final string <identifier> <identifiersep> name <identifiersep> n = <identifier> <identifiersep> name + <identifier> + i ; \n \t4 <identifier> . remove ( <identifier> <identifiersep> name <identifiersep> n ) ; } \n \t2 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t4 try { \n \t5 byte [ ] key <identifiersep> bytes = <identifier> . <identifier> ( s <identifiersep> key ) ; \n \t5 key = new <identifier> . <identifier> <identifiersep> <identifier> ( key <identifiersep> bytes ) . read <identifiersep> public <identifiersep> key ( ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 } catch ( exception e ) { \n \t4 <comment> \n \t4 <identifier> <identifiersep> field = true ; } \n \t3 if ( <identifier> <identifiersep> field ) { \n <ect>
\t2 get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n \t2 log . warn ( <string_literal> , log <identifiersep> file , e . get <identifiersep> message ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t3 return null ; } \n \t2 <comment> \n \t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) || num <identifiersep> <identifier> < = 0 ) { \n <ect>
\t2 assert . assert <identifiersep> equals ( <identifier> , <identifier> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test ( <identifier> = <identifier> <identifiersep> error . class ) \n \t1 public void test <identifiersep> version <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t4 string [ ] <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . from <identifiersep> json ( <identifier> <identifiersep> info , string [ ] . class ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> . length > 0 ) { \n \t5 for ( string <identifier> <identifiersep> name : <identifier> <identifiersep> <identifier> ) { \n <ect>
<comment> \n \t1 @ test \n \t1 public void get <identifiersep> load ( ) throws exception { \n <ect>
\t1 <identifier> . check <identifiersep> state ( state . equals ( <identifier> <identifiersep> <identifier> <identifiersep> state . <identifier> ) , \n \t2 <string_literal> , state ) ; \n \t1 log . debug ( <string_literal> , <identifier> ) ; \n \t1 for ( file <identifiersep> system <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> < e > <identifier> : <identifier> <identifiersep> <identifier> . as <identifiersep> map ( ) . values ( ) ) { \n <ect>
\t5 send <identifiersep> status <identifiersep> <identifier> <identifiersep> count . <identifier> ( ) ; } } \n \t3 try { \n \t4 thread . <identifier> ( send <identifiersep> status <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( interrupted <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> stream <identifiersep> id , \n \t5 new values ( <identifier> <identifiersep> id , <identifier> ) ) ; \n \t3 <comment> \n \t1 } else if ( <identifier> != null ) { \n <ect>
\t5 string . format ( <string_literal> , \n \t7 <identifier> , ex . get <identifiersep> message ( ) ) , \n \t5 ex ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> session <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> thread . <identifier> ( ) ; \n \t1 } catch ( security <identifiersep> exception exception ) { \n <ect>
\t6 <identifier> <identifiersep> resource <identifiersep> filter . default <identifiersep> files , \n \t6 true ) ; \n \t5 result . add <identifiersep> all ( <identifier> <identifiersep> files ) ; } \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t6 + <string_literal> + <identifier> . get <identifiersep> in <identifiersep> <identifier> <identifiersep> count ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) \n \t6 + <string_literal> + <identifier> . get <identifiersep> queue <identifiersep> size ( ) ) ; \n \t4 return <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) > 0 && ( <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) - <identifier> . get <identifiersep> in <identifiersep> <identifier> <identifiersep> count ( ) ) == <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ; } \n \t2 } ) ) ; \n <ect>
\t2 assert . assert <identifiersep> true ( listener . run ( <identifier> <identifiersep> user <identifiersep> handle , <identifier> , <number_literal> ) ) ; \n \t2 <comment> \n \t2 listener . <identifier> . set <identifiersep> value ( 0 ) ; \n \t2 listener . <identifier> . <identifier> ( ) ; \n <ect>
\t3 output <identifiersep> stream . close ( ) ; \n \t3 if ( <identifier> <identifiersep> number > 1 ) { <comment> \n \t3 <identifier> = <identifier> . update <identifiersep> state <identifiersep> <identifier> ( bytes <identifiersep> <identifier> , bytes <identifiersep> read , boolean . false ) ; \n \t3 } else { <comment> \n <ect>
\t2 for ( <identifier> <identifiersep> api <identifiersep> <identifier> <identifier> <identifiersep> manager : <identifier> ) { \n \t3 if ( <identifier> <identifiersep> manager != null && <identifier> <identifiersep> manager instanceof <identifier> <identifiersep> manager ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager = ( <identifier> <identifiersep> manager ) <identifier> <identifiersep> manager ; } } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager == null ) { \n <ect>
\t5 properties . load ( <identifier> <identifiersep> list <identifiersep> stream ) ; \n \t4 } finally { \n \t5 <identifier> <identifiersep> list <identifiersep> stream . close ( ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 request . add <identifiersep> <identifier> ( m ) ; } \n \t2 try { \n \t3 client . send ( request ) ; \n \t2 } catch ( socket <identifiersep> timeout <identifiersep> exception e ) { \n <ect>
\t2 logger . info ( <string_literal> , <string_literal> , <number_literal> , <string_literal> ) ; } \n \t1 public void check <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) { \n \t2 logger . info ( <string_literal> , <string_literal> , <number_literal> , <string_literal> , <number_literal> , <number_literal> , <number_literal> , new string ( <string_literal> ) ) ; } \n \t1 public void check <identifiersep> <identifier> <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) { \n <ect>
\t3 get <identifiersep> <identifier> ( ) ; \n \t3 return ; } \n \t2 i <identifiersep> <identifier> <identifier> = context . i <identifiersep> factory . get <identifiersep> <identifier> ( <identifier> <identifiersep> file ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 @ <identifier> \n \t2 public <identifier> <identifier> ( final <identifier> < <identifier> <identifiersep> key , <identifier> < <identifier> < <identifier> > > > input ) { \n \t3 try { \n <ect>
\t2 for ( int i = 0 ; i < = <identifier> ; i ++ ) { \n \t3 socket <identifiersep> channel <identifier> = null ; \n \t3 try { \n <ect>
\t6 object body = exchange . get <identifiersep> in ( ) . get <identifiersep> body ( ) ; \n \t6 string data = exchange . get <identifiersep> context ( ) . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> to ( string . class , body ) ; \n \t7 log . debug ( <string_literal> ) ; \n <ect>
\t2 if ( message . should <identifiersep> send <identifiersep> message ( ) ) { \n \t3 <comment> \n \t3 try { \n \t4 if ( debug ) { \n <ect>
\t6 log . debug ( <string_literal> + <identifier> <identifiersep> entry ) ; \n \t5 <identifier> <identifiersep> entry . <identifier> ( <identifier> . cache ( ) . entry <identifiersep> ex ( <identifier> <identifiersep> entry . key ( ) ) , <identifier> <identifiersep> entry . key <identifiersep> bytes ( ) ) ; } } } \n <ect>
\t3 if ( new file ( <string_literal> ) . exists ( ) ) { \n \t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . from <identifiersep> <identifier> <identifiersep> info ( ) ; \n \t4 <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> ) { \n \t4 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n \t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t4 <identifier> . set <identifiersep> input ( <string_literal> , meta ) ; \n \t4 <identifier> . set <identifiersep> input ( <string_literal> , new <identifier> <identifiersep> integer <identifiersep> <identifier> <identifiersep> bytes ( <identifier> <identifiersep> first <identifiersep> <identifier> ) ) ; \n \t4 <identifier> . set <identifiersep> input ( <string_literal> , <identifier> <identifiersep> as <identifiersep> next ) ; \n \t3 } catch ( <identifier> <identifiersep> value <identifiersep> exception ex ) { \n <ect>
\t2 <identifier> <identifiersep> conf . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list ( ) . size ( ) == 0 ) { <comment> \n \t2 if ( i == 0 ) { <comment> \n \t2 <identifier> <identifiersep> <identifier> [ i ] = new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , load <identifiersep> <identifier> , write <identifiersep> <identifier> <identifiersep> size , \n \t3 max <identifiersep> <identifier> , true , <identifier> <identifiersep> local <identifiersep> <identifier> ) ; \n <ect>
\t5 logger . debug ( <string_literal> , status , response . get <identifiersep> <identifier> ( ) ) ; \n \t5 return true ; } \n \t4 logger . error ( <string_literal> , response ) ; \n \t3 } else { \n <ect>
\t4 db <identifiersep> <identifier> . load ( new file <identifiersep> input <identifiersep> stream ( properties <identifiersep> file ) ) ; \n \t3 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t4 logger . warn ( <string_literal> + properties <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) , e ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <identifier> ; } \n \t1 <comment> \n \t1 public <identifier> <identifiersep> info ( ) { \n \t2 try { \n <ect>
\t1 public <identifier> <identifiersep> info [ ] get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifiersep> info [ ] result = super . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( is <identifiersep> log <identifiersep> all ( ) || is <identifiersep> log <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 if ( result == null ) { \n <ect>
\t1 public void test <identifiersep> <identifier> ( ) { \n \t2 string conf <identifiersep> debug = <string_literal> + <string_literal> ) ; \n <ect>
\t7 final double <identifier> = double . parse <identifiersep> double ( <identifier> [ 0 ] ) ; \n \t7 final double <identifier> = double . parse <identifiersep> double ( <identifier> [ 1 ] ) ; \n \t7 query . location ( <identifier> , <identifier> , <identifier> ) ; \n \t6 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
<comment> \n \t1 protected void load <identifiersep> store ( ) throws io <identifiersep> exception { \n \t2 <comment> \n \t2 if ( ! file <identifiersep> store . exists ( ) ) { \n <ect>
\t2 } ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> total <identifiersep> count ( ) ) ; \n <ect>
<comment> \n \t1 protected boolean do <identifiersep> principal <identifiersep> attributes <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> access ( final map < string , object > principal <identifiersep> attributes ) { \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> attributes <identifiersep> <identifier> <identifiersep> to <identifiersep> process ( principal <identifiersep> attributes , this . <identifier> <identifiersep> <identifier> <identifiersep> attributes ) ) { \n <ect>
\t5 + string <identifiersep> utils . default <identifiersep> if <identifiersep> blank ( ex . get <identifiersep> message ( ) , <string_literal> + e . get <identifiersep> message ( ) ) ) \n \t4 . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ; \n \t3 final map < string , list < string > > <identifier> <identifiersep> map = new <identifier> <identifiersep> map < > ( ) ; \n \t3 <identifier> <identifiersep> map . put ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 logger . info ( <string_literal> , ip <identifiersep> address , <identifier> <identifiersep> port , \n \t6 <identifier> ? <string_literal> : <string_literal> ) ; } \n \t2 } else { \n \t3 <identifier> = false ; } \n <ect>
\t3 if ( c > 0 ) { \n \t4 time = time / c ; } \n \t3 if ( time > 0 ) { \n \t4 int <identifier> <identifiersep> in <identifiersep> <identifier> = <number_literal> / time ; \n <ect>
\t4 try { \n \t5 volume <identifiersep> <identifier> <identifiersep> entry <identifier> = new volume <identifiersep> <identifier> <identifiersep> entry ( volume <identifiersep> <identifier> , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( conn ) , <identifier> . get <identifiersep> <identifier> <identifiersep> size ( conn ) ) ; \n \t5 <identifier> <identifiersep> entry . put ( volume <identifiersep> <identifier> , <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 return target } \n \t1 <identifier> set <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 log . debug ( <identifier> , <string_literal> ) \n \t2 if ( ! <identifier> <identifiersep> application . <identifier> . is <identifiersep> <identifier> ) { \n <ect>
\t6 to ( <string_literal> ) ; } \n \t2 } ) ; \n \t2 context . start ( ) ; \n \t2 <identifier> <identifiersep> builder <identifier> = new <identifier> <identifiersep> builder ( context ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( 1 ) . create ( ) ; \n <ect>
\t3 @ <identifier> \n \t3 public void on <identifiersep> error ( throwable t ) { \n \t4 logger . info ( <string_literal> ) ; \n \t4 <identifier> . <identifier> ( t ) ; \n <ect>
\t4 string msg = \n \t6 <string_literal> + \n \t6 <string_literal> ; \n \t4 msg += ex . to <identifiersep> string ( ) ; \n <ect>
\t1 public <identifier> <identifier> <identifiersep> <identifier> <identifiersep> name ( string <identifier> <identifiersep> name , <identifier> <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 application <identifiersep> context context = <identifier> <identifiersep> application <identifiersep> context ( ) ; \n \t2 if ( ! context . contains <identifiersep> bean ( <identifier> <identifiersep> name ) ) { \n <ect>
\t4 log . warn ( <string_literal> , <identifier> . to <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t4 line = next <identifiersep> line ( ) ; \n \t4 continue ; } \n \t3 if ( files . is <identifiersep> directory ( <identifier> ) ) { \n <ect>
\t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( 0 ) ) ; \n <ect>
\t2 for ( map . entry < string , string > e : m <identifiersep> config . entry <identifiersep> set ( ) ) { \n \t3 string name = e . get <identifiersep> key ( ) ; \n \t3 string port = e . get <identifiersep> value ( ) ; \n \t3 if ( <identifier> . contains ( port ) ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> item p <identifiersep> item = new <identifier> <identifiersep> <identifier> <identifiersep> item ( ) ; \n \t2 try { \n \t3 string new <identifiersep> value = state <identifiersep> <identifier> . to <identifiersep> string ( item . get <identifiersep> state ( ) ) ; \n \t3 p <identifiersep> item . set <identifiersep> value ( new <identifiersep> value ) ; \n <ect>
\t2 public remote <identifiersep> start <identifiersep> handler ( remote <identifiersep> web <identifier> ) { \n \t3 this . <identifier> = <identifier> ; } \n \t2 @ <identifier> \n \t2 public void handle ( http <identifiersep> exchange t ) throws io <identifiersep> exception { \n <ect>
\t4 log . trace ( <string_literal> , local <identifiersep> <identifier> , <identifier> , <identifier> ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> . <identifier> ( msg ) ; } \n \t3 catch ( throwable t ) { \n <ect>
\t1 @ <identifier> \n \t1 @ path ( <string_literal> ) \n \t1 @ <identifier> ( { <string_literal> , <string_literal> } ) \n \t1 public string add <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> type <identifier> ) { \n <ect>
\t4 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> io <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> , e ) ; } } \n \t1 private void stop <identifiersep> <identifier> ( exception exception ) { \n <ect>
\t1 return true ; } \n static boolean is <identifiersep> in <identifiersep> <identifier> ( string db <identifiersep> name , string <identifier> <identifiersep> name ) { \n \t1 string <identifier> = db <identifiersep> name + <string_literal> + <identifier> <identifiersep> name ; \n \t1 for ( <identifier> <identifier> : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; } \n \t1 if ( ! <identifier> . is <identifiersep> root <identifiersep> <identifier> ( ) ) { \n \t1 set < file <identifiersep> <identifier> > files <identifiersep> in <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> = wait <identifiersep> for <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , false , <number_literal> ) ; \n \t1 if ( files <identifiersep> in <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> . size ( ) > 0 ) \n <ect>
\t1 @ path ( <string_literal> ) \n \t1 @ <identifier> ( <string_literal> ) \n \t1 @ <identifier> ( application <identifiersep> xml <identifiersep> <identifier> ) \n \t1 public char <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> root <identifiersep> element xml <identifiersep> <identifier> ( char <identifiersep> set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> root <identifiersep> element <identifier> ) { \n <ect>
\t4 <identifier> . get <identifiersep> logger ( ) . log ( level . info , <string_literal> , ex ) ; } \n \t3 return ; } \n \t2 final string format = event . get <identifiersep> format ( ) ; \n \t2 event . set <identifiersep> format ( <identifier> ( <string_literal> ) . <identifier> ( event . get <identifiersep> format ( ) ) ) ; \n <ect>
\t3 { \n \t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . query ( query ) ; } \n \t3 catch ( exception e ) \n \t3 { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> security <identifiersep> group <identifiersep> vm <identifiersep> map <identifiersep> dao . list <identifiersep> vm <identifiersep> <identifier> <identifiersep> by <identifiersep> security <identifiersep> group ( security <identifiersep> group . get <identifiersep> id ( ) ) ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> update <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , true , null ) ; \n \t3 return new <identifiersep> <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public response <identifier> ( data <identifiersep> source source ) throws exception { \n \t2 input <identifiersep> stream is = source . get <identifiersep> input <identifiersep> stream ( ) ; \n \t2 while ( is . read ( ) > - 1 ) { } \n <ect>
\t5 if ( <identifier> <identifiersep> string != null ) { \n \t6 return <identifier> <identifiersep> string ; } } } \n \t2 } catch ( final <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; \n <ect>
\t1 log . warn ( <string_literal> + <identifier> <identifiersep> <identifier> ( ( long ) to <identifiersep> millis ( <identifier> <identifiersep> time <identifiersep> <identifier> ) ) ) ; \n \t1 log . warn ( <string_literal> + ( ( double ) num <identifiersep> <identifier> * <number_literal> / to <identifiersep> millis ( <identifier> <identifiersep> time <identifiersep> <identifier> ) ) + <string_literal> ) ; \n \t1 log . warn ( <string_literal> + <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get ( ) ) ) ; \n \t1 log . warn ( <string_literal> + <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get ( ) ) ) ; \n <ect>
<comment> \n \t1 public void put <identifiersep> request ( string id , message request , count <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) { \n <ect>
\t6 <comment> \n \t6 <comment> \n \t6 <comment> \n \t6 <identifier> . get <identifiersep> system <identifiersep> <identifier> ( ) . get <identifiersep> store <identifiersep> <identifier> ( ) . is <identifiersep> <identifier> ( ) ; \n <ect>
\t6 byte <identifier> = ( byte ) ( read <identifiersep> byte ( true ) & <identifier> <identifiersep> <identifier> ) ; \n \t6 send <identifiersep> <identifier> . put ( <identifier> ) ; \n \t6 byte <identifier> = e <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <identifier> , ( byte ) 0 ) ; \n \t6 if ( <identifier> > <number_literal> ) { \n <ect>
\t2 assert . assert <identifiersep> true ( data <identifiersep> utils . <identifier> ( new <identifiersep> cache . get <identifiersep> private <identifiersep> key ( <identifier> <identifiersep> <identifier> ) . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> key ) == 0 ) ; \n \t2 assert . assert <identifiersep> true ( data <identifiersep> utils . <identifier> ( new <identifiersep> cache . get <identifiersep> key ( key <identifiersep> <identifier> ) . get <identifiersep> <identifier> ( ) , \t2 <identifier> <identifiersep> <identifier> <identifiersep> key ) == 0 ) ; \n \t2 assert . assert <identifiersep> true ( data <identifiersep> utils . <identifier> ( new <identifiersep> cache . get <identifiersep> key <identifiersep> id ( private <identifiersep> key <identifiersep> name ) , <identifier> <identifiersep> <identifier> ) == 0 ) ; \n \t2 assert . assert <identifiersep> true ( data <identifiersep> utils . <identifier> ( new <identifiersep> cache . get <identifiersep> key <identifiersep> id ( key <identifiersep> name ) , \t2 key <identifiersep> <identifier> ) == 0 ) ; \n <ect>
\t6 job <identifier> = msg . get <identifiersep> on <identifiersep> failed <identifiersep> <identifier> <identifiersep> job ( ) ; \n \t6 if ( <identifier> != null ) \n \t7 <identifier> <identifiersep> context . job <identifiersep> queue ( ) . add <identifiersep> job ( <identifier> ) ; \n \t6 if ( log ) \n <ect>
\t2 if ( current <identifiersep> version <identifiersep> dir != null ) { \n \t3 current <identifiersep> version = read <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> version <identifiersep> id ( current <identifiersep> version <identifiersep> dir ) ; \n \t2 } else { \n \t3 current <identifiersep> version = - 1 ; <comment> \n <ect>
\t2 <identifier> <identifier> <identifiersep> <identifier> = class <identifiersep> or <identifiersep> object . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n \t2 <identifier> <identifier> <identifiersep> context = <identifier> <identifiersep> <identifier> . <identifier> ( class <identifiersep> or <identifiersep> object ) \n \t2 <identifier> <identifier> = <identifier> <identifiersep> context . get ( <identifier> <identifiersep> context . class , class <identifiersep> or <identifiersep> object ) \n \t2 if ( <identifier> == null ) { \n <ect>
public static class <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> listener implements property <identifiersep> <identifier> <identifiersep> listener < integer > { \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> property t , integer new <identifiersep> value ) throws <identifier> <identifiersep> property <identifiersep> exception { \n \t1 if ( new <identifiersep> value == null ) { \n <ect>
public void <identifier> ( ) { \n \t1 if ( <identifier> <identifiersep> mode == <identifier> <identifiersep> mode <identifiersep> type . <identifier> ) { \n \t1 <identifier> . <identifier> ( ) ; \n \t1 if ( logger . is <identifiersep> <identifier> ( level . <identifier> ) ) { \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t2 try { \n \t2 <identifier> <identifiersep> level = integer . parse <identifiersep> int ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception ex ) { \n <ect>
\t3 directory = <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> ( path ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 <identifier> . error ( e ) ; } \n \t2 if ( directory == null ) { \n <ect>
\t1 <comment> \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> class <identifiersep> <identifier> <identifier> <identifiersep> class ) throws <identifier> <identifiersep> exception { \n \t2 set < <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> set < > ( ) ; \n \t2 object [ ] <identifier> = <identifier> <identifiersep> <identifier> . to <identifiersep> array ( ) ; \n <ect>
\t2 int count = meta . get <identifiersep> int ( ) ; \n \t2 int bytes = meta . get <identifiersep> int ( ) ; \n \t2 int <identifier> = meta . get <identifiersep> int ( ) ; \n \t2 if ( <identifier> != <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 return <identifier> ; } \n @ <identifier> \n public boolean delete ( string name ) { \n \t1 <identifier> . check <identifiersep> argument ( name != null , <string_literal> ) ; \n <ect>
\t2 continue ; } \n \t2 <identifier> = <identifier> <identifiersep> <identifier> ( conf , input <identifiersep> path , model <identifiersep> path , i ) ; } \n \t1 <comment> \n \t1 <identifier> . add ( <identifier> ) ; \n <ect>
\t8 break ; \n \t6 } catch ( remote <identifiersep> exception e ) { \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> service ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n <ect>
<comment> \n @ <identifier> \n public void <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 db <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( conn , table <identifiersep> name , <identifier> . get ( table <identifiersep> name ) , false ) ; } } \n \t1 private void add <identifiersep> <identifier> <identifiersep> <identifier> ( connection conn ) { \n \t2 <identifier> <identifiersep> <identifier> <identifier> = null ; \n \t2 try { \n <ect>
\t2 log . info ( <string_literal> + location + <string_literal> \n \t3 + <identifier> <identifiersep> table . get <identifiersep> table <identifiersep> name ( ) + <string_literal> + status ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n \t2 <comment> \n <ect>
\t2 <comment> \n \t2 try { \n \t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> . <identifier> + <string_literal> + ip <identifiersep> id ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> ip ( ip <identifiersep> id , <identifier> <identifiersep> user <identifiersep> id , <identifier> ) ) { \n <ect>
\t2 assert . not <identifiersep> null ( <identifier> , <string_literal> ) ; \n \t2 connection <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( connection <identifiersep> <identifier> ) transaction <identifiersep> <identifier> <identifiersep> manager . get <identifiersep> resource ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t3 return <identifier> <identifiersep> <identifier> . get <identifiersep> connection ( ) ; } \n <ect>
\t1 private metadata <identifiersep> <identifier> metadata <identifiersep> <identifier> ; \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> result <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> request request ) \n \t2 throws no <identifiersep> <identifier> <identifiersep> found <identifiersep> for <identifiersep> <identifier> <identifiersep> exception \n \t1 { \n <ect>
\t2 && <identifier> . get <identifiersep> query <identifiersep> properties ( ) . is <identifiersep> query ( ) \n \t2 && <identifier> . get <identifiersep> create <identifiersep> table ( ) == null \n \t2 && <identifier> . get <identifiersep> create <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null \n \t2 && ( <identifier> . get <identifiersep> load <identifiersep> table <identifiersep> <identifier> ( ) == null || <identifier> . get <identifiersep> load <identifiersep> table <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) ) { \n <ect>
\t6 && this . <identifier> <identifiersep> <identifier> . get ( c ) < <identifier> - get <identifiersep> <identifier> <identifiersep> event <identifiersep> <identifier> ( ) ) \n \t4 . count ( ) ; \n \t3 if ( <identifier> > 0 ) { \n <ect>
<comment> \n \t1 public void <identifier> ( final int <identifier> ) { \n \t2 <comment> \n \t2 <comment> \n <ect>
\t1 context . <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> map . get ( <identifier> ) . add ( <identifier> ) ; } \n \t1 <comment> \n \t1 if ( ! context . current <identifiersep> map <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t1 for ( map <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : context . current <identifiersep> map <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t5 task . get <identifiersep> <identifier> ( ) . send ( response . to <identifiersep> bytes ( ) ) ; \n \t4 } catch ( final <identifier> <identifiersep> channel <identifiersep> exception e ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + response . to <identifiersep> string ( ) ) ; } } \n \t2 } else { \n <ect>
\t4 event <identifiersep> to <identifiersep> process = null ; \n \t4 <identifier> <identifiersep> <identifier> = null ; } \n \t2 } catch ( throwable t ) \n \t2 { \n <ect>
\t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> dir . exists ( ) ) { \n \t3 logger . error ( this , <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> dir . get <identifiersep> path ( ) ) ; \n \t3 return ; } \n \t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> dir . is <identifiersep> directory ( ) ) { \n <ect>
\t5 dao . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t5 logger . debug ( <string_literal> , <identifier> . get <identifiersep> url ( ) ) ; \n \t4 } else { \n \t5 logger . debug ( <string_literal> , <identifier> . get <identifiersep> url ( ) ) ; } \n <ect>
\t4 data = null ; \n \t4 synchronized ( lock ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> += <identifier> <identifiersep> <identifier> ; <comment> \n \t5 <comment> \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> task = <identifier> . <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> ( listener ) , 0 , <identifier> , time <identifiersep> unit . <identifier> ) ; \n \t3 } catch ( throwable ex ) { \n <ect>
\t1 return null ; } \n \t1 final <identifier> . property <identifiersep> key property <identifiersep> key = get <identifiersep> key ( <identifier> , key ) ; \n \t1 if ( property <identifiersep> key == null ) \n \t1 { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t7 object item = item <identifiersep> <identifier> . new <identifiersep> instance ( ) ; \n \t7 <identifier> <identifiersep> from ( item , item <identifiersep> <identifier> , <identifier> . item ( i ) ) ; \n \t7 array <identifiersep> list . add ( item ) ; } \n \t5 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 options . <identifier> ( template <identifiersep> options . get <identifiersep> <identifier> ( ) ) ; } \n \t1 if ( template <identifiersep> options . get <identifiersep> key <identifiersep> <identifier> <identifiersep> name ( ) != null ) { \n \t2 options . key <identifiersep> <identifier> <identifiersep> name ( template <identifiersep> options . get <identifiersep> key <identifiersep> <identifier> <identifiersep> name ( ) ) ; } \n \t1 if ( ! template <identifiersep> options . get <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) options . <identifier> <identifiersep> device <identifiersep> <identifier> ( template <identifiersep> options . get <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> ( ) ) ; \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> io , level . info ) ) \n <ect>
\t7 m <identifiersep> <identifier> . get <identifiersep> query <identifiersep> status ( ) , cmd ) ; \n \t5 is <identifiersep> <identifier> = true ; \n \t5 if ( cmd == <identifier> ) { \n \t6 <comment> \n <ect>
<comment> \n \t1 protected map < string , object > get <identifiersep> <identifier> <identifiersep> by <identifiersep> default <identifiersep> attributes ( final principal p , final map < string , object > attributes ) { \n \t2 final application <identifiersep> context <identifier> = application <identifiersep> context <identifiersep> provider . get <identifiersep> application <identifiersep> context ( ) ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t1 public boolean is <identifiersep> <identifier> <identifiersep> in ( ) { \n \t2 http <identifiersep> session session = request . get <identifiersep> session ( false ) ; \n \t2 if ( session == null ) return false ; \n \t2 if ( session == null ) { \n <ect>
\t1 <identifier> <identifier> = <identifier> ( \n \t1 get <identifiersep> runtime <identifiersep> context . get <identifiersep> user <identifiersep> code <identifiersep> class <identifiersep> <identifier> , \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . name , \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . code ) \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t3 <identifier> <identifiersep> log . debug ( <string_literal> + message . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) <comment> ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> context . in <identifiersep> <identifier> <identifiersep> message <identifiersep> pool ( ) . add ( message , from <identifiersep> <identifier> , from <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 <comment> \n <ect>
\t2 stack <identifiersep> id stack <identifiersep> id = new stack <identifiersep> id ( stack ) ; \n \t2 if ( ! stack . is <identifiersep> <identifier> ( ) ) { \n \t2 log . info ( <string_literal> , stack <identifiersep> id , string <identifiersep> utils . <identifier> ( stack . get <identifiersep> <identifier> ( ) , <string_literal> ) ) ; \n \t2 } else if ( ! stack . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 <identifier> <identifiersep> from <identifiersep> job <identifiersep> manager ( ) \n \t1 try { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> service . stop ( ) \n \t1 } catch { \n <ect>
\t1 private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( log <identifiersep> <identifier> <identifiersep> failed <identifiersep> <identifier> <identifiersep> logger . class ) ; \n \t1 private final <identifier> <identifiersep> boolean stop = new <identifier> <identifiersep> boolean ( false ) ; \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t4 <comment> \n \t4 try { \n \t5 consumer . close ( ) ; } \n \t4 catch ( throwable t ) { \n <ect>
\t2 return new <identifier> <identifiersep> answer ( job <identifiersep> id , get <identifiersep> <identifier> <identifiersep> <identifier> ( job <identifiersep> id ) , get <identifiersep> <identifier> <identifiersep> error ( job <identifiersep> id ) , get <identifiersep> <identifier> <identifiersep> <identifier> ( job <identifiersep> id ) , get <identifiersep> <identifier> <identifiersep> local <identifiersep> path ( job <identifiersep> id ) , get <identifiersep> <identifier> <identifiersep> path ( job <identifiersep> id ) , \n \t4 get <identifiersep> <identifier> <identifiersep> template <identifiersep> size ( job <identifiersep> id ) ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> answer handle <identifiersep> <identifier> <identifiersep> command ( <identifier> <identifiersep> storage <identifiersep> resource resource , <identifier> <identifiersep> command cmd ) { \n <ect>
<comment> \n \t1 private string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> <identifier> <identifier> ) throws <identifier> <identifiersep> exception { \n <ect>
\t5 if ( <identifier> . get <identifiersep> <identifier> ( ) == <identifier> <identifiersep> type . <identifier> ) { \n \t6 try { \n \t7 <identifier> <identifiersep> metadata . set <identifiersep> <identifier> <identifiersep> <identifier> ( key <identifiersep> info <identifiersep> <identifier> . get <identifiersep> <identifier> ( <identifier> . get <identifiersep> key <identifiersep> info ( ) ) . get ( 0 ) ) ; \n \t6 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 final http <identifiersep> <identifier> <identifiersep> request request = web <identifiersep> utils . get <identifiersep> http <identifiersep> <identifier> <identifiersep> request <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( context ) ; \n \t2 final registered <identifiersep> service service = web <identifiersep> utils . get <identifiersep> registered <identifiersep> service ( context ) ; \n \t2 final authentication authentication = web <identifiersep> utils . get <identifiersep> authentication ( context ) ; \n \t2 if ( service == null || authentication == null ) { \n <ect>
\t2 { \n \t2 shutdown ( id , remove <identifiersep> <identifier> ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t2 return new <identifier> <identifiersep> set < <identifier> > ( <identifier> . as <identifiersep> list ( ( <identifier> [ ] ) <identifier> <identifiersep> <identifier> ) ) ; \n \t2 } else { \n \t2 return new <identifier> <identifiersep> set < <identifier> > ( ( array <identifiersep> list ) <identifier> <identifiersep> <identifier> ) ; } } \n \t1 } catch ( exception e ) { \n <ect>
\t5 . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> <identifier> . class ) ; \n \t2 if ( <identifier> <identifiersep> set <identifiersep> <identifier> == null ) \n \t2 { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; } \n \t2 } else { \n <ect>
<comment> \n public static void check <identifiersep> db <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception { \n <ect>
\t3 <identifier> <identifiersep> <identifier> ( true ) ; } } \n \t1 private <identifier> <identifiersep> info <identifier> <identifiersep> <identifier> ( boolean on <identifiersep> <identifier> ) throws exception { \n \t2 <comment> \n \t2 if ( on <identifiersep> <identifier> ) { \n <ect>
\t4 return ( ( i <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) . <identifier> <identifiersep> <identifier> ( <identifier> , message . <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception io ) { \n \t4 throw new runtime <identifiersep> exception ( io ) ; } \n \t2 } else { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> + cluster <identifiersep> id ) ; } \n \t3 return null ; } \n \t2 if ( cluster . get <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> type . <identifier> ) { \n <ect>
\t1 private object default <identifiersep> find <identifiersep> resource ( resource resource ) throws exception { \n \t2 if ( <identifier> == null ) { \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> + resource ) ; } \n \t2 <comment> \n <ect>
\t2 for ( routing <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t3 string <identifier> = get <identifiersep> <identifier> <identifiersep> text ( <identifier> ) ; \n \t3 <identifier> . <identifier> ( <identifier> ) ; \n \t3 string <identifier> = get <identifiersep> <identifier> <identifiersep> text ( <identifier> ) ; \n <ect>
\t2 try { \n \t2 <identifier> = new path ( storage <identifiersep> root ) . get <identifiersep> file <identifiersep> system ( <identifier> <identifiersep> conf ) ; \n \t2 check <identifiersep> files ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 map . entry < ? , ? > <identifier> = ( map . entry < ? , ? > ) it . next ( ) ; \n \t5 string key = ( string ) <identifier> . get <identifiersep> key ( ) ; \n \t5 string value = ( string ) <identifier> . get <identifiersep> value ( ) ; \n \t5 if ( value == null ) { \n <ect>
\t1 public static <identifier> create <identifiersep> <identifier> ( string <identifier> , boolean <identifier> , <identifier> <identifier> ) { \n \t2 return create <identifiersep> <identifier> ( <identifier> , <identifier> , new <identifier> <identifiersep> list ( <identifier> ) ) ; } \n \t1 public static <identifier> create <identifiersep> <identifier> ( string <identifier> , boolean <identifier> , <identifier> <identifiersep> list <identifier> ) { \n \t2 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> registered ( <identifier> ) ) \n <ect>
\t3 logger . info ( <string_literal> + <identifier> <identifiersep> count . <identifier> <identifiersep> <identifier> ) ; \n \t3 client . execute <identifiersep> <identifier> <identifiersep> query ( byte <identifiersep> <identifier> <identifiersep> <identifier> . bytes ( query ) , <identifier> . <identifier> , <identifier> <identifiersep> level . <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> request <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 <identifier> <identifiersep> model <identifier> = new <identifier> <identifiersep> model ( new <identifier> <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) , <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> model <identifier> <identifiersep> <identifier> <identifiersep> model = new <identifier> <identifiersep> <identifier> <identifiersep> model ( <identifier> , null , true ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> <identifiersep> model ) ; \n \t3 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; } \n <ect>
\t2 end <identifiersep> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> set < integer > ( context . get <identifiersep> <identifier> <identifiersep> <identifier> ( end <identifiersep> <identifier> ) ) ; \n \t2 snapshot <identifiersep> state = new snapshot <identifiersep> state ( context , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , end <identifiersep> <identifier> <identifiersep> <identifier> , state <identifiersep> <identifier> ) ; \n \t2 snapshot <identifiersep> state <identifier> <identifiersep> state = config <identifiersep> <identifier> . <identifier> <identifiersep> transaction <identifiersep> <identifier> <identifiersep> state ( conf ) ? null : ( snapshot <identifiersep> state ) state <identifiersep> <identifier> . <identifier> <identifiersep> state ( <identifier> <identifiersep> name ) ; \n \t2 snapshot <identifiersep> state . <identifier> <identifiersep> state ( <identifier> <identifiersep> state ) ; \n <ect>
\t2 @ <identifier> \n \t2 public void run ( ) { \n \t3 boolean <identifier> = false ; \n \t3 try { \n <ect>
\t2 if ( <identifier> <identifiersep> session <identifiersep> id <identifiersep> <identifier> != null ) { \n \t3 try { \n \t4 <identifier> <identifiersep> session <identifiersep> id = long . parse <identifiersep> long ( <identifier> <identifiersep> session <identifiersep> id <identifiersep> <identifier> ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 message message = message <identifiersep> consumer . <identifier> ( <number_literal> ) ; \n \t3 if ( message != null ) { \n \t4 assert <identifiersep> equals ( i + base , message . get <identifiersep> int <identifiersep> property ( <string_literal> ) ) ; \n \t4 i ++ ; \n <ect>
\t5 try { \n \t6 field . set <identifiersep> <identifier> ( true ) ; \n \t6 field . set ( object , value ) ; \n \t5 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 result = super . put ( key , value , integer . max <identifiersep> value ) ; \n \t2 } else { \n \t3 result = super . put ( key , value , timeout <identifiersep> millis ) ; } \n <ect>
\t2 return <identifier> <identifiersep> <identifier> == null ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( final status state ) { \n \t2 synchronized ( this ) { \n <ect>
\t5 debug . write ( <identifier> , 0 , n ) ; } } \n \t2 } catch ( interrupted <identifiersep> io <identifiersep> exception e ) { \n \t4 if ( is <identifiersep> not <identifiersep> blank ( e . get <identifiersep> message ( ) ) ) { \n <ect>
\t2 if ( ! file . exists ( ) ) { \n \t3 file . <identifier> ( ) ; \n \t3 log . info ( <string_literal> + write <identifiersep> dir ) ; \n \t2 } else if ( ! file . is <identifiersep> directory ( ) ) { \n <ect>
\t4 log . trace ( <string_literal> + local <identifiersep> <identifier> + <string_literal> + <identifier> + <string_literal> + <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> msg ) ; } \n \t2 catch ( exception ex ) { \n <ect>
\t2 try { \n \t3 return <identifier> == null ? null : io <identifiersep> utils . to <identifiersep> string ( <identifier> . get <identifiersep> content <identifiersep> input <identifiersep> stream ( this . <identifier> <identifiersep> provider \n \t4 . get ( ) ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 < input type = <string_literal> <identifier> - model = <string_literal> / > < / <identifier> > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > log < / <identifier> > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > warn < / <identifier> > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > info < / <identifier> > \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t4 log . info ( pool . to <identifiersep> string ( ) ) ; } \n \t3 thread . <identifier> ( <number_literal> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; } \n <ect>
\t7 <string_literal> ) ; \n \t4 default : \n \t5 throw new <identifier> <identifiersep> error ( ) ; } } \n \t2 public void <identifier> ( ) { \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> = false ; \n \t2 remove <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 break ; } } \n <ect>
\t6 throw new <identifier> <identifiersep> exception ( msg , <identifier> <identifiersep> code , <identifier> <identifiersep> exception . input ) ; } \n \t4 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t5 throw <identifier> ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 this . enabled <identifiersep> <identifier> = enabled <identifiersep> <identifier> ; } \n \t1 <comment> \n \t1 @ <identifier> public void on <identifiersep> session <identifiersep> <identifier> ( grid <identifiersep> <identifier> <identifiersep> session <identifier> ) throws grid <identifiersep> exception { \n <ect>
<comment> \n \t2 public void shutdown ( ) { \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 send <identifiersep> message ( queue <identifiersep> channel , web <identifiersep> socket <identifiersep> <identifier> <identifiersep> message . get <identifiersep> failed <identifiersep> <identifier> ( error ) ) ; } } \n \t1 else { \n \t1 final string error = <string_literal> ; \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> ) ; \n \t2 try { \n \t3 return <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( security <identifiersep> context ) . get ( abstract <identifiersep> file . class , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t8 try { \n \t9 <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> path = vm <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> current <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> in <identifiersep> <identifier> ( <identifier> <identifiersep> result . <identifier> ( ) ) ; \n \t8 } catch ( exception e ) { \n \t9 s <identifiersep> logger . error ( <string_literal> , e ) ; } \n <ect>
\t2 if ( <identifier> != null ) \n \t3 <comment> \n \t3 <identifier> <identifiersep> state = <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n <ect>
\t4 } else { \n \t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> \n \t7 + <identifier> . get <identifiersep> type ( ) ) ; } \n \t3 } catch ( exception e ) { \n <ect>
\t5 logger . debug ( <string_literal> + <identifier> . format ( <identifier> . length ) + <string_literal> + <identifier> . format ( <identifier> <identifiersep> size ) + <string_literal> ) ; \n \t5 logger . trace ( <string_literal> + <identifier> . format ( runtime . get <identifiersep> runtime ( ) . <identifier> <identifiersep> <identifier> ( ) ) ) ; \n \t5 logger . trace ( <string_literal> + <identifier> . format ( runtime . get <identifiersep> runtime ( ) . total <identifiersep> <identifier> ( ) ) ) ; \n \t5 logger . trace ( <string_literal> + <identifier> . format ( runtime . get <identifiersep> runtime ( ) . max <identifiersep> <identifier> ( ) ) ) ; \n <ect>
\t3 list < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t4 this . logger . debug ( <string_literal> + string <identifiersep> utils . default <identifiersep> if <identifiersep> empty ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) , <string_literal> ) \n \t5 + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) + <string_literal> ) ; } \n <ect>
<number_literal> <string_literal> + \n <number_literal> <string_literal> , \n <number_literal> <identifier> <identifiersep> <identifier> <identifiersep> info <identifiersep> type . info ) ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t2 } else if ( is <identifiersep> <identifier> ( ) ) { \n \t3 return <string_literal> ; } \n \t2 return <string_literal> ; } \n \t1 public static string get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> path ( ) { \n <ect>
\t3 if ( request <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t4 log . debug ( <string_literal> ) ; \n \t4 should <identifiersep> store = false ; \n \t4 return request <identifiersep> <identifier> <identifiersep> <identifier> ; } \n <ect>
\t4 if ( <identifier> . is <identifiersep> not <identifiersep> blank ( <identifier> ) ) { \n \t5 <identifier> <identifiersep> <identifier> . add <identifiersep> <identifier> <identifiersep> element ( string <identifiersep> <identifier> <identifiersep> <identifier> , <string_literal> , <identifier> ) ; } \n \t4 return <identifier> <identifiersep> <identifier> . to <identifiersep> xml ( <identifier> ) ; \n \t3 } else { \n <ect>
\t2 assert <identifiersep> not <identifiersep> null ( web <identifiersep> application ) ; \n \t2 log . info ( <string_literal> + web <identifiersep> application . get <identifiersep> name ( ) ) ; \n \t2 <identifier> <identifiersep> context <identifier> <identifiersep> context = web <identifiersep> application . get <identifiersep> <identifier> <identifiersep> context ( ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <identifier> <identifiersep> context ) ; \n <ect>
\t3 return ; } \n \t2 try { \n \t3 transaction <identifiersep> manager . <identifier> ( <identifier> <identifiersep> transaction ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t3 if ( server == null || server . error <identifiersep> on <identifiersep> <identifier> ( ) ) { \n \t4 <identifier> . stop ( ) ; \n \t4 log . warn ( <string_literal> ) ; \n \t4 return false ; } \n <ect>
\t4 <identifier> <identifiersep> for <identifiersep> update . set <identifiersep> state ( state . <identifier> ) ; \n \t4 success = <identifier> <identifiersep> account <identifiersep> dao . update ( long . value <identifiersep> of ( account <identifiersep> id ) , <identifier> <identifiersep> for <identifiersep> update ) ; \n \t3 } else { \n <ect>
\t6 message <identifiersep> text , <identifier> <identifiersep> type ) ; } \n \t3 stop <identifiersep> message <identifiersep> <identifier> ( ) ; } \n \t2 catch ( illegal <identifiersep> state <identifiersep> exception ex ) \n \t2 { \n <ect>
\t1 { \n \t2 final string property = get <identifiersep> property ( key ) ; \n \t2 if ( property == null ) \n \t2 { \n <ect>
\t6 <number_literal> * <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) , \n \t6 e ) ; } \n \t2 else \n \t2 { \n <ect>
\t2 assert <identifiersep> equals ( snapshot <identifiersep> state . success , snapshot <identifiersep> info . state ( ) ) ; \n \t2 assert <identifiersep> equals ( snapshot <identifiersep> info . total <identifiersep> shards ( ) , snapshot <identifiersep> info . <identifier> <identifiersep> shards ( ) ) ; \n \t2 assert <identifiersep> equals ( 0 , snapshot <identifiersep> info . failed <identifiersep> shards ( ) ) ; } \n \t1 public void test <identifiersep> <identifier> <identifiersep> and <identifiersep> data <identifiersep> shutdown <identifiersep> <identifier> <identifiersep> snapshot ( ) throws exception { \n <ect>
public static final string <identifier> <identifiersep> server <identifiersep> root <identifiersep> <identifier> <identifiersep> <identifier> = <string_literal> ; \n public static final string root <identifiersep> directory = system . <identifier> ( <identifier> <identifiersep> server <identifiersep> root <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n public static string get <identifiersep> path ( string path ) { \n \t1 if ( root <identifiersep> directory == null ) { \n <ect>
<comment> \n \t1 private void <identifier> <identifiersep> <identifier> ( set < <identifier> <identifiersep> port > <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> service <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> result result = new <identifier> <identifiersep> <identifier> <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> operation <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 return false ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 update . set ( state , null ) ; } \n \t3 cluster <identifiersep> node <identifiersep> info <identifiersep> <identifier> <identifier> = store . find <identifiersep> and <identifiersep> update ( cluster <identifiersep> nodes , update ) ; \n \t3 if ( <identifier> == null ) { \n \t4 throw new runtime <identifiersep> exception ( <string_literal> + cluster <identifiersep> id + <string_literal> ) ; } \n <ect>
\t7 public void <identifier> <identifiersep> data <identifiersep> <identifier> ( ) { \n \t8 <identifier> <identifiersep> <identifier> ( ) ; } \n \t6 } ) ; } \n \t5 <identifier> <identifiersep> provider . <identifier> ( name ) ; \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + id + <string_literal> ) ; \n \t3 return false ; } \n \t2 if ( <identifier> . get <identifiersep> <identifier> ( ) == null ) { \n <ect>
\t1 protected user <identifiersep> transaction <identifier> <identifiersep> user <identifiersep> transaction ( string user <identifiersep> transaction <identifiersep> name ) \n \t3 throws transaction <identifiersep> system <identifiersep> exception { \n \t2 try { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> store <identifiersep> <identifier> , <identifier> , user <identifiersep> info ) ; } \n \t4 finally { \n \t5 <identifier> <identifiersep> object <identifiersep> store <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> remote <identifiersep> <identifier> ( false ) ; } \n <ect>
\t4 } catch ( final io <identifiersep> exception e ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> ip ) ; \n \t5 success = false ; } } \n \t2 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> ( final connection conn , final string name <identifiersep> <identifier> ) { \n \t2 try { \n \t3 final set < <identifier> > <identifier> = <identifier> . get <identifiersep> by <identifiersep> name <identifiersep> <identifier> ( conn , name <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> . size ( ) != 1 ) { \n <ect>
\t5 <comment> \n \t4 } catch ( timeout <identifiersep> exception <identifier> ) { \n \t5 <identifier> <identifiersep> log . logger . warn ( <string_literal> + task . task <identifiersep> type + <string_literal> ) ; \n \t5 task . end . <identifier> ( ) ; \n <ect>
\t5 <comment> \n \t5 task <identifiersep> <identifier> . set <identifiersep> <identifier> ( true ) ; \n \t5 <identifier> <identifiersep> task <identifiersep> <identifier> ( task <identifiersep> <identifier> ) ; } } \n \t3 catch ( exception e ) { \n <ect>
\t5 return null ; } \n \t4 if ( value instanceof <identifier> <identifiersep> object ) { \n \t5 current = ( <identifier> <identifiersep> object ) value ; \n \t4 } else { \n <ect>
\t1 @ <identifier> ( <string_literal> ) \n \t1 @ <identifier> ( <identifier> <identifiersep> type . application <identifiersep> xml ) \n \t1 @ path ( <string_literal> ) \n \t1 public list < context <identifiersep> <identifier> <identifiersep> name > <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> input input ) throws io <identifiersep> exception { \n <ect>
\t7 if ( element . get <identifiersep> code ( ) . equals ( <identifier> . <identifier> ( ) ) ) { \n \t8 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> index ( i ) ; \n \t8 break ; } } \n \t5 } else { \n <ect>
\t3 file file = new file ( file <identifiersep> name ) ; \n \t3 if ( file . exists ( ) && file . <identifier> <identifiersep> read ( ) ) { \n \t4 <identifier> <identifiersep> value = file <identifiersep> utils . read <identifiersep> file <identifiersep> to <identifiersep> string ( new file ( file <identifiersep> name ) , <identifier> ) ; \n \t3 } else { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 t = new thread ( new <identifier> ( ) { \n \t3 public void run ( ) { \n <ect>
\t2 boolean is <identifiersep> i <identifiersep> <identifier> = <identifier> == <number_literal> ; \n \t2 if ( state == null ) { <comment> \n \t3 <comment> \n \t3 <comment> \n <ect>
\t4 store . <identifier> <identifiersep> <identifier> ( ) ; } \n \t3 catch ( store <identifiersep> exception e ) { \n \t4 if ( store != null ) { \n \t5 store . <identifier> <identifiersep> <identifier> ( ) ; } \n <ect>
\t1 private boolean is <identifiersep> <identifier> ( ) \n \t1 { \n \t2 if ( system . get <identifiersep> property ( <string_literal> , null ) != null && system <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ) \n \t2 { \n <ect>
\t2 return get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> <identifiersep> <identifier> . <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> server <identifier> , <identifier> <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> <identifier> <identifier> ) { \n \t2 if ( <identifier> == null ) { \n <ect>
\t5 <identifier> <identifiersep> queue <identifiersep> <identifier> . <identifier> ( ) ; \n \t5 store . <identifier> <identifiersep> local <identifiersep> <identifier> <identifiersep> lock ( ) ; \n \t5 message . <identifier> <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 throw new runtime <identifiersep> exception ( <string_literal> , exception <identifiersep> <identifier> <identifiersep> by <identifiersep> thread ) ; } \n \t2 long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - start ; \n \t2 log . info ( <string_literal> + <identifier> + <string_literal> ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> count . int <identifiersep> value ( ) + <string_literal> + bytes <identifiersep> <identifier> . get ( ) + <string_literal> ) ; \n <ect>
\t2 for ( final <identifier> <identifiersep> interface <identifier> : <identifier> <identifiersep> to <identifiersep> run ) { \n \t3 if ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) && <identifier> <identifiersep> <identifier> == null ) { \n \t4 throw new <identifier> <identifiersep> exception ( <string_literal> + <identifier> . to <identifiersep> string ( ) + <string_literal> ) ; } \n \t3 if ( ! <identifier> <identifiersep> level <identifiersep> default . equals ( <identifier> <identifiersep> <identifier> <identifiersep> level ) && ! <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> level ( ) ) { \n <ect>
\t4 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> command ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> host . get <identifiersep> job <identifiersep> id ( ) , request <identifiersep> type . get <identifiersep> or <identifiersep> <identifier> ) ; } \n \t3 <identifier> . set <identifiersep> <identifier> ( source <identifiersep> <identifier> ) ; <comment> \n \t3 host <identifiersep> vo <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> host ( <identifier> <identifiersep> server ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t3 synchronized ( <identifier> <identifiersep> lock ) { \n \t4 while ( ! <identifier> ) { \n \t5 <identifier> <identifiersep> lock . wait ( ) ; } } \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 set <identifiersep> response <identifiersep> object ( response ) ; \n \t3 } else { \n \t4 throw new server <identifiersep> api <identifiersep> exception ( api <identifiersep> error <identifiersep> code . <identifier> <identifiersep> error , <string_literal> ) ; } \n \t2 } catch ( resource <identifiersep> in <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 try { \n \t4 date value = <identifier> . parse ( value <identifiersep> content ) ; \n \t4 <identifier> . set ( object , date <identifiersep> <identifier> . to <identifiersep> <identifier> ( value ) ) ; \n \t3 } catch ( parse <identifiersep> exception e ) { \n <ect>
<number_literal> final registered <identifiersep> service service ) { \n \t2 final collection < <identifier> <identifiersep> authentication <identifiersep> provider > <identifier> = <identifier> <identifiersep> <identifier> ( get <identifiersep> authentication <identifiersep> provider <identifiersep> for <identifiersep> service ( service ) ) ; \n \t2 if ( <identifier> != null && ! <identifier> . is <identifiersep> empty ( ) ) { \n \t3 final <identifier> <identifiersep> authentication <identifiersep> provider provider = this . <identifier> <identifiersep> authentication <identifiersep> provider <identifiersep> <identifier> . <identifier> ( <identifier> , service , principal ) ; \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> port . get <identifiersep> <identifier> ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> port . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> + exception <identifiersep> delete . get <identifiersep> message ( ) ) ; } \n \t2 s <identifiersep> logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> port . get <identifiersep> <identifier> ( ) + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> port . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> ) ; } \n \t1 private answer handle <identifiersep> exception ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception e , <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> command command , <identifier> <identifiersep> <identifier> <identifiersep> resource <identifier> <identifiersep> <identifier> <identifiersep> resource ) { \n \t2 if ( http <identifiersep> status <identifiersep> code <identifiersep> <identifier> . is <identifiersep> <identifier> ( e . get <identifiersep> error <identifiersep> code ( ) ) ) { \n <ect>
\t6 thread . <identifier> ( time <identifiersep> to <identifiersep> <identifier> ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n \t6 <comment> \n \t3 } catch ( exception e ) { \n <ect>
\t1 <identifier> <identifier> = null ; \n \t1 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = null ; \n \t1 result <identifiersep> set <identifier> = null ; \n \t1 <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> table <identifiersep> id <identifiersep> from <identifiersep> instance <identifiersep> name ( c , instance ) ; \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 conf . set ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> class , config . get <identifiersep> <identifier> <identifiersep> class ( ) ) ; \n \t1 conf . set ( <identifier> <identifiersep> <identifier> . <identifier> , string . value <identifiersep> of ( config . get <identifiersep> <identifier> ( ) ) ) ; \n \t1 job . set <identifiersep> num <identifiersep> <identifier> <identifiersep> <identifier> ( 0 ) ; \n \t1 boolean <identifier> = job . wait <identifiersep> for <identifiersep> <identifier> ( true ) ; \n <ect>
\t2 logger . debug ( <string_literal> , id ) ; \n \t2 try { \n \t3 transaction <identifiersep> store . transaction <identifier> = this . <identifier> <identifiersep> content <identifiersep> by <identifiersep> id . remove ( id ) . get <identifiersep> transaction ( ) ; \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t1 @ <identifier> \n \t1 protected list < string > <identifier> <identifiersep> event <identifiersep> from <identifiersep> http <identifiersep> request ( final http <identifiersep> <identifier> <identifiersep> request request ) { \n \t2 final <identifier> < string > values = request . get <identifiersep> <identifier> ( <identifier> <identifiersep> request <identifiersep> header ) ; \n \t2 if ( values != null ) { \n <ect>
\t1 try { \n \t2 string t = text . <identifier> ( s . get <identifiersep> bytes ( ) , 0 , s . get <identifiersep> bytes ( ) . length ) ; \n \t2 return t . get <identifiersep> bytes ( ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 conf <identifiersep> <identifier> <identifiersep> name = <string_literal> \n \t1 base <identifiersep> dir = <identifier> . path . <identifier> ( <identifier> . path . <identifier> ( <identifier> . path . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> ) ) ) \n \t1 config <identifiersep> dir = self . get <identifiersep> config <identifiersep> dir <identifiersep> <identifier> <identifiersep> stack <identifiersep> <identifier> ( <identifier> , base <identifiersep> dir , conf <identifiersep> <identifier> <identifiersep> name ) \n \t1 if config <identifiersep> dir : \n <ect>
\t6 object value = <identifier> ( <identifier> , method . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) [ 0 ] ) ; \n \t6 if ( value != null ) { \n \t7 method . <identifier> ( bean , new object [ ] { value } ) ; } } \n \t4 } catch ( throwable e ) { \n <ect>
\t2 return <identifier> <identifiersep> status . <identifier> <identifiersep> <identifier> ; \n \t1 case <identifier> : \n \t2 return <identifier> <identifiersep> status . <identifier> ; \n \t1 default : \n <ect>
\t2 new <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> <identifier> , <identifier> , <identifier> , <identifier> <identifiersep> next ) ) ; } \n \t1 <comment> \n \t1 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , new <identifiersep> <identifier> ) ) { \n <ect>
\t2 <comment> \n \t2 string path <identifiersep> for <identifiersep> entry = path <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t2 file entry <identifiersep> file = new file ( path <identifiersep> for <identifiersep> entry ) ; \n \t2 final file <identifier> <identifiersep> file = new file ( path <identifiersep> for <identifiersep> entry + <string_literal> + system . current <identifiersep> time <identifiersep> millis ( ) ) ; \n <ect>
\t6 . <identifier> ( in <identifiersep> <identifier> , first <identifiersep> <identifier> ) != 1 ) <comment> \n \t4 { \n \t5 <comment> \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 logger . warn ( <string_literal> , <identifier> ) ; \n \t3 return false ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public void on <identifiersep> <identifier> <identifiersep> update ( final <identifier> <identifiersep> group in <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> group ) \n \t1 { \n \t2 { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 answer = <identifier> . <identifier> <identifiersep> exchange ( <identifier> <identifiersep> context , <identifier> ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 throw new runtime <identifiersep> exception ( <string_literal> + exchange <identifiersep> id + <string_literal> + <identifier> <identifiersep> name , e ) ; } \n <ect>
\t2 for ( final string <identifier> : <identifier> ) { \n \t3 final <identifier> <identifiersep> id <identifiersep> <identifier> <identifier> <identifiersep> id = <identifier> <identifiersep> to <identifiersep> <identifier> . get ( <identifier> ) ; \n \t3 final <identifier> <identifiersep> id <identifiersep> <identifier> <identifier> <identifiersep> id = <identifier> <identifiersep> to <identifiersep> <identifier> . get ( <identifier> ) ; \n \t3 if ( <identifier> <identifiersep> id == null || <identifier> <identifiersep> id == null ) { \n <ect>
\t1 <comment> \n \t1 private final <identifier> <identifiersep> map < string , list < <identifier> <identifiersep> listener > > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> map < string , list < <identifier> <identifiersep> listener > > ( ) ; \n \t1 public void <identifier> ( url url ) { \n <ect>
\t2 } else { \n \t3 host = ( string ) <identifier> . key <identifiersep> set ( ) . to <identifiersep> array ( ) [ 0 ] ; } \n \t2 <identifier> <identifiersep> map < string , string > host <identifiersep> <identifier> = <identifier> . get ( host ) ; \n \t2 if ( host <identifiersep> <identifier> == null ) { \n <ect>
\t3 else { \n \t4 on <identifiersep> message <identifiersep> <identifier> ( message , <identifier> <identifiersep> id ) ; } } \n \t2 catch ( exception e ) { \n <ect>
\t3 @ <identifier> \n \t3 public void item <identifiersep> state <identifiersep> <identifier> ( item <identifiersep> event e ) { \n \t4 if ( e . get <identifiersep> state <identifiersep> <identifier> ( ) == item <identifiersep> event . <identifier> ) { \n \t5 configuration . set <identifiersep> <identifier> <identifiersep> method ( <identifier> . get <identifiersep> <identifier> <identifiersep> key ( ) ) ; \n <ect>
\t3 remove <identifiersep> <identifier> ( test <identifiersep> name ) ; } \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> stream <identifiersep> update ( ) throws exception { \n <ect>
\t4 <identifier> . remove <identifiersep> last <identifiersep> object ( ) ; \n \t4 if ( <identifier> . count ( ) == 0 ) { \n \t5 <identifier> <identifiersep> lock <identifiersep> <identifier> . remove <identifiersep> object <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> thread ) ; } \n \t3 } else { \n <ect>
protected int <identifier> <identifiersep> num <identifiersep> map <identifiersep> <identifier> ( job job ) throws io <identifiersep> exception { \n \t1 int num <identifiersep> map <identifiersep> <identifier> = options . get <identifiersep> num <identifiersep> <identifier> ( ) ; \n \t1 if ( num <identifiersep> map <identifiersep> <identifier> < 1 ) { \n \t1 num <identifiersep> map <identifiersep> <identifier> = <identifier> <identifiersep> options . default <identifiersep> num <identifiersep> <identifier> ; \n <ect>
\t3 <identifier> <identifiersep> store . create <identifiersep> entity <identifiersep> <identifier> <identifiersep> url ( <identifier> <identifiersep> template . get <identifiersep> <identifier> <identifiersep> path ( ) , <identifier> <identifiersep> template . get <identifiersep> format ( ) , <identifier> <identifiersep> template ) ; } \n \t2 <comment> \n \t2 string url = <identifier> <identifiersep> <identifier> <identifiersep> url ( <identifier> <identifiersep> template ) ; \n \t2 if ( url == null ) { \n <ect>
\t3 connection <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( new input <identifiersep> stream <identifiersep> <identifier> ( \n \t4 connection . get <identifiersep> input <identifiersep> stream ( ) ) ) ; \n \t3 if ( ! connection <identifiersep> <identifier> . read <identifiersep> line ( ) . contains ( <string_literal> ) ) \n \t3 { \n <ect>
\t2 log . debug ( string . format ( <string_literal> + <string_literal> , \n \t8 stream . get <identifiersep> class ( ) ) ) ; } } \n \t1 } catch ( exception e ) { \n <ect>
\t5 <identifier> <identifiersep> exchange = <identifier> ; } \n \t4 ( ( timeout <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) . timeout ( <identifier> <identifiersep> exchange , <identifier> . int <identifiersep> value ( ) , total . int <identifiersep> value ( ) , timeout ) ; \n \t3 } else { \n \t4 <comment> \n <ect>
\t6 ( void value ) - > all <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> state ( <identifier> <identifiersep> <identifier> <identifiersep> version <identifiersep> of <identifiersep> <identifier> ) , \n \t6 <identifier> ) ; \n \t5 break ; } } \n \t3 else { \n <ect>
\t6 <identifier> <identifiersep> type . get <identifiersep> type ( ) == null ) continue ; \n \t4 <identifier> <identifiersep> uri = <identifier> <identifiersep> type . get <identifiersep> <identifier> ( ) . get <identifiersep> uri ( ) ; \n \t4 property <identifiersep> uri = <identifier> <identifiersep> type . get <identifiersep> type ( ) . get <identifiersep> uri ( ) ; \n \t4 integer count <identifiersep> of <identifiersep> <identifier> <identifiersep> type = <identifier> <identifiersep> <identifier> <identifiersep> count . get ( <identifier> <identifiersep> uri + property <identifiersep> uri ) ; \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> + <string_literal> + account . get <identifiersep> account <identifiersep> name ( ) + <string_literal> + account . get <identifiersep> id ( ) + <string_literal> ) ; } } \n \t2 <identifier> = storage <identifiersep> <identifier> <identifiersep> <identifier> . parse ( account , current <identifiersep> start <identifiersep> date , current <identifiersep> end <identifiersep> date ) ; \n \t3 if ( ! <identifier> ) { \n <ect>
\t2 list < map < string , object > > output <identifiersep> config = ( list < map < string , object > > ) config <identifiersep> map . get ( key ) ; \n \t2 output <identifiersep> config <identifiersep> list . add <identifiersep> all ( output <identifiersep> config ) ; \n \t2 break ; \n \t2 default : \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 return null ; } \n \t1 <comment> \n \t1 public object put <identifiersep> <identifier> ( final object key , final <identifier> <identifiersep> <identifier> value ) { \n <ect>
\t3 final authentication authentication = get <identifiersep> authentication <identifiersep> <identifier> <identifiersep> by <identifiersep> policy ( root . get <identifiersep> authentication ( ) , \n \t4 new service <identifiersep> context ( <identifier> <identifiersep> service , registered <identifiersep> service ) ) ; \n \t3 final principal principal = authentication . get <identifiersep> principal ( ) ; \n \t3 final registered <identifiersep> service <identifiersep> attribute <identifiersep> <identifier> <identifiersep> policy attribute <identifiersep> policy = registered <identifiersep> service . get <identifiersep> attribute <identifiersep> <identifier> <identifiersep> policy ( ) ; \n <ect>
\t4 return false ; \n \t3 if ( <identifier> <identifiersep> <identifier> ) \n \t4 key = ( <identifier> ) <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( key , false ) ; \n <ect>
\t5 string user <identifiersep> and <identifiersep> <identifier> = out . to <identifiersep> string ( <identifier> . default <identifiersep> <identifier> ( ) ) ; \n \t5 string <identifier> = object <identifiersep> <identifier> . <identifier> ( user <identifiersep> and <identifiersep> <identifier> , <string_literal> ) ; \n \t5 string password = object <identifiersep> <identifier> . <identifier> ( user <identifiersep> and <identifiersep> <identifier> , <string_literal> ) ; \n \t5 http <identifiersep> principal principal = new http <identifiersep> principal ( <identifier> , password ) ; \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> message ( byte <identifier> <identifiersep> node , boolean state ) { \n \t2 super ( <identifier> <identifiersep> node , ( byte ) 0 ) ; \n <ect>
\t5 } catch ( io <identifiersep> exception x ) { \n \t6 log . error ( <string_literal> , x ) ; \n \t6 return ; \n \t5 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception x ) { \n <ect>
\t4 log . info ( log . <identifier> <identifiersep> <identifier> , <string_literal> , <identifier> ) ; } \n \t3 if ( ( <identifier> != null ) && ( <identifier> . is <identifiersep> protected <identifiersep> content ( name , <identifier> , content <identifiersep> type , handle ) ) ) { \n \t4 <comment> \n \t4 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n <ect>
\t1 protected void stop <identifiersep> <identifier> ( ) { \n \t2 try { \n \t3 <identifier> <identifiersep> group . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 class . for <identifiersep> name ( default <identifiersep> <identifier> ) ; \n \t4 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n \t5 log . error ( <string_literal> + default <identifiersep> <identifier> + <string_literal> , ex ) ; } } } \n \t2 try { \n <ect>
\t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw ex ; \n \t1 } catch ( exception ex ) { \n <ect>
\t3 null , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( resource ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 i <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> . parse ( ) ; \n <ect>
\t2 <identifier> <identifier> = <identifier> . get <identifiersep> instance ( <identifier> . class ) ; \n \t2 try { \n \t3 return <identifier> . get <identifiersep> cluster ( long . value <identifiersep> of ( cluster <identifiersep> id ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 string message = <string_literal> 1 . 0 \\ <string_literal> <identifier> - <number_literal> \\ <string_literal> command \\ <string_literal> \n \t4 + key + <string_literal> ; \n \t2 if ( <identifier> ( ) ) { \n \t3 answer = <identifier> ( <string_literal> , " <identifier> / api / command <string_literal> <ect>
\t1 protected boolean do <identifiersep> process ( <identifier> <identifier> ) { \t1 \n \t1 if ( <identifier> != null && <identifier> . next <identifiersep> double ( ) > <identifier> ) { \n \t2 return true ; <comment> \n <ect>
@ <identifier> \n public static text <identifiersep> <identifier> find <identifiersep> <identifier> <identifiersep> <identifier> ( @ not <identifiersep> null <identifier> <identifier> , int count , boolean is <identifiersep> <identifier> ) { \n \t1 int line = <identifier> . get <identifiersep> <identifier> <identifiersep> model ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . line ; \n \t1 int <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> line <identifiersep> count ( <identifier> ) ; \n <ect>
\t2 { \n \t3 if ( <identifier> <identifiersep> response . get <identifiersep> response ( ) != null ) \n \t3 { \n <ect>
\t4 handle <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state ( <identifier> <identifiersep> state ) ; } \n \t4 log . debug ( <string_literal> , get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , <identifier> <identifiersep> index , <identifier> <identifiersep> state ) ; } \n \t2 } else { \n <ect>
\t2 <identifier> <identifiersep> properties ( true , object , null ) ; } \n \t1 public void <identifier> <identifiersep> properties <identifiersep> ignore <identifiersep> <identifier> ( object object ) { \n \t2 <identifier> <identifiersep> properties ( false , object , null ) ; } \n \t1 private void handle <identifiersep> <identifier> <identifiersep> of <identifiersep> field ( boolean <identifier> , object object , field <identifiersep> access field ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
<comment> \n \t1 public void <identifier> ( input <identifiersep> <identifier> in <identifiersep> <identifier> , job <identifiersep> conf job ) throws io <identifiersep> exception { \n \t1 base <identifiersep> <identifier> = ( org . apache . <identifier> . <identifier> . client . <identifier> . <identifier> <identifiersep> input <identifiersep> <identifier> ) in <identifiersep> <identifier> ; \n <ect>
\t6 string key = this . create <identifiersep> target <identifiersep> property <identifiersep> name ( header <identifiersep> name , true ) ; \n \t6 this . <identifier> <identifiersep> user <identifiersep> <identifier> <identifiersep> header ( key , value , target ) ; } } \n \t4 catch ( exception e ) { \n <ect>
\t6 <identifier> ) ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t6 <identifier> . remove <identifiersep> data ( new grid <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ( file <identifiersep> info . id ( ) , null , file <identifiersep> info . <identifier> <identifiersep> <identifier> ( ) , <identifier> ) ) ; } } } \n \t2 catch ( grid <identifiersep> exception e ) { \n <ect>
\t5 if ( key . value != null ) { \n \t6 message . set <identifiersep> header ( <identifier> <identifiersep> header . key . name ( ) , key . value ) ; } \n \t5 message . set <identifiersep> body ( value . value ) ; \n \t5 exchange . set <identifiersep> in ( message ) ; \n <ect>
\t1 run <identifiersep> import ( <identifier> ) ; \n \t1 <identifier> ( <string_literal> ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n \t1 <comment> \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) < 1 || \n \t5 <identifier> <identifiersep> server . get <identifiersep> in <identifiersep> process ( ) < <identifier> <identifiersep> <identifier> ) { \n \t5 <identifier> <identifiersep> <identifier> ( ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t2 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <comment> \n \t3 <identifier> <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n \t2 <comment> \n <ect>
<comment> \n \t2 final string <identifier> <identifiersep> error = string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> <identifier> <identifiersep> error ( ) ) ? <identifier> <identifiersep> <identifier> <identifiersep> code <identifiersep> <identifier> <identifiersep> <identifier> : <identifier> . get <identifiersep> <identifier> <identifiersep> error ( ) ; \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t3 return true ; } \n \t2 map < string , <identifier> <identifiersep> snapshot <identifiersep> on <identifiersep> <identifier> <identifiersep> vo > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> map < string , <identifier> <identifiersep> snapshot <identifiersep> on <identifiersep> <identifier> <identifiersep> vo > ( ) ; \n \t2 for ( <identifier> <identifiersep> snapshot <identifiersep> on <identifiersep> <identifier> <identifiersep> vo <identifier> <identifiersep> <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> vm <identifiersep> <identifier> ) { \n <ect>
\t2 if ( ! <identifier> <identifiersep> attributes <identifiersep> <identifier> <identifiersep> to <identifiersep> process ( principal , principal <identifiersep> attributes ) ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 return false ; } \n \t2 if ( do <identifiersep> <identifier> <identifiersep> attributes <identifiersep> <identifier> <identifiersep> principal <identifiersep> access ( principal <identifiersep> attributes ) ) { \n <ect>
protected final string <identifier> ; \n public <identifier> <identifiersep> text <identifiersep> <identifier> ( string <identifier> ) { \n \t1 this . <identifier> = <identifier> ; } \n public boolean <identifier> ( <identifier> to ) { \n <ect>
<comment> \n \t1 public final void set <identifiersep> transaction <identifiersep> <identifier> ( int level ) throws data <identifiersep> access <identifiersep> exception { \n \t2 try { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 break ; } } } } \n \t1 protected void process <identifiersep> <identifier> ( <identifier> <identifiersep> message m ) { \n \t2 try { \n \t3 if ( m . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 try { \n \t3 return data . get <identifiersep> bytes ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file ( <identifier> ) ; } \n \t3 <comment> \n \t3 else if ( <identifier> . get <identifiersep> name ( ) . contains ( <string_literal> ) || <identifier> . get <identifiersep> name ( ) . contains ( <string_literal> ) \n \t5 || <identifier> . get <identifiersep> name ( ) . contains ( <string_literal> ) ) { \n <ect>
\t3 } else if ( data <identifiersep> type == integer . class ) { \n \t4 log . debug ( <string_literal> , key ) ; \n \t4 <identifier> . field ( <string_literal> , <string_literal> ) ; \n \t3 } else if ( data <identifiersep> type == long . class ) { \n <ect>
\t2 @ <identifier> \n \t2 public void exception <identifiersep> <identifier> ( channel <identifiersep> handler <identifiersep> context <identifier> , \n \t9 throwable <identifier> ) throws exception { \n <ect>
\t2 if ( <identifier> <identifiersep> message != null ) { \n \t3 try { \n \t4 set <identifiersep> message <identifiersep> id ( <identifier> <identifiersep> message . get <identifiersep> <identifier> <identifiersep> message <identifiersep> id ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 <identifier> = <identifier> . default <identifiersep> <identifier> ( ) . name ( ) ; \n \t3 <comment> \n \t3 configuration . set <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 logger . info ( <string_literal> , <identifier> <identifiersep> node ) ; \n \t2 assert <identifiersep> no <identifiersep> <identifier> ( <identifier> <identifiersep> node , <identifier> <identifiersep> <identifier> . no <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , time <identifiersep> value . time <identifiersep> value <identifiersep> <identifier> ( <number_literal> ) ) ; \n <ect>
\t2 <identifier> . set <identifiersep> end <identifiersep> <identifier> <identifiersep> mode ( true ) ; \n \t2 int <identifier> <identifiersep> size = 1 ; \n \t2 if ( max <identifiersep> read <identifiersep> length == long . max <identifiersep> value || max <identifiersep> read <identifiersep> length < 0 ) { \n \t3 <identifier> <identifiersep> size = max <identifiersep> <identifier> <identifiersep> size ; \n <ect>
\t1 @ <identifier> \n \t1 public boolean execute <identifiersep> user <identifiersep> request ( long host <identifiersep> id , event event ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( event == event . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> client <identifier> <identifiersep> <identifier> <identifiersep> client = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> client <identifiersep> or <identifiersep> null ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> client != null && <identifier> <identifiersep> <identifier> <identifiersep> client . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> group ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> <identifier> . <identifier> ) ) { \n \t4 <identifier> <identifiersep> resource ( resource , source <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> client . <identifier> ( ) ) ; \n \t3 } else { \n <ect>
\t9 group . index ) ; \n \t7 add <identifiersep> to <identifiersep> queue ( <identifier> <identifiersep> command <identifiersep> class . get <identifiersep> <identifier> <identifiersep> message ( group . index ) ) ; } \n \t5 } else { \n \t6 for ( int group = 1 ; group < = <identifier> <identifiersep> command <identifiersep> class . get <identifiersep> max <identifiersep> <identifier> ( ) ; group ++ ) { \n <ect>
\t4 ( m <identifiersep> bean <identifiersep> utils . get <identifiersep> <identifier> ( <identifier> ) + <string_literal> \n \t4 + context <identifiersep> name + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> name ( ) ) ; \n \t3 <identifier> . get <identifiersep> <identifier> ( null , null ) . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 string <identifier> <identifiersep> id = cluster . get <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> cluster <identifiersep> state , <identifier> <identifiersep> name ) ; \n \t3 if ( <identifier> <identifiersep> id != null ) { \n \t4 return <identifier> <identifiersep> id ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> = new <identifier> <identifiersep> map < > ( ) ; \n \t3 <identifier> . put ( template . name , <identifier> <identifiersep> path ) ; \n \t2 } else { \n \t3 if ( ! <identifier> . contains <identifiersep> key ( template . name ) ) { \n <ect>
\t6 s <identifiersep> logger . warn ( <string_literal> ) ; } } \n \t3 } catch ( sql <identifiersep> exception e ) { \n \t4 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> , e ) ; } \n \t3 <comment> \n <ect>
\t3 return <identifier> ; \n \t2 <identifier> . for <identifiersep> <identifier> ( ( id , c ) - > { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . find <identifiersep> <identifier> ( id ) ; \n \t3 if ( ! <identifier> . equals ( c ) ) \n <ect>
\t2 <identifier> ( provider ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> <identifiersep> <identifier> provider ) { \n <ect>
\t3 ( ( user <identifiersep> stream <identifiersep> listener ) listener ) . on <identifiersep> <identifier> <identifiersep> message ( <identifier> <identifiersep> message ) ; } } \n \t1 @ <identifier> \n \t1 protected void on <identifiersep> <identifier> <identifiersep> <identifier> ( json <identifiersep> object json , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 <comment> \n <ect>
\t4 if ( a . is <identifiersep> group ( ) || ! is <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> user , false ) ) { \n \t5 log . warn ( <string_literal> ) ; \n \t5 return false ; } \n \t4 if ( ( ( user ) a ) . is <identifiersep> system <identifiersep> user ( ) ) { \n <ect>
\t2 entity <identifiersep> <identifier> . set <identifiersep> string ( <number_literal> , <string_literal> ) ; } \n \t1 entity <identifiersep> <identifier> . set <identifiersep> string ( <number_literal> , <identifier> <identifiersep> event . get <identifiersep> task <identifiersep> id ( ) . to <identifiersep> string ( ) ) ; \n \t1 entity <identifiersep> <identifier> . execute <identifiersep> update ( ) ; \n \t1 } catch ( sql <identifiersep> exception <identifier> ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> security <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t4 this . set <identifiersep> response <identifiersep> object ( response ) ; \n \t3 } else { \n \t4 throw new server <identifiersep> api <identifiersep> exception ( base <identifiersep> cmd . <identifier> <identifiersep> error , <string_literal> ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t6 if ( <identifier> <identifiersep> <identifier> . size ( ) > 0 ) { \n \t7 do <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( ) ; } \n \t6 for ( <identifier> <identifiersep> consumer consumer : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 try { \n \t3 load <identifiersep> <identifier> result = <identifier> <identifiersep> <identifier> <identifiersep> service . create <identifiersep> load <identifiersep> <identifier> <identifiersep> <identifier> ( this , get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t3 this . set <identifiersep> entity <identifiersep> id ( result . get <identifiersep> id ( ) ) ; \n \t2 } catch ( network <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 throw new not <identifiersep> found <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + job <identifiersep> id + <string_literal> , null ) ; \n \t1 get <identifiersep> resource <identifiersep> manager ( ) . <identifier> <identifiersep> job <identifiersep> status ( job ) ; \n \t1 return response . <identifier> ( ) . build ( ) ; \n \t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n <ect>
\t3 . filter ( <identifier> - > <identifier> . <identifier> ( context ) ) \n \t3 . find <identifiersep> first ( ) \n \t3 . or <identifiersep> else ( null ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t6 <identifier> <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , \n \t6 null ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t4 return null ; \n \t3 return new http <identifiersep> response <identifiersep> result ( result , http <identifiersep> client ) ; } \n \t2 catch ( throwable t ) \n \t2 { \n <ect>
\t3 try { \n \t4 class < ? > <identifier> = class <identifiersep> <identifier> . load <identifiersep> class ( <identifier> <identifiersep> class <identifiersep> name ) ; \n \t4 return ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> . new <identifiersep> instance ( ) ; \n \t3 } catch ( throwable e ) { \n <ect>
\t2 process <identifiersep> <identifier> <identifiersep> configuration . get <identifiersep> db <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 process <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> service ( ) . <identifier> <identifiersep> authentication ( ) ; } \n \t1 } else { \n <ect>
\t1 public boolean <identifier> <identifiersep> network ( long network <identifiersep> id , <identifier> <identifiersep> context context ) { \n \t2 account <identifier> <identifiersep> account = <identifier> <identifiersep> account <identifiersep> <identifier> . get <identifiersep> account ( context . get <identifiersep> <identifier> ( ) . get <identifiersep> account <identifiersep> id ( ) ) ; \n \t2 network <identifiersep> vo network = <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( network <identifiersep> id ) ; \n \t2 if ( network == null ) { \n <ect>
\t2 synchronized ( this . <identifier> <identifiersep> root <identifiersep> <identifier> <identifiersep> service ) \n \t2 { \n \t3 this . <identifier> <identifiersep> service = <identifier> <identifiersep> service ; \n <ect>
\t1 <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> . get <identifiersep> group <identifiersep> base <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> <identifiersep> <identifier> . to <identifiersep> array ( new string [ 0 ] ) , new <identifier> <identifiersep> entry <identifiersep> <identifier> ( ) { \n \t1 @ <identifier> \n \t1 public void process <identifiersep> <identifier> <identifiersep> entry ( string <identifier> , attributes <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 if ( <identifier> ) { \n <ect>
\t2 if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 <identifier> = <identifier> <identifiersep> service . add <identifiersep> <identifier> ( \n \t4 <string_literal> + port + get <identifiersep> <identifier> <identifiersep> config ( ) ) ; \n \t3 port = <identifier> . get <identifiersep> <identifier> <identifiersep> uri ( ) . get <identifiersep> port ( ) ; \n <ect>
public class cache <identifiersep> <identifier> <identifiersep> meta <identifiersep> data <identifiersep> <identifier> extends base <identifiersep> authentication <identifiersep> meta <identifiersep> data <identifiersep> <identifier> { \n \t1 private final <identifier> <identifiersep> <identifier> < string , string > <identifier> <identifiersep> <identifier> ; \n \t1 public cache <identifiersep> <identifier> <identifiersep> meta <identifiersep> data <identifiersep> <identifier> ( ) { \n \t2 this ( null ) ; \n <ect>
\t4 @ <identifier> \n \t4 public test <identifiersep> <identifier> <identifiersep> version <identifier> ( ) throws store <identifiersep> exception { \n \t5 test <identifiersep> <identifier> <identifiersep> version test <identifiersep> <identifier> = <identifier> <identifiersep> test <identifiersep> <identifier> <identifiersep> cache . get <identifiersep> if <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t5 if ( test <identifiersep> <identifier> == null ) { \n <ect>
\t5 . put ( <string_literal> , <identifier> <identifiersep> int <identifiersep> <identifier> ( <number_literal> , <number_literal> ) / <identifier> ) \n \t5 <comment> \n \t5 . put ( <string_literal> , false ) \n \t5 . put ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> length ( <number_literal> ) ) ) ) ; \n <ect>
\t2 } catch ( final <identifier> <identifiersep> api <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t3 return new <identifier> <identifiersep> answer ( command , false , e . get <identifiersep> message ( ) ) ; \n \t2 } catch ( final xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 new properties <identifiersep> file <identifiersep> configuration <identifiersep> provider ( <identifier> <identifiersep> name , new <identifiersep> <identifier> <identifiersep> configuration ) ; \n \t1 <identifier> <identifiersep> application = new application ( ) ; \n \t1 <identifier> <identifiersep> application . handle <identifiersep> configuration <identifiersep> event ( configuration <identifiersep> provider . get <identifiersep> configuration ( ) ) ; \n \t1 <identifier> <identifiersep> application . start ( ) ; \n <ect>
\t1 <comment> \n \t1 if ( <identifier> . length > 0 ) { \n \t1 for ( int i = 0 ; i < <identifier> . length ; i ++ ) { \n \t2 device <identifiersep> <identifier> ( <identifier> [ i ] ) ; \n <ect>
\t6 log . error ( <string_literal> ) ; } \n \t5 return false ; } \n \t3 } catch ( sql <identifiersep> exception e ) { \n \t4 if ( get <identifiersep> pool <identifiersep> properties ( ) . get <identifiersep> log <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t6 log . trace ( <string_literal> , location , key . key ) ; } \n \t5 catch ( throwable t ) { \n \t6 log . error ( <string_literal> , location , key . key , t ) ; } } } } \n \t2 catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 this . name = name ; \n \t2 this . queue = queue ; \n \t2 this . <identifier> <identifiersep> code = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ; \n \t2 if ( <identifier> < = 0 ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> utils . create <identifiersep> <identifier> ( <identifier> <identifiersep> utils , <identifier> , number <identifiersep> of <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> config ) ; \n \t2 } finally { \n \t3 <identifier> <identifiersep> utils . close ( ) ; } \n <ect>
\t1 private static <identifier> . <identifier> create <identifiersep> connection ( ) throws t <identifiersep> transport <identifiersep> exception \n \t1 { \n \t2 if ( system . get <identifiersep> property ( <string_literal> ) == null || system . get <identifiersep> property ( <string_literal> ) == null ) \n \t2 { \n <ect>
\t3 <identifier> <identifiersep> log . debug ( <string_literal> + conn <identifiersep> host <identifiersep> name ) ; \n \t3 break ; \n \t2 case address <identifiersep> type . <identifier> : \n \t3 if ( command != command . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 log . debug ( <string_literal> , <identifier> . local <identifiersep> <identifier> , <identifier> ) ; \n \t4 <identifier> . <identifier> ( <identifier> ) ; <comment> \n \t3 <identifier> <identifiersep> <identifier> ++ ; \n \t3 for ( address <identifier> : <identifier> ) { \n <ect>
\t2 <identifier> <identifier> = uri <identifiersep> <identifier> . <identifier> ( uri ) ; \n \t2 if ( ! <identifier> . <identifier> ( ) ) { \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n \t2 for ( int i = 1 ; i < <identifier> . group <identifiersep> count ( ) + 1 ; i ++ ) { \n <ect>
\t3 set <identifiersep> table <identifiersep> property <identifiersep> result result = new set <identifiersep> table <identifiersep> property <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t2 else if ( <identifier> <identifiersep> service <identifiersep> <identifier> <identifiersep> <identifier> . contains ( <identifier> . get <identifiersep> base <identifiersep> url ( ) ) ) { \n \t2 log . warn ( <string_literal> , <identifier> ) ; } \n \t2 <comment> \n \t2 if ( stack <identifiersep> <identifier> <identifiersep> <identifier> . contains ( <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ) { \n <ect>
\t1 if ( ! get <identifiersep> state ( ) . is <identifiersep> <identifier> <identifiersep> state ( ) ) { \n \t1 logger . warn ( <string_literal> + get <identifiersep> state ( ) + <string_literal> ) ; \n \t1 return ; } \n \t1 set <identifiersep> state ( <identifier> <identifiersep> state . <identifier> ) ; \n <ect>
\t3 <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> result result = new <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t7 true , \n \t7 m <identifiersep> element . <identifier> <identifiersep> <identifier> ( ) , \n \t7 m <identifiersep> element . is <identifiersep> create <identifiersep> new ( ) ) ; \n \t5 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 if ( event . get <identifiersep> throwable <identifiersep> <identifier> ( ) != null ) { \n \t5 if ( event . get <identifiersep> throwable <identifiersep> <identifier> ( ) . get <identifiersep> throwable ( ) instanceof interrupted <identifiersep> exception ) { \n \t6 interrupted <identifiersep> exception <identifier> = ( interrupted <identifiersep> exception ) event . get <identifiersep> throwable <identifiersep> <identifier> ( ) . get <identifiersep> throwable ( ) ; \n \t6 if ( <identifier> . get <identifiersep> message ( ) . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
<number_literal> <string_literal> ) ; \n \t3 return - 1 ; \n \t2 } else { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t4 final set < object > attribute <identifiersep> values = collection <identifiersep> utils . to <identifiersep> collection ( entry . get <identifiersep> value ( ) ) ; \n \t4 logger . debug ( <string_literal> , attribute <identifiersep> name , attribute <identifiersep> values ) ; \n \t4 final collection < <identifier> > <identifier> = create <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> attribute ( attribute <identifiersep> name ) ; \n \t4 <identifier> . for <identifiersep> <identifier> ( <identifier> - > { \n <ect>
\t1 logger . info ( <string_literal> ) ; \n \t1 logger . info ( <string_literal> ) ; \n \t1 logger . info ( <string_literal> ) ; \n \t1 logger . error ( <string_literal> ) ; \n <ect>
\t4 log . debug ( <string_literal> + <identifier> . to <identifiersep> string ( ) ) ; \n \t4 continue ; } \n \t3 if ( <identifier> . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) . contains ( <string_literal> ) ) \n \t3 { \n <ect>
\t1 @ get \n \t1 public response get <identifiersep> string ( ) { \n \t2 response . response <identifiersep> builder builder = response . <identifier> ( <string_literal> ) ; \n \t2 builder . header ( <string_literal> , <string_literal> ) ; \n <ect>
<comment> \n public string <identifier> <identifiersep> configuration ( ) throws exception { \n \t1 string config <identifiersep> set = new <identifier> <identifiersep> config <identifiersep> <identifier> <identifiersep> command ( get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , get <identifiersep> <identifier> ( ) ) . run ( this ) ; \n <ect>
\t6 <identifier> . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t5 } catch ( exception e ) { \n \t6 log . error ( <string_literal> , e ) ; \n \t6 <identifier> . add ( e ) ; } \n <ect>
\t3 <string_literal> + e . get <identifiersep> message ( ) , e ) ; } } } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 log . warn ( <string_literal> + cluster <identifiersep> id + <string_literal> ) ; } } \n private void <identifier> <identifiersep> <identifier> <identifiersep> instance ( long cluster <identifiersep> id , string cluster <identifiersep> name , service service , <identifier> <identifiersep> entity <identifier> <identifiersep> entity , string <identifier> <identifiersep> name , <identifier> <identifiersep> config <identifier> <identifiersep> config , <identifier> <identifiersep> instance <identifiersep> config <identifier> <identifiersep> config , collection < string > <identifier> ) throws system <identifiersep> exception , <identifier> <identifiersep> exception { \n <ect>
\t3 <identifier> <identifiersep> instance = <string_literal> ; } \n \t2 map < string , string > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = config <identifiersep> dao . get <identifiersep> configuration ( <string_literal> , <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> host = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> host == null ) { \n <ect>
\t1 for { \n \t1 <identifier> <identifiersep> <identifier> < - <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) \n \t1 if <identifier> ( <identifier> <identifiersep> <identifier> ) != <identifier> <identifiersep> state . <identifier> <identifiersep> <identifier> \n \t1 } { \n <ect>
\t5 logger . info ( <string_literal> , <identifier> ( ) , <identifier> . get <identifiersep> address ( ) , <identifier> ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 logger . error ( <string_literal> , <identifier> ( ) , e ) ; \n \t3 } catch ( field <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 } catch ( <identifier> <identifiersep> operation <identifiersep> exception <identifier> ) { \n \t2 <comment> \n \t1 } catch ( exception e ) { \n \t2 <comment> \n <ect>
\t1 if ( ! is <identifiersep> <identifier> <identifiersep> exception ( t ) ) { \n \t2 log . warn ( <string_literal> + <identifier> , t ) ; \n \t2 return ; \n \t1 } else if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 final org . <identifier> . web . entity . user user = ( org . <identifier> . web . entity . user ) <identifier> <identifiersep> <identifier> . get <identifiersep> principal <identifiersep> for <identifiersep> <identifier> ( principal . name , user <identifiersep> name ) ; \n \t3 <identifier> . success ( ) ; \n \t3 return user ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 @ <identifier> \n \t1 public access <identifiersep> token <identifiersep> request <identifiersep> data <identifiersep> <identifier> <identifier> ( final http <identifiersep> <identifier> <identifiersep> request request , final http <identifiersep> <identifier> <identifiersep> response response ) { \n \t2 final string client <identifiersep> id = request . get <identifiersep> <identifier> ( o <identifiersep> <identifier> . client <identifiersep> id ) ; \n \t2 final set < string > <identifier> = o <identifiersep> <identifier> . parse <identifiersep> request <identifiersep> <identifier> ( request ) ; \n <ect>
public map < string , map < string , list < <identifier> <identifiersep> <identifier> > > > get <identifiersep> service <identifiersep> <identifier> ( string stack <identifiersep> name , \n \t3 string stack <identifiersep> version , string service <identifiersep> name ) throws <identifier> <identifiersep> exception { \n \t1 service <identifiersep> info <identifier> = get <identifiersep> service ( stack <identifiersep> name , stack <identifiersep> version , service <identifiersep> name ) ; \n \t1 if ( null == <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) || ! <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) . exists ( ) ) { \n <ect>
\t2 protected message <identifiersep> <identifier> <identifier> <identifiersep> value ( ) { \n \t3 try { \n \t4 return message <identifiersep> <identifier> . get <identifiersep> instance ( <string_literal> ) ; } \n \t3 catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 return <number_literal> ; \n \t4 } else { \n \t5 s <identifiersep> logger . info ( <string_literal> + response <identifiersep> code ) ; \n \t5 long <identifier> <identifiersep> vm <identifiersep> id = long . parse <identifiersep> long ( values . get ( <string_literal> ) ) ; \n <ect>
\t4 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t3 return true ; } \n \t2 else { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <comment> \n \t4 if ( ! ( <identifier> <identifiersep> <identifier> . equals ( <identifier> <identifiersep> name ) || <identifier> <identifiersep> <identifier> . equals ( <identifier> <identifiersep> name ) ) ) { \n <ect>
\t1 if ( ! <identifier> <identifiersep> version ) { \n \t1 log . warn ( <string_literal> + \n \t2 <string_literal> , <identifier> <identifiersep> version , <identifier> ) ; \n \t1 return ; } \n <ect>
\t1 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = false ; \n \t1 @ <identifier> \n \t1 public void run ( ) { \n \t2 update <identifiersep> thread <identifiersep> name ( ) ; \n <ect>
\t4 logger . trace ( <string_literal> , name , status ) ; \n \t4 <comment> \n \t4 <comment> \n \t4 if ( status . <identifier> . equals ( status ) ) { \n <ect>
\t9 + <string_literal> , \n \t9 <identifier> <identifiersep> name ) ; \n \t2 <identifier> <identifiersep> result <identifiersep> set <identifier> = query <identifiersep> <identifier> . execute <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( query , <number_literal> ) ; \n \t2 int <identifier> = 0 ; \n <ect>
\t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> time ) ; \n \t2 <identifier> <identifiersep> m <identifiersep> bean . create <identifiersep> <identifier> ( <number_literal> ) ; \n \t2 set < string > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = create <identifiersep> <identifier> ( <number_literal> , <number_literal> ) ; \n \t2 state . <identifier> <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 return byte . value <identifiersep> of ( ( string ) answer ) ; \n \t1 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n \t2 <comment> \n <ect>
\t3 else { \n \t4 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> switch <identifiersep> <identifier> + <string_literal> ) ; \n \t4 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> switch <identifiersep> <identifier> + <string_literal> ) ; } } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t6 if ( num <identifiersep> <identifier> > 0 ) \n \t7 count += <identifier> <identifiersep> size ; } \n \t5 <identifier> = <identifier> - num <identifiersep> <identifier> * <identifier> <identifiersep> size ; } } \n \t2 } catch ( sql <identifiersep> exception <identifier> ) { \n <ect>
\t1 else { \n \t2 add <identifiersep> object <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> <identifier> <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> user . <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> key ) ; } } \n public void remove <identifiersep> from <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . model . <identifier> object ) { \n <ect>
\t3 s <identifiersep> logger . trace ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> state ( <identifier> <identifiersep> <identifier> . state . <identifier> ) ; } \n \t2 try { \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , true , false ) ) { \n <ect>
\t4 <identifier> <identifiersep> model <identifier> <identifiersep> model = <identifier> <identifiersep> model . <identifier> . parse ( root <identifiersep> path + <string_literal> , <identifier> ) ; \n \t4 <identifier> <identifiersep> builder <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> model ( <identifier> <identifiersep> model ) ; <comment> \n \t4 org . <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> id <identifier> = <identifier> <identifiersep> model . get <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t4 string <identifier> = <identifier> <identifiersep> builder <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> properties ( <identifier> ) ; \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 } else { \n \t3 log . warn ( <string_literal> ) ; } \n \t2 } catch ( final interrupted <identifiersep> exception e ) { \n <ect>
\t2 <identifier> = <identifier> . <identifier> ( ) ; \n \t2 do <identifiersep> <identifier> ( <number_literal> ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> count = index . get <identifiersep> <identifier> <identifiersep> file ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> count ( ) ; \n <ect>
\t2 throw new <identifier> <identifiersep> <identifier> ( e . get <identifiersep> message ( ) ) ; \n \t1 } catch ( exception e ) { \n \t1 <comment> \n \t1 if ( ! ( e . get <identifiersep> <identifier> ( ) instanceof no <identifiersep> such <identifiersep> element <identifiersep> exception ) ) { \n <ect>
\t1 try { \n \t2 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , context ) ; \n \t1 } catch ( exception e ) { \n \t2 <comment> \n <ect>
\t5 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t4 } else { \n \t5 success = true ; } \n \t3 } catch ( exception ex ) { \n <ect>
\t4 } else { \n \t5 log . info ( <string_literal> , <identifier> <identifiersep> name ) ; } } \n \t3 log . info ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 if ( ! string <identifiersep> utils . is <identifiersep> empty ( <identifier> ) ) { \n \t1 log . debug ( <string_literal> , <identifier> ) ; \n \t1 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> authentication <identifiersep> <identifier> ( <identifier> ) ; \n \t1 } else { \n <ect>
\t2 <comment> \n \t2 service <identifiersep> <identifier> <identifier> = new service <identifiersep> <identifier> ( ) ; \n \t2 service service = new service ( <string_literal> , true , true ) ; \n \t2 <identifier> . set <identifiersep> service ( service ) ; \n <ect>
\t2 <comment> \n \t2 @ <identifier> \n \t2 public void handle ( message . response response ) { \n \t3 if ( ! ( response instanceof <identifier> . event ) ) { \n <ect>
\t3 <identifier> <identifiersep> host <identifiersep> <identifier> <identifiersep> info ( cmd ) ; \n \t3 <identifier> <identifiersep> host <identifiersep> network <identifiersep> info ( cmd ) ; \n \t3 <identifier> <identifiersep> host <identifiersep> <identifier> <identifiersep> info ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> < <identifier> > <identifier> <identifiersep> application ( \n \t3 final application <identifiersep> status final <identifiersep> status , \n \t3 @ <identifier> final string <identifier> ) { \n <ect>
\t2 <identifier> ( ) ; \n \t2 assert <identifiersep> that ( client . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> size ( 0 ) . get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( client . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> size ( 0 ) . get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( client . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> size ( 0 ) . get ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n <ect>
\t1 default : \n \t2 throw new io <identifiersep> exception ( <string_literal> + status ) ; } } \n \t1 return super . <identifier> ( request ) ; } \n private void <identifier> ( boolean is <identifiersep> client ) throws io <identifiersep> exception { \n <ect>
\t2 start ( task <identifiersep> <identifier> ) ; \n \t2 <comment> \n \t2 <identifier> ( task <identifiersep> <identifier> ) ; \n \t2 long end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n <ect>
\t1 public boolean <identifier> <identifiersep> account ( long account <identifiersep> id ) throws <identifier> <identifiersep> operation <identifiersep> exception , resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 boolean success = false ; \n \t2 if ( account <identifiersep> id < = <number_literal> ) { \n <ect>
\t1 <comment> \n \t1 string <identifier> <identifiersep> user <identifiersep> name = user . get <identifiersep> string <identifiersep> attribute ( <identifier> <identifiersep> server <identifiersep> properties . get <identifiersep> <identifier> <identifiersep> attribute ( ) ) ; \n \t1 string <identifier> <identifiersep> name = authentication . get <identifiersep> name ( ) ; <comment> \n \t1 if ( <identifier> <identifiersep> user <identifiersep> name == null ) { \n <ect>
\t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( 0 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n <ect>
\t5 file <identifiersep> system . delete ( <identifier> <identifiersep> path , true ) ; \n \t5 logger . debug ( <string_literal> + path ) ; \n \t5 output . <identifier> ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \t4 } else { \n <ect>
\t2 log . error ( string . format ( <string_literal> , t ) ) ; } } \n \t1 for ( string <identifier> : shards <identifiersep> list ) { \n \t2 if ( ! <identifier> <identifiersep> shards . contains ( <identifier> ) ) { \n \t2 try { \n <ect>
\t8 try { \n \t9 log . info ( <string_literal> ) ; \n \t9 session . <identifier> ( ) ; \n \t8 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 . set <identifiersep> type ( <string_literal> ) . set <identifiersep> <identifier> ( <identifier> . builder ( ) \n \t6 . put ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> path ( ) ) ) ) ; \n \t2 create <identifiersep> index ( <string_literal> , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t5 else { \n \t7 logger . trace ( this . get <identifiersep> connection <identifiersep> id ( ) + <string_literal> + this . channel <identifiersep> input <identifiersep> stream . <identifier> ( ) ) ; } } } \n \t4 catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . <identifier> <identifiersep> <identifier> \t3 : <identifier> , \n \t2 <identifier> . <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : <identifier> \n \t1 ] ) \n \t1 } else { \n <ect>
\t4 throw new configuration <identifiersep> exception ( <string_literal> , \n \t6 <string_literal> + <identifier> . get <identifiersep> provider <identifiersep> name ( ) + <string_literal> ) ; } } \n \t2 <identifier> = location <identifiersep> <identifier> . size ( ) > 0 ; \n \t2 parse <identifiersep> <identifier> = true ; \n <ect>
\t1 private class <identifier> <identifiersep> set <identifiersep> data <identifiersep> <identifier> implements <identifier> <identifiersep> <identifier> { \n \t2 public void process <identifiersep> result ( int <identifier> , string node , object <identifier> , <identifier> <identifier> ) { \n \t3 if ( code . <identifier> . equals ( code . get ( <identifier> ) ) ) { \n \t4 if ( configuration . is <identifiersep> create ( ) ) { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 for ( network <identifiersep> vo network : <identifier> ) { \n \t5 <identifier> <identifiersep> context context = new <identifier> <identifiersep> context <identifiersep> <identifier> ( null , null , get <identifiersep> <identifier> <identifiersep> user ( <identifier> <identifiersep> user <identifiersep> id ) , <identifier> ) ; \n \t5 if ( ! <identifier> <identifiersep> network <identifiersep> <identifier> . <identifier> <identifiersep> network ( network . get <identifiersep> id ( ) , context , false ) ) { \n <ect>
\t2 } catch ( final <identifier> <identifiersep> api <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> , e ) ; \n \t3 return new answer ( command , false , e . to <identifiersep> string ( ) ) ; \n \t2 } catch ( final xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <string_literal> + <identifier> <identifiersep> id + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id \n \t5 + <string_literal> + e . get <identifiersep> message ( ) , context ) ; \n \t2 } finally { \n \t3 process <identifiersep> finally ( context ) ; } \n <ect>
\t2 return true ; } \n \t1 protected void run <identifiersep> <identifier> ( task <identifiersep> <identifier> task <identifiersep> <identifier> ) { \n \t2 final string <identifier> = task <identifiersep> <identifier> . <identifier> ; \n \t2 if ( ! <identifier> . <identifier> ( ) ) { \n <ect>
\t3 channel . <identifier> <identifiersep> <identifier> ( endpoint . get <identifiersep> <identifier> <identifiersep> size ( ) , endpoint . get <identifiersep> <identifier> <identifiersep> count ( ) , \n \t7 endpoint . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> result = channel . queue <identifiersep> <identifier> ( ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 user user = null ; \n \t3 <comment> \n \t3 <identifier> < user , account > user <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> account <identifiersep> <identifier> . find <identifiersep> user <identifiersep> by <identifiersep> api <identifiersep> key ( api <identifiersep> key ) ; \n \t3 if ( user <identifiersep> <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t3 <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> result result = new <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 conf = \n \t4 ( channel <identifiersep> configuration ) <identifier> <identifiersep> configuration <identifiersep> factory . create ( \n \t5 channel <identifiersep> name , config , <identifier> <identifiersep> type . channel ) ; \n <ect>
\t2 try \n \t2 { \n \t3 s = get <identifiersep> server ( <identifier> . get <identifiersep> ip <identifiersep> address ( ) , <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> password ( ) ) ; \n <ect>
\t4 synchronized ( thread <identifiersep> <identifier> ) { \n \t5 queue . put ( <identifier> <identifiersep> <identifier> ) ; \n \t5 thread <identifiersep> <identifier> . wait ( ) ; } } \n \t3 catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> entity == null ) { \n \t3 return ; <comment> \n \t2 client <identifiersep> <identifier> client <identifiersep> <identifier> = <identifier> <identifiersep> entity . get <identifiersep> <identifier> ( client <identifiersep> <identifier> . class ) ; \n \t2 if ( client <identifiersep> <identifier> == null ) { \n <ect>
\t2 add <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , failed <identifiersep> write ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . execute ( ) ; \n \t2 } catch ( connection <identifiersep> exception e ) { \n <ect>
\t2 log . debug ( <string_literal> , name ) ; } \n \t1 return <identifier> <identifiersep> <identifier> ; \n \t1 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n \t1 <comment> \n <ect>
\t4 <identifier> . <identifier> ( ) ; \n \t4 m <identifiersep> bean <identifiersep> server <identifiersep> connection connection = <identifier> . get <identifiersep> m <identifiersep> bean <identifiersep> server <identifiersep> connection ( ) ; \n \t4 set < object <identifiersep> name > <identifier> = find <identifiersep> <identifier> ( connection ) ; \n \t4 if ( <identifier> . size ( ) > 0 ) { \n <ect>
\t5 logger . debug ( <string_literal> , \n \t7 <identifier> <identifiersep> map <identifiersep> attributes . key <identifiersep> set ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> url ( ) , <identifier> . get <identifiersep> base <identifiersep> <identifier> ( ) ) ; \n \t5 logger . debug ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> url ( ) ) ; \n \t5 final <identifier> <identifiersep> password <identifiersep> policy <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = create <identifiersep> <identifier> <identifiersep> password <identifiersep> policy <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t4 file <identifiersep> system . delete ( new path ( base <identifiersep> path ) , false ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { } \n \t3 return result ; } \n \t2 catch ( exception e ) { \n <ect>
\t2 <comment> \n \t2 log log = log <identifiersep> provider . get <identifiersep> log ( get <identifiersep> class ( ) ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 assert <identifiersep> that ( log <identifiersep> provider . remove ( log <identifiersep> <identifier> ) , is ( true ) ) ; \n <ect>
\t6 <string_literal> ) ; \n \t4 return ; } \n \t3 if ( new <identifiersep> <identifier> < = 0 ) { \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> 1 , <identifier> <identifiersep> password <identifiersep> 1 ) ; \n \t3 assert . assert <identifiersep> true ( <identifier> <identifiersep> <identifier> . is <identifiersep> current ( <identifier> <identifiersep> <identifier> ) ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> password ) ; \n <ect>
\t1 try { \n \t2 log . info ( <string_literal> + storage <identifiersep> info . get <identifiersep> storage <identifiersep> info ( ) . get <identifiersep> name ( ) ) ; \n \t2 connection <identifiersep> manager . check <identifiersep> connection <identifiersep> info ( ) ; \n \t1 } catch ( connection <identifiersep> info <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t5 if ( command . is <identifiersep> <identifier> ( ) ) { \n \t6 logger . debug ( <string_literal> , this , command ) ; \n \t6 execute <identifiersep> <identifier> ( command ) ; \n \t5 } else if ( ! command . get <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> element <identifier> ; \n \t2 <identifier> <identifiersep> volume <identifiersep> vo volume = null ; \n \t2 volume = <identifier> <identifiersep> volume <identifiersep> dao . find <identifiersep> volume ( ip <identifiersep> address , <identifier> <identifiersep> name , <identifier> <identifiersep> name ) ; \n \t2 if ( volume == null ) { \n <ect>
\t1 private void <identifier> ( ) { \n \t2 if ( ! <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> set ( false , true ) ) { \n \t3 return ; } \n \t2 try { \n <ect>
\t1 @ <identifier> ( <string_literal> ) \n \t1 public string <identifier> ( @ path <identifiersep> <identifier> ( value = <string_literal> ) string in ) { \n \t2 assert . assert <identifiersep> equals ( <identifier> <identifiersep> request , in ) ; \n \t2 list < string > <identifier> = info . get <identifiersep> path <identifiersep> <identifier> ( true ) . get ( <string_literal> ) ; \n <ect>
\t3 <identifier> <identifiersep> web <identifiersep> socket <identifiersep> <identifier> . on <identifiersep> close ( close <identifiersep> <identifier> . get <identifiersep> close <identifiersep> code ( ) . get <identifiersep> code ( ) , close <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> error ( session session , throwable t ) \n \t1 { \n <ect>
\t3 <identifier> . put ( table <identifiersep> id , <identifier> <identifiersep> <identifier> ) ; } \n \t3 <identifier> <identifiersep> <identifier> . add <identifiersep> all ( <identifier> . get <identifiersep> value ( ) ) ; } \n \t2 log . error ( <string_literal> + <identifier> ) ; } \n \t2 if ( e . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . size ( ) > 0 ) { \n <ect>
\t2 log . info ( <string_literal> + <identifier> ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <identifier> . <identifier> <identifiersep> value + 1 , <identifier> ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = remote <identifiersep> resource . <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> id ( <identifier> ) ; \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 log . <identifier> ( <string_literal> ) ; \n \t2 log . <identifier> ( <string_literal> , new exception ( <string_literal> ) ) ; \n <ect>
\t7 logger . debug ( <string_literal> , device <identifiersep> token . token <identifiersep> type ) ; \n \t7 logger . debug ( <string_literal> , device <identifiersep> token . <identifier> <identifiersep> token ) ; \n \t7 logger . debug ( <string_literal> , device <identifiersep> token . <identifier> <identifiersep> in ) ; } \n \t6 break ; } \n <ect>
\t3 if ( ! <identifier> . exists ( ) ) { \n \t4 throw new build <identifiersep> exception ( <string_literal> + <identifier> , get <identifiersep> location ( ) ) ; } \n \t3 directory <identifiersep> <identifier> <identifier> = get <identifiersep> directory <identifiersep> <identifier> ( <identifier> ) ; \n \t3 string [ ] <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> files ( ) ; \n <ect>
\t6 get <identifiersep> next <identifiersep> c <identifiersep> <identifier> <identifiersep> value ( ) , request . options ) ; } \n \t4 catch ( parse <identifiersep> exception ex ) \n \t4 { \n \t5 <comment> \n <ect>
\t1 public static void <identifier> ( ) { \n \t2 logger . debug ( <string_literal> ) ; \n \t2 <identifier> . <identifier> ( <string_literal> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n <ect>
\t2 throw new timeout <identifiersep> exception ( ) ; } \n \t1 if ( <identifier> == operation . <identifier> ) { \n \t2 log . info ( <string_literal> ) ; \n \t2 cache ( 0 ) . <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifiersep> item <identifiersep> <identifier> <identifiersep> final ( <identifier> . <identifier> , false ) ; \n \t3 context <identifiersep> <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n <ect>
\t1 log . warn ( <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id + <string_literal> , <identifier> <identifiersep> ex ) ; \n \t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( \n \t2 <string_literal> + snapshot <identifiersep> id + <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id + <string_literal> , <identifier> <identifiersep> ex ) ; } \n \t1 if ( <identifier> == null ) { \n <ect>
\t3 s . close ( ) ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> <identifiersep> log . error ( <string_literal> , e ) ; } } \n \t1 private static void test <identifiersep> <identifier> <identifiersep> line ( string host , int port ) { \n <ect>
public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> logger current <identifiersep> log ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t1 metadata <identifiersep> table <identifiersep> <identifier> . remove ( current <identifiersep> log ) ; \n \t1 synchronized ( <identifier> <identifiersep> <identifier> ) { \n \t1 <identifier> <identifiersep> <identifier> . add ( current <identifiersep> log ) ; } \n <ect>
\t2 if ( connection != null ) { \n \t2 try { \n \t3 connection . close ( ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t2 this . handler = handler ; \n \t2 try { \n \t3 <identifier> <identifiersep> db = ( <identifier> <identifiersep> service ) <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . command ( <identifier> <identifiersep> <identifier> <identifiersep> command . class ) . execute ( ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t4 node <identifiersep> <identifier> . remove <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t4 store . find <identifiersep> and <identifiersep> update ( collection . nodes , <identifier> ) ; \n \t4 return false ; } } \n \t2 <comment> \n <ect>
\t2 } catch ( timeout <identifiersep> exception e ) { \n \t3 if ( server . is <identifiersep> <identifier> ( ) ) { \n \t4 logger . info ( <string_literal> + config . get <identifiersep> port ( ) ) ; \n \t3 } else { \n <ect>
@ <identifier> \n public class <identifier> <identifiersep> <identifier> extends abstract <identifiersep> <identifier> <identifiersep> <identifier> { \n \t1 private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( <identifier> <identifiersep> <identifier> . class ) ; \n \t1 protected abstract <identifiersep> <identifier> <identifiersep> endpoint do <identifiersep> create <identifiersep> endpoint ( string uri , string <identifier> , <identifier> <identifiersep> configuration config ) throws exception { \n <ect>
\t2 key first <identifiersep> key = <identifier> . get <identifiersep> first <identifiersep> key ( ) ; \n \t2 if ( first <identifiersep> key != null ) { \n \t2 map <identifiersep> files <identifiersep> info . put ( <identifier> , new file <identifiersep> info ( first <identifiersep> key , <identifier> . get <identifiersep> last <identifiersep> key ( ) ) ) ; } \n \t1 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 <string_literal> + <identifier> <identifiersep> lock <identifiersep> i <identifiersep> <identifier> + <string_literal> + max <identifiersep> <identifier> <identifiersep> time ) ; } \n \t1 log . debug ( <string_literal> ) ; \n \t1 db <identifiersep> conn . <identifier> ( ) ; } \n \t1 catch ( sql <identifiersep> exception ex ) { \n <ect>
\t3 file properties <identifiersep> file = new file ( get <identifiersep> directory ( ) , path ) ; \n \t3 out = file <identifiersep> utils . <identifier> <identifiersep> output <identifiersep> stream ( properties <identifiersep> file ) ; \n \t3 properties . store ( out , null ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . put ( <identifier> ) ; \n \t4 break ; \n \t3 case <identifier> . type : \n \t4 <identifier> <identifier> = new <identifier> ( ) . <identifier> ( <identifier> ) ; \n <ect>
\t6 <comment> \n \t6 <identifier> = <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> time <identifiersep> <identifier> ( ) / ( double ) <number_literal> ; } \n \t5 if ( input <identifiersep> stream == null ) { \n \t6 <comment> \n <ect>
\t10 <string_literal> + <identifier> ) ; } \n \t8 s <identifiersep> logger . info ( <string_literal> + wait + <string_literal> ) ; \n \t8 thread . <identifier> ( wait ) ; \n \t7 } catch ( exception e ) { \n <ect>
\t3 <identifier> . write ( line <identifiersep> <identifier> ) ; \n \t3 <identifier> . write ( line <identifiersep> <identifier> ) ; \n \t3 <comment> \n \t3 if ( <identifier> . check <identifiersep> error ( ) ) { \n <ect>
\t3 } catch ( socket <identifiersep> exception e ) { \n \t4 if ( ! <string_literal> . equals ( e . get <identifiersep> message ( ) ) ) { \n \t5 log . error ( <string_literal> , e ) ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 } catch ( exception e ) { \n \t4 if ( ! <identifier> . get <identifiersep> as <identifiersep> boolean ( <string_literal> , false ) ) { \n \t5 throw e ; \n \t4 } else { \n <ect>
\t3 <comment> \n \t3 <identifier> = <identifier> . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; \n \t3 <comment> \n \t3 <comment> \n <ect>
\t3 <comment> \n \t3 <comment> \n \t4 <identifier> . close ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 <identifier> . add ( new <identifier> <identifiersep> socket <identifiersep> channel ( this , <identifier> ) ) ; \n \t4 return 1 ; } \n \t2 } catch ( throwable t ) { \n <ect>
\t2 try { \n \t3 if ( c <identifiersep> <identifier> . instance . <identifier> ( <identifier> ) == 0 ) { \n \t4 <identifier> = new version <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> version ( ) ) ; } \n \t2 } catch ( throwable e ) { \n <ect>
\t2 load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> instance instance ; \n \t2 try { \n \t3 instance = load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> instance <identifiersep> entity <identifiersep> <identifier> . instance . <identifier> ( instance <identifiersep> <identifier> ) ; \n \t2 } catch ( final exception ex ) { \n <ect>
\t5 ) ) ; \n \t3 values <identifiersep> count <identifiersep> read <identifiersep> <identifier> <identifiersep> <identifier> += data <identifiersep> header <identifiersep> <identifier> . get <identifiersep> num <identifiersep> values ( ) ; \n \t3 break ; \n \t2 default : \n <ect>
\t2 queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifier> = ( queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean ) <identifier> . get <identifiersep> <identifier> <identifiersep> context ( ) . new <identifiersep> <identifier> <identifiersep> instance ( queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifiersep> name , queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean . class , true ) ; \n \t2 long <identifier> = <identifier> . get <identifiersep> consumer <identifiersep> count ( ) ; \n \t2 log . info ( <string_literal> + <identifier> ) ; \n \t2 long <identifier> = <identifier> . get <identifiersep> queue <identifiersep> size ( ) ; \n <ect>
\t2 logger . debug ( <string_literal> + event . get <identifiersep> metadata ( ) + <string_literal> + event . get <identifiersep> file ( ) ) ; } \n \t1 public void metadata <identifiersep> <identifier> ( <identifier> <identifiersep> event event ) { \n \t2 logger . debug ( <string_literal> + event . get <identifiersep> metadata ( ) + <string_literal> + event . get <identifiersep> file ( ) ) ; } \n \t1 public void metadata <identifiersep> <identifier> ( <identifier> <identifiersep> event event ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> next <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . next ( ) ; \n \t1 if ( next <identifiersep> <identifier> . <identifier> ( <identifier> , <identifier> ) ) { \n \t2 <identifier> <identifiersep> <identifier> = next <identifiersep> <identifier> ; } } \n \t1 if ( <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 if ( ! field <identifiersep> <identifier> . get ( set <identifiersep> <identifier> ) . equals ( set <identifiersep> <identifier> ) ) { \n \t1 throw new io <identifiersep> exception ( <string_literal> \n \t2 + field <identifiersep> <identifier> . get ( set <identifiersep> <identifier> ) ) ; \n \t1 } else { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) , task <identifiersep> manager <identifiersep> location ) ; \n \t3 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( false ) ; } \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> <identifier> . contains ( <identifier> <identifiersep> id ) || <identifier> <identifiersep> <identifier> . contains ( <identifier> <identifiersep> id ) ) { \n <ect>
\t3 for ( instance <identifiersep> listener listener : this . instance <identifiersep> <identifier> ) { \n \t4 try { \n \t5 listener . instance <identifiersep> <identifier> ( instance ) ; \n \t4 } catch ( throwable t ) { \n <ect>
\t2 log . warn ( <string_literal> ) ; \n \t2 state = <identifier> <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> <identifier> ; \n \t2 return ; } \n \t2 state = <identifier> <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> failed ; \n <ect>
\t4 builder . <identifier> ( <identifier> <identifiersep> to <identifiersep> be <identifiersep> <identifier> , e ) ; } \n \t3 return builder . build ( <identifier> <identifiersep> <identifier> <identifiersep> state ) ; } \n \t2 @ <identifier> \n \t2 public void on <identifiersep> failure ( string source , exception e ) { \n <ect>
\t6 if ( ! a <identifiersep> c . is <identifiersep> empty ( ) ) { \n \t7 <identifier> <identifiersep> <identifier> . add ( ( string ) a <identifiersep> c . get ( 1 ) ) ; } } \n \t5 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; } \n \t4 final <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 <identifier> <identifiersep> log log = new <identifier> <identifiersep> log ( <identifier> , <identifier> ) ; \n \t2 <comment> \n \t2 log . info ( <string_literal> ) ; \n \t2 log . remove ( <identifier> ) ; \n <ect>
\t5 <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> name ( <identifier> <identifiersep> client <identifiersep> port <identifiersep> address ) , <identifier> <identifiersep> client <identifiersep> port ) ; \n \t3 log . info ( <string_literal> , this . <identifier> <identifiersep> client <identifiersep> port <identifiersep> address . to <identifiersep> string ( ) ) ; \n \t2 } else { \n \t3 this . <identifier> <identifiersep> client <identifiersep> port <identifiersep> address = new <identifier> <identifiersep> socket <identifiersep> address ( <identifier> <identifiersep> client <identifiersep> port ) ; \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> info key <identifiersep> <identifier> <identifiersep> info = ( <identifier> <identifiersep> <identifier> <identifiersep> info ) <identifier> <identifiersep> info ; \n \t4 log . debug ( <string_literal> , key <identifiersep> <identifier> <identifiersep> info ) ; \n \t4 <identifier> <identifier> <identifiersep> <identifier> = key <identifiersep> <identifier> <identifiersep> info . get <identifiersep> <identifier> ( exchange ) ; \n <ect>
\t3 if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } else { \n <ect>
\t1 void do <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> ) throws exception { \n \t2 logger . info ( <string_literal> + <identifier> + <string_literal> ) ; \n \t2 response response = client . target ( <identifier> <identifiersep> url ( <string_literal> , url <identifiersep> <identifier> + <identifier> ) ) . request ( ) \n \t4 . <identifier> ( entity . entity ( <identifier> , <string_literal> ) ) ; \n <ect>
\t7 size += all <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> size ( ) ; \n \t7 send <identifiersep> <identifier> <identifiersep> info ( <identifier> <identifiersep> id , all <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , meta <identifiersep> type . <identifier> , time ) ; } \n \t6 <identifier> = <identifier> . stop ( ) ; \n \t5 } catch ( throwable ex ) { \n <ect>
\t8 attribute . id , \n \t8 <identifier> <identifiersep> <identifier> <identifiersep> utils . message <identifiersep> text <identifiersep> id + <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> msg <identifiersep> element == null ) \n \t2 { \n <ect>
\t2 assert <identifiersep> true ( <identifier> <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> , time <identifiersep> unit . <identifier> ) ; \n \t1 } finally { \n \t2 if ( ! <identifier> <identifiersep> file . delete ( ) ) { \n <ect>
\t1 private void process <identifiersep> config <identifiersep> data ( byte [ ] data ) throws exception \n \t1 { \n \t2 properties properties = new properties ( ) ; \n \t2 properties . load ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( data ) ) ; \n <ect>
\t4 <comment> \n \t4 url log <identifiersep> url = this . get <identifiersep> class ( ) . get <identifiersep> resource ( log <identifiersep> config ) ; \n \t4 if ( log <identifiersep> url != null ) { \n \t5 property <identifiersep> <identifier> . <identifier> ( log <identifiersep> url ) ; \n <ect>
\t2 @ <identifier> \n \t2 public void handle <identifiersep> <identifier> ( string consumer <identifiersep> <identifier> , <identifier> <identifier> , <identifier> . <identifier> <identifiersep> properties properties , byte [ ] body ) \n \t4 throws io <identifiersep> exception { \n <ect>
\t2 if ( success ) { \n \t3 <identifier> <identifiersep> <identifier> . add <identifiersep> event ( new timeout <identifiersep> <identifier> ( <identifier> ) , <identifier> <identifiersep> <identifier> <identifiersep> timeout ) ; \n \t2 } else { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 try { \n \t5 if ( <identifier> . size ( ) > 0 ) { \n \t6 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get ( \n \t7 r . next <identifiersep> int ( <identifier> . size ( ) ) ) ; \n <ect>
<number_literal> . find <identifiersep> by <identifiersep> short <identifiersep> <identifier> ( context , s ) ; \n \t4 if ( format != null ) { \n \t5 <identifier> <identifiersep> map . put ( format . get <identifiersep> <identifier> <identifiersep> type ( ) , <identifier> ) ; \n \t4 } else { \n <ect>
<comment> \n \t2 assert <identifiersep> <identifier> ( client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> create ( <string_literal> ) . set <identifiersep> <identifier> ( <identifier> . builder ( ) . put ( index <identifiersep> <identifier> ) \n \t4 . put ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . index <identifiersep> routing <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> key ( ) , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> . <identifier> ) ) ) ; \n \t2 client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> <identifiersep> status ( ) . set <identifiersep> timeout ( <string_literal> ) . get ( ) ; \n <ect>
\t7 assert <identifiersep> equals ( <string_literal> , <identifier> <identifiersep> message , <identifier> <identifiersep> message ) ; \n \t6 } finally { \t1 <comment> \n \t7 assert <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , <identifier> . instance . close <identifiersep> handle ( <identifier> <identifiersep> <identifier> ) ) ; } } \n \t4 } ) ; \n <ect>
\t1 try { \n \t1 this . conn = manager . get <identifiersep> connection ( ) ; \n \t1 this . conn . set <identifiersep> <identifier> <identifiersep> <identifier> ( false ) ; \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> = false ; \n \t6 return ; } } \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n \t4 if ( is <identifiersep> <identifier> ( ) ) \n <ect>
\t4 return null ; } \n \t3 test <identifiersep> <identifier> . put ( test <identifiersep> <identifier> <identifiersep> file . get <identifiersep> test <identifiersep> name ( ) , test <identifiersep> <identifier> ) ; } \n \t3 final long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - start ; \n <ect>
\t3 <identifier> ( <string_literal> ) ; } } \n \t1 public void count <identifiersep> <identifier> ( ) { \n \t2 count <identifiersep> <identifier> ( default <identifiersep> <identifier> ) ; } \n \t1 public void count <identifiersep> <identifier> ( string <identifier> ) { \n <ect>
\t4 data <identifiersep> <identifier> . store <identifiersep> <identifier> ( <identifier> , file ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> info ( ) ) \n \t5 <identifier> <identifiersep> log . info ( <string_literal> + name <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) + <string_literal> + file ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 <identifier> <identifiersep> host <identifiersep> <identifier> <identifiersep> metadata ( ) ; \n \t1 if ( cache <identifiersep> manager . is <identifiersep> <identifier> <identifiersep> mode <identifiersep> enabled ( ) ) { \n \t1 log . debug ( <string_literal> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> metadata ( ) ; \n <ect>
\t1 public static string <identifier> <identifiersep> url <identifiersep> <identifier> ( name <identifiersep> value <identifiersep> <identifier> [ ] <identifier> , string <identifier> ) { \n \t2 try { \n \t3 return do <identifiersep> <identifier> <identifiersep> url <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 list < <identifier> > <identifier> <identifiersep> list = new array <identifiersep> list < > ( ) ; \n \t3 <identifier> <identifiersep> <identifier> . get <identifiersep> queue ( ) . <identifier> <identifiersep> to ( <identifier> <identifiersep> list ) ; \n \t3 if ( ! <identifier> <identifiersep> list . is <identifiersep> empty ( ) ) { \n <ect>
\t5 <comment> \n \t4 } else if ( <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) && <identifier> . get <identifiersep> <identifier> ( ) == null ) { \n \t5 <comment> \n \t5 logger . warn ( <string_literal> ) ; \n <ect>
\t5 operation . set <identifiersep> <identifier> ( <identifier> <identifiersep> runtime . <identifier> ( client <identifiersep> context , new <identifier> <identifiersep> <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> runtime > ( ) { \n \t6 @ <identifier> \n \t6 public void <identifier> ( final <identifier> <identifiersep> <identifier> <identifiersep> runtime <identifier> <identifiersep> runtime ) { \n \t7 <identifier> . <identifier> <identifiersep> target ( <identifier> . is <identifiersep> <identifier> ( ) ) ; \n <ect>
\t5 log . debug ( <string_literal> + message . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; } \n \t3 } catch ( throwable e ) { \n <ect>
\t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 log . error ( <string_literal> + object <identifiersep> class . get <identifiersep> name ( ) , e ) ; \n \t4 return false ; \n \t3 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t5 string s = <string_literal> ; \n \t5 for ( <identifier> i : <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t6 s += <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> number ( i . name ( ) ) ; \n \t5 s += <string_literal> ; \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + network <identifiersep> id + <string_literal> ) ; \n \t3 result = false ; \n \t2 } else { \n \t3 <identifier> <identifiersep> private <identifiersep> ip <identifiersep> dao . delete <identifiersep> by <identifiersep> network <identifiersep> id ( network <identifiersep> id ) ; \n <ect>
\t2 + <string_literal> + server <identifiersep> version \n \t2 + <string_literal> + <identifier> <identifiersep> version ; \n \t1 log . warn ( error ) ; \n \t1 throw new <identifier> <identifiersep> exception ( error ) ; } \n <ect>
\t7 template . get <identifiersep> <identifier> ( ) ) ; } \n \t4 boolean data <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> result = true ; \n \t4 list < vm <identifiersep> template <identifiersep> vo > data <identifiersep> <identifier> <identifiersep> <identifier> = template <identifiersep> dao . list <identifiersep> by <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( template . get <identifiersep> id ( ) ) ; \n \t4 if ( data <identifiersep> <identifier> <identifiersep> <identifier> != null && data <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) > 0 ) { \n <ect>
\t4 out <identifiersep> <identifier> . write ( out <identifiersep> bytes ) \n \t4 out <identifiersep> <identifier> . close <identifiersep> entry ( ) } } } \n \t1 logger . info ( <string_literal> ) \n \t1 logger . info ( <string_literal> ) \n <ect>
\t3 method method = web <identifiersep> <identifier> . get <identifiersep> class ( ) . get <identifiersep> method ( <string_literal> , string . class ) ; \n \t3 object <identifier> = method . <identifier> ( web <identifiersep> <identifier> ) ; \n \t3 return ( map < string , object > ) <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 case <identifier> <identifiersep> <identifier> . no <identifiersep> <identifier> : { \n \t1 <comment> \n \t1 break ; } \n \t1 case <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> : { \n <ect>
\t2 config <identifiersep> dir = get <identifiersep> configuration <identifiersep> directory ( ) ; \n \t2 config <identifiersep> file = system . get <identifiersep> property ( <identifier> <identifiersep> config <identifiersep> file , <identifier> <identifiersep> config <identifiersep> file ) ; \n \t2 if ( config <identifiersep> file . contains ( <string_literal> ) ) { \n \t3 throw new service <identifiersep> exception ( error <identifiersep> code . <identifier> , config <identifiersep> file ) ; } \n <ect>
\t2 get <identifiersep> <identifier> <identifiersep> manager ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 <comment> \n \t2 get <identifiersep> data <identifiersep> model <identifiersep> manager ( ) . <identifier> <identifiersep> data <identifiersep> model ( model ) ; \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> ( cmd ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 throw new connection <identifiersep> exception ( true , <string_literal> , e ) ; } \n <ect>
\t2 } else if ( <identifier> instanceof status <identifiersep> task <identifiersep> <identifier> ) { \n \t3 status <identifiersep> task <identifiersep> <identifier> <identifier> = ( status <identifiersep> task <identifiersep> <identifier> ) <identifier> ; \n \t3 job = get <identifiersep> job ( <identifier> . get <identifiersep> job <identifiersep> <identifier> ( ) ) ; \n \t3 if ( job == null ) { \n <ect>
\t3 logger . info ( <string_literal> + job <identifiersep> <identifier> <identifiersep> id + <string_literal> ) ; \n \t2 } else if ( state == <string_literal> ) { \n \t3 logger . info ( <string_literal> + job <identifiersep> <identifier> <identifiersep> id + <string_literal> ) ; \n \t3 if ( <identifier> <identifiersep> state == <string_literal> ) { \n <ect>
\t2 <comment> \n \t2 return get <identifiersep> <identifier> <identifiersep> list ( builder ) ; } \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> filter ( ) throws exception { \n \t2 list < <identifier> > <identifier> = build <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> filter ( ) ; \n <ect>
public void set <identifiersep> <identifier> ( <identifier> . <identifier> . server . server <identifiersep> <identifier> value ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( value , <identifier> <identifiersep> server <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . server . server <identifiersep> <identifier> value ) { \n <ect>
\t3 if ( ! success ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 <identifier> . last <identifiersep> run ( job <identifiersep> name ) . if <identifiersep> <identifier> ( this : : <identifier> <identifiersep> if <identifiersep> failed ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> job <identifiersep> exception | no <identifiersep> such <identifiersep> job <identifiersep> execution <identifiersep> exception e ) { \n \t1 throw new runtime <identifiersep> exception ( e ) ; } \n \t1 <identifier> . <identifier> ( ( ) - > <identifier> <identifiersep> job ( job <identifiersep> name , <identifier> <identifiersep> properties . get <identifiersep> <identifier> <identifiersep> end <identifiersep> <identifier> ( ) ) , new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) ) ) ; \n <ect>
\t4 logger . debug ( <string_literal> , provider , service ) ; \n \t4 final map < string , object > attributes = build <identifiersep> event <identifiersep> attribute <identifiersep> map ( authentication . get <identifiersep> principal ( ) , service , provider ) ; \n \t4 final event event = <identifier> <identifiersep> event <identifiersep> id <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> context ( provider . get <identifiersep> id ( ) , context , attributes ) ; \n \t4 return collection <identifiersep> utils . <identifier> <identifiersep> set ( event ) ; } \n <ect>
\t6 return false ; } \n \t5 break ; \n \t4 case <identifier> : \n \t5 if ( ! m <identifiersep> <identifier> . <identifier> ( <identifier> ) . find ( ) ) { \n <ect>
\t1 if ( options . get <identifiersep> <identifier> <identifiersep> job <identifiersep> name ( ) != null ) { \n \t2 job . set <identifiersep> job <identifiersep> name ( options . get <identifiersep> <identifier> <identifiersep> job <identifiersep> name ( ) ) ; } \n \t1 <identifier> <identifiersep> options <identifiersep> to <identifiersep> job ( job ) ; \n \t1 if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> job ) { \n <ect>
\t2 try { \n \t3 class . for <identifiersep> name ( <string_literal> ) ; \n \t2 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n \t3 <comment> \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void handle <identifiersep> application <identifiersep> command <identifiersep> request ( <identifier> <identifiersep> message <identifier> <identifiersep> message , int <identifier> , int endpoint ) { \n <ect>
\t3 logger . debug ( <string_literal> <string_literal> \\ <string_literal> ) ; } \n \t2 try { \n \t3 get <identifiersep> <identifier> ( ) . set <identifiersep> <identifier> ( integer . parse <identifiersep> int ( <identifier> ) ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t1 config <identifiersep> content = <identifier> <identifiersep> template ( <identifier> # <identifier> by apache <identifier> . { { time . <identifier> ( time . <identifier> ( ) ) } } \n \t1 { <identifier> for key , value in properties <identifiersep> <identifier> | <identifier> <identifier> } \n { { key } } { { key <identifiersep> value <identifiersep> <identifier> } } { { resource <identifiersep> <identifier> . <identifier> . source . <identifier> <identifiersep> template ( <identifier> ( value ) ) . get <identifiersep> content ( ) } } { <identifier> <identifier> <identifier> } \n \t1 <identifier> , <identifier> <identifiersep> <identifier> = [ time , resource <identifiersep> <identifier> , resource <identifiersep> <identifier> . <identifier> , resource <identifiersep> <identifier> . <identifier> . source ] , properties <identifiersep> <identifier> = self . resource . properties , key <identifiersep> value <identifiersep> <identifier> = self . resource . key <identifiersep> value <identifiersep> <identifier> ) \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> output <identifiersep> stream . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , false ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . error ) ) \n <ect>
\t1 <identifier> <identifiersep> lock = true ; \n \t1 <identifier> <identifiersep> all ( ) ; } \n \t1 @ <identifier> \n \t1 public synchronized void failed <identifiersep> to <identifiersep> <identifier> <identifiersep> lock ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> public <identifiersep> <identifier> = get <identifiersep> network <identifiersep> interface ( public <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> storage <identifiersep> <identifier> = get <identifiersep> network <identifiersep> interface ( storage <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> storage <identifiersep> <identifier> = get <identifiersep> network <identifiersep> interface ( storage <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> private <identifiersep> <identifier> == null ) { \n <ect>
\t4 long wait <identifiersep> time = parse <identifiersep> wait <identifiersep> time <identifiersep> or <identifiersep> return <identifiersep> default ( m ) ; \n \t4 try { \n \t5 thread . <identifier> ( wait <identifiersep> time ) ; \n \t4 } catch ( interrupted <identifiersep> exception ex ) { \n <ect>
\t4 break ; \n \t3 case <identifier> : \n \t4 continue ; \n \t3 default : \n <ect>
\t4 <identifier> <identifiersep> set = test . get ( <identifier> , string . value <identifiersep> of ( <identifier> ) ) ; \n \t4 for ( int <identifier> = 0 ; <identifier> < num <identifiersep> <identifier> - 1 ; <identifier> ++ ) { \n \t5 <identifier> <identifiersep> set . remove ( start <identifiersep> <identifier> <identifiersep> id ++ ) ; \n \t5 test . put ( <identifier> , string . value <identifiersep> of ( <identifier> ) , <identifier> <identifiersep> set ) ; } } } \n <ect>
\t4 return null ; } \n \t3 <comment> \n \t3 if ( data <identifiersep> to <identifiersep> send != null ) { \n \t4 <comment> \n <ect>
\t1 try { \n \t1 log . info ( <string_literal> ) ; \n \t1 m <identifiersep> <identifier> <identifiersep> dao . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) ; \n \t1 } catch ( exception exception ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . build ( ) ; } \n \t3 @ <identifier> \n \t3 public void on <identifiersep> failure ( exception e ) { \n \t4 if ( e instanceof <identifier> <identifiersep> timeout <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t5 } else { \n \t6 logger . info ( <string_literal> ) ; } \n \t5 for ( map . entry < integer , store < byte <identifiersep> array , byte [ ] , byte [ ] > > entry : <identifier> <identifiersep> <identifier> . entry <identifiersep> set ( ) ) { \n \t6 in <identifiersep> <identifier> <identifiersep> put <identifiersep> <identifier> <identifiersep> storage <identifiersep> <identifier> < byte <identifiersep> array , byte [ ] , byte [ ] > <identifier> = ( in <identifiersep> <identifier> <identifiersep> put <identifiersep> <identifier> <identifiersep> storage <identifiersep> <identifier> < byte <identifiersep> array , byte [ ] , byte [ ] > ) entry . get <identifiersep> value ( ) ; \n <ect>
<comment> \n \t1 public static <identifier> <identifiersep> <identifier> create <identifiersep> <identifier> ( string <identifier> <identifiersep> name , string source <identifiersep> entity <identifiersep> name , string source <identifiersep> attribute <identifiersep> name , string destination <identifiersep> entity <identifiersep> name , string destination <identifiersep> attribute <identifiersep> name , boolean to <identifiersep> <identifier> , int delete <identifiersep> <identifier> , boolean is <identifiersep> <identifier> , boolean is <identifiersep> class <identifiersep> property , boolean should <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ) { \n \t2 <identifier> <identifiersep> entity source <identifiersep> entity = <identifier> <identifiersep> model <identifiersep> group . default <identifiersep> group ( ) . entity <identifiersep> <identifier> ( source <identifiersep> entity <identifiersep> name ) ; \n \t2 if ( source <identifiersep> entity . is <identifiersep> abstract <identifiersep> entity ( ) ) \n <ect>
\t5 + string <identifiersep> utils . default <identifiersep> if <identifiersep> blank ( ex . get <identifiersep> message ( ) , <string_literal> + e . get <identifiersep> message ( ) ) ) \n \t4 . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ; \n \t3 final map < string , list < string > > <identifier> <identifiersep> map = new <identifier> <identifiersep> map < > ( ) ; \n \t3 <identifier> <identifiersep> map . put ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 throw new <identifier> <identifiersep> store <identifiersep> exception ( ex ) ; } \n \t2 store . put ( root <identifiersep> table . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> + log <identifiersep> entry . get <identifiersep> <identifier> <identifiersep> id ( ) , value ) ; } } } \n \t1 store . remove ( root <identifiersep> table . <identifier> <identifiersep> <identifier> <identifiersep> location ) ; \n \t1 store . remove ( root <identifiersep> table . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> location ) ; \n <ect>
\t3 long store <identifiersep> <identifier> = <identifier> . get <identifiersep> store <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> instanceof <identifier> <identifiersep> store ) { \n \t4 max <identifiersep> <identifier> <identifiersep> file <identifiersep> size = ( ( <identifier> <identifiersep> store ) <identifier> ) . get <identifiersep> <identifier> <identifiersep> max <identifiersep> file <identifiersep> length ( ) ; } \n \t3 if ( store <identifiersep> <identifier> > 0 && store <identifiersep> <identifier> < max <identifiersep> <identifier> <identifiersep> file <identifiersep> size ) { \n <ect>
\t3 <string_literal> . format ( <identifier> <identifiersep> <identifier> <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> info [ <identifier> ] ) ) \n \t2 logger . info ( <identifier> <identifiersep> <identifier> <identifiersep> info ) \n \t2 return false \n \t2 if <identifier> <identifiersep> <identifier> == 0 : \n <ect>
\t4 if ( <identifier> == 0 ) \n \t5 n <identifiersep> <identifier> <identifiersep> length <identifiersep> <identifier> ++ ; \n \t4 unit <identifiersep> <identifier> += <identifier> [ i ] . get <identifiersep> <identifier> ( ) ; } \n \t3 if ( n <identifiersep> <identifier> <identifiersep> length <identifiersep> <identifier> > 0 ) { \n <ect>
\t2 if ( group <identifiersep> <identifier> . size ( ) > 0 ) \n \t2 { \n \t3 { \n <ect>
\t8 log . info ( <string_literal> + job <identifiersep> id + <string_literal> + <identifier> <identifiersep> status [ 0 ] . to <identifiersep> string ( ) \n \t10 + <string_literal> + <identifier> <identifiersep> job . get <identifiersep> status ( ) + <string_literal> ) ; \n \t8 update <identifiersep> <identifier> <identifiersep> job ( <identifier> <identifiersep> action <identifiersep> status , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> job , <identifier> <identifiersep> status [ 0 ] ) ; } \n \t7 else if ( check <identifiersep> <identifier> <identifiersep> status ( <identifier> <identifiersep> action <identifiersep> status , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> status ) ) { \n <ect>
\t2 { \n \t3 info . set <identifiersep> content ( content . get <identifiersep> bytes ( ) , <identifier> ) ; } \n \t2 catch ( parse <identifiersep> exception ex ) \n \t2 { \n <ect>
\t8 result . set <identifiersep> parse ( false ) ; \n \t8 try { \n \t9 result . execute ( <identifier> ) ; \n \t8 } catch ( exception ex ) { \n <ect>
\t1 int i = 0 ; \n \t1 path [ ] <identifier> <identifiersep> data <identifiersep> file = new path [ <number_literal> ] ; \n \t1 string [ ] test <identifiersep> files = { <string_literal> , <string_literal> } ; \n \t1 string test <identifiersep> file <identifiersep> dir = new path ( conf . get ( <string_literal> ) ) . to <identifiersep> uri ( ) . get <identifiersep> path ( ) ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 self . new <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n \t1 } ; \n \t1 this . is <identifiersep> new <identifiersep> <identifier> <identifiersep> <identifier> = function ( ) { \n \t2 if ( this . <identifier> <identifiersep> load <identifiersep> error ) { \n <ect>
\t3 private final long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 @ <identifier> \n \t3 public void <identifier> ( ) throws exception { \n \t3 if ( system . current <identifiersep> time <identifiersep> millis ( ) > <identifier> + ( vm <identifiersep> <identifier> . volatile <identifiersep> state <identifiersep> timeout <identifiersep> <identifier> * <identifier> ) ) { \n <ect>
\t3 if ( <identifier> . equals ( <identifier> ) ) { \n \t4 <comment> \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> <identifier> . contains ( local ) ) { \n <ect>
\t3 throw new <identifier> <identifiersep> delete <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> name + <string_literal> + pool <identifiersep> name \n \t4 + <string_literal> ) ; } \n \t2 return null ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 <comment> \n \t1 public void <identifier> ( ) { \n <ect>
\t4 string result = <identifier> <identifiersep> context . get <identifiersep> service <identifiersep> <identifier> ( ) . wait <identifiersep> for <identifiersep> task ( <identifier> <identifiersep> task ) ; \n \t4 if ( result . equals ( <string_literal> ) ) { \n \t5 <identifier> <identifiersep> context . wait <identifiersep> for <identifiersep> task <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> task ) ; \n \t4 } else { \n <ect>
\t4 <comment> \n \t4 files . delete ( <identifier> . get ( <identifier> ) ) ; } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t1 <comment> \n \t1 if ( null != password <identifiersep> file ) { \n \t2 if ( ! new file ( password <identifiersep> file ) . delete ( ) ) { \n \t2 log . error ( <string_literal> + password <identifiersep> file ) ; \n <ect>
\t3 cmd . add ( <string_literal> , string . value <identifiersep> of ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> update <identifiersep> <identifier> / <number_literal> ) ) ; \n \t3 output <identifiersep> <identifier> . <identifier> <identifiersep> line <identifiersep> <identifier> <identifier> = new output <identifiersep> <identifier> . <identifier> <identifiersep> line <identifiersep> <identifier> ( ) ; \n \t3 string result = cmd . execute ( <identifier> ) ; \n \t3 s <identifiersep> logger . debug ( <string_literal> + pool . <identifier> <identifiersep> pool <identifiersep> ip ) ; \n <ect>
\t2 log <identifiersep> <identifier> <identifier> = list <identifiersep> of <identifiersep> <identifier> . get ( 0 ) ; \n \t2 <comment> \n \t2 return <identifier> . get <identifiersep> log <identifiersep> id ( ) ; } } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 private <identifier> <identifiersep> client <identifier> ; \n \t1 private db <identifiersep> collection <identifier> <identifiersep> collection ; \n \t1 public void <identifier> ( final <identifier> <identifiersep> context <identifier> <identifiersep> context , final map < string , object > config ) { \n \t2 url = ( string ) config . get ( <string_literal> ) ; \n <ect>
\t2 if ( return <identifiersep> value instanceof response ) { \n \t3 return get <identifiersep> principal <identifiersep> id <identifiersep> from <identifiersep> <identifier> <identifiersep> response ( ( response ) return <identifiersep> value ) ; } \n \t2 if ( return <identifiersep> value instanceof <identifier> ) { \n \t3 return get <identifiersep> principal <identifiersep> id <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> response ( ( <identifier> ) return <identifiersep> value ) ; } \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = options . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> options . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> default ( ) ; } \n \t1 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 method method = method <identifiersep> <identifier> . get <identifiersep> class ( ) . get <identifiersep> method ( <string_literal> , string . class , string . class ) ; \n \t3 object <identifier> = method . <identifier> ( method <identifiersep> <identifier> , <identifier> , method <identifiersep> <identifier> ) ; \n \t3 return ( map < string , object > ) <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> info <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> manager . get <identifiersep> <identifier> <identifiersep> info ( <identifier> <identifiersep> name ) ; \n \t2 if ( <identifier> == null ) { \n \t3 if ( ! node . <identifier> <identifiersep> manager . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> or <identifiersep> <identifier> <identifiersep> or <identifiersep> <identifier> <identifiersep> load ( <identifier> <identifiersep> name ) ) { \n \t4 system . <identifier> . <identifier> ( <string_literal> + <identifier> <identifiersep> name ) ; \n <ect>
\t2 <comment> \n \t2 string user <identifiersep> id = <identifier> <identifiersep> user <identifiersep> id . get ( ) . to <identifiersep> string ( ) ; \n \t2 string <identifier> <identifiersep> user <identifiersep> id = url <identifiersep> <identifier> . <identifier> ( user <identifiersep> id , <string_literal> ) ; \n \t2 string url = server + <string_literal> + <identifier> <identifiersep> user <identifiersep> id ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <identifier> . execute <identifiersep> update ( <string_literal> + <identifier> <identifiersep> table <identifiersep> name ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t6 <identifier> . set <identifiersep> <identifier> ( true ) ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> group , <identifier> ) ; } } \n \t4 catch ( throwable t ) \n \t4 { \n <ect>
\t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; \n \t3 return <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . to <identifiersep> byte <identifiersep> array ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 log log = <identifier> <identifiersep> <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> context ( ) . log <identifiersep> manager ( ) . get <identifiersep> log ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ; \n <ect>
\t3 { \n \t4 if ( e instanceof object <identifiersep> check <identifiersep> exception ) \n \t4 { \n \t5 throw ( object <identifiersep> check <identifiersep> exception ) e ; } \n <ect>
\t1 <comment> \n \t1 public static void <identifier> ( string <identifier> [ ] ) { \n <ect>
# if test with <identifier> name exists , run <identifier> this test \n <identifier> <identifiersep> test = <identifier> \n for file <identifiersep> name in files <identifiersep> list : \n \t1 if file <identifiersep> name . <identifier> ( <identifier> <identifiersep> <identifier> ) and not file <identifiersep> name == <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> and file <identifiersep> name . <identifier> ( <identifier> <identifiersep> <identifier> ) : \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( throwable e ) { \n <ect>
\t2 listener . assert <identifiersep> <identifier> <identifiersep> <identifier> ( 1 ) ; \n \t2 list < message > list = listener . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 assert <identifiersep> true ( <string_literal> , ! list . is <identifiersep> empty ( ) ) ; \n \t2 message message = list . get ( 0 ) ; \n <ect>
\t4 for ( stream <identifiersep> <identifier> < ? > <identifier> : <identifier> <identifiersep> <identifier> . get <identifiersep> all <identifiersep> <identifier> ( ) ) { \n \t5 if ( <identifier> != null ) { \n \t6 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; } } } \n \t3 else { \n <ect>
\t3 <identifier> . <identifier> ( <identifier> ) ; } \n \t2 out . close ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . close ( in ) ; \n \t2 final number <identifiersep> format <identifier> = new <identifier> <identifiersep> format ( <string_literal> ) ; \n <ect>
\t6 should <identifiersep> <identifier> = true ; \n \t6 break ; } \n \t5 else if ( <identifier> <identifiersep> <identifier> . <identifier> ( r ) ) \n \t5 { \n <ect>
\t7 + <string_literal> + e . get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + e . get <identifiersep> message ( ) , e ) ; \n \t5 return result ; } } \n \t3 return result ; \n \t2 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t2 return new org . apache . thrift . <identifier> . <identifier> <identifiersep> method <identifiersep> <identifier> < void > ( ) { \n \t2 public void on <identifiersep> <identifier> ( void o ) { } \n \t2 public void on <identifiersep> error ( java . <identifier> . exception e ) { \n \t3 if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t4 try { \n \t5 transport . close ( ) ; } \n \t4 catch ( <identifier> <identifiersep> exception e ) { \n \t5 <comment> \n <ect>
\t3 } else { \n \t4 s <identifiersep> logger . warn ( <string_literal> + ip . get <identifiersep> address ( ) . <identifier> ( ) + <string_literal> + <identifier> . get <identifiersep> id ( ) + <string_literal> + network . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) ) ; } \n \t3 return ip ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 list < vm <identifiersep> template <identifiersep> vo > <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> template <identifiersep> dao . list <identifiersep> by <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( template <identifiersep> id ) ; \n \t2 for ( vm <identifiersep> template <identifiersep> vo <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t3 if ( <identifier> . get <identifiersep> format ( ) == storage . <identifier> <identifiersep> format . <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> . add ( new <identifier> <identifiersep> <identifier> <identifiersep> state ( <identifier> , 0 . 0 ) ) ; \n \t4 <identifier> ++ ; } \n \t3 if ( <identifier> . get <identifiersep> start ( ) >= start && <identifier> . get <identifiersep> end ( ) < = end ) { \n \t4 final <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n <ect>
\t2 final handle <identifiersep> <identifier> handle = new handle <identifiersep> <identifier> ( ) ; \n \t2 final boolean <identifier> <identifiersep> start = this . <identifier> . is <identifiersep> empty ( ) ; \n \t2 this . <identifier> . add ( handle ) ; \n \t2 if ( <identifier> <identifiersep> start ) { \n <ect>
\t2 double <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = index <identifiersep> <identifier> . get <identifiersep> value ( index <identifiersep> <identifier> <identifiersep> policy <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 double <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = index <identifiersep> <identifier> . get <identifiersep> value ( index <identifiersep> <identifier> <identifiersep> policy <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 this . <identifier> <identifiersep> enabled = index <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> as <identifiersep> boolean ( index <identifiersep> <identifier> <identifiersep> enabled , true ) ; \n \t2 if ( <identifier> <identifiersep> enabled == false ) { \n <ect>
\t3 <comment> \n \t3 log . debug ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } \n \t2 catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t2 int command = <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <identifier> ) ; \n \t2 switch ( command ) { \n \t3 case switch <identifiersep> <identifier> <identifiersep> set : \n \t4 logger . trace ( <string_literal> ) ; \n <ect>
\t4 boolean <identifier> <identifiersep> id <identifiersep> in <identifiersep> <identifier> <identifiersep> list = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> cluster . get <identifiersep> <identifier> <identifiersep> id ( ) ) . contains ( <identifier> <identifiersep> id ) ; \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> cluster . get <identifiersep> account <identifiersep> id ( ) != null || ( account <identifiersep> id == null && ! <identifier> <identifiersep> id <identifiersep> in <identifiersep> <identifier> <identifiersep> list ) || \n \t5 ( account <identifiersep> id != null && ! ( <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> cluster . get <identifiersep> <identifier> <identifiersep> id ( ) . equals ( <identifier> <identifiersep> id ) || <identifier> <identifiersep> id <identifiersep> in <identifiersep> <identifier> <identifiersep> list ) ) ) { \n <ect>
\t4 <identifier> <identifiersep> info <identifier> <identifiersep> info = <identifier> <identifiersep> cluster <identifiersep> state . <identifier> <identifiersep> info ( <identifier> <identifiersep> id ) ; \n \t4 if ( <identifier> <identifiersep> info == null ) { \n \t5 log . warn ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t4 } else if ( <identifier> . contains ( <identifier> <identifiersep> info . get <identifiersep> host <identifiersep> name ( ) ) ) { \n <ect>
\t5 s <identifiersep> logger . debug ( log ( <identifier> , <string_literal> ) ) ; } \n \t4 process <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t3 } catch ( throwable t ) { \n \t4 <comment> \n <ect>
\t2 <comment> \n public static class <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> action extends text <identifiersep> action { \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> action ( ) { \n \t1 super ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t4 new <identifier> <identifiersep> <identifier> <identifiersep> test ( <identifier> <identifiersep> size , total <identifiersep> <identifier> ) ; } } \n \t2 return <identifier> <identifiersep> <identifier> <identifiersep> test . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> test . class ) ; } \n \t1 @ test ( data <identifiersep> provider = <string_literal> ) \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> test test ) { \n <ect>
\t3 return ; } \n \t2 try { \n \t3 <identifier> <identifiersep> queue . put ( <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public <identifier> create <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 string <identifier> = null ; \n \t1 try { \n \t2 <identifier> = system . get <identifiersep> property ( <identifier> ) ; \n \t1 } catch ( security <identifiersep> exception <identifier> ) { \n <ect>
\t2 } ) ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 int <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> id ( ) ; \n <ect>
\t1 log . debug ( <string_literal> + <identifier> + <string_literal> + <identifier> ) ; \n \t1 base <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> list . get ( 0 ) ; \n \t1 base <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . root <identifiersep> to <identifiersep> <identifier> <identifiersep> map . get ( <identifier> ) ; \n \t1 <comment> \n <ect>
\t5 server <identifiersep> <identifier> <identifiersep> factory . <identifier> <identifiersep> connection ( <identifier> ) ; \n \t4 } else if ( <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> factory != null && <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> factory . <identifier> . contains ( <identifier> ) ) { \n \t5 <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> factory . <identifier> <identifiersep> connection ( <identifier> ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t2 string path = path ( <identifier> <identifiersep> name , store <identifiersep> name , <identifier> <identifiersep> type <identifiersep> name ) ; \n \t2 resource directory = <identifier> . get ( path ) ; \n \t2 resource resource = file <identifiersep> <identifier> ( directory , <identifier> , request ) ; \n \t2 if ( logger . is <identifiersep> <identifier> ( level . info ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> <identifiersep> name != null ? <identifier> <identifiersep> <identifier> <identifiersep> name . <identifier> ( ) : null ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> name != null && ! <identifier> <identifiersep> <identifier> <identifiersep> name . is <identifiersep> empty ( ) ) { \n \t4 <identifier> [ ] <identifier> = { new <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> name , configuration . get <identifiersep> <identifier> <identifiersep> s ( ) ) } ; \n \t4 return <identifier> ; } } \n <ect>
\t2 try { \n \t3 directory = new directory ( file <identifiersep> path ) ; \n \t3 properties . set <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> directory ( directory ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 private static string log <identifiersep> and <identifiersep> format <identifiersep> error <identifiersep> <identifier> ( throwable <identifier> ) { \n \t2 if ( ( <identifier> instanceof data <identifiersep> channel <identifiersep> error ) && ( <identifier> . get <identifiersep> <identifier> ( ) != null ) ) { \n \t3 <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; } \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 throw new <identifier> <identifiersep> exception ( <string_literal> + this . <identifier> <identifiersep> <identifier> . get <identifiersep> name ( ) , e ) ; } } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) throws <identifier> <identifiersep> exception { \n \t2 if ( <identifier> ) \n <ect>
\t4 <identifier> < long , answer > result = <identifier> <identifiersep> storage <identifiersep> <identifier> . send <identifiersep> to <identifiersep> pool ( pool , host <identifiersep> <identifier> <identifiersep> to <identifiersep> try <identifiersep> first , host <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> , cmd ) ; \n \t4 if ( result . <identifier> ( ) . get <identifiersep> result ( ) ) { \n \t5 return result . <identifier> ( ) ; } \n <ect>
\t2 response = get <identifiersep> url <identifiersep> response ( file , resource <identifiersep> id ) ; \n \t2 if ( response != null ) { \n \t2 return response ; \n \t2 } else { \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> with <identifiersep> client <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> . client <identifiersep> id ( test <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 string <identifier> <identifiersep> <identifier> <identifiersep> url = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> url ( ) ; \n <ect>
\t2 log . debug ( <string_literal> + <identifier> + <string_literal> + volume <identifiersep> id ) ; \n \t2 <identifier> <identifiersep> service . delete <identifiersep> target ( volume <identifiersep> id , <identifier> , timeout , false ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> . resource <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t2 <comment> \n <ect>
\t4 result = false ; } } \n \t2 <comment> \n \t2 final int private <identifiersep> ip <identifiersep> <identifier> <identifiersep> count = <identifier> <identifiersep> private <identifiersep> ip <identifiersep> dao . count <identifiersep> <identifier> <identifiersep> by <identifiersep> network <identifiersep> id ( network <identifiersep> id ) ; \n \t2 if ( private <identifiersep> ip <identifiersep> <identifier> <identifiersep> count > 0 ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id != null && <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> . get <identifiersep> value ( ) != null ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> . get <identifiersep> value ( ) . <identifier> <identifiersep> resource <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ) ; \n \t3 } catch ( throwable e ) { \n <ect>
\t5 object <identifiersep> input <identifiersep> stream in = new object <identifiersep> input <identifiersep> stream ( <identifier> ) ; \n \t5 try { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> cache = ( <identifier> <identifiersep> <identifier> <identifiersep> map < string , set < string > > ) in . read <identifiersep> object ( ) ; \n \t5 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
<comment> \n \t1 private boolean should <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( file file , <identifier> <identifiersep> log <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> log <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) \n \t1 { \n <ect>
\t6 . <identifier> ( <identifier> . to <identifiersep> list ( ) ) ; \n \t3 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t4 logger . info ( <string_literal> , provider . get <identifiersep> name ( ) , provider . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; \n \t4 for ( final string <identifier> : <identifier> ) { \n <ect>
\t5 throw new io <identifiersep> exception ( <string_literal> ) ; \n \t4 } else { \n \t5 <identifier> <identifiersep> <identifier> = remote <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws command <identifiersep> exception , <identifier> <identifiersep> exception { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> value ( <identifier> <identifiersep> value ) ; \n \t2 if ( <identifier> <identifiersep> job == null ) { \n <ect>
\t1 @ <identifier> \n \t1 public void event <identifiersep> <identifier> ( action action , <identifier> <identifier> ) { \n \t2 string name = get <identifiersep> name ( <identifier> ) ; \n \t2 if ( action . equals ( action . error ) ) { \n <ect>
\t3 <identifier> . put ( table <identifiersep> id , <identifier> <identifiersep> <identifier> ) ; } \n \t3 <identifier> <identifiersep> <identifier> . add <identifiersep> all ( <identifier> . get <identifiersep> value ( ) ) ; } \n \t2 log . error ( <string_literal> + <identifier> ) ; } \n \t2 if ( e . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . size ( ) > 0 ) { \n <ect>
\t6 + <string_literal> + <identifier> <identifiersep> id + <string_literal> \n \t6 + instance <identifiersep> name + <string_literal> ) ; \n \t3 } catch ( exception <identifier> ) { \n \t4 log . error ( <identifier> ) ; \n <ect>
\t5 try { \n \t6 final date current <identifiersep> <identifier> = new date ( ) ; \n \t6 <identifier> ( current <identifiersep> <identifier> ) ; \n \t5 } catch ( final throwable t ) { \n <ect>
\t2 <identifier> <identifiersep> name = create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> data <identifiersep> <identifier> . name ) ; \n \t2 } else { \n \t2 <identifier> <identifiersep> name = create <identifiersep> <identifier> <identifiersep> name ( task <identifiersep> info . <identifier> <identifiersep> <identifier> <identifiersep> id , task <identifiersep> info . <identifier> <identifiersep> <identifier> <identifiersep> host , \n \t3 task <identifiersep> info . <identifier> <identifiersep> <identifier> <identifiersep> port , task <identifiersep> info . <identifier> <identifiersep> task <identifiersep> id , <identifier> <identifiersep> data <identifiersep> <identifier> . name ) ; } \n <ect>
\t5 log . info ( <string_literal> + <identifier> . <identifier> <identifiersep> name + <string_literal> + <identifier> . destination + <string_literal> + <identifier> . <identifier> . get ( ) ) ; \n \t5 if ( <identifier> . <identifier> . get ( ) != <identifier> ) { \n \t6 log . info ( <string_literal> + <identifier> . <identifier> <identifiersep> name + <string_literal> + <identifier> . destination + <string_literal> + <identifier> . <identifier> . get ( ) + <string_literal> + <identifier> + <string_literal> + <identifier> . <identifier> ) ; \n \t6 return false ; } \n <ect>
\t2 assert <identifiersep> equals ( <string_literal> , \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> , <identifier> <identifiersep> event <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> , <identifier> <identifiersep> event <identifiersep> <identifier> . get <identifiersep> new <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 else { \n \t4 string [ ] result = null ; \n \t4 try \n \t4 { \n <ect>
\t10 log . warn ( <string_literal> , <identifier> ) ; \n \t10 on <identifiersep> <identifier> <identifiersep> error ( new exception ( <identifier> ) ) ; } } } } \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n \t6 if ( ! is <identifiersep> <identifier> ( ) || ! is <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 log . trace ( <string_literal> + <identifier> <identifiersep> or <identifiersep> uri + this <identifiersep> dir <identifiersep> log <identifiersep> <identifier> ) ; \n \t4 return null ; } \n \t2 } catch ( access <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
private volatile <identifier> <identifiersep> id <identifiersep> set user <identifiersep> i <identifiersep> <identifier> ; \n public <identifier> <identifiersep> base <identifiersep> data <identifiersep> model ( string <identifier> <identifiersep> <identifier> ) throws io <identifiersep> exception { \n \t1 this ( <identifier> <identifiersep> <identifier> , default <identifiersep> table ) ; } \n public <identifier> <identifiersep> base <identifiersep> data <identifiersep> model ( string <identifier> <identifiersep> <identifier> , string table <identifiersep> name ) throws io <identifiersep> exception { \n <ect>
\t1 if is <identifiersep> default <identifiersep> json and <identifier> <identifiersep> <identifier> : \n \t1 ( <identifier> , <identifier> , <identifier> ) = self . parse <identifiersep> host <identifiersep> data ( ) \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> count = self . parse <identifiersep> default <identifiersep> json <identifiersep> data ( <identifier> <identifiersep> json , <identifier> . <identifier> ( <string_literal> ) ) \n \t1 if <identifier> <identifiersep> <identifier> <identifiersep> count != <identifier> ( <identifier> . <identifier> ( <string_literal> ) ) : \n <ect>
\t4 long <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> first ( ) ; \n \t4 if ( p . <identifier> . get <identifiersep> <identifier> ( ) != <identifier> ) { \n \t5 <comment> \n \t5 <comment> \n <ect>
\t5 <identifier> += <identifier> <identifiersep> result . get <identifiersep> <identifier> ( ) ; \n \t5 <identifier> += <identifier> <identifiersep> result . get <identifiersep> <identifier> ( ) ; \n \t4 } <comment> \n \t3 } catch ( execution <identifiersep> exception e ) { \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> filter ( ) throws <identifier> <identifiersep> exception { \n \t2 <identifier> ( <identifier> <identifiersep> test <identifiersep> <identifier> . <identifier> <identifiersep> input <identifiersep> <identifier> + <string_literal> ) ; \n \t2 <comment> \n <ect>
\t1 public <identifier> <identifiersep> info ( ) { \n \t2 try { \n \t3 logger . info ( <string_literal> ) ; \n \t3 handle = <identifier> <identifiersep> info <identifiersep> <identifier> <identifiersep> <identifier> . instance . new ( ) ; \n <ect>
\t7 provider , address . get <identifiersep> <identifier> <identifiersep> id ( ) , address . get <identifiersep> address ( ) , address . get <identifiersep> <identifier> <identifiersep> address ( ) , true ) ) ; \n \t5 event <identifiersep> <identifier> . <identifier> <identifiersep> update ( item <identifiersep> name , \n \t7 new <identifier> <identifiersep> type ( address . <identifier> <identifiersep> value ( result , address . get <identifiersep> <identifier> <identifiersep> address ( ) ) ) ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 { \n \t3 <identifier> host <identifiersep> id = <identifier> . instance . get <identifiersep> host <identifiersep> id ( endpoint ) ; \n \t3 <identifier> <identifiersep> address <identifier> = token <identifiersep> metadata . get <identifiersep> endpoint <identifiersep> for <identifiersep> host <identifiersep> id ( host <identifiersep> id ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) && <identifier> . instance . get <identifiersep> endpoint <identifiersep> state <identifiersep> for <identifiersep> endpoint ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> address ( ) ) != null && ( host <identifiersep> id . equals ( <identifier> . instance . get <identifiersep> host <identifiersep> id ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> address ( ) ) ) ) ) \n <ect>
\t6 if ( ! file . delete ( ) ) \n \t7 logger . warn ( <string_literal> , file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; } } } \n \t3 else \n \t3 { \n <ect>
\t4 <identifier> <identifiersep> <identifier> ( ) \n \t4 <identifier> <identifiersep> <identifier> ( ) \n \t4 output <identifiersep> <identifier> ( out ) \n \t3 } catch ( e : exception ) { \n <ect>
\t2 <comment> \n \t2 assert <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( ) , <number_literal> , <number_literal> ) ; \n \t2 assert <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( ) , <number_literal> , <number_literal> ) ; \n \t2 cache <identifiersep> <identifier> ( ) ; \n <ect>
\t10 request <identifiersep> for <identifiersep> response . <identifier> <identifiersep> response ( map <identifiersep> <identifier> <identifiersep> type <identifiersep> to <identifiersep> response <identifiersep> type . <identifier> ( <identifier> <identifiersep> return <identifiersep> type ) ) ; \n \t10 <comment> \n \t10 <identifier> <identifiersep> <identifier> . add ( response <identifiersep> key ) ; \n \t9 } else { \n <ect>
\t1 private static boolean delete <identifiersep> user <identifiersep> directory <identifiersep> <identifier> ( final string user , final file directory ) { \n \t2 logger . info ( <string_literal> + directory + <string_literal> + user ) ; \n \t2 final boolean success = file <identifiersep> utils . delete <identifiersep> <identifier> ( directory ) ; \n \t2 if ( ! success ) { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> <identifier> = <identifier> \n \t4 . <identifier> <identifiersep> to ( <identifier> . class , <string_literal> 1 . 0 \\ <string_literal> <identifier> - <number_literal> \\ <string_literal> ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n <ect>
\t7 bytes <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> [ 0 ] = 0 ; } } \n \t4 } else { \n \t5 bytes <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> = answer . ip <identifiersep> bytes . get ( public <identifiersep> ip ) ; } \n \t4 if ( bytes <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> == null ) { \n <ect>
\t2 collection <identifier> = new collection ( ) ; \n \t2 for ( int i = 0 ; i < <identifier> . length ; ++ i ) { \n \t3 <identifier> . add ( <identifier> [ i ] ) ; } \n \t2 xml <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> byte <identifiersep> array <identifiersep> test ( <string_literal> , <identifier> , <identifier> , <identifier> ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . put ( <identifier> . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , <identifier> <identifiersep> time ) ; } } \n \t1 if ( ! m <identifiersep> failed <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t2 throw new <identifier> <identifiersep> failed <identifiersep> exception ( m <identifiersep> failed <identifiersep> <identifier> . size ( ) + <string_literal> ) ; } \n \t1 } catch ( throwable throwable ) { \n <ect>
\t7 i <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . add <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } } \n \t4 } else { \n \t5 logger . info ( <string_literal> ) ; } \n \t3 } catch ( xml <identifiersep> parse <identifiersep> exception | uri <identifiersep> <identifier> <identifiersep> exception | io <identifiersep> exception e ) { \n <ect>
\t3 if ( index <identifiersep> of <identifiersep> <identifier> > 0 ) { \n \t4 string first <identifiersep> <identifier> = key . <identifier> ( 0 , index <identifiersep> of <identifiersep> <identifier> ) ; \n \t4 string <identifier> <identifiersep> <identifier> = key . <identifier> ( index <identifiersep> of <identifiersep> <identifier> + 1 , key . length ( ) ) ; \n \t4 result = cache . object <identifiersep> for <identifiersep> key ( first <identifiersep> <identifier> ) ; \n <ect>
\t4 log . error ( <string_literal> ) ; } \n \t3 if ( ! config <identifiersep> dao . update ( root <identifiersep> <identifier> <identifiersep> private <identifiersep> key . key ( ) , root <identifiersep> <identifier> <identifiersep> private <identifiersep> key . <identifier> ( ) , <identifier> <identifiersep> utils . private <identifiersep> key <identifiersep> to <identifiersep> <identifier> ( key <identifiersep> <identifier> . get <identifiersep> private ( ) ) ) ) { \n \t4 log . error ( <string_literal> ) ; } \n \t2 } catch ( final no <identifiersep> such <identifiersep> provider <identifiersep> exception | no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception | io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> = new file <identifiersep> output <identifiersep> stream ( <identifier> ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n \t5 <identifier> <identifiersep> log . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t7 <identifier> object = <identifier> . get <identifiersep> object ( <identifier> <identifiersep> <identifier> , path ) ; \n \t7 file <identifiersep> utils . <identifier> <identifiersep> input <identifiersep> stream <identifiersep> to <identifiersep> file ( object . get <identifiersep> data <identifiersep> input <identifiersep> stream ( ) , \n \t9 new file ( <identifier> <identifiersep> path , local <identifiersep> file <identifiersep> name ) ) ; \n \t7 success = true ; \n <ect>
\t2 { \n \t3 <identifier> <identifiersep> user <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t3 { \n \t4 file <identifiersep> stream . close ( ) ; } \n \t3 catch ( exception e ) \n \t3 { \n <ect>
<number_literal> key . <identifier> ( ) ; \n <number_literal> break ; } } } \n \t8 state . set <identifiersep> last <identifiersep> <identifier> ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; \n \t7 } catch ( final exception e ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t1 private void create <identifiersep> port <identifiersep> <identifier> <identifiersep> <identifier> ( connection conn ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> \n \t5 + <string_literal> ) ; \n <ect>
\t1 stack <identifiersep> info stack = get <identifiersep> stack ( stack <identifiersep> name , stack <identifiersep> version ) ; \n \t1 return stack . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null ? \n \t2 <identifier> . empty <identifiersep> map ( ) : stack . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 super ( <identifier> ) ; \n \t2 this . <identifier> <identifiersep> info = <identifier> <identifiersep> info . <identifier> <identifiersep> info ( ) ; \n \t2 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( <identifier> ) ; \n <ect>
\t7 logger . warn ( <string_literal> , e . get <identifiersep> message ( ) ) ; } \n \t6 try { \n \t7 the <identifiersep> channel . channel = <identifier> <identifiersep> channel . <identifier> ( ) ; \n \t6 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 logger . error ( <string_literal> + <identifier> <identifiersep> id + <string_literal> , e ) ; \n \t3 throw new x <identifiersep> <identifier> <identifiersep> exception ( x <identifiersep> <identifier> <identifiersep> exception . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , x <identifiersep> <identifier> <identifiersep> exception . error <identifiersep> <identifier> <identifiersep> <identifier> , \n \t4 <string_literal> + <identifier> <identifiersep> id + <string_literal> , e ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 throw new runtime <identifiersep> exception ( string . format ( <string_literal> , <identifier> <identifiersep> server <identifiersep> <identifier> ) ) ; } \n \t3 boolean cache <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> = boolean . parse <identifiersep> boolean ( system . get <identifiersep> property ( <string_literal> ) ) ; \n \t3 if ( <identifier> <identifiersep> context . get <identifiersep> cache <identifiersep> <identifier> <identifiersep> info ( ) . is <identifiersep> empty ( ) && ! cache <identifiersep> server <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n <ect>
<comment> \n \t1 public void run <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> session session , <identifier> <identifiersep> status <identifier> <identifiersep> <identifier> ) { \n <ect>
<comment> \n \t1 protected static void check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> check ( command <identifiersep> line line , <identifier> <identifiersep> service <identifier> ) \n \t2 throws <identifier> <identifiersep> service <identifiersep> exception { \n \t2 if ( line . has <identifiersep> <identifier> ( <string_literal> ) ) { \n <ect>
\t6 object <identifiersep> <identifier> ( <identifier> <identifiersep> event , destination <identifiersep> type , new <identifiersep> <identifier> <identifiersep> type ) ; \n \t6 <identifier> <identifiersep> to <identifiersep> type = true ; \n \t6 break ; } } \n \t4 if ( ! <identifier> <identifiersep> to <identifiersep> type ) { \n <ect>
<number_literal> if ( <identifier> <identifiersep> options . <identifier> <identifiersep> shutdown <identifiersep> timeout <identifiersep> <identifier> != <identifier> <identifiersep> <identifier> <identifiersep> timeout <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <number_literal> <comment> \n <number_literal> <identifier> . <identifier> ( <identifier> <identifiersep> options . <identifier> <identifiersep> shutdown <identifiersep> timeout <identifiersep> <identifier> ) { \n <number_literal> <identifier> ( ) \n <ect>
\t3 } catch ( exception e ) { \n \t4 logger . error ( <string_literal> , e ) ; } \n \t3 this . <identifier> <identifiersep> <identifier> . <identifier> ( this . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; } } \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t3 return false ; } \n \t2 if ( <identifier> instanceof <identifier> <identifiersep> <identifier> ) \n \t3 return false ; \n \t2 if ( id <identifiersep> to <identifiersep> <identifier> <identifiersep> map . get ( <identifier> . get <identifiersep> id ( ) ) == null ) { \n <ect>
\t2 <comment> \n \t2 continue ; } \n \t1 collection < field <identifiersep> <identifier> > <identifier> = <identifier> . get ( entry . get <identifiersep> key ( ) ) ; \n \t1 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t1 return true ; } \n \t1 private boolean check <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , base <identifiersep> <identifier> base ) { \n \t1 for ( base <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( base ) ) { \n \t2 if ( ! <identifier> . get <identifiersep> <identifier> <identifiersep> mode ( ) ) { \n <ect>
\t2 object <identifiersep> name <identifier> = <identifier> . create <identifiersep> <identifier> <identifiersep> <identifier> ( client <identifiersep> id , <string_literal> , <identifier> <identifiersep> name , <identifier> ) ; \n \t2 <identifier> . create <identifiersep> <identifier> <identifiersep> <identifier> ( client <identifiersep> id , <string_literal> , <identifier> <identifiersep> name , <identifier> ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <number_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . length ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , <identifier> ) ; \n <ect>
\t3 string <identifier> = o . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> = o . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> . is <identifiersep> empty ( ) ) { \n \t4 if ( <identifier> != null && <identifier> != <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> job <identifiersep> result . status <identifiersep> in <identifiersep> <identifier> ) ; \n \t2 list < <identifier> <identifiersep> job <identifiersep> vo > <identifier> = list <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> by ( <identifier> ) ; \n \t2 if ( <identifier> != null && <identifier> . size ( ) > 0 ) { \n \t3 if ( <identifier> . size ( ) > 1 ) { \n <ect>
\t3 <comment> \n \t3 return null ; } \n \t2 if ( <identifier> <identifiersep> value < <identifier> <identifiersep> value || <identifier> <identifiersep> value > max <identifiersep> value ) \n \t2 { \n <ect>
\t3 logger . log ( level . <identifier> , <string_literal> , filter ) ; \n \t2 if ( logger . is <identifiersep> <identifier> ( level . info ) ) \n \t3 if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) <identifier> <number_literal> == 0 ) { \n \t4 logger . info ( <string_literal> + <identifier> <identifiersep> cache . <identifier> ( ) ) ; \n <ect>
\t2 exception <identifier> = exchange . get <identifiersep> exception ( ) ; \n \t2 if ( <identifier> != null ) { \n \t3 log . warn ( <string_literal> + exchange , <identifier> ) ; \n \t2 } else { \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> , ex ) ; } \n \t2 return null ; } \n \t1 private static string <identifier> <identifiersep> <identifier> <identifiersep> test ( string host ) { \n \t2 if ( host == null ) { \n <ect>
\t1 public static void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 string <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> property ( <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> = <identifier> != null ? <identifier> . <identifier> ( <string_literal> ) : new string [ 0 ] ; \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 <comment> \n \t2 string <identifier> <identifiersep> path = null ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n <ect>
\t3 <identifier> . get <identifiersep> config ( ) . put ( <string_literal> , <identifier> <identifiersep> provider <identifiersep> model . get <identifiersep> config ( ) != null ? <identifier> <identifiersep> provider <identifiersep> model . get <identifiersep> config ( ) . get ( <string_literal> ) : null ) ; } \n \t2 <identifier> . update <identifiersep> <identifier> <identifiersep> provider ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> provider <identifiersep> id != null && ! <identifier> <identifiersep> provider <identifiersep> id . equals ( new <identifiersep> provider <identifiersep> id ) ) { \n \t3 <comment> \n <ect>
\t3 synchronized ( listener ) { \n \t4 try { \n \t5 listener . wait ( timeout <identifiersep> in <identifiersep> <identifier> ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> policy result = <identifier> <identifiersep> <identifier> <identifiersep> service . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> policy ( this ) ; \n \t3 this . set <identifiersep> entity <identifiersep> id ( result . get <identifiersep> id ( ) ) ; \n \t2 } catch ( network <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 integer timeout = local <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> . remove ( session <identifiersep> id ) ; \n \t2 if ( timeout != null ) { \n <ect>
<comment> \n \t1 static public string get <identifiersep> <identifier> <identifiersep> code ( string <identifier> <identifiersep> code ) { \n \t2 if ( null == <identifier> <identifiersep> code ) { \n <ect>
\t1 public <identifier> <identifiersep> server <identifiersep> http <identifiersep> request <identifiersep> handler ( map < string , string > <identifier> <identifiersep> resource <identifiersep> json <identifiersep> response ) { \n \t2 this . <identifier> <identifiersep> resource <identifiersep> json <identifiersep> response = <identifier> <identifiersep> resource <identifiersep> json <identifiersep> response ; } \n \t1 @ <identifier> \n \t1 public void handle ( http <identifiersep> request request , http <identifiersep> response response , http <identifiersep> context context ) throws http <identifiersep> exception , io <identifiersep> exception { \n <ect>
\t3 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , options , <identifier> <identifiersep> context ) ; } \n \t2 client = <identifier> <identifiersep> client . get <identifiersep> instance ( ) ; \n \t2 if ( endpoint . is <identifiersep> web <identifiersep> socket ( ) ) { \n \t3 this . web <identifiersep> socket <identifiersep> handler = ( <identifier> <identifiersep> web <identifiersep> socket <identifiersep> handler ) endpoint . get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> endpoint ( endpoint . get <identifiersep> http <identifiersep> handler <identifiersep> <identifier> <identifiersep> info ( ) , endpoint . get <identifiersep> <identifier> <identifiersep> context ( ) , new <identifier> <identifiersep> web <identifiersep> socket <identifiersep> handler ( ) ) ; } \n <ect>
<comment> \n \t2 run <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t1 <identifier> . delete <identifiersep> <identifier> ( node . get <identifiersep> <identifier> <identifiersep> index ( ) ) ; \n \t1 node . set <identifiersep> <identifier> ( null ) ; } } \n void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> node <identifier> , <identifier> <identifiersep> context <identifiersep> factory <identifier> ) throws <identifier> <identifiersep> exception { \n \t1 <comment> \n <ect>
\t6 <comment> \n \t6 check <identifiersep> <identifier> <identifiersep> state ( <identifier> , <identifier> <identifiersep> <identifier> . key <identifiersep> set ( ) ) ; \n \t6 final <identifier> <identifiersep> instance instance = <identifier> . remove ( <identifier> . next <identifiersep> int ( <identifier> . size ( ) ) ) ; \n \t6 assert <identifiersep> not <identifiersep> null ( instance . <identifier> <identifiersep> dir ) ; \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> + service . get <identifiersep> name ( ) + <string_literal> + network . get <identifiersep> id ( ) ) ; \n \t3 return null ; } \n \t2 if ( <identifier> . size ( ) != 1 && service != service . <identifier> ) { \n \t3 <comment> \n <ect>
\t4 return true ; } } \n \t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( <identifier> <identifier> , <identifier> <identifier> , target <identifiersep> <identifier> target , <identifier> <identifier> ) { \n <ect>
\t1 <comment> \n \t1 <identifier> <identifiersep> node ++ ; } } \n <comment> \n private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> node <identifier> ) throws <identifier> <identifiersep> exception { \n <ect>
\t2 } catch ( io <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> file . exists ( ) ) \n \t4 <identifier> <identifiersep> log . error ( <string_literal> + <identifier> <identifiersep> file , <identifier> ) ; \n \t3 else if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t5 logger . warn ( <string_literal> , client <identifiersep> ip ) ; \n \t5 return false ; } \n \t3 } else { \n \t4 logger . info ( <string_literal> , client <identifiersep> ip ) ; } } \n <ect>
\t1 @ <identifier> \n \t1 public map < string , object > get <identifiersep> attributes <identifiersep> <identifier> ( final principal principal , final map < string , object > attributes , final registered <identifiersep> service service ) { \n \t2 final application <identifiersep> context application <identifiersep> context = application <identifiersep> context <identifiersep> provider . get <identifiersep> application <identifiersep> context ( ) ; \n \t2 if ( application <identifiersep> context == null ) { \n <ect>
\t1 log . error ( <string_literal> + <identifier> , e ) ; \n \t1 } catch ( exception e ) { \n \t1 final <identifier> error = new <identifier> <identifiersep> <identifier> ( <string_literal> , e . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t1 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> id . with <identifiersep> <identifier> <identifiersep> <identifier> ( error ) ) ; \n <ect>
\t5 store . close ( ) ; \n \t4 } catch ( exception e ) { \n \t5 exception <identifiersep> count ++ ; \n \t5 log . debug ( <string_literal> , e ) ; \n <ect>
<comment> \n \t1 public void handle <identifiersep> <identifier> <identifiersep> <identifier> ( string consumer <identifiersep> <identifier> ) { \n \t2 <comment> \n <ect>
\t6 if ( meta <identifiersep> data . has <identifiersep> index <identifiersep> meta <identifiersep> data ( index <identifiersep> meta <identifiersep> data ) == false ) { \n \t7 meta <identifiersep> state <identifiersep> service . write <identifiersep> index ( <string_literal> , index <identifiersep> meta <identifiersep> data ) ; } } } \n \t4 long start <identifiersep> <identifier> = system . <identifier> <identifiersep> time ( ) ; \n \t4 meta <identifiersep> state <identifiersep> service . load <identifiersep> <identifier> <identifiersep> state ( ) ; \n <ect>
\t3 format <identifiersep> info info = null ; \n \t3 try { \n \t4 info = <identifier> . process ( resource <identifiersep> path , null , template <identifiersep> name , process <identifiersep> timeout * <number_literal> ) ; \n \t3 } catch ( <identifier> <identifiersep> error <identifiersep> exception e ) { \n <ect>
\t3 for ( final string key : <identifier> <identifiersep> to <identifiersep> <identifier> . key <identifiersep> set ( ) ) { \n \t4 <identifier> <identifiersep> to <identifiersep> <identifier> . get ( key ) . <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) . get ( key ) ) ; } \n \t3 no <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> . get <identifiersep> no <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t3 if ( <identifier> . get <identifiersep> exception ( ) != null ) { \n <ect>
\t3 new <identifiersep> template . set <identifiersep> name ( template <identifiersep> <identifier> ) ; \n \t3 result = true ; \n \t3 return new <identifier> <identifiersep> cmd <identifiersep> answer ( new <identifiersep> template ) ; \n \t2 } catch ( final <identifier> <identifiersep> server <identifiersep> response e ) { \n <ect>
\t2 synchronized ( s <identifiersep> <identifier> ) { \n \t3 if ( ! s <identifiersep> <identifier> ) { \n \t4 file file = properties <identifiersep> <identifier> . find <identifiersep> config <identifiersep> file ( <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t4 if ( file != null ) { \n <ect>
\t3 return false ; } \n \t2 final string client <identifiersep> id = context . get <identifiersep> request <identifiersep> <identifier> ( o <identifiersep> <identifier> . client <identifiersep> id ) ; \n \t2 final o <identifiersep> <identifier> <identifiersep> registered <identifiersep> service registered <identifiersep> service = get <identifiersep> registered <identifiersep> service <identifiersep> by <identifiersep> client <identifiersep> id ( client <identifiersep> id ) ; \n \t2 if ( ! <identifier> . check <identifiersep> service <identifiersep> <identifier> ( registered <identifiersep> service ) ) { \n <ect>
\t1 files . <identifier> ( new file ( <identifier> <identifiersep> test <identifiersep> utils . get <identifiersep> file <identifiersep> from <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> name ) ) , <identifier> ) ; \n \t1 <identifier> . load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 assert . assert <identifiersep> equals ( <string_literal> , get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> version ( <identifier> . get <identifiersep> conf ( ) . get <identifiersep> class <identifiersep> <identifier> ( ) ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 try { \n \t1 this . close ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> cache . put ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; } } \n \t1 return <identifier> <identifiersep> <identifier> ; } \n private static <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 @ <identifier> <identifiersep> on <identifiersep> <identifier> <identifiersep> bean ( name = <string_literal> ) \n \t1 @ bean \n \t1 public authentication <identifiersep> event <identifiersep> execution <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> authentication <identifiersep> event <identifiersep> execution <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 return <identifier> - > <identifier> <identifiersep> authentication <identifiersep> <identifier> ( ) . for <identifiersep> <identifier> ( handler - > { \n <ect>
\t4 out <identifiersep> <identifier> . put <identifiersep> next <identifiersep> entry ( entry ) \n \t4 out <identifiersep> <identifier> . write ( out <identifiersep> bytes ) \n \t4 out <identifiersep> <identifier> . close <identifiersep> entry ( ) } } } \n \t1 logger . info ( <string_literal> ) \n <ect>
\t2 assert <identifiersep> equals ( <string_literal> , body ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size ( ) throws exception { \n \t2 <identifier> ( <identifier> <identifiersep> test <identifiersep> <identifier> . <identifier> <identifiersep> input <identifiersep> <identifier> + <string_literal> ) ; \n <ect>
\t3 return new <identifier> <identifiersep> access <identifiersep> authentication <identifiersep> answer ( cmd , false ) ; } \n \t2 try { \n \t3 vm <identifiersep> id = long . parse <identifiersep> long ( cmd . get <identifiersep> vm <identifiersep> id ( ) ) ; \n \t2 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t6 log . error ( <string_literal> , e ) ; } \n \t5 try { \n \t6 metadata <identifiersep> resource . set <identifiersep> <identifier> ( true , <identifier> <identifiersep> <identifier> . new <identifiersep> <identifier> ( 1 ) ) ; } \n \t5 catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 logger . debug ( <string_literal> , port <identifiersep> string ) ; \n \t3 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( port <identifiersep> string ) ) { \n \t4 port = port <identifiersep> string ; \n \t3 } else { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 if ( <identifier> . get <identifiersep> <identifier> ( ) != null ) { \n \t3 <identifier> <identifiersep> to [ ] <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t3 return create <identifiersep> <identifier> ( vm , <identifier> ) ; \n \t2 } else { \n <ect>
\t1 for ( output output : <identifier> ) { \n \t2 if ( ! output . is <identifiersep> <identifier> ( ) ) { \n \t2 try { \n \t3 all <identifiersep> <identifier> = false ; \n <ect>
\t4 if ( configuration . is <identifiersep> <identifier> ( ) ) { \n \t5 this . logger . info ( log <identifiersep> <identifier> , <string_literal> , \n \t6 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> ( ) ) ; } } \n \t2 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 final string <identifier> \t3 = this <identifiersep> user . get <identifiersep> <identifier> <identifiersep> name ( ) ; \n \t2 if ( <identifier> <identifiersep> service != null ) { \n \t3 system . out . <identifier> ( <identifier> <identifiersep> service . <identifier> <identifiersep> object <identifiersep> info ( <identifier> ) ) ; \n \t2 } else { \n <ect>
\t3 log . info ( <string_literal> , node <identifiersep> state <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 file <identifiersep> utils . <identifier> <identifiersep> delete ( node <identifiersep> state <identifiersep> file ) ; } \n \t2 <identifier> <identifier> = <identifier> . create <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> files ( <identifier> , <identifier> , <identifier> , <identifier> <identifiersep> files ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 protected void execute ( ) { \n \t2 <comment> \n <ect>
\t2 private final <identifier> < entry < db <identifiersep> key , v > > <identifier> ; \n \t2 private final db <identifiersep> key to ; \n \t2 private entry < db <identifiersep> key , v > next ; \n \t2 private <identifier> ( db <identifiersep> key start , db <identifiersep> key to ) { \n <ect>
\t2 try ( <identifier> <identifiersep> <identifier> update <identifiersep> <identifier> <identifiersep> <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; ) { \n \t3 update <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> long ( 1 , <identifier> <identifiersep> network <identifiersep> id ) ; \n \t3 update <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> long ( <number_literal> , ( long ) <identifier> [ 0 ] ) ; \n \t3 update <identifiersep> <identifier> <identifiersep> <identifier> . execute <identifiersep> update ( ) ; } \n <ect>
\t2 long start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 for ( <identifier> <identifiersep> service service : <identifier> ) { \n \t3 service . start ( ) ; } \n \t2 long end = system . current <identifiersep> time <identifiersep> millis ( ) ; \n <ect>
\t2 final type <identifiersep> <identifier> < integer > key <identifiersep> <identifier> = new int <identifiersep> <identifier> ( true ) ; \n \t2 <comment> \n \t2 test <identifiersep> data . <identifier> <identifiersep> <identifier> < <identifier> < integer , string > > <identifier> = test <identifiersep> data . get <identifiersep> int <identifiersep> string <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n <ect>
\t3 if ( file . exists ( ) ) { \n \t4 try { \n \t5 java . <identifier> . <identifier> . get <identifiersep> <identifier> ( ) . <identifier> ( file ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 if ( ! <identifier> . check ( <identifier> ) ) { \n \t4 logger . debug ( <string_literal> , \n \t6 <identifier> . get <identifiersep> <identifier> ( ) , <identifier> ) ; \n \t4 return false ; } } \n <ect>
\t3 for ( process <identifier> : <identifier> <identifiersep> server <identifiersep> <identifier> ) { \n \t3 try { \n \t4 cluster . stop <identifiersep> process <identifiersep> with <identifiersep> timeout ( <identifier> , <number_literal> , time <identifiersep> unit . <identifier> ) ; \n \t3 } catch ( execution <identifiersep> exception | timeout <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> queue . create ( user , <identifier> ) ; \n \t3 } else { \n \t4 logger . error ( <string_literal> ) ; } \n \t2 } else { \n <ect>
\t5 @ <identifier> \n \t5 public boolean run ( client <identifiersep> context context ) { \n \t6 client <identifiersep> request <identifier> = handler . get <identifiersep> <identifier> <identifiersep> request ( <identifier> , handler , <identifier> ) ; \n \t6 if ( <identifier> == null ) { \n <ect>
\t5 <comment> \n \t5 ( ( abstract <identifiersep> <identifier> <identifiersep> channel ) a ) . <identifier> <identifiersep> key = new <identifiersep> key ; } \n \t4 n <identifiersep> <identifier> ++ ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 try { \n \t2 cluster cluster = <identifier> <identifiersep> provider . get ( ) . get <identifiersep> cluster <identifiersep> by <identifiersep> id ( cluster <identifiersep> id ) ; \n \t2 set <identifiersep> resource <identifiersep> property ( resource , <identifier> <identifiersep> cluster <identifiersep> name , cluster . get <identifiersep> cluster <identifiersep> name ( ) , <identifier> <identifiersep> <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 <identifier> . get ( <string_literal> ) . set ( <string_literal> ) ; \n \t3 <identifier> . get ( <string_literal> ) . set ( <string_literal> + <identifier> <identifiersep> password <identifiersep> string + <string_literal> ) ; \n \t3 <identifier> . get ( operation <identifiersep> <identifier> ) . get ( <identifier> <identifiersep> resource <identifiersep> service <identifiersep> <identifier> ) . set ( true ) ; \n \t3 <identifier> <identifiersep> client . get <identifiersep> <identifier> <identifiersep> client ( ) . execute ( new operation <identifiersep> builder ( <identifier> ) . build ( ) ) ; \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> to <identifiersep> <identifier> = <identifier> . remove <identifiersep> first ( ) ; \n \t4 <identifier> <identifiersep> to <identifiersep> <identifier> . <identifier> <identifiersep> on <identifiersep> <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 this . id = <identifier> . get <identifiersep> id ( ) ; } \n \t1 @ test ( <identifier> = <string_literal> , enabled = false , <identifier> <identifiersep> on <identifiersep> <identifier> = { <string_literal> } ) \n \t1 public void test <identifiersep> get <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 <identifier> <identifier> = <identifier> . get ( test <identifiersep> <identifier> . <identifier> <identifiersep> context , this . id ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 } else if ( message . get <identifiersep> body ( ) == null ) { \n \t4 properties = endpoint . get <identifiersep> message <identifiersep> <identifier> ( ) . build <identifiersep> properties ( <identifier> <identifiersep> exchange ) . build ( ) ; \n \t4 body = null ; \n \t3 } else { \n <ect>
\t1 <identifier> . <identifier> <identifiersep> bytes ( length / <number_literal> / <number_literal> ) ; \n \t1 return <identifier> ; } \n @ <identifier> \n public void set <identifiersep> <identifier> <identifiersep> filter ( <identifier> <identifier> ) throws io <identifiersep> exception { \n <ect>
\t3 port = <identifier> <identifiersep> e <identifiersep> port ; \n \t2 if ( ! <identifier> <identifiersep> to <identifiersep> <identifier> . is <identifiersep> empty ( ) && <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n \t3 <identifier> <identifiersep> log . warn ( <string_literal> + <identifier> <identifiersep> to <identifiersep> <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t4 network <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = create <identifiersep> <identifier> ( <identifier> <identifiersep> host , <identifier> <identifiersep> port ) ; \n \t4 <identifier> <identifiersep> properties . put ( <string_literal> , <identifier> . get <identifiersep> local <identifiersep> port ( ) ) ; } \n \t3 <comment> \n \t3 if ( config . is <identifiersep> <identifier> <identifiersep> mode ( ) ) { \n <ect>
\t2 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> ) <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 wait . wait <identifiersep> for ( new wait . <identifier> ( ) { \n \t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n <ect>
<comment> \n \t1 private void <identifier> ( <identifier> <identifiersep> info <identifier> ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 return null ; } \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n \t3 log . warn ( <string_literal> + <identifier> + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> url ( ) ) ; \n \t3 return null ; } \n <ect>
\t2 string . format ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) . to <identifiersep> string ( ) , job . get <identifiersep> id ( ) ) ) ; \n \t1 json <identifiersep> object job <identifiersep> object = json <identifiersep> object <identifiersep> from <identifiersep> job ( <identifier> <identifiersep> job <identifiersep> <identifier> ) ; \n \t1 return response . <identifier> ( job <identifiersep> object ) . status ( <number_literal> ) . build ( ) ; \n \t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n <ect>
\t4 try { \n \t5 close <identifiersep> client <identifiersep> socket ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t6 int <identifier> = <identifier> <identifier> <identifier> <identifiersep> <identifier> ; \n \t6 data [ 0 ] [ x * <identifier> + <identifier> ] = <identifier> <identifiersep> data [ <identifier> + <identifier> ] ; } } } \n \t2 } else { \n \t3 <comment> \n <ect>
\t5 s <identifiersep> logger . info ( <string_literal> ) ; \n \t4 } catch ( exception ex ) { \n \t5 s <identifiersep> logger . error ( <string_literal> + ex ) ; } \n \t4 if ( conn == null ) { \n <ect>
\t7 ++ <identifier> <identifiersep> message <identifiersep> set <identifiersep> count ; \n \t6 } else if ( builder . size ( ) == 0 ) { \n \t7 thread . <identifier> ( config . get <identifiersep> <identifier> <identifiersep> timeout ( ) ) ; } \n \t5 } catch ( exception e ) { \n <ect>
\t1 self ( ) . <identifier> ( new execute <identifiersep> next <identifiersep> <identifier> ( ) , self ( ) ) ; } } \n private void process <identifiersep> <identifier> ( ) { \n \t1 <identifier> = false ; \n \t1 if ( is <identifiersep> <identifier> ( ) && job <identifiersep> id . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 map < string , host > host <identifiersep> <identifier> = <identifier> . new <identifiersep> <identifier> <identifiersep> map ( host <identifiersep> map ) ; \n \t1 set < address > current <identifiersep> <identifier> = <identifier> . new <identifiersep> <identifier> <identifiersep> set ( <identifier> . <identifier> ( host <identifiersep> <identifier> . values ( ) , group <identifiersep> address <identifiersep> <identifier> . instance ) ) ; \n \t1 set < address > <identifier> <identifiersep> <identifier> = <identifier> . <identifier> ( current <identifiersep> <identifier> , current <identifiersep> <identifier> ) ; \n \t1 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t4 + <string_literal> ) ; \n \t2 break ; } \n \t1 if ( <identifier> <identifiersep> time <identifiersep> millis - this . last <identifiersep> <identifier> <identifiersep> millis > <identifier> <identifiersep> <identifier> ) { \n \t2 <comment> \n <ect>
\t2 try { \n \t3 <comment> \n \t3 s <identifiersep> logger . debug ( <string_literal> + network + <string_literal> ) ; \n \t3 if ( ! <identifier> <identifiersep> network <identifiersep> <identifier> ( network . get <identifiersep> id ( ) , <identifier> <identifiersep> context . current ( ) . get <identifiersep> <identifier> <identifiersep> account ( ) , network ) ) { \n <ect>
\t3 log . warn ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t3 return ; } \n \t2 element <identifier> <identifiersep> element = ( element ) nodes . item ( 0 ) ; \n \t2 if ( <identifier> <identifiersep> element == null ) { \n <ect>
\t6 thread . <identifier> ( <number_literal> * <number_literal> ) ; \n \t6 log . info ( <string_literal> ) ; \n \t6 <identifier> . <identifier> ( ) ; \n \t5 } catch ( interrupted <identifiersep> exception x ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t5 if ( <identifier> == null || <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t6 logger . warn ( <string_literal> , <identifier> ) ; \n \t6 return null ; } \n \t5 if ( <identifier> . get <identifiersep> security <identifiersep> token ( ) . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 final result < <identifier> <identifiersep> method > delete <identifiersep> result = request <identifiersep> body ( \n \t3 <string_literal> , <identifier> <identifiersep> method . get <identifiersep> token ( ) , result . class ) ; \n \t2 assert <identifiersep> not <identifiersep> null ( <string_literal> , delete <identifiersep> result ) ; \n \t2 assert <identifiersep> true ( delete <identifiersep> result . is <identifiersep> success ( ) ) ; \n <ect>
\t4 int port = local <identifiersep> address . get <identifiersep> port ( ) ; \n \t4 if ( host . contains ( <string_literal> ) ) \n \t4 { \n \t5 <comment> \n <ect>
\t2 final <identifier> <identifiersep> id <identifiersep> p <identifiersep> properties <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 final <identifier> <identifiersep> id <identifiersep> p <identifiersep> response <identifiersep> properties . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> type = <identifier> <identifiersep> id <identifiersep> p <identifiersep> response <identifiersep> properties . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . value <identifiersep> of ( \n \t4 string <identifiersep> utils . default <identifiersep> if <identifiersep> blank ( service . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type ( ) , <identifier> <identifiersep> <identifier> . get <identifiersep> response ( ) . get <identifiersep> <identifier> <identifiersep> type ( ) . name ( ) ) . to <identifiersep> <identifier> <identifiersep> case ( ) ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void filter ( <identifier> <identifiersep> request <identifiersep> context request <identifiersep> context ) throws io <identifiersep> exception { \n \t2 string request <identifiersep> uri = request <identifiersep> context . get <identifiersep> uri <identifiersep> info ( ) . get <identifiersep> request <identifiersep> uri ( ) . to <identifiersep> string ( ) ; \n \t2 if ( info <identifiersep> level ) { \n <ect>
\t4 grid <identifiersep> cache <identifiersep> version from = <identifier> . <identifier> <identifiersep> version ( ) ; \n \t4 if ( from != null ) \n \t5 <identifier> <identifiersep> <identifier> . put ( from , <identifier> . <identifier> <identifiersep> version ( ) ) ; \n <ect>
\t5 text <identifiersep> mode <identifiersep> client <identifiersep> interface <identifier> = \n \t5 new text <identifiersep> mode <identifiersep> client <identifiersep> interface ( this , in , out ) ; \n \t5 n . <identifier> . execute ( <identifier> , <string_literal> + s . get <identifiersep> port ( ) ) ; \n \t4 } catch ( socket <identifiersep> exception e ) { \n <ect>
\t9 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> file ( ) ; \n \t8 } catch ( exception e ) { \n \t9 log . warn ( <string_literal> + <identifier> <identifiersep> file + <string_literal> , e ) ; } \n \t7 } catch ( exception e ) { \n <ect>
\t1 protected path get <identifiersep> key <identifiersep> dir ( string key ) { \n \t2 string <identifier> = string . value <identifiersep> of ( <identifier> . <identifier> ( ( long ) key . <identifier> <identifiersep> code ( ) ) <identifier> <identifier> ) ; \n \t2 path <identifier> <identifiersep> dir = new path ( <identifier> <identifiersep> <identifier> <identifiersep> path , <identifier> ) ; \n \t2 path <identifier> = new path ( <identifier> <identifiersep> dir , key ) ; \n <ect>
\t1 for <identifier> <identifiersep> <identifier> in <identifier> <identifiersep> <identifier> : \n \t1 logger . info ( <string_literal> . format ( <identifier> <identifiersep> <identifier> [ 0 ] ) ) \n if <identifier> . <identifier> <identifiersep> id == <identifier> <identifiersep> <identifier> <identifiersep> id and <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> id == <identifier> <identifiersep> <identifier> <identifiersep> id : \n \t1 # <identifier> if this name <identifiersep> node is <identifier> and <identifier> name <identifiersep> node is <identifier> and in <identifier> ( i . e . <identifier> to <identifier> <identifier> on <identifier> ) \n <ect>
\t1 if ( output != null ) { \n \t2 try { \n \t2 output . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 final int final <identifiersep> version <identifiersep> for <identifiersep> <identifier> = index <identifiersep> <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( index , <number_literal> , n <identifiersep> <identifier> ) ; \n \t3 assert <identifiersep> <identifier> ( client ( ) . <identifier> <identifiersep> request ( <string_literal> , index + <string_literal> ) ) ; \n \t3 shards = build <identifiersep> shards ( index , nodes , new <identifiersep> node <identifiersep> client ) ; \n \t3 <identifier> = shards . stream ( ) . filter ( <identifier> : : is <identifiersep> <identifier> ) . find <identifiersep> first ( ) . get ( ) ; \n <ect>
\t5 if ( <identifier> <identifiersep> state <identifiersep> <identifier> ( ) != <identifier> ) \n \t6 return ; \n \t5 if ( msg . status ( ) == status <identifiersep> <identifier> ) { \n <ect>
\t1 private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( test <identifiersep> <identifier> <identifiersep> bean . class ) ; \n \t1 private <identifier> <identifiersep> integer <identifier> = new <identifier> <identifiersep> integer ( ) ; \n \t1 public int get <identifiersep> count ( ) \n \t1 { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . add ( <identifier> ) ; \n \t3 <identifier> . set <identifiersep> <identifier> ( true ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 case transaction <identifiersep> <identifier> : \n \t4 <identifier> <identifiersep> status = state . <identifier> ; \n \t4 if ( event . has <identifiersep> event <identifiersep> value ( ) ) { \n \t5 state = ( transaction <identifiersep> state ) event . get <identifiersep> event <identifiersep> value ( ) . get ( 0 ) ; } \n <ect>
\t2 <comment> \n \t2 assert <identifiersep> that ( wait <identifiersep> for <identifiersep> index ( <string_literal> , time <identifiersep> value . time <identifiersep> value <identifiersep> <identifier> ( <number_literal> ) ) , equal <identifiersep> to ( true ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 cluster ( ) . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t4 } catch ( io <identifiersep> exception <identifier> ) { \n \t5 <identifier> . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; } \n \t3 } ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 try ( <identifier> <identifiersep> output <identifiersep> stream <identifier> = new <identifier> <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( <identifier> <identifiersep> log <identifiersep> file ) ) ) { \n \t4 for ( map . entry < file , <identifier> <identifiersep> check <identifiersep> <identifier> > item : <identifier> . entry <identifiersep> set ( ) ) { \n \t5 if ( item . get <identifiersep> value ( ) . is <identifiersep> <identifier> ( ) ) { \n \t6 file file = item . get <identifiersep> key ( ) ; \n <ect>
\t4 . <identifier> ( <identifier> . to <identifiersep> set ( ) ) ; \n \t2 logger . info ( <string_literal> , <identifier> . size ( ) ) ; \n \t2 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t3 <identifier> . for <identifiersep> <identifier> ( entry - > storage . <identifier> ( entry . get <identifiersep> <identifier> <identifiersep> key ( ) ) ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t8 log . trace ( <string_literal> , read <identifiersep> byte ) ; \n \t8 switch ( read <identifiersep> byte ) { \n \t8 case - 1 : \n \t9 if ( <identifier> <identifiersep> socket . is <identifiersep> <identifier> ( ) && ! <identifier> <identifiersep> socket . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 else { \n \t4 local <identifiersep> <identifier> . add ( method ) ; } } \n \t2 for ( <identifier> < ? > <identifier> : <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 if ( local <identifiersep> <identifier> . contains ( <identifier> ) ) { \n <ect>
\t6 for ( <identifier> <identifiersep> action action : <identifier> . <identifier> . values ( ) ) { \n \t7 this . logger . debug ( string . format ( <string_literal> , action . name , action . <identifier> , \n \t9 action . <identifier> != null ? action . <identifier> : <string_literal> ) ) ; } } } \n \t3 } catch ( no <identifiersep> device <identifiersep> exception e ) { \n <ect>
\t2 server <identifiersep> socket socket = server <identifiersep> socket <identifiersep> factory . get <identifiersep> default ( ) . create <identifiersep> server <identifiersep> socket ( ) ; \n \t2 socket . set <identifiersep> <identifier> <identifiersep> address ( true ) ; \n \t2 <identifier> <identifiersep> address address = <identifier> <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) ; \n \t2 socket . <identifier> ( new <identifier> <identifiersep> socket <identifiersep> address ( address , <identifier> <identifiersep> port ) ) ; \n <ect>
\t5 cache <identifiersep> item = <identifier> [ index ] ; } \n \t4 if ( ! <identifier> || ! cache <identifiersep> item ) { \n \t5 <comment> \n \t5 return false ; } \n <ect>
<comment> \n \t4 try { \n \t5 if ( this . server <identifiersep> socket == null ) { \n <ect>
\t1 if ( <identifier> . has <identifiersep> list ( <identifier> ) ) { \n \t1 <comment> \n \t1 return write <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> read <identifiersep> <identifier> ( ) ; <comment> \n \t1 long first <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t4 <identifier> <identifiersep> log <identifiersep> level ( ( logger ) e . next <identifiersep> element ( ) , <identifier> <identifiersep> <identifier> <identifiersep> configuration ) ; } \n \t3 log . info ( <string_literal> ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { <comment> \n \t3 log . error ( ex ) ; \n <ect>
\t2 logger . info ( <string_literal> , number <identifiersep> of <identifiersep> shards ) ; \n \t2 data <identifiersep> node <identifiersep> client ( ) . <identifier> ( ) . cluster ( ) . <identifier> <identifiersep> create <identifiersep> snapshot ( <string_literal> , <string_literal> ) . set <identifiersep> wait <identifiersep> for <identifiersep> <identifier> ( false ) . set <identifiersep> <identifier> ( <string_literal> ) . get ( ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> cluster ( ) . stop <identifiersep> current <identifiersep> <identifier> <identifiersep> node ( ) ; \n <ect>
\t5 throw new cmd <identifiersep> exception ( <identifier> <identifiersep> port . get <identifiersep> key <identifiersep> name ( ) + <string_literal> + port <identifiersep> <identifier> ) ; } } \n \t3 if ( contains ( <identifier> <identifiersep> <identifier> ) ) \n \t4 <identifier> . config <identifiersep> log . warn ( <string_literal> ) ; \n \t3 if ( contains ( <identifier> <identifiersep> <identifier> <identifiersep> port ) ) \n <ect>
\t4 handle . <identifier> <identifiersep> filter ( name , this ) ; \n \t4 <comment> \n \t4 <identifier> . <identifier> ( ) ; \n \t4 handle . <identifier> <identifiersep> filter ( name , this ) ; \n <ect>
\t8 s <identifiersep> logger . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <string_literal> + i + <string_literal> + \n \t10 e . get <identifiersep> message ( ) ) ; } } } } \n \t3 } catch ( final throwable e ) { \n <ect>
\t6 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n \t7 throw new illegal <identifiersep> argument <identifiersep> exception ( e ) ; } } \n \t4 } ; \n \t3 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n <ect>
\t2 <identifier> . <identifier> ( ) . remove ( this ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> success ( ) ; } \n \t2 else \n \t2 { \n <ect>
\t1 public set < event > <identifier> <identifiersep> <identifier> ( final request <identifiersep> context context ) { \n \t2 final registered <identifiersep> service service = <identifier> <identifiersep> registered <identifiersep> service <identifiersep> in <identifiersep> request <identifiersep> context ( context ) ; \n \t2 final authentication authentication = web <identifiersep> utils . get <identifiersep> authentication ( context ) ; \n \t2 if ( service == null || authentication == null ) { \n <ect>
\t2 list < exchange > list = a . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 assert <identifiersep> true ( <string_literal> , ! list . is <identifiersep> empty ( ) ) ; \n \t2 exchange exchange = list . get ( 0 ) ; \n \t2 message in = exchange . get <identifiersep> in ( ) ; \n <ect>
\t4 input <identifiersep> stream <identifier> = process . get <identifiersep> error <identifiersep> stream ( ) ; \n \t4 synchronized ( <identifier> ) { \n \t5 <identifier> <identifiersep> <identifier> . close ( ) ; } \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 } else if ( <identifier> <identifiersep> type == <identifier> <identifiersep> network <identifiersep> <identifier> ) { \n \t4 break ; \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t5 try { \n \t6 int id = integer . parse <identifiersep> int ( key . <identifier> ( <number_literal> ) ) ; \n \t6 boolean <identifier> = <identifier> . remove ( id ) ; \n \t6 if ( ! <identifier> ) \n <ect>
\t1 if ( success && ! all <identifiersep> files <identifiersep> to <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n \t1 log . warn ( <string_literal> ) ; \n \t1 for ( input <identifiersep> file <identifier> : all <identifiersep> files <identifiersep> to <identifiersep> <identifier> ) { \n \t2 log . warn ( <string_literal> + <identifier> ) ; } \n <ect>
\t4 <identifier> <identifiersep> log . info ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . update <identifiersep> <identifier> ( <string_literal> ) ; \n \t3 return <identifier> <identifiersep> new <identifiersep> session ( data , target , key , <identifier> <identifiersep> for <identifiersep> <identifier> , new <identifiersep> key , <identifier> <identifiersep> size ) ; } \n \t2 <comment> \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> ( <number_literal> , <number_literal> , <string_literal> ) ; \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> ( 1 , <number_literal> , <string_literal> ) ; \n <ect>
\t2 string <identifier> <identifiersep> name \t1 = ( string ) request . get <identifiersep> attribute ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> key ) ; \n \t2 string <identifier> <identifiersep> status = null ; \n \t2 node item \t3 = null ; \n \t2 if ( null == <identifier> <identifiersep> name ) { \n <ect>
\t3 <identifier> . <identifier> ( context ) ; \n \t2 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n \t3 logger . error ( this , <string_literal> + e , e ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 logger . info ( <string_literal> , event <identifiersep> <identifier> ) ; } \n \t2 return ( ) - > { \n \t3 if ( event <identifiersep> <identifier> . remove ( event <identifiersep> <identifier> ) ) { \n <ect>
\t5 && result . get ( result <identifiersep> key <identifiersep> <identifier> ) . as <identifiersep> text ( ) . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) { \n \t5 return true ; } \n \t4 logger . warn ( <string_literal> , result ) ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t3 <identifier> . <identifier> <identifiersep> default <identifiersep> <identifier> ( ) ; \n \t3 <identifier> . set <identifiersep> <identifier> <identifiersep> header <identifiersep> value ( <identifier> <identifiersep> header <identifiersep> value ) ; \n \t3 <identifier> . set <identifiersep> <identifier> <identifiersep> method <identifiersep> header <identifiersep> <identifier> ( content <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . set <identifiersep> key ( <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> key ) ; \n <ect>
\t2 log . info ( <string_literal> + channel <identifiersep> <identifier> <identifiersep> address + <string_literal> + new <identifiersep> channel <identifiersep> <identifier> <identifiersep> address ) ; \n \t2 channel <identifiersep> <identifier> <identifiersep> address = new <identifiersep> channel <identifiersep> <identifier> <identifiersep> address ; \n \t2 <identifier> = true ; } \n \t2 if ( channel <identifiersep> <identifier> <identifiersep> <identifier> != new <identifiersep> channel <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 this . <identifier> . <identifier> <identifiersep> <identifier> ( new <identifier> ( ) { \n \t3 public void run ( ) { \n \t4 storage <identifiersep> <identifier> < byte <identifiersep> array , byte [ ] , byte [ ] > store = store <identifiersep> <identifier> . get <identifiersep> storage <identifiersep> <identifier> ( store <identifiersep> name ) ; \n \t4 if ( store == null ) { \n <ect>
public void remove <identifiersep> from <identifiersep> <identifier> ( <identifier> . <identifier> . model . <identifier> object ) { \n \t1 <identifier> <identifiersep> object <identifiersep> from <identifiersep> property <identifiersep> with <identifiersep> key ( object , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void add <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . model . <identifier> object ) { \n <ect>
\t1 private string get <identifiersep> <identifier> <identifiersep> <identifier> ( string content <identifiersep> type , byte [ ] content <identifiersep> bytes ) throws io <identifiersep> exception { \n \t2 string <identifier> = <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> ( content <identifiersep> type , content <identifiersep> bytes ) ; \n \t2 if ( <identifier> == null ) { \n \t3 <identifier> = <identifier> . default <identifiersep> <identifier> ( ) . name ( ) ; \n <ect>
\t3 token <identifiersep> info = <identifier> <identifiersep> entity . get <identifiersep> or <identifiersep> create <identifiersep> <identifier> <identifiersep> token ( ) ; \n \t3 if ( token <identifiersep> info == null ) { \n \t3 throw new exception ( <string_literal> ) ; } \n \t2 } else { \n <ect>
\t6 <comment> \n \t6 boolean is <identifiersep> read <identifiersep> <identifier> = read <identifiersep> <identifier> <identifiersep> storage <identifiersep> configuration . type <identifiersep> name . equals ( <identifier> . get <identifiersep> type ( ) ) ; \n \t6 storage <identifiersep> service . remove <identifiersep> <identifier> ( <identifier> , is <identifiersep> read <identifiersep> <identifier> , <identifier> . get <identifiersep> type ( ) , true ) ; \n \t6 throw new <identifier> <identifiersep> exception ( e ) ; } \n <ect>
\t2 try { \n \t3 map < string , string > <identifier> = <identifier> . read <identifiersep> value ( event <identifiersep> entity . get <identifiersep> <identifier> <identifiersep> json ( ) , map <identifiersep> type ) ; \n \t3 event . set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 conn . <identifier> ( ) \n \t1 <identifier> : \n \t2 logger . exception ( <string_literal> ) \n \t1 if <identifier> ( ex , socket <identifiersep> error ) : \n <ect>
\t1 public void <identifier> ( <identifier> <identifiersep> config config ) throws <identifier> <identifiersep> exception { \n \t1 file properties <identifiersep> file = configuration <identifiersep> <identifier> . find <identifiersep> configuration <identifiersep> file ( <string_literal> ) ; \n \t1 properties <identifier> = null ; \n \t1 if ( null != properties <identifiersep> file ) { \n <ect>
\t2 try { \n \t3 account <identifiersep> vo account <identifiersep> vo = find <identifiersep> by <identifiersep> id ( id ) ; \n \t3 <identifier> <identifiersep> id = account <identifiersep> vo . get <identifiersep> <identifier> <identifiersep> id ( ) ; } \n \t2 catch ( exception e ) { \n <ect>
\t4 channel = get <identifiersep> channel ( false ) ; \n \t4 this . size = channel . size ( ) ; \n \t4 update <identifiersep> size ( this . size ) ; \n \t3 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t6 get <identifiersep> m <identifiersep> bean <identifiersep> server ( ) . <identifier> ( <identifier> <identifiersep> service <identifiersep> object <identifiersep> name , <string_literal> , null , null ) ; \n \t6 log . debug ( <string_literal> , <identifier> <identifiersep> service <identifiersep> object <identifiersep> name ) ; \n \t6 get <identifiersep> m <identifiersep> bean <identifiersep> server ( ) . <identifier> <identifiersep> m <identifiersep> bean ( <identifier> <identifiersep> service <identifiersep> object <identifiersep> name ) ; } \n \t4 } catch ( throwable ignore ) { \n <ect>
\t3 throw new io <identifiersep> exception ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , true ) ) { \n \t3 return <identifier> <identifiersep> <identifier> ; \n \t2 } else { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> data ( true ) ; \n \t2 <identifier> <identifiersep> <identifier> . start ( ) ; \n \t2 logger . add <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n <ect>
\t4 <identifier> <identifiersep> template <identifiersep> cmd = [ <identifier> , template <identifiersep> <identifier> <identifiersep> path , <identifier> ] \n \t4 logger . info ( <identifier> <identifiersep> storage <identifiersep> pool . <identifier> <identifiersep> template , <string_literal> . <identifier> ( <identifier> <identifiersep> template <identifiersep> cmd ) ) \n \t4 do <identifiersep> cmd ( <identifier> <identifiersep> template <identifiersep> cmd ) \n \t4 template <identifiersep> size = <identifier> . path . <identifier> ( <identifier> ) \n <ect>
\t2 <identifier> connection = \n \t4 try { \n \t5 get <identifiersep> <identifier> <identifiersep> connection ( <identifier> ) } \n \t4 catch ( e : throwable ) { \n <ect>
\t2 try { \n \t3 node = client . get <identifiersep> v <identifiersep> <identifier> <identifiersep> client ( ) . get <identifiersep> v <identifiersep> <identifier> ( resource . get <identifiersep> <identifier> ( ) ) ; \n \t3 nodes . add ( node ) ; \n \t2 } catch ( null <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t7 connection . close ( ) ; \n \t7 all <identifiersep> <identifier> . count <identifiersep> <identifier> ( ) ; \n \t7 log . info ( <string_literal> ) ; \n \t6 } catch ( exception <identifier> ) { \n <ect>
\t2 { \n \t3 <identifier> . <identifier> ( result ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> logger ( ) ; \n \t2 <identifier> <identifiersep> storage <identifiersep> <identifier> = new <identifier> <identifiersep> storage <identifiersep> manager <identifiersep> <identifier> ( this ) ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( string name , map < string , object > <identifier> ) throws configuration <identifiersep> exception { \n <ect>
\t2 synchronized ( <identifier> ) { \n \t3 final <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message > <identifier> = <identifier> . get ( <identifier> <identifiersep> number ) ; \n \t3 assert <identifier> == null : <string_literal> ; \n \t3 if ( <identifier> != null ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t2 create <identifiersep> <identifier> ( ) ; } } } \n \t1 return <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( <identifier> ) ; } \n private void create <identifiersep> <identifier> ( ) { \n <ect>
\t3 logger . debug ( <string_literal> , this . entity <identifiersep> id <identifiersep> <identifier> <identifiersep> name ) ; \n \t3 return success ( ) ; } \n \t2 logger . debug ( <string_literal> , entity <identifiersep> id ) ; \n \t2 if ( ! metadata <identifiersep> <identifier> <identifiersep> utils . is <identifiersep> metadata <identifiersep> found <identifiersep> for <identifiersep> entity <identifiersep> id ( metadata <identifiersep> <identifier> , entity <identifiersep> id ) ) { \n <ect>
\t5 string e <identifiersep> response = request ( <identifier> <identifiersep> <identifier> <identifiersep> method . get , e <identifiersep> <identifier> ) ; \n \t5 has <identifiersep> default = ( <identifier> <identifiersep> response ( e <identifiersep> response ) && response <identifiersep> not <identifiersep> empty ( e <identifiersep> response ) ) ; \n \t5 <comment> \n \t5 if ( has <identifiersep> default ) { \n <ect>
\t2 if ( new <identifiersep> service <identifiersep> <identifier> == null ) { \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> + new <identifiersep> service <identifiersep> <identifier> <identifiersep> id ) ; } \n \t2 <comment> \n \t2 if ( ! vm <identifiersep> instance . get <identifiersep> state ( ) . equals ( state . <identifier> ) ) { \n <ect>
\t2 logger . info ( <string_literal> + config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 logger . info ( <string_literal> + config . get <identifiersep> max <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t2 logger . info ( <string_literal> + config . get <identifiersep> <identifier> <identifiersep> user <identifiersep> name <identifiersep> length ( ) ) ; \n \t2 logger . info ( <string_literal> + config . get <identifiersep> max <identifiersep> user <identifiersep> name <identifiersep> length ( ) ) ; \n <ect>
\t3 throw new web <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + <identifier> \n <number_literal> + <string_literal> \n <number_literal> + ex . get <identifiersep> message ( ) , ex ) ; } } \n \t1 } catch ( exception <identifier> ) { \n <ect>
\t8 . put ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> length ( <number_literal> ) ) \n \t8 . put ( <string_literal> , <number_literal> ) ) ) ; \n \t2 <comment> \n \t2 assert <identifiersep> <identifier> ( <identifier> <identifiersep> create ( <string_literal> , <number_literal> , <identifier> . builder ( ) . put ( <string_literal> , 0 ) ) ) ; \n <ect>
\t1 @ <identifier> <identifiersep> operation ( <identifier> = <string_literal> ) \n \t1 public boolean start <identifiersep> node <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> . size ( ) > 1 ) { \n \t3 if ( start <identifiersep> <identifier> <identifiersep> thread ( ) ) { \n <ect>
\t5 try { \n \t6 meta <identifiersep> type m = meta <identifiersep> type . value <identifiersep> of ( meta <identifiersep> type . class , meta <identifiersep> type . <identifier> ( ) ) ; \n \t6 <identifier> <identifiersep> <identifier> . add ( m ) ; \n \t5 } catch ( exception <identifier> ) { \n <ect>
\t7 log . warn ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t6 } else { \n \t7 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> name ) ; } \n \t5 } else { \n <ect>
\t3 s <identifiersep> logger . error ( error ) ; \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( error ) ; \n \t2 } else if ( ( root <identifiersep> <identifier> <identifiersep> size < < <number_literal> ) > template <identifiersep> vo . get <identifiersep> size ( ) ) { \n \t3 if ( <identifier> <identifiersep> type == <identifier> <identifiersep> type . v <identifiersep> <identifier> && ( vm . get <identifiersep> <identifier> ( ) == null || vm . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) == null ) ) { \n <ect>
\t3 return collection <identifiersep> utils . <identifier> <identifiersep> set ( event ) ; } \n \t2 logger . debug ( <string_literal> , id , service ) ; \n \t2 final <identifier> < boolean , <identifier> < <identifier> <identifiersep> authentication <identifiersep> provider > > result = this . authentication <identifiersep> context <identifiersep> <identifier> . <identifier> ( authentication , id , service ) ; \n \t2 if ( result . get <identifiersep> key ( ) ) { \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + job <identifiersep> id + <string_literal> + status + <string_literal> ) ; \n \t3 return ; } \n \t2 template <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> template <identifiersep> <identifier> ( ) ; \n <ect>
\t4 if ( debug ) \n \t5 log . debug ( <string_literal> + manager ) ; \n \t4 query query = manager . get <identifiersep> query ( node ) ; \n \t4 if ( debug ) \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t3 return false ; } \n \t2 final user <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> . get ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t2 try { \n \t3 start ( ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 <comment> \n <ect>
\t6 } else if ( message instanceof byte [ ] ) { \n \t7 <identifier> . write ( ( byte [ ] ) message , 0 , ( ( byte [ ] ) message ) . length ) ; \n \t6 } else { \n \t7 <comment> \n <ect>
<comment> \n \t1 synchronized void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( byte <identifiersep> <identifier> <identifier> ) { \n \t2 <comment> \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> . start ( get <identifiersep> <identifier> <identifiersep> dir ( ) ) ; <comment> \n \t3 abstract <identifiersep> builder . <identifier> ( ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t3 log . info ( <string_literal> + <identifier> <identifiersep> bytes ) ; \n \t3 log . info ( <string_literal> + file <identifiersep> <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> <identifiersep> list <identifiersep> start ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t3 assert <identifiersep> equals ( <string_literal> + i , 0 , store . get <identifiersep> p <identifiersep> list ( <string_literal> + i ) . size ( ) ) ; } \n \t2 log . info ( <string_literal> ) ; \n \t2 for ( int i = 0 ; i < num <identifiersep> <identifier> ; i ++ ) { \n \t3 new job ( i , p <identifiersep> list <identifiersep> test <identifiersep> <identifier> . task <identifiersep> type . delete , <identifier> ) . run ( ) ; } \n <ect>
\t6 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> message ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t4 log . warn ( <string_literal> , field , line <identifiersep> number , e . to <identifiersep> string ( ) ) ; } \n \t3 throw new <identifier> <identifiersep> <identifier> <identifiersep> error ( e ) ; \n \t2 } catch ( array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 string property <identifiersep> uri = <identifier> <identifiersep> type . get <identifiersep> type ( ) . get <identifiersep> uri ( ) ; \n \t2 double <identifier> = <identifier> <identifiersep> type . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifier> = <identifier> <identifiersep> type . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> uri == null || <identifier> <identifiersep> uri . is <identifiersep> empty ( ) ) { \n <ect>
\t3 logger . debug ( <string_literal> , remote <identifiersep> user ) ; \n \t3 return remote <identifiersep> user ; } \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( this . remote <identifiersep> principal <identifiersep> header ) ) { \n \t3 final map < string , list < string > > <identifier> = get <identifiersep> all <identifiersep> request <identifiersep> header <identifiersep> values ( request ) ; \n <ect>
\t3 } else { \n \t4 logger . error ( <string_literal> , <identifier> <identifiersep> id , configuration . get <identifiersep> <identifier> <identifiersep> provider <identifiersep> <identifier> ( ) ) ; \n \t4 return error ( ) ; } \n \t3 context . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . put ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> service , service ) ; \n <ect>
<comment> \n \t1 public void on <identifiersep> <identifier> <identifiersep> <identifier> ( list < <identifier> < <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> type > > <identifier> ) { \n \t2 for ( <identifier> < <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> type > result : <identifier> ) { \n <ect>
\t5 boolean <identifier> <identifiersep> failure = false ; \n \t5 for ( <identifier> <identifiersep> item <identifiersep> response response : <identifier> <identifiersep> item <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t6 <comment> \n \t6 if ( response . is <identifiersep> failed ( ) && response . get <identifiersep> failure ( ) . get <identifiersep> status ( ) != <identifier> <identifiersep> status . not <identifiersep> found ) { \n <ect>
\t3 type <identifiersep> <identifier> <identifier> = new type <identifiersep> <identifier> ( <identifier> <identifiersep> body ) ; \n \t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> 1 ( ) ; \n \t2 } catch ( type <identifiersep> exception <identifier> ) { \n \t3 if ( debug ) { \n <ect>
\t1 thread <identifier> <identifiersep> thread ; \n \t1 server <identifiersep> socket <identifier> <identifiersep> socket ; \n \t1 server <identifiersep> socket <identifier> <identifiersep> socket ; \n \t1 public void start ( ) { \n <ect>
\t4 logger . debug ( <string_literal> , connection . get <identifiersep> host ( ) , e ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n \t4 logger . debug ( <string_literal> , connection . get <identifiersep> host ( ) , e ) ; } \n \t3 <identifier> = <identifier> <identifiersep> <identifier> ; } \n <ect>
\t4 logger . debug ( <string_literal> , item <identifiersep> name ) ; \n \t3 } else { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + mode . name ( ) ) ; } \n \t2 } catch ( io <identifiersep> exception exception ) { \n <ect>
\t2 if ( <identifier> <identifiersep> host == null ) { \n \t3 add <identifiersep> host ( host <identifiersep> name , new string [ 0 ] , host ) ; \n \t3 <identifier> <identifiersep> host = <identifier> <identifiersep> find ( <identifier> , host <identifiersep> name ) ; \n \t3 if ( <identifier> <identifiersep> host == null ) { \n <ect>
\t3 logger . warn ( <string_literal> , registered <identifiersep> service ) ; \n \t3 return false ; } \n \t2 final string <identifier> <identifiersep> uri = request . get <identifiersep> <identifier> ( o <identifiersep> <identifier> . <identifier> <identifiersep> uri ) ; \n \t2 if ( ! <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> ( registered <identifiersep> service , <identifier> <identifiersep> uri ) ) { \n <ect>
\t3 this . <identifier> <identifiersep> <identifier> = ! is <identifiersep> x <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> url ( ) , <number_literal> ) . <identifier> <identifiersep> out ; } \n \t2 if ( ! this . <identifier> <identifiersep> <identifier> ) { \n \t3 logger . info ( <string_literal> , get <identifiersep> url ( ) ) ; \n \t3 stop <identifiersep> <identifier> ( ) ; \n <ect>
\t2 final object value = <identifier> [ index ] ; \n \t2 if ( value instanceof <identifier> ) { \n \t3 return ( <identifier> ) value ; } \n \t2 if ( value == null ) { \n <ect>
\t3 if ( <identifier> != null ) \n \t4 return true ; \n \t3 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 <identifier> <identifiersep> io . write ( <identifier> <identifiersep> <identifier> , <string_literal> , out <identifiersep> stream ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> data = out <identifiersep> stream . to <identifiersep> byte <identifiersep> array ( ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
<comment> \n public void <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t5 m <identifiersep> <identifier> . set <identifiersep> enabled ( false ) ; \n \t5 m <identifiersep> info <identifiersep> <identifier> <identifiersep> root . set <identifiersep> <identifier> ( true ) ; \n \t5 return ; } } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 string <identifier> <identifiersep> id = <identifier> . get <identifiersep> content <identifiersep> <identifier> ( ) ; \n \t3 <comment> \n \t3 <comment> \n \t3 if ( <identifier> . get <identifiersep> <identifier> ( ) == null || <identifier> <identifiersep> id == null ) { \n <ect>
\t2 log . error ( string . format ( <string_literal> , <identifier> <identifiersep> key <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) , e . get <identifiersep> <identifier> <identifiersep> message ( ) ) , e ) ; } \n \t1 } else { \n \t2 log . error ( string . format ( <string_literal> , <identifier> <identifiersep> key <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ) ; } \n \t1 } else { \n <ect>
\t1 @ <identifier> <identifiersep> throws \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config ( ) { \n \t2 final string <identifier> <identifiersep> value = system . get <identifiersep> property ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> conf ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> value ) ) { \n <ect>
\t2 for ( int i = 1 ; i < = <number_literal> ; i ++ ) { \n \t3 <identifier> next <identifiersep> timeout = <identifier> <identifiersep> timeout . get <identifiersep> next <identifiersep> timeout ( <identifier> <identifiersep> timeout ) ; \n \t3 assert . assert <identifiersep> not <identifiersep> null ( time <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name , next <identifiersep> timeout ) ; \n \t3 assert . assert <identifiersep> not <identifiersep> null ( time <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name , next <identifiersep> timeout . <identifier> ( <identifier> <identifiersep> timeout ) ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void close ( boolean <identifier> <identifiersep> log ) { \n <ect>
\t5 boolean <identifier> = <identifier> . <identifier> <identifiersep> version ( <identifier> <identifiersep> <identifier> ) ; \n \t5 assert <identifier> : <string_literal> + <identifier> + <string_literal> + msg + \n \t6 <string_literal> + last <identifiersep> msg + <string_literal> + <identifier> <identifiersep> state <identifiersep> <identifier> ( ) + ' ] ' ; \n <ect>
\t4 action <identifiersep> <identifier> <identifiersep> factory <identifier> = <identifier> . get <identifiersep> instance ( action <identifiersep> <identifier> <identifiersep> factory . class , factory <identifiersep> name ) ; \n \t4 if ( <identifier> != null ) { \n \t5 action <identifiersep> <identifier> <identifiersep> <identifier> . put ( factory <identifiersep> <identifier> , <identifier> ) ; \n \t4 } else { \n <ect>
\t2 assert <identifiersep> not <identifiersep> null ( data ) ; \n \t2 log . debug ( <string_literal> + data . <identifier> <identifiersep> bytes . length + <string_literal> + utils . <identifier> . <identifier> ( data . <identifier> <identifiersep> bytes ) + <string_literal> ) ; \n \t2 byte [ ] <identifier> <identifiersep> <identifier> <identifiersep> bytes = key <identifiersep> <identifier> . <identifier> ( data , key <identifiersep> <identifier> . <identifier> <identifiersep> key ( <identifier> ) ) ; \n \t2 log . debug ( <string_literal> + utils . <identifier> . <identifier> ( test <identifiersep> <identifier> ) ) ; \n <ect>
\t5 <identifier> <identifiersep> log . info ( <string_literal> ) ; } \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> throwable = false ; } \n \t3 catch ( security <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> . message ( ) . remote <identifiersep> <identifier> ( s <identifiersep> <identifier> <identifiersep> 1 , new <identifier> < <identifier> , object > ( ) { \n \t3 @ <identifier> \n \t3 public boolean <identifier> ( <identifier> node <identifiersep> id , object msg ) { \n \t4 try { \n <ect>
\t2 for ( answer answer : <identifier> ) { \n \t3 if ( answer . get <identifiersep> result ( ) == false ) { \n \t4 s <identifiersep> logger . warn ( <string_literal> + answer . to <identifiersep> string ( ) ) ; \n \t3 } else { \n <ect>
\t3 throw new runtime <identifiersep> exception ( <string_literal> ) ; } } \n \t1 private <identifier> <identifiersep> <identifier> <identifier> <identifiersep> add <identifiersep> vm <identifiersep> to <identifiersep> network ( final <identifier> <identifiersep> <identifier> vm , final network network , final <identifier> <identifiersep> <identifier> <identifier> ) throws <identifier> <identifiersep> operation <identifiersep> exception , resource <identifiersep> <identifier> <identifiersep> exception , \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 final <identifier> <identifiersep> context <identifier> = <identifier> <identifiersep> context . current ( ) ; \n <ect>
\t1 private static final int <identifier> <identifiersep> length = <number_literal> ; \n \t1 private <identifier> [ ] <identifier> <identifiersep> <identifier> = new <identifier> [ <identifier> <identifiersep> length ] ; \n \t1 private boolean <identifier> <identifiersep> <identifier> = true ; \n \t1 protected void <identifier> <identifiersep> <identifier> ( body <identifier> , string <identifier> <identifiersep> name , map options ) { \n <ect>
\t3 } while ( ! <identifier> ) ; \n \t3 return response ; \n \t2 } catch ( exception ex ) { \n \t3 final string <identifier> <identifiersep> msg = <string_literal> ; \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 final <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n \t5 . get <identifiersep> <identifier> <identifiersep> <identifier> ( m <identifiersep> <identifier> <identifiersep> message . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t5 this . in <identifiersep> <identifier> . remove ( item ) ; } \n \t4 this . <identifier> . <identifier> ( ) ; } } \n \t2 else { \n <ect>
\t2 log . error ( <string_literal> , ex ) ; } \n \t2 try { \n \t3 load <identifiersep> <identifier> . delete <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> name , <identifier> <identifiersep> name ) ; \n \t2 } catch ( load <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t4 <identifier> <identifiersep> id = long . parse <identifiersep> long ( <identifier> <identifiersep> <identifier> . get <identifiersep> value ( ) ) ; \n \t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> <identifiersep> id , network <identifiersep> to <identifiersep> <identifier> ) ; \n \t3 } else { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> ( new <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> = new <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t2 if ( <identifier> . has <identifiersep> <identifier> ( ) ) \n \t2 { \n <ect>
\t2 final delete <identifiersep> item <identifiersep> request <identifier> = new delete <identifiersep> item <identifiersep> request ( ) . with <identifiersep> table <identifiersep> name ( <identifier> <identifiersep> db <identifiersep> properties . get <identifiersep> table <identifiersep> name ( ) ) \n \t3 . with <identifiersep> key ( collection <identifiersep> utils . <identifier> ( <identifier> <identifiersep> <identifier> . id . get <identifiersep> <identifier> <identifiersep> name ( ) , new attribute <identifiersep> value ( string . value <identifiersep> of ( service . get <identifiersep> id ( ) ) ) ) ) ; \n \t2 logger . debug ( <string_literal> , <identifier> , service ) ; \n \t2 final delete <identifiersep> item <identifiersep> result <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> db <identifiersep> client . delete <identifiersep> item ( <identifier> ) ; \n <ect>
\t2 url <identifiersep> <identifier> <identifier> = new url <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 return <identifier> . <identifier> ( <identifier> ) . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; } \n \t2 catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 s <identifiersep> logger . info ( <string_literal> + url ) ; \n \t2 http <identifiersep> client client = new http <identifiersep> client ( ) ; \n \t2 http <identifiersep> method method = new get <identifiersep> method ( url ) ; \n \t2 response <identifiersep> code = client . execute <identifiersep> method ( method ) ; \n <ect>
\t3 try { \n \t4 thread . <identifier> ( wait <identifiersep> <identifier> ) ; \n \t4 time <identifiersep> out ++ ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> host <identifiersep> state == null ) { \n \t4 logger . debug ( <string_literal> + host + <string_literal> ) ; \n \t4 break ; } \n \t3 if ( <identifier> . <identifier> ( host , <identifier> <identifiersep> <identifier> <identifiersep> host <identifiersep> state , new <identifier> <identifiersep> host <identifiersep> state ( <identifier> <identifiersep> <identifier> <identifiersep> host <identifiersep> state ) ) ) { \n <ect>
\t1 private list < long > <identifier> <identifiersep> <identifier> ( final list < <identifier> <identifiersep> <identifier> <identifiersep> vo > <identifier> ) { \n \t2 final list < long > job <identifiersep> <identifier> = new array <identifiersep> list < long > ( ) ; \n \t2 for ( final <identifier> <identifiersep> <identifier> <identifiersep> vo <identifier> : <identifier> ) { \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . check <identifiersep> <identifier> <identifiersep> version ( <identifier> ) ) { \n <ect>
\t5 if ( <identifier> != null ) { \n \t6 if ( answer == null ) { \n \t7 answer = <identifier> ; \n \t6 } else { \n <ect>
\t7 <identifier> <identifiersep> url <identifiersep> <identifier> = <identifier> <identifiersep> host <identifiersep> <identifier> . <identifier> <identifiersep> host <identifiersep> name <identifiersep> in <identifiersep> url ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> url <identifiersep> <identifier> ) ; \n \t7 string <identifier> <identifiersep> local <identifiersep> path = <identifier> <identifiersep> dir + file . <identifier> + <identifier> <identifiersep> file <identifiersep> name ; \n \t7 file <identifiersep> <identifier> . add ( <identifier> <identifiersep> local <identifiersep> path ) ; \n <ect>
\t5 if ( <identifier> != null ) \n \t5 { \n \t6 if ( ! <identifier> . equals ( <identifier> ) ) { \n \t7 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) { \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t3 <comment> \n \t3 if ( conf <identifiersep> file == null || ! conf <identifiersep> file . exists ( ) ) { \n \t4 class <identifiersep> <identifier> class <identifiersep> <identifier> = thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) ; \n \t4 if ( class <identifiersep> <identifier> . get <identifiersep> resource ( <identifier> <identifiersep> file <identifiersep> name ) != null ) { \n <ect>
\t3 configuration <identifiersep> vo config <identifiersep> in <identifiersep> db = <identifier> <identifiersep> config <identifiersep> dao . find <identifiersep> by <identifiersep> name ( config . <identifier> . key ( ) ) ; \n \t3 if ( config <identifiersep> in <identifiersep> db == null ) { \n \t4 configuration <identifiersep> vo config <identifiersep> vo = new configuration <identifiersep> vo ( config . <identifier> . get <identifiersep> <identifier> ( ) , <string_literal> , config . <identifier> . get <identifiersep> <identifier> ( ) , config . <identifier> . key ( ) , get <identifiersep> private <identifiersep> key ( ) , \n \t6 config . <identifier> . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 if ( file . exists ( ) ) { \n \t4 if ( ! file . is <identifiersep> directory ( ) ) { \n \t5 logger . warn ( <string_literal> + <identifier> + <string_literal> ) ; } \n \t3 } else { \n <ect>
\t5 if ( ! <identifier> ) { \n \t6 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t6 log . error ( <identifier> + <string_literal> + <identifier> ) ; \n \t6 <identifier> <identifiersep> object object = <identifier> . get <identifiersep> object ( <identifier> . get <identifiersep> source <identifiersep> id ( ) ) ; \n <ect>
\t2 try { \n \t3 context = create <identifiersep> context ( ) ; \n \t3 org . <identifier> . content . metadata <identifiersep> field <identifier> <identifiersep> field = metadata <identifiersep> field <identifiersep> service . find ( context , field <identifiersep> id ) ; \n \t3 if ( <identifier> <identifiersep> field == null ) { \n <ect>
\t1 logger . error ( <string_literal> ) ; \n \t1 logger . error ( <string_literal> + e . get <identifiersep> message ( ) ) ; } \n private void do <identifiersep> <identifier> ( ) { \n \t1 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
<comment> \n \t1 protected void build <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> filter <identifiersep> if <identifiersep> <identifier> ( final <identifier> <identifiersep> registered <identifiersep> service service , final list < metadata <identifiersep> filter > metadata <identifiersep> filter <identifiersep> list ) throws exception { \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( service . get <identifiersep> metadata <identifiersep> <identifier> <identifiersep> location ( ) ) ) { \n <ect>
\t3 throw new runtime <identifiersep> exception ( e ) ; } \n \t2 try { \n \t3 return ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) m . <identifier> ( null , url ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 <identifier> <identifiersep> info <identifier> <identifiersep> info = null ; \n \t1 try { \n \t1 <identifier> <identifiersep> info = <identifier> . find ( new <identifier> <identifiersep> info ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 exchange . get <identifiersep> in ( ) . set <identifiersep> body ( <identifier> ) ; \n \t2 <identifier> . process ( exchange ) ; \t3 \n \t2 if ( ! execution <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t3 xml <identifiersep> <identifier> = new xml <identifiersep> <identifier> ( ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 long start = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 for ( int <identifier> = 0 ; <identifier> < <identifier> <identifiersep> count ; ++ <identifier> ) { \n \t3 message message = session . create <identifiersep> text <identifiersep> message ( <string_literal> + <identifier> ) ; \n \t3 <identifier> . send ( message ) ; } \n <ect>
\t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + <identifier> + <string_literal> + network <identifiersep> id + \n <number_literal> <string_literal> + <identifier> ) ; } } \n \t3 return <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 list < <identifier> > <identifier> = new array <identifiersep> list < <identifier> > ( <identifier> <identifiersep> <identifier> . size ( ) ) ; \n \t3 for ( <identifier> <identifiersep> method <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t4 <identifier> <identifier> = <identifier> . new <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) , ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> . add ( <identifier> ) ; \n <ect>
\t2 thread . <identifier> ( <identifier> ) ; \n \t1 } catch ( interrupted <identifiersep> exception <identifier> ) { \n \t2 logger . info ( <string_literal> + <identifier> . get <identifiersep> channel ( ) , <identifier> ) ; } \n \t1 } else { \n <ect>
\t2 final <identifier> <identifiersep> location <identifiersep> request <identifier> = web <identifiersep> utils . get <identifiersep> http <identifiersep> <identifier> <identifiersep> request <identifiersep> <identifier> <identifiersep> location ( request ) ; \n \t2 if ( <identifier> != null && <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t3 logger . debug ( <string_literal> , <identifier> ) ; \n \t3 final long count = <identifier> . stream ( ) . filter ( e - > e . get <identifiersep> <identifier> <identifiersep> location ( ) . equals ( <identifier> ) ) . count ( ) ; \n <ect>
\t1 <identifier> <identifiersep> client <identifiersep> <identifier> <identifiersep> name = <string_literal> ; \n \t1 if ( <identifier> <identifiersep> service <identifiersep> principal <identifiersep> name == null ) \n \t1 <identifier> <identifiersep> service <identifiersep> principal <identifiersep> name = <string_literal> ; \n \t1 system . set <identifiersep> property ( <string_literal> , <string_literal> ) ; \n <ect>
\t2 system . <identifier> ( ) ; <comment> \n \t2 status . current . <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t2 new <identifier> <identifiersep> collection <identifiersep> <identifier> ( ) . <identifier> ( new <identifier> <identifiersep> <identifier> ( root <identifiersep> table . name ) ) ; \n \t2 new <identifier> <identifiersep> collection <identifiersep> <identifier> ( ) . <identifier> ( new <identifier> <identifiersep> <identifier> ( metadata <identifiersep> table . name ) ) ; \n <ect>
\t3 <identifier> . update ( data . get <identifiersep> bytes ( <string_literal> ) ) ; \n \t3 final byte [ ] <identifier> <identifiersep> bytes = <identifier> . do <identifiersep> final ( ) ; \n \t3 return <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> bytes ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception | <identifier> <identifiersep> key <identifiersep> exception | <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 private static logger logger = logger . get <identifiersep> logger ( xml <identifiersep> java <identifiersep> type <identifiersep> <identifier> <identifiersep> resource . class . get <identifiersep> name ( ) ) ; \n \t1 public static void <identifier> ( ) { \n \t2 <identifier> <identifiersep> <identifier> = 0 ; \n \t2 <identifier> <identifiersep> <identifier> = 0 ; \n <ect>
\t7 answer = resource . execute <identifiersep> request ( <identifier> [ i ] ) ; \n \t6 } else { \n \t7 answer = new answer ( <identifier> [ i ] , false , <string_literal> ) ; } \n \t5 } catch ( exception e ) { \n <ect>
\t2 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t3 <identifier> <identifier> = <identifier> . get <identifiersep> state ( ) . get <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . get ( <identifier> <identifiersep> id ) ; \n \t3 if ( <identifier> != null ) { \n <ect>
\t3 command <identifiersep> listener . command <identifiersep> failed ( new command <identifiersep> failed <identifiersep> event ( message . get <identifiersep> id ( ) , connection <identifiersep> <identifier> , command <identifiersep> name , <identifier> <identifiersep> time <identifiersep> <identifier> , \n \t5 throwable ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void shutdown <identifiersep> application ( application <identifiersep> status final <identifiersep> status , string <identifier> <identifiersep> <identifier> ) { \n \t2 <comment> \n \t2 final <identifiersep> application <identifiersep> status <identifier> <identifiersep> status = get <identifiersep> <identifier> <identifiersep> status ( final <identifiersep> status ) ; \n <ect>
\t2 json <identifiersep> array <identifier> = json . get <identifiersep> json <identifiersep> array ( <identifier> <identifiersep> key ) ; \n \t2 for ( int <identifier> = 0 ; <identifier> < <identifier> . length ( ) ; <identifier> ++ ) { \n \t2 string <identifier> = <identifier> ( current , <identifier> . get <identifiersep> string ( <identifier> ) ) ; \n \t2 if ( <identifier> <identifiersep> files . contains ( <identifier> ) ) { \n <ect>
\t1 client . add <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> add <identifiersep> <identifier> <identifiersep> <identifier> . create ( <identifier> <identifiersep> to <identifiersep> <identifier> ) . build ( ) ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = client . get <identifiersep> <identifier> ( db <identifiersep> name , table <identifiersep> name , <identifier> <identifiersep> <identifier> ) ; \n \t1 assert <identifiersep> not <identifiersep> null ( <identifier> ) ; \n \t1 <comment> \n <ect>
\t2 { \n \t3 mode <identifiersep> <identifier> <identifiersep> <identifier> . get ( <number_literal> , time <identifiersep> unit . <identifier> ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t3 <comment> \n \t3 try { \n \t4 return <identifier> <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> or <identifiersep> <identifier> ( true , null , <identifier> ) == 0 ; \n \t3 } catch ( x <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 void on <identifiersep> <identifier> ( final <identifier> node <identifiersep> id , final grid <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message < <identifier> , v > msg ) { \n \t2 assert msg != null ; \n \t2 if ( is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 <identifier> = <identifier> . <identifier> ( <identifier> ) ; \n \t2 } catch ( illegal <identifiersep> state <identifiersep> exception <identifier> ) { \n \t3 logger . warn ( <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> + <identifier> + <string_literal> ) ; \n \t3 if ( <identifier> >= <number_literal> ) { \n <ect>
\t1 try { \n \t2 <identifier> <identifiersep> pool . return <identifiersep> object ( <identifier> ) ; \n \t1 } catch ( final exception e ) { \n \t2 <comment> \n <ect>
\t2 <identifier> . close ( ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> network <identifiersep> manager <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> token <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type ( string token <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 private static map < string , string > load <identifiersep> from <identifiersep> file ( @ <identifier> file file , @ <identifier> log log ) \n \t1 { \n \t2 if ( ! file . exists ( ) ) \n \t2 { \n <ect>
\t3 final i <identifiersep> map < string , ticket > map = get <identifiersep> ticket <identifiersep> map <identifiersep> instance <identifiersep> by <identifiersep> metadata ( metadata ) ; \n \t3 final ticket ticket = map . get ( <identifier> <identifiersep> ticket <identifiersep> id ) ; \n \t3 final ticket result = <identifier> <identifiersep> ticket ( ticket ) ; \n \t3 if ( result != null && result . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 for ( <identifier> <identifiersep> action . <identifier> <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t4 try { \n \t5 <identifier> . on <identifiersep> failure ( e ) ; \n \t4 } catch ( exception <identifier> ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t3 return ; } \n \t2 if ( is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 long <identifier> ; \n \t2 try { \n \t3 <identifier> = <identifier> . get <identifiersep> long ( <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> parse <identifiersep> exception e ) { \n <ect>
\t1 protected static void log <identifiersep> <identifier> ( byte [ ] bytes , final string msg ) { \n \t2 s <identifiersep> logger . debug ( <string_literal> + request . get <identifiersep> <identifier> <identifiersep> id ( bytes ) + <string_literal> + request . get <identifiersep> <identifier> ( bytes ) + <string_literal> + request . get <identifiersep> <identifier> <identifiersep> server <identifiersep> id ( bytes ) + <string_literal> \n \t4 + ( request . is <identifiersep> request ( bytes ) ? <string_literal> : <string_literal> ) + msg ) ; } \n \t1 protected static void log <identifiersep> i ( byte [ ] bytes , final string msg ) { \n <ect>
\t3 logger . info ( <string_literal> , total <identifiersep> num <identifiersep> <identifier> ) ; \n \t3 <comment> \n \t3 logger . info ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> nodes ( <string_literal> , <number_literal> ) ; \n <ect>
\t8 if ( s . length == <number_literal> ) { \n \t9 try { \n \t10 integer <identifier> = integer . parse <identifiersep> int ( s [ 1 ] ) ; \n \t10 <identifier> . set <identifiersep> <identifier> ( <identifier> , this ) ; \n <ect>
\t2 try { \n \t3 store = new <identifier> <identifiersep> string <identifiersep> key <identifiersep> value <identifiersep> store <identifiersep> <identifier> <identifiersep> sql ( url , user , password , table , data <identifiersep> store <identifiersep> config . sql <identifiersep> <identifier> <identifiersep> write ( ) ) ; \n \t2 } catch ( exception ex ) { \n \t3 store = string <identifiersep> key <identifiersep> value <identifiersep> store <identifiersep> no <identifiersep> <identifier> . <identifier> ; \n <ect>
\t4 if ( is <identifiersep> object <identifiersep> local ( <identifier> . get <identifiersep> base ( ) , <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ) ) \n \t4 { \n \t5 boolean <identifier> = <identifier> . is <identifiersep> field <identifiersep> local <identifiersep> to <identifiersep> <identifier> ( <identifier> . get <identifiersep> field <identifiersep> <identifier> ( ) . <identifier> ( ) ) ; \n \t5 if ( <identifier> . <identifier> <identifiersep> debug ( ) ) \n <ect>
\t3 <string_literal> + \n \t3 <string_literal> ) ; \n \t2 return true ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 { \n \t3 v <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> provider . get <identifiersep> connection ( ) ) ; } \n \t2 catch ( <identifier> <identifiersep> exception <identifier> ) \n \t2 { \n <ect>
\t1 { \n \t2 try { \n \t3 return <identifier> <identifiersep> resource <identifiersep> <identifier> <identifiersep> dao . list <identifiersep> <identifier> ( ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 } else if ( state == on <identifiersep> <identifier> <identifiersep> value . on ) { \n \t4 logger . debug ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> on ( ) ; \n \t3 } else { \n <ect>
\t3 return false ; } \n \t2 list < user <identifiersep> vm <identifiersep> vo > user <identifiersep> vm <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> user <identifiersep> vm <identifiersep> dao . list <identifiersep> by <identifiersep> <identifier> <identifiersep> id ( template <identifiersep> id ) ; \n \t2 <comment> \n \t2 if ( ! user <identifiersep> vm <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t4 <string_literal> + <string_literal> + <string_literal> + \n \t4 <string_literal> + <identifier> . null ; \n \t2 <identifier> <identifiersep> connection . send <identifiersep> <identifier> ( <identifier> ) ; \n \t2 <identifier> = <identifier> <identifiersep> connection . <identifier> ( ) ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> [ i ] = <identifier> [ i ] ; \n \t4 } else { \n \t5 <comment> \n \t5 if ( <identifier> [ i ] != null ) { \n <ect>
\t2 catch ( io <identifiersep> exception ex ) { \n \t3 log . error ( <identifier> <identifiersep> integer . class , <string_literal> + ex . get <identifiersep> message ( ) , ex ) ; \n \t3 io . exception ( ex ) ; } \n \t2 catch ( number <identifiersep> format <identifiersep> exception ex ) { \n <ect>
\t7 <string_literal> ) ) ; } \n \t4 if ( source <identifiersep> id . <identifier> <identifiersep> with ( <string_literal> ) ) <comment> \n \t5 source <identifiersep> id = source <identifiersep> id . <identifier> ( 0 , source <identifiersep> id . length ( ) - <number_literal> ) . <identifier> ( ) ; \n \t4 if ( <identifier> <identifiersep> uri . <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> = ( <identifier> + <identifier> <identifiersep> <identifier> ) . <identifier> ( ) ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> configuration <identifiersep> map ( <identifier> <identifiersep> map , field <identifiersep> type , <identifier> <identifiersep> <identifier> ) ; \n \t5 } else { \n \t6 if ( <identifier> <identifiersep> map . contains <identifiersep> key ( property <identifiersep> name ) ) { \n <ect>
\t3 final map < string , list < string > > <identifier> = get <identifiersep> all <identifiersep> request <identifiersep> header <identifiersep> values ( request ) ; \n \t3 logger . debug ( <string_literal> , <identifier> , this . remote <identifiersep> principal <identifiersep> header ) ; \n \t3 if ( <identifier> . contains <identifiersep> key ( this . remote <identifiersep> principal <identifiersep> header ) ) { \n \t4 final string header = <identifier> . get ( this . remote <identifiersep> principal <identifiersep> header ) . get ( 0 ) ; \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifier> = ( ( <identifier> <identifiersep> <identifier> <identifiersep> store ) <identifier> <identifiersep> store ) . get <identifiersep> <identifier> ( ) ; \n \t5 if ( <identifier> != null ) { \n \t6 <identifier> . remove ( id <identifiersep> <identifier> <identifiersep> delete <identifiersep> file , options . <identifier> <identifiersep> <identifier> ) ; } } \n \t3 } catch ( exception e ) { \n <ect>
\t3 <identifier> . close ( ) ; \n \t3 if ( <identifier> <identifiersep> utils . is <identifiersep> <identifier> ( ) ) \n \t4 system . <identifier> ( ) ; <comment> \n \t3 <comment> \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> ( <identifier> <identifiersep> policy ) ; } } \n \t2 try { \n \t3 <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> config ( cmd . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t8 <string_literal> , <string_literal> , item . <identifier> ) ; \n \t2 for ( metadata <identifiersep> value <identifier> : <identifier> ) { \n \t3 if ( this . <identifier> ( <identifier> . get <identifiersep> value ( ) ) ) { \n \t4 <comment> \n <ect>
\t2 logger . info ( <string_literal> + <identifier> ) ; \n \t2 <identifier> <identifiersep> job <identifiersep> db <identifiersep> <identifier> = <identifier> . <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> db ( <identifier> , start <identifiersep> date , end <identifiersep> date , connection <identifiersep> <identifier> , <identifier> ) ; <comment> \n \t2 total <identifiersep> <identifier> += <identifier> <identifiersep> job <identifiersep> db <identifiersep> <identifier> . size ( ) ; \n \t2 for ( int <identifier> = 0 ; <identifier> < <identifier> <identifiersep> job <identifiersep> db <identifiersep> <identifier> . size ( ) ; <identifier> ++ ) { \n <ect>
\t2 <comment> \n \t2 session . <identifier> ( job <identifiersep> id , session . <identifier> ) \n \t2 } catch { \n \t2 case e : exception = > \n <ect>
\t2 logger . error ( <string_literal> , entry . get <identifiersep> value ( ) , e ) ; } } \n \t1 for ( entry < string , source <identifiersep> <identifier> > entry : \n \t2 <identifier> <identifiersep> configuration . get <identifiersep> source <identifiersep> <identifier> ( ) . entry <identifiersep> set ( ) ) { \n \t1 try { \n <ect>
\t1 else : \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) \n \t1 if <identifier> ( <identifier> <identifiersep> <identifier> ) > 0 : \n \t1 ignore <identifiersep> list = [ <identifier> [ <string_literal> ] for <identifier> in <identifier> <identifiersep> <identifier> ] \n <ect>
\t4 ) . get ( ) ; \n \t2 assert <identifiersep> that ( put <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) , equal <identifiersep> to ( true ) ) ; \n \t2 create <identifiersep> index ( <string_literal> , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t8 network <identifiersep> <identifier> <identifiersep> answer answer = null ; \n \t8 try { \n \t9 answer = ( network <identifiersep> <identifier> <identifiersep> answer ) <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> send ( <identifier> . get <identifiersep> host <identifiersep> id ( ) , <identifier> <identifiersep> cmd ) ; \n \t8 } catch ( final exception e ) { \n <ect>
\t2 <identifier> . set <identifiersep> code ( <string_literal> ) ; \n \t2 api <identifiersep> context api <identifiersep> context = new api <identifiersep> context ( ) ; \n \t2 api <identifiersep> context . set <identifiersep> configuration <identifiersep> map ( configuration <identifiersep> map ) ; \n \t2 info = <identifier> . create <identifiersep> from <identifiersep> <identifier> <identifiersep> code ( api <identifiersep> context , <identifier> ) ; \n <ect>
\t3 return <identifier> <identifiersep> authentication <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> authentication <identifiersep> <identifier> ( application <identifiersep> context ) . values ( ) . stream ( ) \n \t4 . filter ( p - > p . <identifier> ( provider <identifiersep> id ) ) \n \t4 . find <identifiersep> first ( ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t2 i <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cmd . add ( <string_literal> , pool . get <identifiersep> source <identifiersep> host ( ) + <string_literal> + pool . get <identifiersep> source <identifiersep> port ( ) ) ; \n \t2 i <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cmd . add ( <string_literal> , <string_literal> ) ; \n \t2 string result = i <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cmd . execute ( ) ; \n \t2 if ( result != null ) { \n <ect>
\t6 <identifier> . get <identifiersep> <identifier> ( ) . request ( request ) ; } \n \t5 break ; } } \n \t2 } catch ( exception e ) { \n \t3 handle <identifiersep> exception ( this . get <identifiersep> name ( ) , e ) ; } \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> service ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n \t5 <identifier> = true ; \n <ect>
\t2 try { \n \t2 vm <identifiersep> instance entity = <identifier> . <identifier> <identifiersep> result ( vm <identifiersep> instance . <identifier> ( null , input ) ) ; \n \t2 <identifier> . delete ( entity ) ; \n \t2 } catch ( final no <identifiersep> such <identifiersep> element <identifiersep> exception ex ) { \n <ect>
\t2 if ( result == null || result . is <identifiersep> empty ( ) ) { \n \t3 log . warn ( <string_literal> , job <identifiersep> id , check <identifiersep> path ) ; \n \t3 return 0 ; \n \t2 } else if ( result . size ( ) > 1 ) { \n <ect>
\t3 this . <identifier> = new <identifier> ( <string_literal> + get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> ) ; \n \t3 try { \n \t4 this . <identifier> . start ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> node . delete <identifiersep> node ( <identifier> ) ) { \n \t4 if ( test ) { \n \t5 data <identifiersep> <identifier> <identifiersep> node find = <identifier> <identifiersep> node . get <identifiersep> node ( <identifier> ) ; \n \t5 if ( find != null && find == <identifier> ) { \n <ect>
\t2 if ( <identifier> <identifiersep> manager instanceof <identifier> ) { \n \t3 try { \n \t4 ( ( <identifier> ) <identifier> <identifiersep> manager ) . <identifier> ( ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 out . close ( ) ; \n \t3 out = null ; } \n \t2 catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 if ( <identifier> <identifiersep> string <identifiersep> <identifier> . is <identifiersep> not <identifiersep> empty <identifiersep> or <identifiersep> <identifier> <identifiersep> <identifier> ( create <identifiersep> type ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> type = <identifier> <identifiersep> <identifier> . get <identifiersep> resource <identifiersep> manager ( ) . get <identifiersep> resource <identifiersep> type ( create <identifiersep> type ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 delete <identifiersep> <identifier> <identifiersep> ticket ( ticket <identifiersep> id ) ; \n \t5 return null ; } \n \t4 return result ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t3 throw new exception ( <string_literal> ) ; } \n \t2 final string <identifier> <identifiersep> id = stream <identifiersep> <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> <identifiersep> id <identifiersep> string ( get <identifiersep> <identifier> ( ) . get <identifiersep> job <identifiersep> id ( ) , <identifier> <identifiersep> id , \n \t4 get <identifiersep> <identifier> ( ) . get <identifiersep> task <identifiersep> info ( ) . get <identifiersep> index <identifiersep> of <identifiersep> this <identifiersep> <identifier> ( ) ) ; \n \t2 final long <identifier> <identifiersep> wait <identifiersep> time = get <identifiersep> configuration ( ) . get <identifiersep> <identifier> <identifiersep> wait <identifiersep> time ( ) ; \n <ect>
\t3 if ( ! result . first ( ) ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> ip + <string_literal> + result . <identifier> ( ) ) ; \n \t4 return new answer ( cmd , false , <string_literal> + result . <identifier> ( ) ) ; } \n <ect>
\t9 try { \n \t10 log . info ( <string_literal> ) ; \n \t10 assert <identifiersep> true ( <string_literal> , <identifier> <identifiersep> message <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) ; \n \t10 assert <identifiersep> true ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) ; \n <ect>
\t4 class entity <identifiersep> class = class . for <identifiersep> name ( class <identifiersep> name ) ; \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> entity <identifiersep> data <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> by <identifiersep> class ( entity <identifiersep> class ) ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> entity <identifiersep> data <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( entity <identifiersep> class ) ; } \n \t3 } else { \n <ect>
\t3 string ip <identifiersep> string = <identifier> . to <identifiersep> string ( config . get ( <string_literal> ) , null ) ; \n \t3 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( ip <identifiersep> string ) ) { \n \t4 ip <identifiersep> address = ip <identifiersep> string ; } \n \t3 if ( <identifier> <identifiersep> port == null && ip <identifiersep> address == null ) { \n <ect>
<number_literal> . build ( ) ; \n \t4 response . add <identifiersep> <identifier> <identifiersep> store <identifiersep> <identifier> ( store <identifiersep> response ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 response . set <identifiersep> error ( <identifier> <identifiersep> utils . <identifier> <identifiersep> error ( error <identifiersep> code <identifiersep> <identifier> , e ) ) ; \n <ect>
\t2 <comment> \n \t2 logger . info ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> files ( <string_literal> ) ; \n \t2 <comment> \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> == null ) continue ; \n \t3 <identifier> property <identifiersep> <identifier> = <identifier> <identifiersep> manager . get <identifiersep> uri <identifiersep> <identifier> ( property <identifiersep> uri ) ; \n \t3 if ( property <identifiersep> <identifier> == null ) continue ; \n \t3 <identifier> <identifiersep> type <identifier> <identifiersep> type = new <identifier> <identifiersep> type ( <identifier> <identifiersep> node . get <identifiersep> <identifier> <identifiersep> node <identifiersep> id ( ) , property <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , null , false , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> model , <identifier> ) ; \n <ect>
\t5 final <identifier> <identifiersep> unit <identifier> = java <identifiersep> <identifier> . parse ( file <identifiersep> content ) ; \n \t5 index . add ( <identifier> ) ; \n \t5 <identifier> <identifiersep> count ++ ; \n \t4 } catch ( final parse <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t4 <identifier> <identifiersep> to <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> files . values ( ) ) ; \n \t4 try { \n \t5 state <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> all <identifiersep> state <identifiersep> <identifier> ( <identifier> <identifiersep> to <identifiersep> <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 int i = 0 ; \n \t2 logger . debug ( <string_literal> + i ++ ) ; \n \t2 logger . info ( <string_literal> + i ++ ) ; \n \t2 logger . warn ( <string_literal> + i ++ ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> ( new remote <identifiersep> <identifier> < user > ( ) { \n \t2 @ <identifier> \n \t2 public void <identifier> ( user user ) { \n \t3 final string name = ( user . get <identifiersep> property ( first <identifiersep> name ) != null ) ? user . get <identifiersep> property ( first <identifiersep> name ) : <string_literal> ; \n <ect>
\t3 system . <identifier> ( 1 ) ; } \n \t2 if ( http <identifiersep> <identifier> <identifiersep> port != 0 ) { \n \t3 <identifier> <identifiersep> http <identifiersep> <identifier> ( ) ; \n \t2 } else { \n <ect>
<comment> \n \t1 public void message <identifiersep> <identifier> ( <identifier> <identifiersep> message <identifiersep> <identifier> <identifier> , <identifier> <identifiersep> message message ) { \n \t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 string <identifier> <identifiersep> name = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ( address ) ) ; \n \t3 if ( <identifier> <identifiersep> name == null ) { \n <ect>
\t2 output . write ( entry . get <identifiersep> key ( ) ) ; \n \t2 output . write ( <string_literal> ) ; \n \t2 output . write ( entry . get <identifiersep> value ( ) ) ; \n \t2 output . write ( <string_literal> ) ; } \n <ect>
\t4 <identifier> = test ; \n \t4 last = test ; \n \t3 } else { \n \t4 max = test ; } } \n <ect>
\t4 boolean result = false ; \n \t4 try { \n \t5 result = ( ( node <identifiersep> <identifier> ) get <identifiersep> node ( ) ) . <identifier> <identifiersep> <identifier> <identifiersep> query ( <identifier> <identifiersep> <identifier> <identifiersep> query , <identifier> ) ; \n \t4 } catch ( final exception ex ) { \n <ect>
\t3 else <identifier> . <identifier> ( socket , status ) ; \n \t3 if ( <identifier> && get <identifiersep> <identifier> ( ) != null ) get <identifiersep> <identifier> ( ) . execute ( <identifier> ) ; \n \t3 else <identifier> . run ( ) ; \n \t2 } catch ( <identifier> <identifiersep> execution <identifiersep> exception <identifier> ) { \n <ect>
\t2 class <identifier> <identifiersep> filter <identifiersep> <identifier> { \n \t3 final <identifier> <identifiersep> filter <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> filter <identifiersep> <identifier> ( ) ; \n \t3 final i <identifiersep> filter <identifiersep> code <identifiersep> system <identifier> = new <identifier> <identifiersep> filter <identifiersep> code <identifiersep> <identifier> ( ) ; \n \t3 <identifier> <identifiersep> filter <identifiersep> <identifier> ( ) { \n <ect>
\t7 break ; } } \n \t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> enabled ) { \n \t6 result = <identifier> <identifiersep> host <identifiersep> <identifier> ( conn , <string_literal> , <string_literal> , <string_literal> , vm <identifiersep> name ) ; \n \t6 if ( result == null || result . is <identifiersep> empty ( ) || ! boolean . parse <identifiersep> boolean ( result ) ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> access <identifiersep> exception e ) { \n \t3 <comment> \n \t3 <identifier> . <identifier> ( result <identifiersep> <identifier> <identifiersep> access <identifiersep> exception ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 try : \n \t2 if not self . <identifier> <identifiersep> <identifier> . is <identifiersep> registered : \n \t2 self . <identifier> ( ) \n \t2 <identifier> <identifiersep> body = self . get <identifiersep> <identifier> <identifiersep> body ( ) \n <ect>
\t3 user <identifiersep> context <identifier> = user <identifiersep> context . current ( ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> static <identifiersep> <identifier> ( ip . get <identifiersep> id ( ) , <identifier> . get <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> <identifier> <identifiersep> user <identifiersep> id ( ) , true ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n \t4 return <identifier> <identifiersep> service . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . length == 1 ; } \n \t2 } ) ) ; \n <ect>
\t2 assert <identifiersep> equals ( <string_literal> , \n \t4 test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> text ( ) ) ; \n \t2 string <identifier> <identifiersep> <identifier> <identifiersep> url = assert <identifiersep> <identifier> <identifiersep> and <identifiersep> get <identifiersep> url ( <identifier> <identifiersep> server <identifiersep> configuration . from , user . get <identifiersep> <identifier> ( ) , \n \t4 <string_literal> , true ) ; \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 try { \n \t2 <identifier> . close ( ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 context = <identifier> <identifiersep> context <identifiersep> factory . get <identifiersep> context ( <identifier> <identifiersep> v <identifiersep> <identifier> <identifiersep> address , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> password ) ; \n \t3 s <identifiersep> service <identifiersep> context . set ( context ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 if ( ! ignore <identifiersep> failure ) { \n \t2 log . error ( <string_literal> , query , e ) ; \n \t2 throw e ; \n \t1 } else { \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> == 0 ) <identifier> <identifiersep> <identifier> = 1 . <identifier> ; \n \t4 else <identifier> <identifiersep> <identifier> = ( float ) <identifier> / <identifier> <identifiersep> <identifier> ; \n \t4 if ( log <identifiersep> debug ) logger . debug ( <identifier> . class , <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t4 if ( node . <identifier> . next <identifiersep> float ( ) < <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> . get ( ) ; \n \t1 <identifier> . <identifier> ( <identifier> . <identifier> <identifiersep> mode , <identifier> <identifiersep> public <identifiersep> key , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get ( ) ) ; \n \t1 return new string ( <identifier> . <identifier> ( <identifier> . do <identifiersep> final ( data . get <identifiersep> bytes ( ) ) ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . put ( header , <identifier> . new <identifiersep> array <identifiersep> list ( <identifier> <identifiersep> list . get ( 0 ) ) ) ; \n \t1 } else { \n \t2 <identifier> <identifiersep> <identifier> . put ( header , <identifier> <identifiersep> list ) ; } } \n \t1 if ( found <identifiersep> <identifier> ) { \n <ect>
<comment> \n <comment> \n <comment> \n \t3 logger . debug ( <string_literal> + this . <identifier> . <identifier> <identifiersep> set ( ) . size ( ) ) ; \n <ect>
\t4 <identifier> <identifiersep> node <identifier> <identifiersep> node = <identifier> . get <identifiersep> <identifier> <identifiersep> node <identifiersep> by <identifiersep> <identifier> <identifiersep> node <identifiersep> id ( <identifier> <identifiersep> node <identifiersep> id ) ; \n \t4 if ( <identifier> <identifiersep> node . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null ) { \n \t5 <comment> \n \t5 <comment> \n <ect>
\t2 { \n \t3 <identifier> . <identifier> ( ) ; } } \n \t1 private synchronized void <identifier> ( throwable e ) \n \t1 { \n <ect>
\t2 { \n \t3 assert . <identifier> ( <string_literal> ) ; } \n \t2 synchronized ( this ) { \n \t3 if ( ! all <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 } else { \n \t3 if ( configuration . get <identifiersep> key <identifiersep> store <identifiersep> file ( ) == null && configuration . get <identifiersep> key <identifiersep> store <identifiersep> resource ( ) == null ) { \n \t4 log . debug ( <string_literal> ) ; } \n \t3 if ( configuration . get <identifiersep> <identifier> <identifiersep> store <identifiersep> file ( ) == null && configuration . get <identifiersep> <identifier> <identifiersep> store <identifiersep> resource ( ) == null ) { \n <ect>
\t5 snapshot <identifiersep> data <identifiersep> store <identifiersep> vo <identifier> <identifiersep> snapshot <identifiersep> store = snapshot <identifiersep> data <identifiersep> store <identifiersep> dao . find <identifiersep> by <identifiersep> store <identifiersep> snapshot ( data <identifiersep> store . get <identifiersep> <identifier> ( ) , data <identifiersep> store . get <identifiersep> id ( ) , <identifier> <identifiersep> id ) ; \n \t5 if ( <identifier> <identifiersep> snapshot <identifiersep> store != null ) { \n \t6 return snapshot <identifiersep> data <identifiersep> store <identifiersep> dao . remove ( <identifier> <identifiersep> snapshot <identifiersep> store . get <identifiersep> id ( ) ) ; \n \t5 } else { \n <ect>
\t2 for ( <identifier> <identifiersep> table <identifiersep> <identifier> <identifier> : <identifier> ) \n \t2 { \n \t3 <identifier> . add ( new <identifier> < > ( <identifier> . first . get <identifiersep> token ( ) , <identifier> . last . get <identifiersep> token ( ) ) ) ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> time <identifiersep> <identifier> ( ) ) ; \n <ect>
\t1 public void context <identifiersep> <identifier> ( <identifier> <identifiersep> context <identifiersep> event <identifier> ) { \n \t2 try { \n \t3 <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 device . get <identifiersep> <identifier> <identifiersep> storage <identifiersep> path ( ) , \n \t1 <string_literal> \n \t1 ) . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t1 <comment> \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void stop ( <identifier> <identifiersep> context <identifier> ) throws exception { \n \t2 context = null ; \n <ect>
\t2 } catch ( io <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } } \n \t1 public void test <identifiersep> <identifier> ( ) { \n \t2 string [ ] <identifier> = <string_literal> . <identifier> ( <string_literal> ) ; \n <ect>
@ <identifier> \n public list < <identifier> <identifiersep> item > <identifier> ( long user <identifiersep> id , int <identifier> <identifiersep> <identifier> , id <identifiersep> <identifier> <identifier> , boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t1 throws <identifier> <identifiersep> exception { \n \t1 <identifier> . check <identifiersep> argument ( <identifier> <identifiersep> <identifier> >= 1 , <string_literal> ) ; \n <ect>
\t2 byte [ ] content = <identifier> . get <identifiersep> bytes ( ) ; \n \t2 <identifier> e = null ; \n \t2 for ( ; ; ) { \n \t3 <identifier> i = <identifier> . <identifier> <identifiersep> <identifier> ( name , e , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , null , null , null ) ; \n <ect>
\t4 if ( <identifier> != null && <identifier> . get <identifiersep> status ( ) == <identifier> <identifiersep> status <identifiersep> enum . <identifier> ) { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; } } } } \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> name ) { \n <ect>
\t3 if ( num <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> > 0 && <identifier> . should <identifiersep> send <identifiersep> <identifier> ( key , <identifier> <identifiersep> key , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t4 for ( int i = 0 ; i < num <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ; i ++ ) \n \t5 <identifier> <identifiersep> <identifier> . add ( new session <identifiersep> <identifier> ( true ) ) ; \n \t4 if ( log . should <identifiersep> log ( log . info ) ) \n <ect>
\t3 <identifier> = new object <identifiersep> output <identifiersep> stream ( <identifier> ) ; \n \t3 <identifier> . write <identifiersep> object ( object ) ; \n \t3 result = <identifier> . to <identifiersep> byte <identifiersep> array ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 object <identifiersep> path <identifier> <identifiersep> entry = new object <identifiersep> path ( <identifier> <identifiersep> path ) ; \n \t2 if ( <identifier> <identifiersep> api <identifiersep> <identifier> . client . get <identifiersep> system <identifiersep> metadata ( <identifier> <identifiersep> entry ) == null ) { \n \t3 throw new <identifier> <identifiersep> exception ( <identifier> <identifiersep> path + <string_literal> ) ; } \n \t2 if ( ! <identifier> <identifiersep> entry . is <identifiersep> directory ( ) ) { \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 log . <identifier> ( <string_literal> ) ; \n \t2 log . <identifier> ( <string_literal> , new exception ( <string_literal> ) ) ; \n <ect>
\t4 <identifier> <identifiersep> id , exception <identifiersep> utils . get <identifiersep> root <identifiersep> <identifier> ( e ) ) } } \n \t1 current <identifiersep> job <identifiersep> manager <identifier> { \n \t2 <identifier> = > <identifier> ! <identifier> <identifiersep> message ( <identifier> ( instance <identifiersep> id , <identifier> <identifiersep> <identifier> ) ) } } \n \t1 catch { \n <ect>
\t4 { \n \t5 <identifier> <identifiersep> stream . close ( ) ; } } \n \t3 catch ( io <identifiersep> exception ex ) \n \t3 { \n <ect>
\t1 builder . set <identifiersep> channel <identifiersep> <identifier> ( channel <identifiersep> <identifier> ) ; \n \t1 return builder ; } \n @ <identifier> \n public synchronized void stop ( ) { \n <ect>
\t1 final <identifier> <identifiersep> service <identifier> = ( <identifier> <identifiersep> service ) class . for <identifiersep> name ( <string_literal> ) . new <identifiersep> instance ( ) ; \n \t1 log . debug ( <string_literal> ) ; \n \t1 return <identifier> ; \n \t1 } catch ( final exception e ) { \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 final <identifier> s = <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( file ) ) ; \n \t2 config . set <identifiersep> <identifier> ( s ) ; \n \t2 this . directory <identifiersep> server = new in <identifiersep> <identifier> <identifiersep> directory <identifiersep> server ( config ) ; \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( list < <identifier> < <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> > > <identifier> <identifiersep> by <identifiersep> target ) { \n \t2 logger . debug ( <string_literal> + integer . to <identifiersep> string ( <identifier> <identifiersep> by <identifiersep> target . size ( ) ) ) ; \n \t2 logger . debug ( <string_literal> ) ; \n \t2 location <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
# \n # <identifier> the <identifier> policy for <identifier> server . \n # \n <identifier> <identifier> <identifiersep> <identifier> <identifiersep> policy ( <identifier> ) : \n <ect>
\t2 <comment> \n \t2 file <identifier> <identifiersep> dir = \n \t3 ( file ) <identifier> <identifiersep> context . get <identifiersep> attribute ( <identifier> <identifiersep> context . <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> dir == null ) { \n <ect>
\t2 <identifier> . get <identifiersep> <identifier> <identifiersep> update <identifiersep> response ( ) . set <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t3 get <identifiersep> <identifier> <identifiersep> <identifier> ( operation <identifiersep> handle ) ) ; } \n \t1 <identifier> . set <identifiersep> status ( <identifier> <identifiersep> status ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 command <identifiersep> <identifier> . put <identifiersep> all ( command <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t1 <comment> \n \t1 for ( service service : cluster . get <identifiersep> <identifier> ( ) . values ( ) ) { \n \t1 service <identifiersep> info service <identifiersep> info <identifiersep> instance = <identifier> <identifiersep> map . get ( service . get <identifiersep> name ( ) ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void process <identifiersep> <identifier> <identifiersep> configuration ( final string context , final item item , final string <identifier> <identifiersep> config ) \n \t3 throws <identifier> <identifiersep> config <identifiersep> parse <identifiersep> exception { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> <identifiersep> info ( remote <identifiersep> <identifier> . get <identifiersep> <identifier> ( <string_literal> , t ) , t . get <identifiersep> request <identifiersep> <identifier> ( ) . get <identifiersep> first ( <string_literal> ) ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> resource r = root . get <identifiersep> <identifier> <identifiersep> resource ( id , <identifier> ) ; \n \t2 if ( r == null ) { \n <ect>
\t7 state . current <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> . exchange <identifiersep> id , new <identifiersep> <identifier> , \n \t9 <identifier> . <identifier> <identifiersep> request , <identifier> . <identifier> <identifiersep> <identifier> , client <identifiersep> context , <identifier> . <identifier> <identifiersep> runtime ) ; } } } \n \t4 if ( state . <identifier> <identifiersep> uri != null ) { \n <ect>
\t1 } catch ( exception exception ) { \n \t2 log . warn ( <string_literal> , exception ) ; } } \n \t1 void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> task <identifiersep> service ( ) { \n \t1 if ( ! is <identifiersep> <identifier> ( ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <number_literal> ) ; \n \t4 log . info ( <string_literal> ) ; } } \n \t2 task <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> output <identifiersep> <identifier> ( <identifier> ) ; \n \t2 task <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t4 if ( client != null ) \n \t5 client . <identifier> <identifiersep> close ( ) ; \n \t4 if ( <identifier> == <identifier> <identifiersep> <identifier> || conn <identifiersep> <identifier> > max <identifiersep> conn <identifiersep> timeout ) { \n <ect>
\t1 public void process ( exchange exchange ) throws exception { \n \t2 <identifier> <identifiersep> <identifier> msg = exchange . get <identifiersep> in ( ) . get <identifiersep> body ( <identifier> <identifiersep> <identifier> . class ) ; \n \t2 <comment> \n \t2 <identifier> <identifier> = get <identifiersep> <identifier> ( msg ) ; \n <ect>
\t1 return failed <identifiersep> <identifier> ; } } \n private static final class <identifier> <identifiersep> shutdown implements <identifier> { \n \t1 @ <identifier> \n \t1 public void run ( ) { \n <ect>
\t2 log . debug ( <string_literal> , <identifier> <identifiersep> key ) ; } \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( action action , string <identifier> <identifiersep> id ) throws <identifier> <identifiersep> exception { \n \t2 <identifier> <identifiersep> key <identifier> <identifiersep> key = <identifier> <identifiersep> <identifier> <identifiersep> key ( action , <identifier> <identifiersep> id ) ; \n \t2 get <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> key ) ; \n <ect>
\t3 m <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = false ; \n \t3 <comment> \n \t3 do <identifiersep> <identifier> <identifiersep> float <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> item , false ) ; \n \t3 m <identifiersep> <identifier> <identifiersep> time = m <identifiersep> <identifier> <identifiersep> time ; \n <ect>
\t2 final ticket ticket = get <identifiersep> ticket ( ticket <identifiersep> id ) ; \n \t2 if ( ticket == null ) { \n \t3 return count . int <identifiersep> value ( ) ; } \n \t2 if ( ticket instanceof ticket <identifiersep> <identifier> <identifiersep> ticket ) { \n <ect>
\t1 <identifier> . check <identifiersep> state ( total == from . length ( ) , \n \t2 <string_literal> ) ; \n \t1 return true ; \n \t1 } catch ( exception ex ) { \n <ect>
\t3 command . add ( <string_literal> ) ; \n \t3 command . add ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t3 string result = command . execute ( ) ; \n \t3 if ( result != null ) { \n <ect>
<comment> \n \t1 public map < string , vm > list <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception { \n \t2 object [ ] result = ( object [ ] ) <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 if ( result == null ) { \n <ect>
\t1 <comment> \n \t1 text <identifiersep> input <identifiersep> format input <identifiersep> format = new text <identifiersep> input <identifiersep> format ( ) ; \n \t1 list < ? > <identifier> = input <identifiersep> format . get <identifiersep> <identifier> ( job ) ; \n \t1 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t5 } catch ( io <identifiersep> exception e ) { \n \t6 log . warn ( <string_literal> , e ) ; } \n \t5 break ; \n \t4 default : \n <ect>
public void set <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . <identifier> value ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( value , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> . <identifier> . <identifier> value ) { \n <ect>
\t1 <identifier> <identifiersep> config = self . <identifier> <identifiersep> config <identifiersep> handler . read <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t1 self . <identifier> ) \n \t1 if <identifier> <identifiersep> config is not <identifier> : \n \t1 <identifier> [ <identifier> <identifiersep> <identifier> ] = <identifier> <identifiersep> config \n <ect>
\t4 final public <identifiersep> ip public <identifiersep> ip = public <identifiersep> ip . create <identifiersep> from <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( ip , <identifier> <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( ip . get <identifiersep> <identifier> <identifiersep> id ( ) ) ) ; \n \t4 if ( ( ip . get <identifiersep> state ( ) == ip <identifiersep> address . state . <identifier> || ip . get <identifiersep> state ( ) == ip <identifiersep> address . state . <identifier> ) \n \t6 && <identifier> <identifiersep> <identifier> . is <identifiersep> ip <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ip ) \n \t6 && ! public <identifiersep> <identifier> . contains ( public <identifiersep> ip . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 log . set <identifiersep> level ( <identifier> <identifiersep> log . log <identifiersep> level <identifiersep> all ) ; \n \t2 <identifier> . set <identifiersep> level ( <identifier> <identifiersep> log . log <identifiersep> level <identifiersep> all ) ; \n \t2 log . <identifier> <identifiersep> message ( ) ; \n \t2 <identifier> . <identifier> <identifiersep> message ( ) ; \n <ect>
<comment> \n @ <identifier> \n public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( ) { \n \t1 if ( ! m <identifiersep> configuration . is <identifiersep> <identifier> <identifiersep> cache <identifiersep> enabled ( ) ) { \n <ect>
\t5 <comment> \n \t5 <comment> \n \t5 <comment> \n \t5 <identifier> <identifiersep> in . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <identifier> , i , <identifier> <identifiersep> in . get <identifiersep> <identifier> <identifiersep> output ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ( ) ) ; \n <ect>
\t1 @ <identifier> \n \t1 private logger log ; \n \t1 @ <identifier> <identifiersep> <identifier> \n \t1 public object <identifier> ( <identifier> <identifiersep> context <identifier> ) throws exception { \n <ect>
\t1 if ( result . is <identifiersep> <identifier> ( ) ) { \n \t1 result = <identifier> <identifiersep> command <identifiersep> <identifier> . set <identifiersep> file <identifiersep> group ( file <identifiersep> path , group <identifiersep> name ) ; \n \t1 if ( ! result . is <identifiersep> <identifier> ( ) ) { \n \t2 <comment> \n <ect>
<comment> \n \t1 private boolean execute <identifiersep> <identifier> <identifiersep> operation ( final set < string > new <identifiersep> <identifier> , final <identifier> <identifiersep> entry entry ) { \n \t2 final map < string , set < string > > <identifier> <identifiersep> map = new <identifier> <identifiersep> map < > ( ) ; \n \t2 <identifier> <identifiersep> map . put ( this . <identifier> . get <identifiersep> <identifier> <identifiersep> attribute <identifiersep> name ( ) , new <identifiersep> <identifier> ) ; \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> start <identifiersep> stop <identifiersep> <identifier> ( ) throws throwable { \n <ect>
\t1 public string url <identifiersep> <identifier> ( string s ) { \n \t2 try { \n \t3 return url <identifiersep> <identifier> . <identifier> ( s , <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> log . info ( <string_literal> + <identifier> <identifiersep> path + <string_literal> + get <identifiersep> data <identifiersep> length ( data ) ) ; \n \t4 <identifier> <identifiersep> create ( <identifier> <identifiersep> path , data , <identifier> , create <identifiersep> mode , string <identifiersep> <identifier> , <identifier> ) ; } \n \t4 break ; \n \t3 default : \n <ect>
\t4 this . <identifier> <identifiersep> run ( ) ; \n \t3 } catch ( throwable t ) { \n \t4 this . <identifier> <identifiersep> <identifier> ( false ) ; \n \t4 this . <identifier> <identifiersep> <identifier> ( false , false , true ) ; \n <ect>
\t8 <identifier> <identifiersep> client <identifiersep> map . put ( node , new <identifier> <identifiersep> client ( node ) ) ; } } \n \t6 string to <identifiersep> <identifier> = <identifier> <identifiersep> event . get <identifiersep> target <identifiersep> node ( ) ; \n \t6 if ( to <identifiersep> <identifier> == null ) \n \t7 to <identifiersep> <identifier> = <string_literal> ; \n <ect>
\t2 super . send <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 send <identifiersep> <identifier> ( ) ; \n \t2 } catch ( not <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> . log <identifiersep> error ( e ) ; } } } \n \t3 if ( <identifier> == 0 ) { \n \t4 log . warn ( <string_literal> + <identifier> <identifiersep> directory + <string_literal> ) ; } \n \t2 } else { \n <ect>
\t4 <identifier> <identifiersep> content <identifiersep> text . set <identifiersep> length ( 0 ) ; } } } \n \t1 private void <identifier> <identifiersep> parse <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> content <identifiersep> text != null ) { \n <ect>
\t4 try { \n \t5 if ( <identifier> . get <identifiersep> url ( ) == null || <identifier> . get <identifiersep> url ( ) . get <identifiersep> <identifier> ( <identifier> . runtime <identifiersep> key , false ) ) { \n \t6 <identifier> = <identifier> . <identifier> ( <identifier> , get <identifiersep> consumer <identifiersep> url ( ) , <identifier> ) ; } \n \t4 } catch ( throwable t ) { \n <ect>
\t2 { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 logger . debug ( <string_literal> + \n \t5 to <identifiersep> time <identifiersep> string ( <identifier> . v ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> collection <identifiersep> <identifier> , total <identifiersep> time ) ) ; } \n <ect>
\t4 final set < object > attribute <identifiersep> values = collection <identifiersep> utils . to <identifiersep> collection ( entry . get <identifiersep> value ( ) ) ; \n \t4 logger . debug ( <string_literal> , attribute <identifiersep> name , attribute <identifiersep> values ) ; \n \t4 final collection < <identifier> > <identifier> = create <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> attribute ( attribute <identifiersep> name ) ; \n \t4 <identifier> . for <identifiersep> <identifier> ( <identifier> - > { \n <ect>
\t2 <identifier> . set <identifiersep> double ( <number_literal> , value ) ; \n \t2 log . debug ( <string_literal> , set <identifiersep> <identifier> <identifiersep> sql ) ; \n \t2 <identifier> . execute <identifiersep> update ( ) ; } \n \t1 } catch ( sql <identifiersep> exception <identifier> ) { \n <ect>
\t1 private data <identifiersep> store <identifiersep> request create <identifiersep> request ( string message ) { \n \t2 try { \n \t3 return request <identifiersep> from <identifiersep> text <identifiersep> factory . create <identifiersep> request ( message ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t2 if ( <identifier> <identifiersep> id <identifiersep> <identifier> != null ) { \n \t3 try { \n \t4 this . <identifier> <identifiersep> id = integer . parse <identifiersep> int ( <identifier> <identifiersep> id <identifiersep> <identifier> ) ; \n \t3 } catch ( java . <identifier> . number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t7 } catch ( illegal <identifiersep> <identifier> <identifiersep> name <identifiersep> exception <identifier> ) { \n \t8 logger . warn ( <string_literal> , <identifier> ) ; } } \n \t6 return io <identifiersep> utils . to <identifiersep> input <identifiersep> stream ( result , <identifier> ) ; \n \t5 } catch ( throwable t ) { \n <ect>
\t2 <comment> \n \t2 log . info ( <string_literal> + ( <identifier> == store . get ( <string_literal> ) ) ) ; \n \t2 log . info ( <string_literal> + ( <identifier> == store . get ( <string_literal> ) ) ) ; \n \t2 log . info ( <string_literal> + ( <identifier> == store . get ( <string_literal> ) ) ) ; \n <ect>
\t1 log . debug ( <string_literal> , <identifier> , value ) ; } \n \t1 conf . set <identifiersep> <identifier> ( <identifier> , value ) ; } \n private static void set <identifiersep> <identifier> <identifiersep> conf ( <identifier> <identifiersep> conf conf , <identifier> <identifiersep> conf . conf <identifiersep> <identifier> <identifier> , boolean value ) { \n <ect>
\t8 get <identifiersep> error <identifiersep> handler . handle <identifiersep> <identifier> ( message <identifiersep> event , e ) ; } } \n \t6 break ; \n \t5 case <identifier> <identifiersep> <identifier> <identifiersep> code . get <identifiersep> <identifier> <identifiersep> code : \n <ect>
\t4 try { \n \t5 out . <identifier> ( ) ; \n \t5 out . close ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t4 log . debug ( <string_literal> , object <identifiersep> model <identifiersep> uri ) ; \n \t4 <identifier> <identifiersep> factory = object <identifiersep> <identifier> . is <identifiersep> empty ( <identifier> <identifiersep> factory <identifiersep> class <identifiersep> name ) \n \t5 ? x <identifiersep> path <identifiersep> factory . new <identifiersep> instance ( object <identifiersep> model <identifiersep> uri ) \n \t5 : x <identifiersep> path <identifiersep> factory . new <identifiersep> instance ( object <identifiersep> model <identifiersep> uri , <identifier> <identifiersep> factory <identifiersep> class <identifiersep> name , null ) ; \n <ect>
\t4 process <identifiersep> switch <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> message , <identifier> , endpoint ) ; \n \t4 <identifier> <identifiersep> <identifier> = true ; \n \t4 break ; \n \t3 default : \n <ect>
\t1 <comment> \n \t1 if ( <identifier> <identifiersep> <identifier> > 0 ) { \n \t1 <identifier> < void > action = new <identifier> < void > ( ) { \n \t2 public void <identifier> ( ) throws exception { \n <ect>
\t3 log . warn ( <string_literal> , file . get <identifiersep> path ( ) . to <identifiersep> string ( ) ) ; } \n \t2 continue ; } \n \t1 if ( ! <identifier> . <identifier> <identifiersep> with ( <identifier> . <identifier> <identifiersep> <identifier> + <string_literal> ) \n \t2 && ! file <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . contains ( <identifier> . <identifier> ( <string_literal> ) [ 1 ] ) ) { \n <ect>
\t4 return new result ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> list ( result <identifiersep> list , <identifier> <identifiersep> size , <identifier> ) , <identifier> <identifiersep> result <identifiersep> count , true , false ) ; \n \t3 } catch ( throwable t ) { \n \t4 logger . warn ( <string_literal> , t ) ; } \n \t2 } else { \n <ect>
\t4 return queue <identifiersep> <identifier> . get <identifiersep> in <identifiersep> <identifier> <identifiersep> count ( ) == 0 ; } \n \t2 } ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n \t2 log . info ( <string_literal> , queue <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ) ; \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t3 <string_literal> + \n \t3 <string_literal> + \n \t3 <string_literal> , \n \t3 c . get <identifiersep> command <identifiersep> id ( ) , c . get <identifiersep> task <identifiersep> id ( ) , c . get <identifiersep> <identifier> <identifiersep> command ( ) ) ; \n <ect>
\t4 <identifier> = data <identifiersep> type . to <identifiersep> string ( input . get ( 1 ) ) ; \n \t4 data <identifiersep> <identifier> input <identifiersep> <identifier> = input <identifiersep> <identifier> . get ( <identifier> ) ; \n \t4 if ( input <identifiersep> <identifier> == null || input <identifiersep> <identifier> . size ( ) == 0 ) \n \t4 { \n <ect>
\t1 throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t1 <identifier> <identifiersep> object <identifiersep> <identifier> = object <identifiersep> <identifier> <identifiersep> factory \n \t2 . get <identifiersep> <identifier> <identifiersep> object <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . class , \n \t2 object <identifiersep> <identifier> <identifiersep> factory . object <identifiersep> <identifier> <identifiersep> options . java ) ; \n <ect>
\t5 <identifier> <identifiersep> put ( key <identifiersep> to <identifiersep> <identifier> , value ) ; } \n \t4 <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n \t4 <comment> \n <ect>
\t3 final list < <identifier> < string > > <identifier> = <identifier> . <identifier> <identifiersep> all ( <identifier> ) ; \n \t3 for ( final <identifier> < string > result : <identifier> ) { \n \t4 assert <identifiersep> not <identifiersep> null ( result . get ( ) ) ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t4 if ( <identifier> != null ) \n \t5 handle <identifiersep> response ( <identifier> , msg . <identifier> ( ) , msg . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , msg . get <identifiersep> <identifier> ( ) , msg . get <identifiersep> length ( ) , <identifier> . type == header . <identifier> <identifiersep> <identifier> ) ; \n \t4 break ; \n \t3 default : \n <ect>
\t2 <identifier> <identifiersep> <identifier> = configuration . get ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> property , <string_literal> ) ; \n \t2 <identifier> = configuration . get ( <identifier> <identifiersep> <identifier> <identifiersep> property , <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> = parse <identifiersep> <identifier> <identifiersep> string <identifiersep> <identifier> <identifiersep> collection ( configuration . get ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> property , <string_literal> ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 log . info ( <string_literal> , test <identifiersep> user <identifiersep> id ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> item <identifiersep> exception <identifier> ) { \n <ect>
\t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n \t3 logger . error ( e , <string_literal> , method ) ; \n \t3 <identifier> ( e ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t1 public delete <identifiersep> resource <identifiersep> <identifier> <identifiersep> registered <identifiersep> service <identifiersep> <identifier> ( final abstract <identifiersep> resource <identifiersep> <identifier> <identifiersep> service <identifiersep> <identifier> service <identifiersep> <identifier> <identifiersep> dao ) { \n \t2 super ( service <identifiersep> <identifier> <identifiersep> dao ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( final file file ) { \n <ect>
\t4 string <identifier> = <identifier> . to <identifiersep> string ( ) ; \n \t4 boolean <identifier> <identifiersep> error = <identifier> . <identifier> <identifiersep> with ( <string_literal> ) ; \n \t4 if ( <identifier> <identifiersep> error ) { \n \t5 <identifier> = <identifier> . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; } \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> connection <identifiersep> manager <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> connection <identifiersep> manager ) <identifier> ; \n \t5 <identifier> . <identifier> <identifiersep> connection ( this , <identifier> , <identifier> ) ; \n \t5 return true ; \n \t4 } catch ( throwable t ) { \n <ect>
\t2 try { \n \t3 log . debug ( <string_literal> ) ; \n \t3 state <identifiersep> <identifier> <identifier> <identifiersep> task = <identifier> . <identifier> <identifiersep> new <identifiersep> task ( ) ; \n \t3 int <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n <ect>
public boolean has <identifiersep> next ( ) { \n \t1 try { \n \t1 return <identifier> . next ( ) ; } \n \t1 catch ( exception <identifier> ) { \n <ect>
\t9 <identifier> <identifiersep> <identifier> += <identifier> <identifiersep> <identifier> . get ( 0 ) ; \n \t9 <identifier> <identifiersep> <identifier> += <string_literal> ; \n \t9 <identifier> <identifiersep> <identifier> += <identifier> <identifiersep> <identifier> . get ( 1 ) ; \n \t8 } else { \n <ect>
\t3 if ( task <identifiersep> by <identifiersep> state . contains <identifiersep> key ( create <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> snapshot ) ) { \n \t4 try { \n \t5 this . process <identifiersep> <identifier> <identifiersep> <identifier> ( task <identifiersep> by <identifiersep> state . get ( vm <identifiersep> create <identifiersep> <identifier> <identifiersep> task . create <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> snapshot ) ) ; \n \t4 } catch ( final exception ex ) { \n <ect>
\t3 this . <identifier> <identifiersep> context = create <identifiersep> <identifier> <identifiersep> context ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n \t3 throw object <identifiersep> <identifier> . <identifier> <identifiersep> runtime <identifiersep> <identifier> <identifiersep> exception ( e ) ; } \n \t2 if ( <identifier> <identifiersep> context != null ) { \n <ect>
@ <identifier> \n public void <identifier> ( ) { \n \t1 if ( config . exists ( ) ) { \n \t1 if ( ! config . delete ( ) ) { \n <ect>
\t6 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n \t6 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t6 log . info ( <string_literal> + grid <identifiersep> name ) ; \n <ect>
\t3 if ( data <identifiersep> socket != null ) \n \t4 data <identifiersep> socket . close ( ) ; } \n \t2 catch ( io <identifiersep> exception <identifier> ) \n \t2 { \n <ect>
\t6 log . error ( e . get <identifiersep> message ( ) , e ) ; } } \n \t3 } ) ; \n \t3 <identifier> <identifiersep> <identifier> . stop ( ) ; } } \n \t1 public static void create <identifiersep> <identifier> <identifiersep> account ( string <identifier> , string password ) { \n <ect>
\t4 entity . set <identifiersep> <identifier> ( true ) ; \n \t4 entity . set <identifiersep> content <identifiersep> type ( content <identifiersep> type ) ; \n \t4 method . set <identifiersep> entity ( entity ) ; \n \t4 for ( string key : metadata . key <identifiersep> set ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> result = null ; \n \t2 try { \n \t3 result = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> system <identifiersep> vm ( this ) ; \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t4 . set <identifiersep> <identifier> <identifiersep> last <identifiersep> token ( false ) \n \t4 . set <identifiersep> <identifier> <identifiersep> <identifier> ( <number_literal> ) \n \t4 . execute <identifiersep> with <identifiersep> <identifier> ( <identifier> ) ; \n \t3 set < long > set = <identifier> . get ( ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> != null && string . class . is <identifiersep> instance ( <identifier> <identifiersep> <identifier> ) ) { \n \t3 try { \n \t4 <identifier> = integer . value <identifiersep> of ( ( string ) <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 <identifier> . add <identifiersep> <identifier> <identifiersep> from ( new file ( <identifier> <identifiersep> directory + file . <identifier> ) . to <identifiersep> uri ( ) ) ; \n \t2 this . <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 this . <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . class ) ; \n \t2 this . <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <identifier> ( false ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t6 else \n \t7 <identifier> = message <identifiersep> <identifier> . <identifier> <identifiersep> session ( get <identifiersep> context ( ) ) ; \n \t6 if ( <identifier> != null ) { \n \t7 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t2 log . warn ( <string_literal> ) ; } \n \t1 throw new job <identifiersep> execution <identifiersep> exception ( throwable ) ; } \n \t1 <identifier> . <identifier> <identifiersep> job <identifiersep> <identifier> ( action <identifiersep> bean , action <identifiersep> user , <identifier> , stream <identifiersep> provider ) ; \n \t1 if ( <identifier> <identifiersep> update ) { \n <ect>
\t6 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> host <identifiersep> id ) ; } \n \t5 <identifier> ( vm <identifiersep> <identifier> , new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( vm ) , <identifier> , event . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , true ) ; \n \t5 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + vm ) ; } \n \t3 } catch ( final operation <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 protected network get <identifiersep> network ( connection conn , <identifier> <identifiersep> to <identifier> ) throws <identifier> <identifiersep> api <identifiersep> exception , xml <identifiersep> <identifier> <identifiersep> exception { \n \t2 string name = <identifier> . get <identifiersep> name ( ) ; \n \t2 <identifier> <identifiersep> local <identifiersep> network network = get <identifiersep> native <identifiersep> network <identifiersep> for <identifiersep> <identifier> ( conn , <identifier> . get <identifiersep> type ( ) , name ) ; \n \t2 if ( network == null ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . count <identifiersep> <identifier> ( ) ; \n \t5 <identifier> . close ( ) ; \n \t5 session . close ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
<comment> \n \t1 public message get ( string id ) { \n \t2 <identifier> <identifiersep> <identifier> <identifier> = table . remove ( id ) ; \n <ect>
\t5 logger . error ( this , <string_literal> + e ) ; \n \t4 } finally { \n \t5 <identifier> <identifiersep> <identifier> . close ( ) ; } \n \t3 } catch ( <identifier> <identifiersep> failed <identifiersep> exception e ) { \n <ect>
\t3 for ( service <identifiersep> <identifier> < ? > <identifier> : <identifier> . values ( ) ) { \n \t4 try { \n \t5 <identifier> . <identifier> ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> test <identifiersep> case . num <identifiersep> shards num <identifiersep> shards = get <identifiersep> num <identifiersep> shards ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 final <identifier> <identifiersep> response <identifier> <identifiersep> response = client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <string_literal> ) . execute ( ) . get ( ) ; <comment> \n \t2 final boolean <identifier> <identifiersep> failed = <identifier> <identifiersep> response . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . length != 0 || <identifier> <identifiersep> response . get <identifiersep> failed <identifiersep> shards ( ) != 0 ; \n <ect>
\t3 final ticket <identifiersep> <identifier> metadata = this . ticket <identifiersep> <identifier> . find ( ticket ) ; \n \t3 if ( metadata == null ) { \n \t4 logger . error ( <string_literal> , ticket . get <identifiersep> id ( ) ) ; \n \t4 return null ; } \n <ect>
\t1 @ <identifier> \n \t1 public void close ( ) { \n \t2 log . info ( <string_literal> , map . size ( ) ) ; \n \t2 log . info ( <string_literal> , <identifier> . size ( ) ) ; \n <ect>
\t1 <identifier> . close ( null ) ; \n \t1 input <identifiersep> stream in = socket . get <identifiersep> input <identifiersep> stream ( ) ; \n \t1 <identifier> <identifiersep> base <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> base <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t2 in , null , text . class , job , null , null ) ; \n <ect>
\t3 <identifier> = network <identifiersep> interface . get <identifiersep> network <identifiersep> <identifier> ( ) ; } \n \t2 catch ( socket <identifiersep> exception e ) \n \t2 { \n <ect>
\t5 <comment> \n \t5 <identifier> . channel ( ) . close ( ) ; \n \t5 return ; \n \t4 } else { \n <ect>
\t4 <comment> \n \t4 thread . <identifier> ( <identifier> ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n \t4 <comment> \n <ect>
<number_literal> io <identifiersep> <identifier> <identifiersep> size ) ) ; \n \t5 <identifier> [ <identifier> <identifiersep> id ] [ <identifier> <identifiersep> <identifier> <identifiersep> id ] = new data <identifiersep> output <identifiersep> stream ( new <identifier> <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( data <identifiersep> file ) , \n <number_literal> io <identifiersep> <identifier> <identifiersep> size ) ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> id ++ ; } } } \n <ect>
\t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + template <identifiersep> pool <identifiersep> <identifier> <identifiersep> id ) ; } \n \t2 if ( template <identifiersep> pool <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> state ( ) == status . <identifier> ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t3 if ( <identifier> <identifiersep> config . e <identifiersep> is <identifiersep> set ( <identifier> <identifiersep> config . e <identifiersep> class ( ) . get <identifiersep> e <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ) ) { \n \t4 set <identifiersep> system <identifiersep> code ( <identifier> <identifiersep> config . get <identifiersep> system <identifiersep> code ( ) ) ; \n \t4 system <identifiersep> code <identifiersep> found = true ; \n \t3 } else { \n <ect>
\t2 assert <identifiersep> equals ( <string_literal> , <identifier> . <identifier> <identifiersep> value , <identifier> ) ; \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 int <identifier> = remote <identifiersep> resource . create <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t2 assert <identifiersep> equals ( response <identifiersep> code , <number_literal> ) ; \n \t2 conn . <identifier> ( ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> number <identifiersep> time <identifiersep> out ( ) { \n <ect>
\t4 <identifier> <identifiersep> count ( ) ; \n \t4 return true ; } \n \t3 return false ; \n \t2 } catch ( exception e ) { \n <ect>
protected void <identifier> <identifiersep> group <identifiersep> to <identifiersep> <identifier> ( string <identifier> , string name ) { \n \t1 try { \n \t2 super . <identifier> <identifiersep> group <identifiersep> to <identifiersep> <identifier> ( <identifier> , name ) ; \n \t1 } catch ( <identifier> <identifiersep> response <identifiersep> exception e ) { \n <ect>
\t3 for ( int i = 0 ; i < <identifier> <identifiersep> pool . length ; i ++ ) { \n \t4 <identifier> <identifiersep> pool [ i ] = this . <identifier> <identifiersep> connection ( 0 , null , null ) ; <comment> \n \t3 } <comment> \n \t2 } catch ( sql <identifiersep> exception x ) { \n <ect>
\t5 return new <identifier> <identifiersep> type ( <identifier> <identifiersep> value ) ; \n \t4 case <number_literal> : \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ; \n \t5 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> code ( ) == 0 ) { \n <ect>
\t2 if ( ! result ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + cmd . get <identifiersep> vm <identifiersep> name ( ) ) ; \n \t3 return new security <identifiersep> group <identifiersep> <identifier> <identifiersep> answer ( cmd , false , <string_literal> ) ; \n \t2 } else { \n <ect>
\t5 if ( client != null ) { \n \t6 client . <identifier> <identifiersep> close ( ) ; \n \t6 client = null ; } \n <ect>
\t4 item <identifiersep> service . update ( context , item ) ; \n \t4 <comment> \n \t4 context . <identifier> <identifiersep> <identifier> <identifiersep> system <identifiersep> state ( ) ; } \n \t2 } catch ( sql <identifiersep> exception | <identifier> <identifiersep> exception | io <identifiersep> exception e ) { \n <ect>
\t4 account <identifiersep> vo account = <identifier> <identifiersep> account <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> <identifiersep> account . get <identifiersep> id ( ) ) ; \n \t4 if ( account == null ) { \n \t5 continue ; <comment> \n <ect>
\t1 protected void check <identifiersep> <identifier> ( ) { \n \t2 boolean <identifier> <identifiersep> <identifier> = check <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , false ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> != <identifier> <identifiersep> is <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 if ( ! <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 set < integer > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> set < integer > ( ) ; \n \t1 for ( int <identifier> = 0 ; <identifier> < total <identifiersep> files ; <identifier> ++ ) { \n \t2 if ( this . get <identifiersep> <identifier> <identifiersep> context ( ) != null && this . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> file <identifiersep> id ( ) != null ) { \n <ect>
\t3 file [ ] files = dir . list <identifiersep> files ( ) ; \n \t3 for ( file file : files ) { \n \t4 if ( file . get <identifiersep> name ( ) . to <identifiersep> <identifier> <identifiersep> case ( ) . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t5 <identifier> . add ( file . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ) ; \n <ect>
\t5 public void run ( ) { \n \t6 try { \n \t7 stop <identifiersep> and <identifiersep> <identifier> <identifiersep> listener <identifiersep> <identifier> ( ) ; \n \t6 } catch ( throwable e ) { \n <ect>
<comment> \n \t1 public static <identifier> <identifiersep> <identifier> file <identifiersep> <identifier> <identifiersep> <identifier> ( http <identifiersep> action action , stream <identifiersep> <identifier> <identifier> ) { \n \t2 string base = action <identifiersep> <identifier> . <identifier> <identifiersep> request <identifiersep> url ( action . request ) ; \n \t2 <identifier> <identifiersep> file <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> file <identifiersep> <identifier> ( ) ; \n <ect>
\t3 file <identifiersep> name = <identifier> <identifiersep> url <identifiersep> to <identifiersep> file <identifiersep> name ( file <identifiersep> name ) ; \n \t3 file host <identifiersep> dir = new file ( <identifier> . get <identifiersep> configuration ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , host <identifiersep> name ) ; \n \t3 if ( ! host <identifiersep> dir . is <identifiersep> directory ( ) ) { \n \t4 if ( ! host <identifiersep> dir . <identifier> ( ) ) { \n <ect>
\t3 try { \n \t4 if ( out != null && out . get <identifiersep> <identifier> <identifiersep> message ( ) != null ) { \n \t5 out . set <identifiersep> message <identifiersep> id ( out . get <identifiersep> <identifier> <identifiersep> message ( ) . get <identifiersep> <identifier> <identifiersep> message <identifiersep> id ( ) ) ; } \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t4 break ; \n \t3 case <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : \n \t3 default : \n \t4 <identifier> <identifiersep> <identifier> = message <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> ; } \n <ect>
\t2 <identifier> . and ( <identifier> . entity ( ) . get <identifiersep> type ( ) , <identifier> . <identifier> , host . type . routing ) ; \n \t2 <identifier> . and ( <identifier> . entity ( ) . get <identifiersep> <identifier> <identifiersep> server <identifiersep> id ( ) , <identifier> . <identifier> , <identifier> <identifiersep> id ) ; \n \t2 list < host <identifiersep> vo > all <identifiersep> <identifier> = <identifier> . list ( ) ; \n \t2 if ( all <identifiersep> <identifier> . size ( ) < = <identifier> <identifiersep> load ) { \n <ect>
\t2 # <identifier> <identifier> <identifier> return 1 if <identifier> <identifier> no <identifier> <identifier> , \n \t2 # <identifier> do not check the return value . \n \t2 # \n \t2 if cmd . <identifier> ( ) != command . <identifier> : \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> find <identifiersep> vm <identifiersep> on <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> host ( string name ) throws exception { \n \t2 int key = get <identifiersep> <identifier> <identifiersep> field <identifiersep> key ( <string_literal> , <identifier> <identifiersep> field <identifiersep> <identifier> . <identifier> <identifiersep> vm <identifiersep> <identifier> <identifiersep> name ) ; \n \t2 if ( key == 0 ) { \n <ect>
\t3 if ( ! <string_literal> . equals ( value ) ) { \n \t4 log . warn ( <string_literal> , <identifier> <identifiersep> info . get <identifiersep> name ( ) , value ) ; } \n \t3 <identifier> . set <identifiersep> null ( db <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> info . get <identifiersep> type ( ) ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t6 try ( file <identifiersep> input <identifiersep> stream <identifier> = new file <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> file ) ) { \n \t7 remote <identifiersep> <identifier> . load ( <identifier> ) ; \n \t6 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> \n <ect>
\t2 user <identifiersep> account user = this . <identifier> <identifiersep> user <identifiersep> account <identifiersep> dao . get <identifiersep> user <identifiersep> account ( <identifier> , <identifier> <identifiersep> id ) ; \n \t2 if ( user != null ) { \n \t3 is <identifiersep> <identifier> <identifiersep> user = true ; \n \t2 } else { \n <ect>
\t2 } catch ( <identifier> . handle <identifiersep> <identifier> e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + cmd + <string_literal> + get <identifiersep> <identifier> <identifiersep> string ( <identifier> ) \n \t5 + <string_literal> + e . <identifier> + <string_literal> + e . handle ) ; \n \t2 } catch ( <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t5 public void run ( ) { \n \t6 try { \n \t7 <identifier> . listener . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , new <identifiersep> <identifier> ) ; \n \t6 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> == null ) { \n \t4 logger . debug ( <string_literal> , <identifier> ) ; \n \t4 <identifier> = r ; } \n \t3 if ( <identifier> == null ) { \n <ect>
\t1 long timeout = <identifier> <identifiersep> storage <identifiersep> info . get <identifiersep> storage <identifiersep> info ( ) . get <identifiersep> timeout <identifiersep> in <identifiersep> millis ( ) ; \n \t1 <identifier> <identifiersep> service . delete <identifiersep> user ( <identifier> , timeout ) ; } \n <comment> \n public void <identifier> <identifiersep> target ( string volume <identifiersep> id , int <identifier> , string name , int <identifier> , string path , string user ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n <ect>
\t3 assert . <identifier> ( <string_literal> ) ; } \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> wait ( ) throws exception { \n <ect>
\t4 { \n \t5 <identifier> <identifiersep> <identifier> <identifier> = meta . get ( <identifier> ) ; \n \t5 byte <identifiersep> <identifier> <identifier> <identifiersep> value = <identifier> . get <identifiersep> bytes ( <identifier> . name . to <identifiersep> string ( ) ) ; \n \t5 <identifier> . <identifier> ( string . format ( <string_literal> , <identifier> . name , format <identifiersep> value ( <identifier> <identifiersep> value , <identifier> . type ) ) ) ; } \n <ect>
\t3 log . warn ( <string_literal> ) ; } } \n \t1 public void process <identifiersep> transaction <identifiersep> <identifier> ( \n \t3 transaction <identifiersep> <identifier> <identifiersep> event transaction <identifiersep> <identifier> <identifiersep> event ) { \n <ect>
\t2 <identifier> <identifier> <identifiersep> <identifier> = ( ) - > { \n \t3 for ( <identifier> <identifier> : <identifier> . all ( ) ) \n \t3 { \n \t4 <identifier> . <identifier> <identifiersep> manager . build <identifiersep> all <identifiersep> <identifier> ( ) ; } \n <ect>
\t4 while ( the <identifiersep> channel . <identifier> == null && ( system . current <identifiersep> time <identifiersep> millis ( ) - current <identifiersep> <identifier> <identifiersep> time <identifiersep> millis ) < time <identifiersep> out ) { \n \t5 try { \n \t6 thread . <identifier> ( <number_literal> ) ; \n \t5 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 if ( this . transport != null && this . transport . is <identifiersep> <identifier> ( ) ) { \n \t3 log . info ( <string_literal> , target <identifiersep> address ) ; \n \t3 this . transport . close ( ) ; \n <ect>
\t3 s <identifiersep> logger . warn ( msg ) ; \n \t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( msg ) ; \n \t2 } else { \n \t3 <identifier> <identifiersep> vm <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; \n <ect>
\t1 private void handle <identifiersep> <identifier> ( <identifier> <identifiersep> build <identifiersep> <identifier> <identifiersep> message msg , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> config <identifier> , long <identifier> ) { \n \t2 long <identifier> <identifiersep> on = <identifier> . get <identifiersep> <identifier> ( ) - <number_literal> * <number_literal> * <number_literal> ; \n \t2 long <identifier> = <identifier> <identifiersep> context . <identifier> ( ) . <identifier> ( ) - <identifier> <identifiersep> on ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t3 } catch ( io <identifiersep> exception e ) { \n \t4 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t3 } finally { \n \t4 <identifier> . close ( ) ; } \n <ect>
\t2 out . write <identifiersep> short ( ( short ) <identifier> . length ( ) ) ; \n \t2 out . write ( <identifier> . get <identifiersep> bytes ( <identifier> . <identifier> <identifiersep> <number_literal> ) ) ; } \n \t2 <comment> \n \t2 <comment> \n <ect>
\t2 connection . start ( ) ; \n \t2 session <identifier> = connection . create <identifiersep> session ( false , session . <identifier> <identifiersep> <identifier> ) ; \n \t2 consumer = <identifier> . create <identifiersep> consumer ( destination ) ; \n \t2 msg = consumer . <identifier> ( <number_literal> ) ; \n <ect>
\t2 final <identifier> <identifiersep> execution <identifiersep> result result = <identifier> <identifiersep> authentication <identifiersep> policy <identifiersep> <identifier> . execute ( context ) ; \n \t2 if ( ! result . is <identifiersep> execution <identifiersep> failure ( ) ) { \n \t3 logger . debug ( <string_literal> , registered <identifiersep> service , client ) ; \n \t3 return true ; } \n <ect>
\t2 int <identifier> = 1 ; \n \t2 for ( ; <identifier> < = <number_literal> ; ++ <identifier> ) { \n \t3 assert <identifiersep> not <identifiersep> null ( consumer . <identifier> ( <number_literal> ) ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; } \n <ect>
\t4 <identifier> . <identifier> ( query , consumer , \n \t6 new default <identifiersep> channel <identifiersep> <identifier> <identifiersep> <identifier> ( null , <identifier> <identifiersep> event <identifiersep> <identifier> . instance ) ) ; \n \t4 consumer . send <identifiersep> <identifier> ( ) ; \n \t3 } catch ( query <identifiersep> exception e ) { \n <ect>
<comment> \n \t3 <identifier> { \n \t3 log . info ( s <string_literal> ) \n \t3 create <identifiersep> result <identifiersep> <identifier> ( java <identifiersep> context , <identifier> <identifiersep> authentication <identifiersep> result ) } } } \n <ect>
\t2 try { \n \t2 get <identifiersep> channel <identifiersep> <identifier> ( ) . process <identifiersep> event ( e ) ; \n \t2 source <identifiersep> <identifier> . <identifier> <identifiersep> event <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t2 } catch ( channel <identifiersep> exception ex ) { \n <ect>
\t2 log . info ( <string_literal> , get <identifiersep> <identifier> <identifiersep> base <identifiersep> url ( ) , <identifier> <identifiersep> session <identifiersep> id ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> service . <identifier> <identifiersep> <identifier> <identifiersep> session <identifiersep> id ( <identifier> <identifiersep> session <identifiersep> id ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t2 <identifier> . put ( <string_literal> , user <identifiersep> session ) ; \n \t2 <identifier> . put ( <string_literal> , <identifier> <identifiersep> session ) ; \n \t1 } ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 bytes <identifiersep> <identifier> <identifier> = cache . get <identifiersep> or <identifiersep> <identifier> ( entity , <identifier> , <identifier> , <identifier> <identifiersep> bytes ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <identifier> . stream <identifiersep> input ( ) . read <identifiersep> string ( ) ) ; \n \t2 bytes <identifiersep> <identifier> <identifier> = cache . get <identifiersep> or <identifiersep> <identifier> ( <identifier> <identifiersep> entity , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> bytes ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , <identifier> . stream <identifiersep> input ( ) . read <identifiersep> string ( ) ) ; \n <ect>
\t1 <identifier> . find ( new <identifier> <identifiersep> info ( <identifier> <identifiersep> name ) ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t1 throw new no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception ( <identifier> <identifiersep> name ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 logger . logger . error ( <string_literal> + logger . version <identifiersep> <identifier> . get <identifiersep> version <identifiersep> <identifier> ( logger . class ) ) ; <comment> \n \t1 } else { \n \t2 logger . logger . error ( <string_literal> ) ; <comment> \n \t1 logger . logger . <identifier> ( logger . <identifier> <identifiersep> log + id + <string_literal> + message , error ) ; <comment> \n <ect>
\t2 <identifier> : \n \t4 if not <identifier> : \n \t5 self . <identifier> ( <string_literal> <identifier> ( public <identifiersep> ip . <identifier> . <identifier> ) ) \n \t4 else : \n <ect>
\t4 user = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> user , \n \t4 password = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n <identifier> <identifiersep> files = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n version = <identifier> . get <identifiersep> <identifier> <identifiersep> version ( ) \n <ect>
\t4 file file = new file ( <identifier> <identifiersep> <identifier> ) ; \n \t4 if ( file . exists ( ) ) { \n \t5 file . delete ( ) ; } } } } \n \t1 private void shutdown <identifiersep> <identifier> ( ) { \n <ect>
\t5 if ( file . create <identifiersep> new <identifiersep> file ( ) ) { \n \t6 if ( is <identifiersep> file <identifiersep> <identifier> ( file ) ) { \n \t7 is <identifiersep> <identifier> = true ; } \n \t6 if ( ! file . delete ( ) ) { \n <ect>
\t3 if ( is <identifiersep> ip <identifiersep> system && ! <identifier> <identifiersep> ip <identifiersep> if <identifiersep> <identifier> ) { \n \t4 ip <identifiersep> address . set <identifiersep> system ( false ) ; } \n \t3 <identifier> <identifiersep> ip <identifiersep> address <identifiersep> dao . update ( ip <identifiersep> address . get <identifiersep> id ( ) , ip <identifiersep> address ) ; \n \t3 if ( is <identifiersep> ip <identifiersep> system && <identifier> <identifiersep> ip <identifiersep> if <identifiersep> <identifier> && ! <identifier> <identifiersep> network <identifiersep> <identifier> . handle <identifiersep> system <identifiersep> ip <identifiersep> <identifier> ( ip <identifiersep> address ) ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> close <identifiersep> <identifier> ( <identifier> <identifiersep> sql ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t3 if ( ! state <identifiersep> <identifier> <identifiersep> to ( vm , <identifier> <identifiersep> <identifier> . event . <identifier> <identifiersep> operation , vm . get <identifiersep> host <identifiersep> id ( ) ) ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + vm ) ; \n \t4 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + vm ) ; } \n \t2 } catch ( final no <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 throw new <identifier> <identifiersep> channel <identifiersep> exception ( <string_literal> , ex ) ; \n \t1 } finally { \n \t1 if ( <identifier> != null ) { \n \t2 <identifier> . close ( ) ; } } \n <ect>
\t2 if ( <identifier> != null ) { \n \t3 try { \n \t4 this . properties . load ( <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t8 log . <identifier> ( <string_literal> , result . get <identifiersep> <identifier> ( ) ) ; } } \n \t5 } catch ( interrupted <identifiersep> exception <identifier> ) { \n \t6 <identifier> ++ ; \n <ect>
\t3 } else { \n \t4 log . debug ( <string_literal> ) ; \n \t4 return ; } \n \t3 } catch ( exception e ) { \n <ect>
\t5 } else if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> class <identifiersep> path , <identifier> ) ) { \n \t6 add <identifiersep> file <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> output <identifiersep> stream , <identifier> <identifiersep> class <identifiersep> path , <identifier> <identifiersep> path + <identifier> <identifiersep> class <identifiersep> path . get <identifiersep> name ( ) ) ; } } \n \t4 add <identifiersep> <identifier> <identifiersep> conf <identifiersep> to <identifiersep> <identifier> ( <identifier> <identifiersep> output <identifiersep> stream , base <identifiersep> path , <identifier> <identifiersep> name , connection <identifiersep> ip , port , <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 if ( template . get <identifiersep> <identifier> ( ) == null ) { \n \t5 try { \n \t6 all <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . delete ( <identifier> <identifiersep> user <identifiersep> id , template . get <identifiersep> id ( ) , null ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> != null && <identifier> <identifiersep> <identifier> . length ( ) > 0 ) { \n \t3 string <identifier> = vm . get <identifiersep> <identifier> <identifiersep> <identifier> ( conn ) ; \n \t3 <identifier> = <identifier> + vm <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; \n <ect>
\t3 } while ( ex instanceof exception <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ) ; \n \t2 } else { \n \t3 task <identifiersep> name = <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> task <identifiersep> info ( ) . get <identifiersep> task <identifiersep> name ( ) ; } \n \t2 if ( log . is <identifiersep> error <identifiersep> enabled ( ) ) { \n <ect>
\t5 log <identifiersep> <identifier> = false ; \n \t5 s <identifiersep> logger . debug ( <string_literal> + host <identifiersep> id + <string_literal> + host <identifiersep> name + <string_literal> ) ; \n \t5 s <identifiersep> logger . trace ( <string_literal> + host <identifiersep> id + <string_literal> + request . get <identifiersep> <identifier> ( ) + <string_literal> + request ) ; \n \t4 } else { \n <ect>
\t1 return <identifier> ; } \n private void check <identifiersep> <identifier> ( boolean is <identifiersep> <identifier> <identifiersep> mode ) { \n \t1 if ( is <identifiersep> <identifier> <identifiersep> mode ) { \n \t1 if ( ! <identifier> . exists ( ) ) { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> ) ; } } \n \t2 s <identifiersep> logger . info ( <string_literal> ) ; \n \t2 return false ; \n \t2 <comment> <ect>
\t1 load <identifiersep> <identifier> <identifiersep> <identifier> . update <identifiersep> load <identifiersep> <identifier> ( <identifier> . get <identifiersep> account <identifiersep> number ( ) , <identifier> <identifiersep> name ) ; \n \t1 } catch ( final load <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t1 throw ex ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> == null ) return <identifier> ; \n \t3 try { \n \t4 <identifier> = new resource <identifiersep> <identifier> ( utils . get <identifiersep> <identifier> <identifiersep> from <identifiersep> string ( <identifier> <identifiersep> <identifier> ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> delete <identifiersep> response response = delete <identifiersep> <identifier> . execute ( <identifier> <identifiersep> <identifier> ) ; \n \t2 <comment> \n \t2 { \n <ect>
\t3 try { \n \t4 current . <identifier> <identifiersep> <identifier> <identifiersep> base <identifiersep> state ( <identifier> , new <identifier> <identifiersep> <identifier> ( builder , store , client , <identifier> ) ) ; \n \t4 return ; \n \t3 } catch ( <identifier> <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t5 log . error ( <string_literal> ) ; \n \t4 return 1 ; } \n \t2 } catch ( final throwable e ) { \n \t3 <comment> \n <ect>
\t1 for ( <identifier> <identifiersep> <identifier> <identifiersep> entity <identifier> : <identifier> ) { \n \t2 try { \n \t2 m <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> ) ; \n \t2 } catch ( exception exception ) { \n <ect>
public class <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> http <identifiersep> request <identifiersep> <identifier> <identifiersep> factory implements <identifier> <identifiersep> http <identifiersep> request <identifiersep> <identifier> <identifiersep> factory { \n \t1 @ <identifier> \n \t1 public list < <identifier> > from <identifiersep> request <identifiersep> body ( final <identifier> <identifiersep> value <identifiersep> map < string , string > request <identifiersep> body ) { \n \t2 final string <identifier> = request <identifiersep> body . get <identifiersep> first ( <string_literal> ) ; \n <ect>
\t3 for ( <identifier> <identifiersep> operation <identifiersep> listener listener : <identifier> ) { \n \t4 try { \n \t5 listener . on <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> context , <identifier> <identifiersep> in <identifiersep> <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t5 s <identifiersep> logger . debug ( <string_literal> + db <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> class <identifiersep> name ( <identifier> ) ) ; } \n \t4 <comment> \n \t4 <identifier> <identifiersep> lock <identifiersep> <identifier> <identifiersep> mode . <identifier> ( ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t5 <identifier> <identifiersep> properties , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( ( <identifier> ) <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t1 if ( all <identifiersep> <identifier> ) { \n \t2 log . info ( <string_literal> + i ) ; \n \t2 return ; } } \n <ect>
\t5 if ( event . get <identifiersep> end ( ) . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t6 try { \n \t7 create <identifiersep> job ( event <identifiersep> <identifier> , event , index ) ; \n \t6 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 protected <identifier> < <identifier> , <identifier> > read <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( byte [ ] <identifier> , int <identifier> , int length ) { \n \t2 try { \n \t3 return <identifier> <identifiersep> read <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> ( <identifier> , <identifier> , length ) ; } \n \t2 catch ( exception ex ) { \n <ect>
\t5 if ( <identifier> <identifiersep> all ) { \n \t6 log . info ( <string_literal> ) ; \n \t6 while ( consumer . <identifier> ( message <identifiersep> <identifier> <identifiersep> timeout ) != null ) { \n \t7 count ++ ; } } \n <ect>
\t1 int num <identifiersep> <identifier> = data <identifiersep> input . read <identifiersep> int ( ) ; \n \t1 log . debug ( <string_literal> + num <identifiersep> <identifier> ) ; \n \t1 for ( int i = 0 ; i < num <identifiersep> <identifier> ; i ++ ) { \n \t2 <identifier> = data <identifiersep> input . read <identifiersep> int ( ) ; \n <ect>
\t1 private void <identifier> <identifiersep> client ( ) throws <identifier> <identifiersep> exception { \n \t2 if ( client != null ) \n \t3 return ; \n <ect>
\t2 for ( string cache : <identifier> ) { \n \t3 try { \n \t3 server <identifiersep> cache <identifiersep> manager . <identifier> <identifiersep> local ( class . for <identifiersep> name ( cache ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t4 m <identifiersep> device = factory . create <identifiersep> m <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t4 m <identifiersep> device . set <identifiersep> device <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . device <identifiersep> <identifier> ) ; \n \t3 } else if ( device <identifiersep> <identifier> == <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . device <identifiersep> <identifier> ) { \n <ect>
\t1 public void run ( ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> event <identifiersep> input <identifiersep> stream = new <identifier> <identifiersep> <identifier> <identifiersep> event <identifiersep> input <identifiersep> stream ( new <identifier> <identifiersep> input <identifiersep> stream ( socket . get <identifiersep> input <identifiersep> stream ( ) ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 map <identifiersep> <identifier> <identifiersep> <identifier> . put ( <identifier> . get <identifiersep> key ( ) , new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> . get <identifiersep> value ( ) ) ) ; } \n \t3 for ( <identifier> <identifier> <identifiersep> <identifier> : map <identifiersep> <identifier> <identifiersep> <identifier> . key <identifiersep> set ( ) ) \n \t4 <identifier> . <identifier> ( map <identifiersep> <identifier> <identifiersep> <identifier> . get ( <identifier> <identifiersep> <identifier> ) ) ; \n \t3 list < <identifier> > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = new array <identifiersep> list < > ( <identifier> <identifiersep> <identifier> . size ( ) ) ; \n <ect>
\t1 private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( http <identifiersep> session <identifiersep> manager . class ) ; \n \t1 private session <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new local <identifiersep> session <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 @ <identifier> \n \t1 public void session <identifiersep> <identifier> ( http <identifiersep> session <identifiersep> event event ) { \n <ect>
\t3 <identifier> . start ( ) ; \n \t3 <comment> \n \t3 group <identifiersep> handle = <identifier> <identifiersep> security <identifiersep> group <identifiersep> dao . <identifier> <identifiersep> in <identifiersep> lock <identifiersep> table ( <identifier> . get <identifiersep> security <identifiersep> group <identifiersep> id ( ) ) ; \n \t3 if ( group <identifiersep> handle == null ) { \n <ect>
\t3 else if ( count <identifiersep> <identifier> instanceof string ) { \n \t4 try { \n \t5 count = integer . parse <identifiersep> int ( ( string ) count <identifiersep> <identifier> ) ; } \n \t4 catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . remove <identifiersep> all ( <identifier> <identifiersep> cache <identifiersep> <identifier> ) ; \n \t3 cache <identifiersep> <identifier> . add <identifiersep> all ( <identifier> <identifiersep> cache <identifiersep> <identifier> ) ; \n \t3 cache <identifiersep> <identifier> . remove <identifiersep> all ( <identifier> <identifiersep> <identifier> . key <identifiersep> set ( ) ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) \n <ect>
\t3 <identifier> <identifiersep> target <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <identifier> <identifiersep> target <identifiersep> <identifier> ; } \n \t2 try { \n \t3 return <identifier> <identifiersep> manager . get <identifiersep> instance ( <identifier> <identifiersep> <identifier> . class , <identifier> <identifiersep> target <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 if ( ! <identifier> . try <identifiersep> success ( result ) ) { \n \t3 logger . warn ( <string_literal> , result , <identifier> ) ; } } \n \t1 private static void try <identifiersep> failure ( <identifier> < ? > <identifier> , throwable <identifier> ) { \n \t2 if ( ! <identifier> . try <identifiersep> failure ( <identifier> ) ) { \n <ect>
\t3 <identifier> . set <identifiersep> int ( <number_literal> , security <identifiersep> group ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) { \n \t3 system . out . <identifier> ( <string_literal> + ex . get <identifiersep> message ( ) ) ; \n <ect>
\t4 return null ; \n \t3 } else { \n \t4 result = entity <identifiersep> utils . to <identifiersep> string ( response . get <identifiersep> entity ( ) ) ; \n \t4 final string log <identifiersep> result = <identifier> <identifiersep> password ( string <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> java ( result ) ) ; \n <ect>
\t3 } else { \n \t4 string content = io <identifiersep> utils . to <identifiersep> string ( <identifier> . get <identifiersep> entity ( ) . get <identifiersep> content ( ) , http <identifiersep> <identifier> . <identifier> ( <identifier> ) ) ; \n \t4 content = <identifier> <identifiersep> <identifier> <identifiersep> if <identifiersep> <identifier> ( content ) ; \n \t4 system . out . <identifier> ( <string_literal> + content ) ; \n <ect>
\t2 bean <identifiersep> log . trace ( <string_literal> , cache <identifiersep> name , id , <identifier> . get <identifiersep> <identifier> <identifiersep> load <identifiersep> property ( ) ) ; } \n \t1 return false ; } \n \t1 <identifier> <identifiersep> bean <identifiersep> data <identifiersep> to <identifiersep> bean . load ( <identifier> , bean , cache <identifiersep> data , context ) ; \n <ect>
\t6 object <identifier> = consumer . <identifier> ( <number_literal> ) ; \n \t6 if ( <identifier> != null ) { \n \t7 if ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> text <identifiersep> message ) { \n \t8 if ( count <identifier> <number_literal> == 0 ) { \n <ect>
\t1 string response <identifiersep> string = <string_literal> ; \n \t1 url <identifiersep> service <identifier> = null ; \n \t1 <identifier> <identifier> = new <identifier> ( ) . start ( ) ; \n \t1 try { \n <ect>
\t4 + <string_literal> \n \t4 + default <identifiersep> value \n \t4 + <string_literal> , ex ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t5 remove <identifiersep> entry ( storage , <identifier> <identifiersep> uri ) ; } \n \t4 remove <identifiersep> entry ( storage , cache <identifiersep> key ) ; } \n \t3 if ( uri != null ) { \n <ect>
\t6 continue ; } \n \t5 try { \n \t6 authentication <identifiersep> manager . <identifier> <identifiersep> <identifier> ( session , <identifier> , user <identifiersep> session , uri <identifiersep> info , client <identifiersep> connection , <identifier> , false ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t1 <identifier> = <identifier> . execute <identifiersep> query ( <string_literal> + table <identifiersep> name ) ; \n \t1 <identifier> . next ( ) ; \n \t1 assert <identifiersep> equals ( <identifier> , <identifier> . get <identifiersep> long ( 1 ) ) ; \n \t1 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> thread <identifiersep> pool . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> <identifiersep> task ( 0 ) , \n \t5 i , \n \t5 <identifier> <identifiersep> thread <identifiersep> <identifier> <identifiersep> millis , \n \t5 time <identifiersep> unit . <identifier> ) ; } \n <ect>
\t4 string <identifier> <identifiersep> name = <string_literal> ; \n \t4 try { \n \t5 <identifier> <identifiersep> name = <identifier> . get <identifiersep> queue <identifiersep> name ( ) ; \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> time <identifiersep> token <identifiersep> account get ( final string <identifier> ) { \n \t2 try { \n \t3 if ( ! this . location . get <identifiersep> file ( ) . exists ( ) ) { \n <ect>
\t2 class < ? > class <identifiersep> type = this . create <identifiersep> java <identifiersep> type ( java <identifiersep> <identifier> , json <identifiersep> <identifier> . type <identifiersep> id ) ; \n \t2 class < ? > content <identifiersep> class <identifiersep> type = this . create <identifiersep> java <identifiersep> type ( java <identifiersep> <identifier> , json <identifiersep> <identifier> . content <identifiersep> type <identifiersep> id ) ; \n \t2 class < ? > key <identifiersep> class <identifiersep> type = this . create <identifiersep> java <identifiersep> type ( java <identifiersep> <identifier> , json <identifiersep> <identifier> . key <identifiersep> type <identifiersep> id ) ; \n \t2 if ( key <identifiersep> class <identifiersep> type != null ) { \n <ect>
<comment> \n private static void handle <identifiersep> <identifier> <identifiersep> <identifier> ( map < string , string > from <identifiersep> map , map < string , string > to <identifiersep> map , \n \t1 string <identifier> <identifiersep> name , string new <identifiersep> name , string new <identifiersep> <identifier> ) { \n \t1 if ( from <identifiersep> map . contains <identifiersep> key ( <identifier> <identifiersep> name ) ) { \n <ect>
\t2 final map < string , list < object > > attributes = <identifier> <identifiersep> <identifier> <identifiersep> attributes ( principal <identifiersep> id , <identifier> ) ; \n \t2 if ( attributes == null || attributes . is <identifiersep> empty ( ) ) { \n \t3 logger . debug ( <string_literal> , principal <identifiersep> id ) ; \n \t3 if ( ! this . return <identifiersep> null <identifiersep> if <identifiersep> no <identifiersep> attributes ) { \n <ect>
\t1 public set < <identifier> <identifiersep> <identifier> <identifiersep> destination > get <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 set < <identifier> <identifiersep> <identifier> <identifiersep> destination > result = super . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( is <identifiersep> log <identifiersep> all ( ) || is <identifiersep> log <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 if ( result == null ) { \n <ect>
\t3 assert <identifiersep> equals ( true , value >= i ) ; \n \t3 i = value ; \n \t3 log . info ( log . <identifier> <identifiersep> test , <string_literal> + i ) ; \n \t3 check <identifiersep> get <identifiersep> <identifier> ( <identifier> ) ; } \n <ect>
\t2 @ <identifier> \n \t2 public void on <identifiersep> message ( message message , channel channel ) throws exception { \n \t3 string value = new string ( message . get <identifiersep> body ( ) ) ; \n \t3 try { \n <ect>
\t1 if ( config . get <identifiersep> <identifier> <identifiersep> channel <identifiersep> log <identifiersep> level ( ) != null ) { \n \t1 try { \n \t2 log <identifiersep> level = log <identifiersep> level . value <identifiersep> of ( config . get <identifiersep> <identifier> <identifiersep> channel <identifiersep> log <identifiersep> level ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> info ) ; } \n \t3 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> info . get <identifiersep> snapshot <identifiersep> id ( ) + <string_literal> ) ; \n \t2 } catch ( exception e ) { \n \t3 error = boolean . true ; \n <ect>
\t2 msg . <identifier> ( ) ; \n \t2 write <identifiersep> bytes ( byte <identifiersep> <identifier> . <identifier> ( msg . to <identifiersep> byte <identifiersep> array ( ) ) ) ; } \n \t1 public void stop <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 s <identifiersep> logger . info ( <string_literal> + name + <string_literal> ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 <identifier> = null ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> info <identifier> = get <identifiersep> <identifier> <identifiersep> data <identifiersep> info <identifiersep> from <identifiersep> cache ( i ) ; \n \t3 if ( <identifier> != null ) { \n \t4 this . <identifier> <identifiersep> <identifier> . set ( i , set ) ; \n \t4 <identifier> ++ ; } } \n <ect>
\t1 public synchronized void <identifier> ( ) { \n \t2 if ( this . <identifier> <identifiersep> <identifier> == null ) { \n \t3 this . <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } else { \n <ect>
\t1 return <identifier> <identifiersep> result . success ; } \n \t1 if ( property . equals ( <identifier> <identifiersep> url ) ) { \n \t1 string <identifier> <identifiersep> url = <identifier> <identifiersep> instance <identifiersep> <identifier> . get <identifiersep> property <identifiersep> map ( ) . get ( <identifier> <identifiersep> url ) ; \n \t1 if ( ! <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> url ( <identifier> <identifiersep> url ) ) { \n <ect>
\t1 @ <identifier> \n \t1 @ db \n \t1 public string <identifier> <identifiersep> <identifier> <identifiersep> ip <identifiersep> address ( network network , string <identifier> <identifiersep> ip ) { \n \t2 if ( <identifier> <identifiersep> ip != null && <identifier> <identifiersep> ip . equals ( network . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t3 log . info ( <string_literal> , name ) ; \n \t3 if ( ! <identifier> . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t4 log . warn ( <string_literal> , name ) ; } } \n \t2 catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> info <identifier> <identifiersep> <identifier> ( long data <identifiersep> <identifier> <identifiersep> id , long user <identifiersep> vm <identifiersep> id ) { \n \t2 user <identifiersep> vm <identifiersep> vo user <identifiersep> vm = <identifier> <identifiersep> user <identifiersep> vm <identifiersep> dao . find <identifiersep> by <identifiersep> id ( user <identifiersep> vm <identifiersep> id ) ; \n \t2 if ( user <identifiersep> vm == null ) { \n <ect>
\t5 return <number_literal> ; \n \t4 } else { \n \t5 s <identifiersep> logger . info ( <string_literal> + response <identifiersep> code ) ; \n \t5 long <identifier> <identifiersep> vm <identifiersep> id = long . parse <identifiersep> long ( values . get ( <string_literal> ) ) ; \n <ect>
\t4 } else if ( item instanceof switch <identifiersep> item ) { \n \t5 logger . debug ( <string_literal> ) ; \n \t5 return <identifier> <identifiersep> value ( value <identifiersep> <identifier> ) . equals ( <identifier> <identifiersep> value <identifiersep> <identifier> ) ? on <identifiersep> <identifier> <identifiersep> type . <identifier> : on <identifiersep> <identifier> <identifiersep> type . on ; \n \t4 } else if ( item instanceof <identifier> <identifiersep> item ) { \n <ect>
\t3 { \n \t4 return get <identifiersep> field <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n \t3 else \n \t3 { \n <ect>
\t4 <comment> \n \t4 return <identifier> ; } \n \t3 return <identifier> . new <identifiersep> instance ( new object [ ] { new <identifier> <identifiersep> <identifier> ( <identifier> , sql ) } ) ; \n \t2 } catch ( exception x ) { \n <ect>
\t3 queue <identifiersep> <identifier> = queue <identifiersep> session . create <identifiersep> <identifier> ( queue ) ; \n \t3 message = queue <identifiersep> session . create <identifiersep> text <identifiersep> message ( ) ; \n \t3 for ( int i = 0 ; i < num <identifiersep> <identifier> ; i ++ ) { \n \t4 message . set <identifiersep> text ( <string_literal> + ( i + 1 ) ) ; \n <ect>
\t2 logger . debug ( <string_literal> + key <identifiersep> store ) ; \n \t2 logger . debug ( <string_literal> + key <identifiersep> store <identifiersep> password ) ; \n \t2 logger . debug ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> directory ) ; \n \t2 logger . debug ( <string_literal> + <identifier> ) ; \n <ect>
\t7 } catch ( <identifier> <identifiersep> runtime <identifiersep> exception e ) { \n \t8 s <identifiersep> logger . warn ( <string_literal> + volume . get <identifiersep> <identifier> ( ) + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t8 answer = new <identifier> <identifiersep> status <identifiersep> answer ( cmd , <identifier> <identifiersep> status . <identifier> , e . get <identifiersep> message ( ) ) ; } \n \t7 if ( answer == null || ! ( answer instanceof <identifier> <identifiersep> status <identifiersep> answer ) ) { \n <ect>
\t1 for ( <identifier> <identifiersep> <identifier> < object > <identifier> : <identifier> ) { \n \t2 bean <identifiersep> <identifier> <identifiersep> context <identifier> = bean <identifiersep> <identifier> <identifiersep> context . of ( <identifier> ) ; \n \t2 string msg = <identifier> . <identifier> ( <identifier> . get <identifiersep> message <identifiersep> template ( ) , <identifier> , get <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> . add ( new <identifier> <identifiersep> message ( msg , <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> ) ) ) ; \n <ect>
\t3 <identifier> <identifiersep> context <identifier> <identifiersep> context = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> context ( true ) ; \n \t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> context . create <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> host , <identifier> <identifiersep> port ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> client <identifiersep> mode ( true ) ; \n \t3 <identifier> . do <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> , true ) ; \n <ect>
\t1 string <identifier> <identifiersep> url = null ; \n \t1 try { \n \t1 <identifier> <identifiersep> url = get <identifiersep> <identifier> <identifiersep> url <identifiersep> from <identifiersep> <identifier> ( ) ; \n \t1 } catch ( <identifier> <identifiersep> http <identifiersep> exception e ) { \n <ect>
\t1 string default <identifiersep> class <identifiersep> location = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> group <identifiersep> resource <identifiersep> info . class . get <identifiersep> package ( ) . get <identifiersep> name ( ) + <string_literal> + resource <identifiersep> type . <identifier> ( <string_literal> , <string_literal> ) + <string_literal> ; \n \t1 try { \n \t1 return ( resource <identifiersep> info ) class . for <identifiersep> name ( default <identifiersep> class <identifiersep> location ) . new <identifiersep> instance ( ) ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
\t4 while ( <identifier> . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t5 object <identifier> <identifiersep> name = <identifier> . next <identifiersep> element ( ) ; \n \t5 logger . info ( <string_literal> + <identifier> <identifiersep> name + <string_literal> + \n \t6 request . get <identifiersep> <identifier> ( ( string ) <identifier> <identifiersep> name ) ) ; } } \n <ect>
\t5 <comment> \n \t5 wait . set ( 1 + wait . get ( ) * <number_literal> ) ; <comment> \n \t5 wait . set ( <identifier> . <identifier> ( wait . get ( ) , <number_literal> * <number_literal> ) ) ; <comment> \n \t5 mode <identifiersep> <identifier> <identifiersep> <identifier> = mode <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( this , wait . get ( ) , time <identifiersep> unit . <identifier> ) ; \n <ect>
\t2 long vm <identifiersep> id = event . get <identifiersep> resource <identifiersep> id ( ) ; \n \t2 long <identifier> <identifiersep> id = event . get <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t2 if ( event <identifiersep> <identifier> . event <identifiersep> security <identifiersep> group <identifiersep> <identifier> . equals ( event . get <identifiersep> type ( ) ) ) { \n <ect>
\t1 @ <identifier> \n \t1 public void stop <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> == null ) { \n \t3 return ; } \n <ect>
\t3 return false ; } } \n \t1 @ <identifier> \n \t1 protected boolean is <identifiersep> response <identifiersep> <identifier> ( <identifier> <identifiersep> message response ) { \n \t2 if ( response . get <identifiersep> command ( ) != command <identifiersep> code ) { \n <ect>
\t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n \t4 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . length ) ; \n \t4 return max == <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . length ; } \n \t2 } , <number_literal> * <number_literal> ) ; \n <ect>
\t1 <identifier> = new char <identifiersep> <identifier> ( <identifier> ) ; } \n \t1 last <identifiersep> <identifier> = <identifier> . to <identifiersep> string ( ) ; \n \t1 <identifier> <identifiersep> <identifier> ( false ) ; \n <ect>
\t4 while ( ! interrupted ( ) ) { \n \t5 <comment> \n \t5 <comment> \n \t5 if ( ! send <identifiersep> <identifier> . try <identifiersep> <identifier> ( 1 , <identifier> <identifiersep> <identifier> <identifiersep> response <identifiersep> timeout , time <identifiersep> unit . <identifier> ) ) { \n <ect>
\t2 + <string_literal> ) ; \n \t1 return 1 ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t1 <identifier> . <identifier> <identifiersep> error ( <string_literal> + e . to <identifiersep> string ( ) ) ; \n <ect>
\t2 } else { \n \t3 new <identifier> <identifiersep> delete <identifiersep> <identifier> ( <identifier> ) . <identifier> ( <identifier> ) ; } \n \t2 delete ( delete <identifiersep> type , <identifier> ) ; \n \t2 <identifier> ( <identifier> ) ; \n <ect>
\t1 { \n \t2 <identifier> . on <identifiersep> response ( response ) ; } \n \t1 else \n \t1 { \n <ect>
\t6 continue ; \n \t5 stop <identifiersep> <identifier> . add ( line . <identifier> ( ) ) ; } } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 string <identifier> <identifiersep> value = m <identifiersep> new <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cache . get ( <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> value != null ) { \n <ect>
\t5 process <identifiersep> <identifier> <identifiersep> shards ( event ) ; } \n \t4 remove <identifiersep> <identifier> <identifiersep> snapshot <identifiersep> from <identifiersep> cluster <identifiersep> state ( event ) ; \n \t4 <identifier> <identifiersep> snapshot <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( event ) ; } \n \t2 } catch ( exception e ) { \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> node <identifiersep> <identifier> ( int node <identifiersep> id ) { \n \t2 if ( nodes <identifiersep> status . get ( node <identifiersep> id ) != node <identifiersep> status . <identifier> ) { \n <ect>
\t1 m <identifiersep> <identifier> = c ; } \n private void set <identifiersep> <identifier> ( i <identifiersep> <identifier> <identifier> ) { \n \t1 <comment> \n \t1 if ( m <identifiersep> <identifier> != null && m <identifiersep> <identifier> != <identifier> ) { \n <ect>
\t3 if ( <identifier> ) { \n \t4 <identifier> . send ( job , <identifier> . get ( 0 ) ) ; \n \t4 log . info ( <string_literal> + job ) ; } \n \t3 else { \n <ect>
\t3 try { \n \t4 int <identifier> = integer . parse <identifiersep> int ( new string ( content <identifiersep> object . content ( ) ) ) ; \n \t4 if ( ! <identifier> <identifiersep> <identifier> . contains ( <identifier> ) ) { \n \t5 <identifier> <identifiersep> <identifier> . add ( <identifier> ) ; \n <ect>
\t2 object <identifiersep> entity <identifier> = entity <identifiersep> <identifier> . get ( ) ; \n \t2 try { \n \t3 entity <identifiersep> <identifier> . get <identifiersep> and <identifiersep> set ( object <identifiersep> metadata <identifiersep> <identifier> . get <identifiersep> instance ( ) . update <identifiersep> <identifier> <identifiersep> timeout ( <identifier> ) ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t1 + <identifier> <identifiersep> context . get <identifiersep> source <identifiersep> <identifier> <identifiersep> count ( ) + <string_literal> \n \t1 + <identifier> <identifiersep> context . get <identifiersep> target <identifiersep> <identifier> <identifiersep> count ( ) + <string_literal> ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> context . get <identifiersep> source <identifiersep> <identifier> <identifiersep> count ( ) , \n \t1 <identifier> <identifiersep> context . get <identifiersep> target <identifiersep> <identifier> <identifiersep> count ( ) ) ) { \n <ect>
\t6 <identifier> <identifiersep> empty = false ; } \n \t4 else { \n \t5 <identifier> . get <identifiersep> <identifier> ( ) . add <identifiersep> all ( <identifier> ) ; \n \t5 if ( ! string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> input <identifiersep> <identifier> ( ) ) ) \n <ect>
\t4 return - 1 ; } \n \t3 try { \n \t4 return long . value <identifiersep> of ( <identifier> <identifiersep> string ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t3 else { \n \t4 current += value ; } } \n \t2 @ <identifier> \n \t2 public list < <identifier> <identifiersep> <identifier> > snapshot <identifiersep> state ( long <identifier> <identifiersep> id , long <identifier> ) throws exception { \n <ect>
\t2 final list < service <identifiersep> <identifier> <identifiersep> execution <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> = object <identifiersep> utils . default <identifiersep> if <identifiersep> null ( service <identifiersep> <identifier> <identifiersep> dao <identifiersep> <identifier> . get <identifiersep> if <identifiersep> <identifier> ( ) , new array <identifiersep> list < > ( 0 ) ) ; \n \t2 final default <identifiersep> service <identifiersep> <identifier> <identifiersep> execution <identifiersep> <identifier> <identifier> = new default <identifiersep> service <identifiersep> <identifier> <identifiersep> execution <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . for <identifiersep> <identifier> ( c - > { \n \t3 final string name = string <identifiersep> utils . remove <identifiersep> <identifier> ( c . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , <string_literal> ) ; \n <ect>
\t2 ) \n \t1 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> <identifier> ( <identifier> . <identifier> <identifiersep> <identifier> ) \n \t1 <identifier> = <identifier> if not <identifier> else <identifier> [ - 1 ] \n \t1 if <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> : \n <ect>
\t2 return <identifier> <identifiersep> <identifier> ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( ) throws <identifier> <identifiersep> exception { \n \t2 if ( debug ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> . shutdown ( ) . get ( ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t3 return ; } \n \t2 if ( user . <identifier> != null ) { \n \t3 <identifier> . <identifier> <identifiersep> map . put ( user . <identifier> , user . <identifier> ) ; } \n \t2 status <identifiersep> message ( string . format ( <string_literal> , user . <identifier> , user . <identifier> , user . client ) ) ; \n <ect>
\t2 } else { \n \t3 log . info ( <string_literal> ) ; } \n \t2 log . info ( <string_literal> + default <identifiersep> <identifier> ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> time ) ; \n <ect>
\t5 <identifier> <identifiersep> o <identifiersep> <identifier> <identifiersep> client <identifier> <identifiersep> server ; \n \t5 try { \n \t6 <identifier> <identifiersep> server = ( <identifier> <identifiersep> o <identifiersep> <identifier> <identifiersep> client ) server <identifiersep> class . new <identifiersep> instance ( ) ; \n \t6 <identifier> <identifiersep> server . <identifier> ( <identifier> <identifiersep> location , token <identifiersep> location , client <identifiersep> id , client <identifiersep> <identifier> , <identifier> <identifiersep> uri , token <identifiersep> response <identifiersep> class ) ; \n <ect>
\t6 || value . equals ( <string_literal> ) \n \t6 || value . equals ( <string_literal> ) \n \t4 ) { \n \t5 if ( output <identifiersep> format != 0 && output <identifiersep> format != output <identifiersep> format <identifiersep> <identifier> ) { \n <ect>
\t6 system . <identifier> ( 1 ) ; } } \n \t4 if ( <identifier> <identifiersep> request ) { \n \t5 thread . <identifier> ( <number_literal> ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> . contains ( next <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t2 try { \n \t3 <identifier> = ( ( load <identifiersep> metadata ) <identifier> . get <identifiersep> load <identifiersep> <identifier> ( ) ) \n \t6 . get <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) . get <identifiersep> file <identifiersep> name ( ) , job ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t6 if ( read > 0 ) { \n \t7 try { \n \t8 this . out . write ( <identifier> , 0 , read ) ; \n \t7 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 <identifier> = new file <identifiersep> output <identifiersep> stream ( file <identifiersep> to <identifiersep> <identifier> ) ; \n \t3 stream <identifiersep> <identifier> . io ( resource . get <identifiersep> input <identifiersep> stream ( ) , <identifier> , true , true ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 if ( ! ( this . service <identifiersep> <identifier> . equals ( <string_literal> ) || this . service <identifiersep> <identifier> . equals ( <string_literal> ) ) ) { \n \t3 logger . warn ( <string_literal> ) ; \n \t3 this . service <identifiersep> <identifier> = <string_literal> ; } \n <ect>
\t1 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> metadata ( <identifier> <identifiersep> key , <identifier> , <identifier> , null , null , null , null ) ; \n \t1 log . info ( <string_literal> + root . <identifier> ( <identifier> , map ) + <string_literal> ) ; \n \t1 <identifier> . do <identifiersep> stream <identifiersep> <identifier> = true ; \n \t1 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> metadata ( <identifier> <identifiersep> key , <identifier> , <identifier> , null , null , null , null ) ; \n <ect>
\t8 return ; } \n \t7 if ( msg == null ) { \n \t8 <comment> \n \t8 <comment> \n <ect>
<number_literal> routing <identifiersep> <identifier> <identifier> ) { \n \t2 synchronized ( lock ) { \n \t3 file store <identifiersep> dir = new file ( data <identifiersep> directory , store <identifiersep> <identifier> . get <identifiersep> name ( ) ) ; \n \t3 if ( ! store <identifiersep> dir . exists ( ) ) { \n <ect>
\t1 public void test <identifiersep> empty <identifiersep> filter ( ) throws exception { \n \t2 logger . info ( <string_literal> ) ; \n \t2 create <identifiersep> index ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
<comment> \n \t1 public void send <identifiersep> data ( <identifier> <identifiersep> message <identifier> <identifiersep> message ) { \n \t2 if ( <identifier> <identifiersep> message == null ) { \n <ect>
\t2 <identifier> . for <identifiersep> <identifier> ( <identifier> - > { \n \t3 if ( <identifier> . contains <identifiersep> key ( <string_literal> ) && <identifier> . contains <identifiersep> key ( <string_literal> ) ) { \n \t4 map . put ( <identifier> . get ( <string_literal> ) . to <identifiersep> string ( ) , <identifier> . get ( <string_literal> ) . to <identifiersep> string ( ) ) ; } \n \t2 } ) ; \n <ect>
\t3 final logger <identifiersep> context logger <identifiersep> context = <identifier> . <identifier> ( <string_literal> , null , log <identifiersep> configuration <identifiersep> file . get <identifiersep> uri ( ) ) ; \n \t3 logger . debug ( <string_literal> ) ; \n \t3 logger <identifiersep> context . get <identifiersep> configuration ( ) . add <identifiersep> listener ( <identifier> - > logger <identifiersep> context . update <identifiersep> <identifier> ( <identifier> . <identifier> ( ) ) ) ; \n \t3 return <identifier> . of ( <identifier> . of ( log <identifiersep> configuration <identifiersep> file , logger <identifiersep> context ) ) ; } \n <ect>
\t5 for ( <identifier> <identifiersep> result r : <identifier> . build <identifiersep> result . values ( ) ) { \n \t6 try { \n \t7 r . table . close ( ) ; \n \t6 } catch ( throwable e ) { \n <ect>
\t3 { \n \t4 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( current <identifiersep> <identifier> ) ) ; } } \n \t2 catch ( exception ex ) \n \t2 { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> type ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + <identifier> . get <identifiersep> message ( ) ) ; \n \t3 throw <identifier> ; \n \t2 } catch ( uri <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t4 } else { \n \t5 <identifier> . <identifier> ( current [ 0 ] ) ; \n \t5 <identifier> = current [ 0 ] ; } } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t1 log . info ( <string_literal> , e ) ; \n \t1 <identifier> = <identifier> . as <identifiersep> transaction ( volume <identifiersep> info . class , create <identifiersep> <identifier> <identifiersep> volume ) . <identifier> ( volume <identifiersep> id ) ; \n \t1 } catch ( transaction <identifiersep> exception e ) { \n <ect>
\t3 map <identifier> <identifiersep> <identifier> = ( map ) <identifier> . get ( <number_literal> ) ; \n \t3 assert . assert <identifiersep> equals ( <identifier> <identifiersep> a . size ( ) , <identifier> <identifiersep> <identifier> . size ( ) ) ; \n \t3 count ++ ; } \n \t2 assert . assert <identifiersep> equals ( test <identifiersep> <identifier> <identifiersep> count , count ) ; \n <ect>
\t3 context . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 return true ; } \n \t2 final string <identifier> <identifiersep> id = <identifier> . <identifier> <identifiersep> id ; \n \t2 if ( ! context . is <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ) { \n <ect>
\t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t2 log . warn ( <string_literal> + <identifier> <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 continue ; } \n \t2 for ( action <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : <identifier> . action <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 node <identifier> <identifiersep> root , node <identifier> , <identifier> <identifiersep> factory <identifier> <identifiersep> factory ) { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this ) ; \n \t1 if ( <identifier> != null ) { \n \t1 if ( logger . is <identifiersep> <identifier> ( level . info ) ) { \n <ect>
\t1 public void on <identifiersep> <identifier> ( base <identifiersep> client <identifiersep> <identifier> state ) { \n \t2 if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> <identifier> <identifiersep> uri ( <identifier> <identifiersep> uri uri , base <identifiersep> client <identifiersep> <identifier> state ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 logger . info ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> port != null ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> ( final connection conn , final string name <identifiersep> <identifier> ) { \n \t2 try { \n \t3 final set < <identifier> > <identifier> = <identifier> . get <identifiersep> by <identifiersep> name <identifiersep> <identifier> ( conn , name <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> . size ( ) != 1 ) { \n <ect>
\t2 if ( <identifier> == 0 ) { \n \t3 logger . info ( <string_literal> ) ; \n \t2 } else { \n \t3 if ( <identifier> > 0 ) { \n <ect>
\t2 options . set <identifiersep> <identifier> <identifiersep> size ( integer . <identifier> <identifiersep> value ) ; } \n \t1 } else if ( \n \t2 ! options . get <identifiersep> <identifier> <identifiersep> size ( ) . equals ( integer . <identifier> <identifiersep> value ) \n \t2 && ! options . get <identifiersep> <identifier> <identifiersep> size ( ) . equals ( 0 ) ) { \n <ect>
\t2 assert . assert <identifiersep> equals ( <identifier> <identifiersep> state . <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> output ( <identifier> . get <identifiersep> id ( ) ) . get <identifiersep> state ( ) ) ; \n \t2 <identifier> . wait <identifiersep> for <identifiersep> do <identifiersep> <identifier> ( ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> illegal <identifiersep> state ( ) throws exception { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> get <identifiersep> property <identifiersep> value ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t4 throw new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t3 <identifier> <identifier> = <identifier> . get ( 0 ) ; \n \t3 list < item > <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t4 . set <identifiersep> source ( <string_literal> , <string_literal> , \n \t6 <string_literal> , <string_literal> , \n \t6 <string_literal> , <string_literal> ) . get ( ) ; \n \t2 <identifier> ( ) ; \n <ect>
<comment> \n \t1 return new <identifier> <identifiersep> <identifier> ( ) { \n \t1 @ <identifier> \n \t1 public void update <identifiersep> <identifier> ( string name , long <identifier> , time <identifiersep> unit unit ) { \n <ect>
\t7 if ( <identifier> <identifiersep> account == null ) { \n \t8 s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> id ( ) ) ; \n \t8 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . delete <identifiersep> <identifier> ( user <identifiersep> context . current ( ) . get <identifiersep> <identifier> ( ) , user <identifiersep> context . current ( ) . get <identifiersep> <identifier> <identifiersep> user <identifiersep> id ( ) , <identifier> ) ; \n \t7 } else { \n <ect>
\t3 final <identifier> < url > e ; \n \t3 try { \n \t4 e = class <identifiersep> <identifier> . get <identifiersep> <identifier> ( config <identifiersep> file ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 for ( volume <identifiersep> vo <identifier> : <identifier> ) { \n \t3 if ( <identifier> . get <identifiersep> <identifier> ( ) != null ) { \n <ect>
\t4 <comment> \n \t4 if ( <identifier> <identifiersep> type != null \n \t6 && ! <identifier> <identifiersep> <identifier> <identifiersep> has <identifiersep> <identifier> <identifiersep> close <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t4 { \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> query <identifiersep> filter filter = command . filter . with <identifiersep> <identifier> <identifiersep> count ( <identifier> . <identifier> ( command . filter . count , <identifier> <identifiersep> size ) ) ; \n \t2 if ( last <identifiersep> <identifier> != null ) \n \t3 filter = filter . with <identifiersep> <identifier> <identifiersep> start ( last <identifiersep> <identifier> , <identifier> . <identifier> ) ; \n <ect>
\t5 <identifier> . add ( entry . get <identifiersep> value ( ) ) ; } \n \t3 for ( cluster <identifiersep> service <identifiersep> request <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> . remove ( <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; } } \n \t2 for ( cluster <identifiersep> service <identifiersep> request <identifiersep> <identifier> <identifier> : <identifier> ) { \n <ect>
\t2 if ( <identifier> <identifiersep> config != null ) { \n \t3 try { \n \t4 result = config <identifiersep> <identifier> . get <identifiersep> configuration ( <identifier> <identifiersep> config . <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> . set <identifiersep> object <identifiersep> name ( <string_literal> ) ; \n \t3 <identifier> . set <identifiersep> response <identifiersep> name ( get <identifiersep> command <identifiersep> name ( ) ) ; \n \t3 this . set <identifiersep> response <identifiersep> object ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> utils . delete <identifiersep> dir ( <identifier> . get <identifiersep> dir ( ) ) ; } } \n \t1 @ <identifier> \n \t1 public void create ( <identifier> <identifiersep> <identifier> <identifier> ) throws security <identifiersep> exception { \n \t2 if ( <identifier> . is <identifiersep> root ( ) ) { \n <ect>
\t9 new <identifier> <identifiersep> exception ( <identifier> <identifiersep> exception <identifiersep> mode . <identifier> <identifiersep> error , t , \n <number_literal> null ) , \n \t9 null , context ) ; } \n \t6 } catch ( throwable t ) { \n <ect>
\t3 if ( <identifier> == null ) { \n \t4 <identifier> = new configuration <identifiersep> vo ( <string_literal> , <string_literal> , <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> . to <identifiersep> string ( ) , null , <string_literal> ) ; } \n \t3 <identifier> . set <identifiersep> value ( db <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> store <identifiersep> password ) ) ; \n \t3 <identifier> <identifiersep> config <identifiersep> dao . <identifier> ( <identifier> ) ; \n <ect>
\t7 if ( ! <identifier> . <identifier> <identifiersep> exists ( location ) ) { \n \t8 error . add <identifiersep> key ( <string_literal> ) ; } \n \t6 } catch ( exception ex ) { \n \t7 <comment> \n <ect>
\t1 @ <identifier> \n \t1 @ path ( <string_literal> ) \n \t1 @ <identifier> ( { <string_literal> } ) \n \t1 public string add <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> type <identifier> ) { \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> job . get <identifiersep> <identifier> ( ) . set <identifiersep> start <identifiersep> <identifier> ( <identifier> <identifiersep> context . <identifier> ( ) . <identifier> ( ) + <identifier> <identifiersep> job <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> context . job <identifiersep> queue ( ) . add <identifiersep> job ( <identifier> <identifiersep> <identifier> <identifiersep> job ) ; \n \t2 } else { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> queue new <identifiersep> queue = new <identifier> <identifiersep> <identifier> <identifiersep> queue ( <string_literal> ) ; \n \t2 session . create <identifiersep> consumer ( new <identifiersep> queue ) ; \n \t2 thread . <identifier> ( <number_literal> ) ; \n \t2 assert <identifiersep> that ( new <identifiersep> queue , is <identifiersep> in ( new <identifiersep> <identifier> ) ) ; \n <ect>
\t4 if ( <identifier> == null ) { \n \t4 <identifier> <identifiersep> file <identifiersep> <identifier> . value = true ; <comment> \n \t4 continue ; <comment> \n \t3 } catch ( throwable t ) { \n <ect>
\t4 log . error ( <string_literal> ) ; \n \t4 log . error ( ex . get <identifiersep> message ( ) , ex ) ; } \n \t3 socket = null ; } \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> data = new file <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> file ) ; \n \t3 return s <identifiersep> <identifier> . add <identifiersep> <identifier> ( <identifier> <identifiersep> data , <identifier> ) ; \n \t2 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 protected void check <identifiersep> property ( final url web <identifiersep> <identifier> <identifiersep> url , final string property <identifiersep> name , final int <identifier> <identifiersep> code , \n \t3 final string <identifier> <identifiersep> body ) throws exception { \n \t2 final uri <identifier> <identifiersep> <identifier> <identifiersep> uri = new uri ( web <identifiersep> <identifier> <identifiersep> url . to <identifiersep> <identifier> <identifiersep> <identifier> ( ) + <identifier> <identifiersep> system <identifiersep> property <identifiersep> <identifier> . <identifier> <identifiersep> path . <identifier> ( 1 ) + <string_literal> \n \t4 + utils . <identifier> <identifiersep> query <identifiersep> <identifier> ( <identifier> <identifiersep> system <identifiersep> property <identifiersep> <identifier> . <identifier> <identifiersep> property <identifiersep> name , property <identifiersep> name ) ) ; \n <ect>
\t2 final <identifier> <identifiersep> <identifier> <identifiersep> item <identifier> <identifiersep> <identifier> <identifiersep> item = new <identifier> <identifiersep> <identifier> <identifiersep> item ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> item . add <identifiersep> action <identifiersep> listener ( new client <identifiersep> <identifier> <identifiersep> action <identifiersep> listener ( ) { \n \t3 @ <identifier> \n \t3 public void client <identifiersep> action <identifiersep> <identifier> ( <identifier> <identifiersep> handler <identifier> <identifiersep> handler , action <identifiersep> event e ) { \n <ect>
\t2 date start = new date ( system . current <identifiersep> time <identifiersep> millis ( ) + ( config . get <identifiersep> <identifier> ( ) ) * <number_literal> ) ; \n \t2 <identifier> <identifier> = new <identifiersep> <identifier> ( ) . with <identifiersep> <identifier> ( job <identifiersep> name + <string_literal> , job <identifiersep> group ) . start <identifiersep> <identifier> ( start ) \n \t4 . with <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> ( ) . with <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ( config . get <identifiersep> <identifier> ( ) ) ) . build ( ) ; \n \t2 <identifier> ( job <identifiersep> name , <identifier> <identifiersep> job . class , <identifier> , new job <identifiersep> data <identifiersep> map ( ) ) ; \n <ect>
\t2 } finally { \n \t3 <identifier> <identifiersep> <identifier> . end ( ) ; } \n \t2 <identifier> <identifiersep> time = system . <identifier> <identifiersep> time ( ) ; \n \t2 time = ( <identifier> <identifiersep> time - start <identifiersep> time ) / 1 . 0e6 ; \n <ect>
\t1 byte <identifiersep> array <identifiersep> output <identifiersep> stream out = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; \n \t1 try { \n \t1 job <identifiersep> conf . write ( new data <identifiersep> output <identifiersep> stream ( out ) ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 log . warn ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t1 <identifier> . <identifier> ( ) . info ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; \n \t1 throw new <identifier> <identifiersep> exception ( code . <identifier> <identifiersep> <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; \n \t1 } catch ( <identifier> <identifiersep> security <identifiersep> exception e ) { \n <ect>
\t3 throw new <identifier> <identifiersep> exception ( <string_literal> ) ; } \n \t2 session . get <identifiersep> context ( ) . set <identifiersep> <identifier> ( <identifier> ) ; \n \t2 authentication <identifiersep> manager . <identifier> <identifiersep> result <identifier> <identifiersep> result = <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> token ( session , <identifier> , uri <identifiersep> info , client <identifiersep> connection , <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> result == null ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> result result = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> result ( ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 try { \n \t4 thread . <identifier> ( <number_literal> ) ; \n \t3 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t3 log . debug ( <string_literal> , <identifier> , <identifier> ) ; } \n \t2 <comment> \n \t2 <comment> \n \t2 if ( <identifier> . is <identifiersep> <identifier> <identifiersep> failed ( ) && ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 url model <identifiersep> file = null ; \n \t3 try { \n \t4 model <identifiersep> file = <identifier> <identifiersep> file . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ; \n \t3 } catch ( <identifier> <identifiersep> url <identifiersep> exception <identifier> ) { \n <ect>
\t2 try { \n \t3 <comment> \n \t3 <identifier> <identifiersep> properties . load <identifiersep> from <identifiersep> resource <identifiersep> file ( <string_literal> ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 && instance . get <identifiersep> status ( ) != instance . status . <identifier> <identifiersep> <identifier> ) { \n \t2 <comment> \n \t2 int timeout = ( instance . get <identifiersep> status ( ) == instance . status . new || instance . get <identifiersep> status ( ) == instance . status . <identifier> ) ? <number_literal> \n \t4 : <number_literal> ; \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t1 if <identifier> <identifiersep> query <identifiersep> server <identifiersep> <identifier> is <identifier> : \n \t2 return [ ] \n \t1 return [ host [ <identifier> ] [ <identifier> <identifiersep> <identifier> ] for host in <identifier> <identifiersep> query <identifiersep> server <identifiersep> <identifier> ] \n <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( self , <identifier> , cluster <identifiersep> data , <identifier> , <identifier> ) : \n <ect>
\t1 double cluster <identifiersep> <identifier> <identifiersep> <identifier> , boolean run <identifiersep> <identifier> ) throws io <identifiersep> exception , interrupted <identifiersep> exception , \n \t1 class <identifiersep> not <identifiersep> found <identifiersep> exception { \n \t1 log . info ( <string_literal> ) ; \n <ect>
\t5 <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> ) ; \n \t3 break ; \n \t2 case <identifier> <identifiersep> storage <identifiersep> vm <identifiersep> <identifier> <identifiersep> event <identifiersep> <identifier> . <identifier> <identifiersep> start <identifiersep> failure : \n <ect>
\t3 self . queue . put ( <identifier> <identifiersep> process <identifiersep> result ( self . element , failed , \n \t7 <string_literal> <identifier> ( self . function , self . element , <identifier> ( e ) ) ) ) \n \t2 return \n <identifier> execute <identifiersep> in <identifiersep> <identifier> ( function , array , <identifier> , wait <identifiersep> for <identifiersep> all = false ) : \n <ect>
\t3 ) ; } \n \t2 index <identifiersep> <identifier> ( true , <identifier> ) ; \n \t2 <identifier> ( ) ; \n \t2 query <identifiersep> builder <identifier> = query <identifiersep> <identifier> . <identifier> <identifiersep> query ( <string_literal> ) . from ( 0 ) . to ( <number_literal> ) ; \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( false ) ; \n \t3 <identifier> . start ( ) ; \n \t3 <identifier> . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 private final file <identifier> <identifiersep> <identifier> ; \n \t1 private final object <identifiersep> <identifier> <identifier> ; \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> dir <identifiersep> manager ( @ output <identifiersep> <identifier> file output <identifiersep> <identifier> , object <identifiersep> <identifier> <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> request < <identifier> <identifiersep> response > <identifier> <identifiersep> request = new <identifier> <identifiersep> request ( ) ; \n \t2 <identifier> <identifiersep> request . set <identifiersep> method ( <identifier> <identifiersep> request . method . get ) ; \n \t2 <identifier> <identifiersep> request . set <identifiersep> path ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> response = <identifier> <identifiersep> request . process ( <identifier> <identifiersep> client ) ; \n <ect>
\t2 if ( <identifier> . is <identifiersep> empty ( config . get <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> ( ) . list <identifiersep> <identifier> ( ) ) ) { \n \t3 config . get <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t2 check <identifiersep> server <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n <ect>
\t2 string config <identifiersep> property = key . <identifier> ( <identifier> <identifiersep> property <identifiersep> <identifier> . length ( ) ) ; \n \t2 try { \n \t2 set <identifiersep> property ( configuration , config <identifiersep> property , value ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception | <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
protected char [ ] class <identifiersep> name <identifiersep> <identifier> = new char [ string <identifiersep> <identifier> <identifiersep> length * <number_literal> ] ; \n protected char [ ] process <identifiersep> file <identifiersep> name <identifiersep> <identifier> = new char [ string <identifiersep> <identifier> <identifiersep> length * <number_literal> ] ; \n protected int [ ] <identifier> <identifiersep> size = new int [ ] { string <identifiersep> <identifier> <identifiersep> length } ; \n public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t4 wait <identifiersep> for <identifiersep> data <identifiersep> <identifier> ( wait <identifiersep> time <identifiersep> <identifier> ) ; } \n \t2 } catch ( <identifier> <identifiersep> service <identifiersep> exception <identifier> ) { \n \t3 log . error ( <string_literal> ) ; \n \t3 log . error ( <string_literal> + <identifier> . get <identifiersep> error <identifiersep> code ( ) ) ; \n <ect>
\t3 property <identifiersep> utils . load <identifiersep> from <identifiersep> file ( properties , meta <identifiersep> <identifier> ) ; } \n \t2 catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { } \n \t2 catch ( io <identifiersep> exception ex ) \n \t2 { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 answer = <identifier> . <identifier> <identifiersep> exchange ( <identifier> <identifiersep> context , new <identifier> ( <identifier> ) ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 throw new runtime <identifiersep> exception ( <string_literal> + key + <string_literal> + <identifier> <identifiersep> name , e ) ; } \n <ect>
\t2 throw new <identifier> <identifiersep> exception ( http <identifiersep> response <identifiersep> status . not <identifiersep> found , <identifier> <identifiersep> exception . no <identifiersep> such <identifiersep> entity , <string_literal> + <identifier> <identifiersep> name + <string_literal> ) ; \n \t1 else if ( <identifier> <identifiersep> exception . server <identifiersep> <identifier> <identifiersep> delete <identifiersep> <identifier> . equals ( ex . get <identifiersep> message ( ) ) ) \n \t2 throw new <identifier> <identifiersep> exception ( http <identifiersep> response <identifiersep> status . <identifier> , <identifier> <identifiersep> exception . delete <identifiersep> <identifier> , <string_literal> + <identifier> <identifiersep> name + <string_literal> ) ; \n \t1 else { \n <ect>
\t6 if ( from . get <identifiersep> uri ( ) != null && from . get <identifiersep> uri ( ) . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t7 has <identifiersep> <identifier> <identifiersep> api = true ; } } \n \t5 if ( ! has <identifiersep> <identifier> <identifiersep> api ) { \n \t6 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . as <identifiersep> <identifier> <identifiersep> api <identifiersep> <identifier> ( get <identifiersep> context ( ) , config ) ; \n <ect>
\t1 private static boolean is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 if ( is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 return true ; \n \t2 } else { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> client == null ) { \n \t3 <comment> \n \t3 <comment> \n \t3 string <identifier> <identifiersep> url = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , <string_literal> ) ; \n <ect>
\t4 host <identifiersep> <identifier> = host . get <identifiersep> <identifier> ( conn ) ; \n \t4 if ( host <identifiersep> <identifier> != null ) { \n \t5 break ; } \n \t3 } catch ( xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t9 new <identifier> <identifiersep> type ( get <identifiersep> double <identifiersep> value <identifiersep> from <identifiersep> attribute ( element , <string_literal> ) ) ) ; \n \t7 logger . debug ( <string_literal> , item <identifiersep> name , \n \t9 get <identifiersep> double <identifiersep> value <identifiersep> from <identifiersep> attribute ( element , <string_literal> ) ) ; \n \t6 } else { \n <ect>
\t2 try { \n \t3 final <identifier> <identifiersep> cluster <identifiersep> status <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> api . get <identifiersep> <identifier> <identifiersep> cluster <identifiersep> status ( ) ; \n \t3 get <identifiersep> api <identifiersep> provider <identifiersep> <identifier> <identifiersep> version ( <identifier> ) ; \n \t3 if ( ! <string_literal> . equals ( <identifier> . get <identifiersep> cluster <identifiersep> status ( ) ) ) { \n <ect>
\t3 if ( n <identifiersep> <identifier> != <identifier> ) { \n \t4 logger . info ( <string_literal> + <identifier> + <string_literal> + n <identifiersep> <identifier> + <string_literal> ) ; } } \n \t2 int <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = ( int ) ( total <identifiersep> size <identifiersep> in <identifiersep> m / n <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . max ( 1 , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 { \n \t3 <identifier> . handle ( <identifier> <identifiersep> message ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t3 for ( string <identifier> : <identifier> ) { \n \t4 if ( <identifier> <identifiersep> <identifier> . contains ( <identifier> ) ) { \n \t5 add <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t4 } else { \n <ect>
\t4 return ; } \n \t3 <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; } \n \t2 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> ( <identifier> ) == null ) { \n <ect>
\t2 session <identifiersep> status <identifiersep> message msg = ( session <identifiersep> status <identifiersep> message ) message ; \n \t2 session . set <identifiersep> session <identifiersep> id ( msg . get <identifiersep> session <identifiersep> id ( ) ) ; \n \t2 switch ( msg . get <identifiersep> status ( ) ) { \n \t2 case session <identifiersep> status <identifiersep> message . status <identifiersep> <identifier> : \n <ect>
\t1 if ( null != <identifier> ) { \n \t1 try { \n \t2 <identifier> . close ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> event <identifier> ) \n \t2 { \n \t3 synchronized ( this ) \n \t3 { \n <ect>
\t1 logger . debug ( <string_literal> , <identifier> <identifiersep> name , name ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = client . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> client ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> result = get ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , 0 ) ; \n \t1 logger . trace ( <string_literal> , result . get <identifiersep> id ( ) ) ; \n <ect>
\t6 int <identifiersep> <identifier> <identifiersep> set set = int <identifiersep> <identifier> <identifiersep> set . from ( <identifier> <identifiersep> <identifier> ) ; \n \t6 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t7 int id = integer . parse <identifiersep> int ( <identifier> . get <identifiersep> id ( ) ) ; \n \t7 if ( ! set . remove ( id ) ) { \n <ect>
\t4 logger . error ( <string_literal> , ex ) ; \n \t4 logger . error ( <string_literal> + <identifier> . format ( <identifier> . length ) + <string_literal> ) ; \n \t4 logger . error ( <string_literal> + <identifier> ) ; \n \t4 logger . error ( <string_literal> + <identifier> . format ( <identifier> . length ) + <string_literal> ) ; \n <ect>
\t5 <string_literal> ) ; \n \t3 log . debug ( <string_literal> , e ) ; \n \t3 return null ; \n \t2 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n <ect>
\t3 security <identifiersep> context = security <identifiersep> context . get <identifiersep> instance ( <identifier> <identifiersep> user , access <identifiersep> mode . <identifier> ) ; \n \t3 this . user = new <identifier> <identifiersep> <identifier> <identifiersep> user ( security <identifiersep> context , <identifier> <identifiersep> user ) ; \n \t3 <identifier> . success ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t2 <identifier> . process ( ) ; \n \t2 failed = true ; } \n \t1 } catch ( event <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t1 private void add <identifiersep> <identifier> <identifiersep> type ( connection conn , long <identifier> <identifiersep> network <identifiersep> id , string <identifier> <identifiersep> type , string <identifier> <identifiersep> public <identifiersep> <identifier> , string <identifier> <identifiersep> public <identifiersep> <identifier> , string <identifier> <identifiersep> public <identifiersep> <identifier> ) { \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> update = null ; \n \t2 try { \n <ect>
\t4 m <identifiersep> system <identifiersep> <identifier> <identifiersep> <identifier> = on ; \n \t4 m <identifiersep> service . <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> mode <identifiersep> <identifier> ( on ) ; } } } \n \t1 private void update <identifiersep> <identifier> <identifiersep> manager <identifiersep> for <identifiersep> system <identifiersep> <identifier> ( boolean on ) { \n \t2 int device = m <identifiersep> service . get <identifiersep> <identifier> <identifiersep> manager ( ) . set <identifiersep> <identifier> <identifiersep> system <identifiersep> <identifier> <identifiersep> <identifier> ( on ) ; \n <ect>
\t1 } catch ( final exception ex ) { \n \t2 log . warn ( <string_literal> , ex ) ; \n \t2 return ; } \n \t1 if ( <identifier> <identifiersep> <identifier> . size ( ) > 1 ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> = true ; } \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> + <string_literal> ) ; \n \t4 if ( ! shutdown <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ) { \n <ect>
\t4 <identifier> <identifiersep> in <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; } \n \t3 if ( answer != null ) { \n \t4 final response response = new response ( <identifier> , answer ) ; \n <ect>
\t1 boolean <identifier> <identifiersep> table = false ; \n \t1 <comment> \n \t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> table <identifiersep> name . equals ( table <identifiersep> name ) ) { \n \t1 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> table <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 check <identifiersep> connection ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> send <identifiersep> key ( key ) ; \n \t2 } catch ( socket <identifiersep> exception e ) { \n <ect>
\t1 } catch ( <identifier> <identifiersep> exception e ) { \n \t2 switch ( e . code ( ) ) { \n \t2 case <identifier> : \n \t2 case <identifier> : \n <ect>
\t4 <identifier> <identifiersep> state = true ; \n \t4 break ; } } \n \t2 set < string > <identifier> <identifiersep> to <identifiersep> check = new <identifier> <identifiersep> set < string > ( ) ; \n \t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t5 logger . debug ( <string_literal> { } \\ <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t5 <identifier> . close ( ) ; \n \t5 <identifier> . switch <identifiersep> to ( ) . <identifier> ( current ) ; } } \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . set <identifiersep> ignore <identifiersep> <identifier> <identifiersep> <identifier> ( true ) ; \n \t5 log . debug ( <string_literal> + object ) ; } } \n \t3 catch ( exception e ) { \n <ect>
\t1 for ( conf <identifiersep> logger logger : conf <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) { \n \t2 string logger <identifiersep> name = logger . get <identifiersep> logger ( ) ; \n \t2 level log <identifiersep> level = level . get <identifiersep> level ( logger . get <identifiersep> level ( ) ) ; \n \t2 if ( log <identifiersep> level == null ) { \n <ect>
\t3 <comment> \n \t3 this . has <identifiersep> <identifier> <identifiersep> <identifier> = false ; \n \t3 this . <identifier> = new failure <identifiersep> code <identifiersep> <identifier> ( false ) ; \n \t2 } catch ( storage <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t4 <identifier> = new <identifier> <identifiersep> <identifier> ( new output <identifiersep> stream <identifiersep> <identifier> ( new file <identifiersep> output <identifiersep> stream ( file ) , <string_literal> ) ) ; \n \t4 stream . <identifier> ( node , new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> dir ( ) ; \n \t1 run ( <string_literal> + db <identifiersep> name , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> result ( 0 , 0 , <identifier> ) ; \n \t1 string <identifier> <identifiersep> <identifier> <identifiersep> id = get <identifiersep> result ( 0 , 1 , true , <identifier> ) ; \n <ect>
\t2 if ( <identifier> == null ) \n \t3 throw new configuration <identifiersep> exception ( string . format ( <string_literal> , <identifier> . name , <identifier> . <identifier> ) ) ; \n \t2 else if ( <identifier> . get <identifiersep> table <identifiersep> or <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . name ) != null ) \n \t3 throw new <identifier> <identifiersep> exists <identifiersep> exception ( <identifier> . <identifier> , <identifier> . name ) ; \n <ect>
\t1 <identifier> <identifier> = null ; \n \t1 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = null ; \n \t1 result <identifiersep> set <identifier> = null ; \n \t1 <identifier> <identifiersep> <identifier> = <identifier> . get <identifiersep> table <identifiersep> id <identifiersep> from <identifiersep> instance <identifiersep> name ( c , instance ) ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t1 public void start <identifiersep> <identifier> <identifiersep> server ( @ <identifier> ( <identifier> = - 1 ) <identifier> <identifiersep> class event ) throws <identifier> <identifiersep> url <identifiersep> exception , interrupted <identifiersep> exception , io <identifiersep> exception { \n \t2 if ( test <identifiersep> context . is <identifiersep> <identifier> <identifiersep> test ( ) && ! test <identifiersep> context . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test ( ) ) { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> instance . get ( ) ; \n \t3 if ( ! <identifier> . is <identifiersep> <identifier> ( test <identifiersep> context . get <identifiersep> <identifier> <identifiersep> server <identifiersep> info ( ) . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t3 for ( int i = 0 ; i < <identifier> . length ; i ++ ) { \n \t4 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> set . get <identifiersep> <identifier> ( i ) ; \n \t4 if ( <identifier> [ i ] ) { \n \t5 if ( ! <identifier> . is <identifiersep> local ( <identifier> , <identifier> ) ) { \n <ect>
\t6 <identifier> <identifiersep> log . warn ( <string_literal> + <identifier> . to <identifiersep> string ( ip ) + <string_literal> + count + <string_literal> + <identifier> ) ; \n \t4 } else { \n \t5 count = 1 ; \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 try { \n \t3 execute <identifiersep> <identifier> <identifiersep> json <identifiersep> test ( <string_literal> , <string_literal> , false , <number_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 logger . warn ( <string_literal> + this , ex ) ; } } } \n \t1 protected void close <identifiersep> <identifier> ( close <identifiersep> status status ) throws io <identifiersep> exception { \n \t2 if ( this . state == null ) { \n <ect>
<number_literal> event . get <identifiersep> security <identifiersep> level ( ) , <identifier> , \n <number_literal> event . get <identifiersep> max <identifiersep> size <identifiersep> response <identifiersep> <identifier> ( ) , <identifier> , \n <number_literal> status <identifiersep> <identifier> ) ; \n <ect>
\t6 local . <identifier> ( new <identifier> <identifiersep> command ( <identifier> <identifiersep> id . <identifier> <identifiersep> and <identifiersep> get ( ) ) ) ; \n \t5 } catch ( exception e ) { } } } \n \t2 } ) ; \n \t2 t . start ( ) ; \n <ect>
\t3 s <identifiersep> logger . trace ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> state ( <identifier> <identifiersep> <identifier> . state . <identifier> ) ; } \n \t2 try { \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , true , false ) ) { \n <ect>
\t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n \t2 } finally { \n \t3 <identifier> . close <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 } else { \n <ect>
\t3 return null ; } \n \t2 final map < string , <identifier> <identifiersep> authentication <identifiersep> provider > provider <identifiersep> map = \n \t4 <identifier> <identifiersep> authentication <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> authentication <identifiersep> <identifier> ( this . application <identifiersep> context ) ; \n \t2 if ( provider <identifiersep> map == null || provider <identifiersep> map . is <identifiersep> empty ( ) ) { \n <ect>
\t4 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , \n \t4 <identifier> ) ; \n \t2 int <identifier> = file <identifiersep> io <identifiersep> utils . write <identifiersep> <identifier> ( <identifier> , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , true ) ; \n \t2 log . debug ( <string_literal> + <identifier> ) ; \n <ect>
\t4 <identifier> <identifiersep> <identifier> . add ( 0 , <identifier> <identifiersep> address ) ; \n \t4 <identifier> <identifiersep> <identifier> . add ( 1 , new long ( <identifier> <identifiersep> size ) ) ; \n \t4 current <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . put ( <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> ) ; } \n \t2 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t5 else { \n \t6 <identifier> = thread <identifiersep> group <identifiersep> <identifier> <identifiersep> <identifier> . next ( ) ; } } \n \t4 if ( thread <identifiersep> group <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t5 <identifier> = false ; \n <ect>
import <identifier> . <identifier> . utils . <identifier> . <identifier> <identifiersep> enabled <identifiersep> test <identifiersep> case ; \n public class test <identifiersep> <identifier> extends <identifier> <identifiersep> enabled <identifiersep> test <identifiersep> case { \n \t1 protected final static logger s <identifiersep> logger = logger . get <identifiersep> logger ( test <identifiersep> <identifier> . class ) ; \n \t1 public void test <identifiersep> <identifier> ( ) { \n <ect>
\t2 string value = <identifier> <identifiersep> config <identifiersep> dao . get <identifiersep> value ( config . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> last <identifiersep> state . key ( ) ) ; \n \t2 if ( value != null ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state state = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> state . value <identifiersep> of ( value ) ; \n \t3 if ( state == null ) { \n <ect>
\t4 <identifier> . write ( <identifier> , 0 , count ) ; \n \t4 count = <identifier> . read ( <identifier> ) ; } \n \t3 return new string ( <identifier> . to <identifiersep> byte <identifiersep> array ( ) , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t1 self . check <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> cmd , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , int ( format ( <string_literal> ) ) , \n \t5 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> principal , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> authentication , <identifier> . <identifier> <identifiersep> transport <identifiersep> mode , \n \t5 <identifier> . <identifier> <identifiersep> http <identifiersep> endpoint ) \n \t1 logger . info ( <string_literal> ) \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> task ( task ) ; } \n \t4 catch ( exception e ) { \n \t5 <comment> \n <ect>
\t1 @ <identifier> \n \t1 public collection < authentication <identifiersep> handler <identifiersep> <identifier> > get <identifiersep> authentication <identifiersep> handler <identifiersep> <identifier> ( final authentication <identifiersep> transaction transaction ) { \n \t2 final list < authentication <identifiersep> handler <identifiersep> <identifier> > list = new array <identifiersep> list ( this . authentication <identifiersep> handler <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( list ) ; \n <ect>
\t4 thread . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> millis ) ; \n \t4 total <identifiersep> <identifier> <identifiersep> wait += <identifier> <identifiersep> <identifier> <identifiersep> millis ; \n \t4 if ( max <identifiersep> <identifier> <identifiersep> wait <identifiersep> in <identifiersep> millis > - 1 && total <identifiersep> <identifier> <identifiersep> wait > max <identifiersep> <identifier> <identifiersep> wait <identifiersep> in <identifiersep> millis ) { \n \t5 <identifier> <identifiersep> out = true ; \n <ect>
\t3 resource <identifiersep> manager <identifiersep> <identifier> <identifiersep> count > 0 ) ) { <comment> \n \t2 return state . <identifier> ; } \n \t2 return <identifier> <identifiersep> <identifier> <identifiersep> state ; } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> service <identifiersep> properties <identifiersep> <identifier> ( <identifier> , instance <identifiersep> type , <identifier> , <identifier> <identifiersep> <identifier> ) ) ; \n \t1 try { \n \t1 return task . get ( ) ; \n \t1 } catch ( final exception ex ) { \n <ect>
\t1 public void start ( int port ) throws io <identifiersep> exception { \n \t2 server <identifiersep> socket server <identifiersep> socket ; \n \t2 try { \n \t3 server <identifiersep> socket = new server <identifiersep> socket ( port ) ; \n <ect>
\t2 xml <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> test ( <string_literal> , ex <identifiersep> <identifier> , ex <identifiersep> <identifier> <identifiersep> <identifier> , ex <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) { \n <ect>
\t2 <identifier> session <identifiersep> id = request . session <identifiersep> id ; \n \t2 local <identifiersep> session session = get <identifiersep> session ( session <identifiersep> id ) ; \n \t2 if ( session == null ) \n \t2 { \n <ect>
\t1 @ <identifier> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) throws exception { } \n \t1 public void <identifier> ( ) throws sql <identifiersep> exception { \n <ect>
\t4 if ( <identifier> != null ) { \n \t5 s <identifiersep> <identifier> <identifiersep> on <identifiersep> error = <identifier> <identifiersep> <identifier> . parse <identifiersep> <identifier> ( <identifier> , <number_literal> ) * <number_literal> ; } \n \t4 s <identifiersep> logger . info ( <string_literal> + s <identifiersep> <identifier> <identifiersep> on <identifiersep> error ) ; \n \t3 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t4 { \n \t5 byte [ ] ip <identifiersep> bytes = new byte [ ] { <number_literal> , ( byte ) <identifier> , ( byte ) <identifier> , ( byte ) <identifier> } ; \n \t5 <identifier> <identifiersep> address address = <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> address ( ip <identifiersep> bytes ) ; \n \t5 string <identifiersep> token token = new string <identifiersep> token ( string . format ( <string_literal> , <identifier> , <identifier> , <identifier> ) ) ; \n <ect>
\t3 string <identifier> <identifiersep> uri = <identifier> <identifiersep> type . get <identifiersep> <identifier> ( ) . get <identifiersep> uri ( ) ; \n \t3 string property <identifiersep> uri = <identifier> <identifiersep> type . get <identifiersep> type ( ) . get <identifiersep> uri ( ) ; \n \t3 double <identifier> = <identifier> <identifiersep> type . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 <identifier> <identifier> = <identifier> <identifiersep> type . get <identifiersep> <identifier> ( ) ; \n <ect>
\t3 try { \n \t4 s <identifiersep> logger . trace ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> conn . set <identifiersep> <identifier> <identifiersep> <identifier> ( false ) ; \n \t3 } catch ( final sql <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> factory . get <identifiersep> default <identifiersep> <identifier> ( ) ; \n \t3 super . <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 input <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( this . <identifier> <identifiersep> path ) ; \n \t2 store . load ( input <identifiersep> stream , this . <identifier> <identifiersep> password ) ; \n \t2 this . <identifier> = <identifier> . get <identifiersep> instance ( this . <identifier> <identifiersep> type ) ; \n \t2 this . <identifier> = ( <identifier> ) store . get <identifiersep> <identifier> ( this . <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 try { \n \t4 for ( path path : data <identifiersep> dir <identifiersep> to <identifiersep> <identifier> ) { \n \t5 try { \n \t6 file <identifiersep> system <identifiersep> utils . delete <identifiersep> <identifier> <identifiersep> <identifier> ( path ) ; \n <ect>
\t1 protected class <identifier> <identifiersep> server <identifiersep> <identifier> <identifiersep> task extends <identifier> <identifiersep> context <identifiersep> <identifier> { \n \t2 @ <identifier> \n \t2 protected void run <identifiersep> in <identifiersep> context ( ) { \n <ect>
\t4 logger . info ( <string_literal> , <identifier> , get <identifiersep> <identifier> <identifiersep> info ( <identifier> , <identifier> ) ) ; \n \t4 <identifier> . set <identifiersep> has <identifiersep> <identifier> <identifiersep> db <identifiersep> entry ( true ) ; } \n \t2 } else { \n \t3 if ( m <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> db <identifiersep> <identifier> ( ) && ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> . start <identifiersep> or <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t1 log . info ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public void not <identifiersep> <identifier> ( ) { \n <ect>
\t5 <comment> \n \t5 if ( ( ip <identifiersep> <identifier> != null ) && <identifier> <identifiersep> utils . is <identifiersep> ip <identifiersep> with <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( ip <identifiersep> <identifier> , network <identifiersep> <identifier> ) ) { \n \t6 ip = ip <identifiersep> <identifier> ; \n \t6 break ; } \n <ect>
\t6 host <identifiersep> <identifier> host <identifiersep> <identifier> = new host <identifiersep> <identifier> ( context , <string_literal> , <identifier> <identifiersep> <identifier> . get <identifiersep> host <identifiersep> <identifier> <identifiersep> value ( ) ) ; \n \t6 cluster <identifiersep> <identifier> cluster <identifiersep> <identifier> = new cluster <identifiersep> <identifier> ( context , host <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> host <identifiersep> cluster ( ) ) ; \n \t6 vm <identifiersep> <identifier> = cluster <identifiersep> <identifier> . find <identifiersep> vm <identifiersep> on <identifiersep> <identifier> <identifiersep> host ( <identifier> <identifiersep> <identifier> . get <identifiersep> vm <identifiersep> name ( ) ) ; } \n \t5 if ( vm <identifiersep> <identifier> != null ) { \n <ect>
\t3 this . <identifier> . <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> task , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; } \n \t2 void <identifier> ( connection connection , long <identifier> <identifiersep> time ) { \n \t3 if ( shutdown ) { \n \t4 <comment> \n <ect>
\t1 public list < i <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao > <identifier> <identifiersep> attribute <identifiersep> <identifier> ( ) { \n \t2 final list < i <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao > list = new array <identifiersep> list < > ( ) ; \n \t2 final map < string , string > <identifier> = <identifier> <identifiersep> properties . get <identifiersep> <identifier> ( ) . get <identifiersep> attribute <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) . get <identifiersep> attributes ( ) ; \n \t2 if ( ! <identifier> . is <identifiersep> empty ( ) && list . is <identifiersep> empty ( ) ) { \n <ect>
\t6 bean . bean <identifiersep> <identifier> . <identifier> <identifiersep> check = abstract <identifiersep> bean <identifiersep> <identifier> . <identifier> <identifiersep> check <identifiersep> <identifier> } \n \t5 if ( <identifier> <identifiersep> <identifier> <identifiersep> id ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> id = <identifier> <identifiersep> <identifier> <identifiersep> id } } } } \n \t2 if ( config . get <identifiersep> property ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> json <identifiersep> builder , boolean . class , false ) ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 if ( conf . length ( ) > 0 ) { \n \t5 string [ ] <identifier> = conf . <identifier> ( <string_literal> , <number_literal> ) ; \n \t5 <comment> \n \t5 if ( <identifier> . length == 1 ) { \n <ect>
\t5 <identifier> < <identifier> <identifiersep> <identifier> > <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> manager . instance . get <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t5 if ( ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t5 } else { \n \t6 table <identifiersep> <identifier> table = <identifier> . get ( ) . create <identifiersep> <identifier> <identifiersep> table ( user <identifiersep> id , options ) ; \n <ect>
\t2 test <identifiersep> <identifier> . start ( ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) { \n \t2 test <identifiersep> <identifier> . stop ( ) ; \n <ect>
\t1 @ test \n \t1 public void get <identifiersep> if <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws io <identifiersep> exception { \n \t2 log . info ( <string_literal> ) ; \n \t2 get ( false ) ; \n <ect>
\t3 log . warn ( <string_literal> , e . get <identifiersep> message ( ) , e . get <identifiersep> status <identifiersep> code ( ) , \n \t5 e . get <identifiersep> response <identifiersep> <identifier> ( ) , e ) ; \n \t3 throw new job <identifiersep> execution <identifiersep> exception ( <string_literal> , e , false ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 logger . error ( <string_literal> , <identifier> ) ; \n \t1 } catch ( illegal <identifiersep> access <identifiersep> exception <identifier> ) { \n \t2 logger . error ( <string_literal> , <identifier> ) ; \n \t1 } catch ( <identifier> <identifiersep> target <identifiersep> exception <identifier> ) { \n <ect>
\t6 string <identifier> = <identifier> <identifiersep> <identifier> + ' <identifiersep> ' + list ; \n \t6 string list <identifiersep> version = info . get <identifiersep> property ( <identifier> ) ; \n \t6 if ( list <identifiersep> version == null || version <identifiersep> <identifier> . <identifier> ( list <identifiersep> version , <string_literal> ) < 0 ) { \n \t7 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( log <identifiersep> files , queue , true ) ; \n \t1 if ( <identifier> . <identifier> ( ) ) { \n \t2 <identifier> . write <identifiersep> <identifier> ( ) ; \n \t1 } else { \n <ect>
\t4 input <identifiersep> stream input = method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) ; \n \t4 element <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( server , input ) ; \n \t4 s <identifiersep> logger . info ( <string_literal> ) ; \n \t3 } else { \n <ect>
public static void shutdown ( ) { \n \t1 <identifier> . lock ( ) ; \n \t1 try { \n \t1 if ( pool != null ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> [ <identifier> . <identifier> . <identifier> . <identifier> ] = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n \t2 logger . info ( <string_literal> \n \t5 . format ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) \n \t1 else : \n <ect>
\t3 logger . error ( e . get <identifiersep> message ( ) , e ) ; \n \t2 } finally { \n \t3 if ( this . <identifier> <identifiersep> key == null ) { \n \t4 this . <identifier> <identifiersep> key = new <identifier> <identifiersep> key ( <identifier> <identifiersep> <identifier> <identifiersep> key . get <identifiersep> bytes ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> ) ) ; \n <ect>
\t6 { \n \t7 logger . error ( <string_literal> , ex ) ; } \n \t6 catch ( io <identifiersep> exception ex ) \n \t6 { \n <ect>
\t2 logger . info ( <string_literal> , path <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t2 logger . info ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) , system . get <identifiersep> property ( <string_literal> ) ) ; \n \t2 logger . info ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) , system . get <identifiersep> property ( <string_literal> ) ) ; \n \t2 logger . info ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) , system . get <identifiersep> property ( <string_literal> ) , system . get <identifiersep> property ( <string_literal> ) ) ; \n <ect>
\t4 put <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size ( to <identifiersep> be <identifiersep> <identifier> <identifiersep> file . get <identifiersep> name ( ) , to <identifiersep> be <identifiersep> <identifier> <identifiersep> file , true ) ; \n \t3 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t4 count ++ ; \n \t3 } else { \n <ect>
\t1 void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> ( connection conn , string name <identifiersep> <identifier> ) { \n \t2 try { \n \t3 set < <identifier> > <identifier> = <identifier> . get <identifiersep> by <identifiersep> name <identifiersep> <identifier> ( conn , name <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> . size ( ) != 1 ) { \n <ect>
\t3 for ( <identifier> <identifier> : shards ) { \n \t4 assert <identifiersep> version ( index , 1 , <string_literal> + <identifier> . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> name ( ) , final <identifiersep> version <identifiersep> for <identifiersep> <identifier> ) ; \n \t4 assert <identifiersep> count ( index , <string_literal> + <identifier> . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> name ( ) , 1 ) ; } \n \t3 n <identifiersep> <identifier> = <identifier> <identifiersep> int <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , max <identifiersep> <identifier> ) ; \n <ect>
\t4 <comment> \n \t4 element <identifier> <identifiersep> <identifier> = ( element ) <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> data ) ; \n \t4 <comment> \n <ect>
\t2 log . warn ( <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id + <string_literal> , <identifier> <identifiersep> ex ) ; \n \t2 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( \n \t3 <string_literal> + snapshot <identifiersep> id + <string_literal> + <identifier> <identifiersep> snapshot <identifiersep> id + <string_literal> , <identifier> <identifiersep> ex ) ; } \n \t2 if ( <identifier> == null ) { \n <ect>
\t1 logger . info ( <string_literal> ) ; \n \t1 version <identifiersep> <identifier> version <identifiersep> <identifier> = <identifier> . get <identifiersep> version <identifiersep> <identifier> ( <identifier> . get <identifiersep> id ( ) , null ) ; \n \t1 assert <identifiersep> not <identifiersep> null ( version <identifiersep> <identifier> ) ; \n \t1 assert <identifiersep> not <identifiersep> null ( version <identifiersep> <identifier> . get <identifiersep> id ( ) ) ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 public void run ( ) { \n \t3 try { \n \t4 <identifier> <identifiersep> task . run ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . <identifier> ( <identifier> ) ; \n \t3 string sql <identifiersep> template = out . to <identifiersep> string ( ) ; \n \t3 return <identifier> <identifiersep> utils . <identifier> ( sql <identifiersep> template ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 add <identifiersep> <identifier> <identifiersep> field ( <identifier> <identifiersep> <identifier> ) ; } \n \t2 <comment> \n \t2 if ( item <identifiersep> is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 if ( is <identifiersep> <identifier> ) { \n \t2 <identifier> <identifiersep> context . close ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . this . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> + name ) ; \n \t1 } else { \n <ect>
\t1 assert <identifiersep> true ( <string_literal> , <identifier> . <identifier> ( ( s - e ) / e ) < error <identifiersep> <identifier> ) ; \n \t1 <identifier> v = state . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( i ) ; \n \t1 <identifier> <identifier> = <identifier> . get <identifiersep> v ( ) . <identifier> <identifiersep> <identifier> ( i ) ; \n \t1 double error = 1 - <identifier> . <identifier> ( v . <identifier> ( <identifier> ) / ( v . <identifier> ( <number_literal> ) * <identifier> . <identifier> ( <number_literal> ) ) ) ; \n <ect>
\t2 try { \n \t3 log . debug ( <string_literal> ) ; \n \t3 <identifier> . <identifier> ( get <identifiersep> <identifier> ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( this ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = factory . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . set <identifiersep> <identifier> ( get <identifiersep> <identifier> ( ) ) ; \n \t2 string <identifier> <identifiersep> id <identifiersep> <identifier> = <string_literal> ; \n <ect>
\t2 for ( <identifier> <identifiersep> server <identifiersep> host <identifiersep> vo <identifier> : <identifier> . get <identifiersep> <identifier> <identifiersep> nodes ( ) ) { \n \t3 if ( <identifier> . get <identifiersep> id ( ) != <identifier> . get <identifiersep> self ( ) . long <identifiersep> value ( ) ) { \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> dao . <identifier> <identifiersep> <identifier> <identifiersep> count ( <identifier> . get <identifiersep> id ( ) ) > 0 ) { \n <ect>
public void set <identifiersep> <identifier> ( string <identifier> ) { \n \t1 this . <identifier> = <identifier> ; } \n @ <identifier> <identifiersep> remove \n public void delete <identifiersep> remote <identifiersep> file ( ) { \n <ect>
\t4 <identifier> <identifiersep> storage <identifiersep> pool <identifiersep> command cmd = new <identifier> <identifiersep> storage <identifiersep> pool <identifiersep> command ( false , storage <identifiersep> pool ) ; \n \t4 final answer answer = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> send ( host . get <identifiersep> id ( ) , cmd ) ; \n \t4 if ( answer == null || ! answer . get <identifiersep> result ( ) ) { \n <ect>
\t3 try { \n \t3 file <identifiersep> in . close ( ) ; \n \t3 file <identifiersep> in = null ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 } else { \n \t5 s <identifiersep> logger . debug ( <string_literal> + db <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> class <identifiersep> name ( <identifier> ) ) ; } \n \t4 if ( <identifier> <identifiersep> db <identifiersep> <identifier> . <identifier> ( <identifier> ) == false ) { \n \t5 if ( <identifier> <identifiersep> db <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> mode ( ) == db <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> mode <identifiersep> check ) { \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t4 break <identifier> ; } \n \t3 <comment> \n \t3 if ( v instanceof <identifier> ) continue ; \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> thread <identifiersep> event <identifiersep> <identifier> . this . run ( ) ; \n \t5 success = true ; \n \t4 } catch ( throwable t ) { \n <ect>
\t5 send <identifiersep> <identifier> <identifiersep> command ( item <identifiersep> name , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> on + group , out <identifiersep> to <identifiersep> server , i ) ; \n \t4 } else if ( command . equals ( on <identifiersep> <identifier> <identifiersep> type . on ) ) { \n \t5 send <identifiersep> <identifier> <identifiersep> command ( item <identifiersep> name , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> + group , out <identifiersep> to <identifiersep> server , i ) ; \n \t4 } else { \n <ect>
\t4 throw new type <identifiersep> not <identifiersep> <identifier> <identifiersep> exception ( default <identifiersep> <identifier> <identifiersep> class + <string_literal> , null ) ; } } \n \t2 try { \n \t3 method factory <identifiersep> method = factory . get <identifiersep> method ( <string_literal> , <identifier> <identifiersep> context . class , map . class ) ; \n \t3 map < string , object > <identifier> = get <identifiersep> <identifier> <identifiersep> as <identifiersep> map ( ) ; \n <ect>
\t2 for ( entry < <identifier> <identifiersep> <identifier> , c > entry : <identifier> <identifiersep> to <identifiersep> connection . entry <identifiersep> set ( ) ) { \n \t3 c connection = entry . get <identifiersep> value ( ) ; \n \t3 <identifier> <identifiersep> <identifier> p = entry . get <identifiersep> key ( ) ; \n \t3 if ( ! <identifier> . contains ( connection ) ) { \n <ect>
\t4 log . info ( <string_literal> , <identifier> <identifiersep> transaction . get <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> . <identifier> ( <identifier> <identifiersep> transaction ) ; } } \n \t2 if ( <identifier> <identifiersep> <identifier> == null ) \n \t3 return ; \n <ect>
\t5 { \n \t6 throw new illegal <identifiersep> state <identifiersep> exception ( e ) ; } } } \n \t3 catch ( final <identifier> <identifiersep> exception e ) \n \t3 { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( count ) ; \n \t2 stop <identifiersep> <identifier> <identifier> = new stop <identifiersep> <identifier> ( ) ; \n \t2 execute ( count ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t8 result <identifiersep> list . add <identifiersep> all ( <identifier> ) ; } } } } \n \t4 final int <identifier> <identifiersep> result <identifiersep> count = result <identifiersep> list . size ( ) ; \n \t4 return new result ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> list ( result <identifiersep> list , <identifier> <identifiersep> size , <identifier> ) , <identifier> <identifiersep> result <identifiersep> count , true , false ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t5 config <identifiersep> stream = config <identifiersep> url . <identifier> <identifiersep> stream ( ) ; } } \n \t3 if ( config <identifiersep> stream != null ) { \n \t4 return <identifier> <identifiersep> <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( config <identifiersep> stream ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception | io <identifiersep> exception | <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> store <identifiersep> <identifier> , false ) ; } \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 final output <identifiersep> stream <identifier> = output <identifiersep> stream ; \n \t2 <identifier> <identifier> = new <identifier> ( ) ; \n \t2 <identifier> <identifiersep> task <identifier> <identifiersep> task = new <identifier> <identifiersep> task ( ) { \n \t3 public void run ( ) { \n <ect>
\t6 <identifier> . put <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t6 thread . <identifier> ( <number_literal> ) ; } \n \t5 catch ( exception <identifier> ) \n \t5 { \n <ect>
\t2 new connection ( channel . <identifier> ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> channel <identifiersep> exception e ) { \n \t2 return ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> task task = new <identifier> <identifiersep> <identifier> <identifiersep> task ( <identifier> , request ) ; \n \t5 task . run ( ) ; \n \t5 break ; \n \t4 case <identifier> <identifiersep> request : \n <ect>
\t5 if ( index >= data <identifiersep> <identifier> <identifiersep> max <identifiersep> <identifier> ) { \n \t6 <comment> \n \t7 byte [ ] log <identifiersep> data = <identifier> . <identifier> <identifiersep> of ( data <identifiersep> <identifier> , index ) ; \n <ect>
\t3 } finally { \n \t4 try { \n \t5 file <identifiersep> utils . delete <identifiersep> directory ( <identifier> <identifiersep> dir . to <identifiersep> file ( ) ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 } else if ( result is file <identifiersep> <identifier> <identifiersep> result . <identifier> ) { \n \t4 <identifier> result <identifiersep> text = result . get <identifiersep> <identifier> <identifiersep> text ( ) \n \t4 if ( target <identifiersep> file . exists ( ) && target <identifiersep> file . is <identifiersep> text <identifiersep> equal <identifiersep> to ( result <identifiersep> text ) ) \n \t5 continue \n <ect>
\t3 string <identifier> <identifiersep> name = <identifier> . <identifier> <identifiersep> id <identifiersep> to <identifiersep> name ( <identifier> <identifiersep> id ) ; \n \t3 model . add <identifiersep> attribute ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; } \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 <identifier> . start ( ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 <identifier> . start ( ) ; \n <ect>
\t4 update <identifiersep> host <identifiersep> <identifier> <identifiersep> state ( task , execution <identifiersep> command , <identifier> . get <identifiersep> command <identifiersep> <identifier> ( ) ) ; } \n \t3 } else { \n \t3 log . warn ( <string_literal> , task <identifiersep> id ) ; } \n \t2 } else { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> type ( <identifier> ) ; \n \t5 <identifier> . <identifier> ( <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t1 public void on <identifiersep> host <identifiersep> <identifier> ( host host , exception <identifier> ) { \n \t2 logger . warn ( string . format ( <string_literal> + host + <string_literal> <string_literal> \\ <string_literal> ) ) ; } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> host <identifiersep> <identifier> ( host host , host <identifiersep> connection <identifiersep> pool < ? > pool ) { \n <ect>
\t9 e . get <identifiersep> <identifier> ( ) != null ? e . get <identifiersep> <identifier> ( ) . get <identifiersep> message ( ) : <string_literal> ) ) ; \n \t3 lock <identifiersep> <identifier> = false ; } \n \t2 <comment> \n \t2 catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t5 logger . error ( <string_literal> + <identifier> + <string_literal> + <identifier> , e ) ; } \n \t3 } ) ; } \n \t2 else { \n <ect>
\t2 for ( final file <identifier> : files ) { \n \t3 try { \n \t4 <identifier> . add ( <identifier> <identifiersep> list <identifiersep> input <identifiersep> type . get <identifiersep> <identifier> <identifiersep> list ( <identifier> , <identifier> <identifiersep> <identifier> ) . <identifier> ( <identifier> ) ) ; \n \t3 } catch ( final exception e ) { \n <ect>
\t4 <identifier> . <identifier> ( false ) ; \n \t4 return null ; } \n \t2 } ) ; \n \t2 <comment> \n <ect>
\t1 } else if ( target <identifiersep> bean != null ) { \n \t1 throw new <identifier> <identifiersep> exception ( <string_literal> + target <identifiersep> bean + <string_literal> ) ; \n \t1 } else { \n <ect>
\t7 answer answer = null ; \n \t7 try { \n \t8 answer = <identifier> . send <identifiersep> message ( cmd ) ; \n \t7 } catch ( <identifier> <identifiersep> runtime <identifiersep> exception e ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> ( ) ; \n \t1 try { \n \t1 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( get <identifiersep> <identifier> <identifiersep> session ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 long end <identifiersep> time <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> = system . <identifier> <identifiersep> time ( ) ; \n \t3 logger . info ( <string_literal> ) ; \n \t3 log <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list <identifiersep> for <identifiersep> <identifier> ( <identifier> <identifiersep> nodes ) ; \n <ect>
\t3 logger . error ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . length ) ; \n \t3 logger . error ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . length ) ; \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> . length ; i ++ ) { \n \t4 logger . error ( <string_literal> , i , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> [ i ] . <identifier> ) ; \n <ect>
\t1 private void do <identifiersep> <identifier> ( exchange exchange , string data <identifiersep> base <identifiersep> name , string <identifier> <identifiersep> policy ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( ! endpoint . is <identifiersep> <identifier> ( ) ) { \n \t3 <identifier> p = exchange . get <identifiersep> in ( ) . get <identifiersep> <identifier> <identifiersep> body ( <identifier> . class ) ; \n \t3 try { \n <ect>
\t3 if <identifier> <identifiersep> properties is not <identifier> : \n \t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> [ <identifier> <identifiersep> name ] [ <string_literal> ] \n \t3 self . logger . info ( <string_literal> <identifier> ( <identifier> <identifiersep> name , method . <identifier> <identifiersep> <identifier> <identifiersep> name <identifiersep> <identifier> <identifiersep> <identifier> ) ) \n \t3 self . logger . info ( <string_literal> <identifier> <identifier> ( <identifier> <identifiersep> properties ) ) \n <ect>
\t4 <comment> \n \t4 file <identifiersep> <identifier> = new <identifiersep> <identifier> ; } \n \t3 return test <identifiersep> <identifier> ; \n \t2 } catch ( @ <identifier> final json <identifiersep> parse <identifiersep> exception e ) { \n <ect>
\t3 user <identifiersep> group <identifiersep> <identifier> <identifier> <identifiersep> user ; \n \t3 try { \n \t4 <identifier> <identifiersep> user = user <identifiersep> group <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> user ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 return action <identifiersep> state ; } \n \t1 @ <identifier> \n \t1 public <identifier> <identifiersep> state create <identifiersep> <identifier> <identifiersep> state ( final <identifier> <identifier> , final string id , final string test <identifiersep> <identifier> , final string <identifier> <identifiersep> state <identifiersep> id , final string else <identifiersep> state <identifiersep> id ) { \n \t2 if ( contains <identifiersep> <identifier> <identifiersep> state ( <identifier> , id ) ) { \n <ect>
\t2 <comment> \n \t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 <comment> \n \t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n <ect>
\t1 @ test \n \t1 public void test <identifiersep> data <identifiersep> source <identifiersep> provider <identifiersep> input <identifiersep> stream <identifiersep> <identifier> ( ) throws exception { \n \t2 <comment> \n \t2 int count <identifiersep> <identifier> = count <identifiersep> files ( server <identifiersep> <identifier> <identifiersep> dir ) ; \n <ect>
\t3 int <identifier> = <identifier> <identifiersep> input <identifiersep> stream . read ( ) & <identifier> ; \n \t3 if ( <identifier> == <identifier> ) \n \t4 return - 1 ; \n <ect>
\t2 try { \n \t3 set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> meta <identifiersep> data . <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } \n \t2 catch ( sql <identifiersep> exception ex ) { \n <ect>
\t3 user <identifiersep> model user = null ; \n \t3 if ( user <identifiersep> session != null ) { \n \t4 user = user <identifiersep> session . get <identifiersep> user ( ) ; \n \t4 if ( user == null || ! user . is <identifiersep> enabled ( ) ) { \n <ect>
\t4 if ( <identifier> . get <identifiersep> <identifier> ( ) instanceof socket <identifiersep> timeout <identifiersep> exception ) <comment> \n \t5 continue ; \n \t4 if ( ! <identifier> ) \n \t4 { \n <ect>
\t2 @ <identifier> \n \t2 public map < string , object > <identifier> <identifiersep> user ( <identifier> <identifier> , test <identifiersep> user test <identifiersep> user ) { \n \t3 item <identifiersep> <identifier> <identifier> = <identifier> . get <identifiersep> item <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t3 name <identifiersep> map . load ( <identifier> ) ; \n \t2 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> , e ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + pool . get <identifiersep> <identifier> ( ) ) ; \n \t2 } else if ( <identifier> . size ( ) == 1 ) { \n \t3 <identifier> <identifier> = <identifier> . <identifier> ( ) . next ( ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> config != null ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> config config = parse <identifiersep> <identifier> <identifiersep> config ( item , <identifier> <identifiersep> config ) ; \n \t3 add <identifiersep> <identifier> <identifiersep> config ( item , config ) ; \n \t2 } else { \n <ect>
\t4 throw new web <identifiersep> application <identifiersep> exception ( response . status . not <identifiersep> found ) ; \n \t3 } else if ( ! <identifier> <identifiersep> service . <identifier> <identifiersep> action <identifiersep> boolean ( context , collection , action ) ) { \n \t4 context . <identifier> ( ) ; \n \t4 if ( context . get <identifiersep> current <identifiersep> user ( ) != null ) { \n <ect>
\t3 e . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; } \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> ( ) { \n <ect>
private static array <identifiersep> list < url > find <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws io <identifiersep> exception { \n \t1 string <identifier> = get <identifiersep> <identifier> <identifiersep> property ( <identifier> <identifiersep> <identifier> , null ) ; \n \t1 if ( <identifier> == null ) \n \t1 return new array <identifiersep> list < > ( ) ; \n <ect>
\t3 for ( <identifier> <identifier> : <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( exchange ) ) { \n \t4 if ( ! <identifier> <identifiersep> list . contains ( <identifier> ) ) { \n \t5 <identifier> <identifiersep> list . add ( <identifier> ) ; \n \t5 <identifier> . add <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ) ; \n <ect>
\t3 list < string > <identifier> = <identifier> <identifiersep> client . list <identifiersep> <identifier> ( <identifier> ) ; \n \t3 for ( string <identifier> <identifiersep> name : <identifier> ) { \n \t4 <identifier> <identifiersep> client . delete <identifiersep> object ( <identifier> , <identifier> <identifiersep> name ) ; } } \n \t2 catch ( exception t ) { \n <ect>
\t9 <identifier> = t . get <identifiersep> first ( field <identifiersep> key . <identifier> ) ; \n \t9 <identifier> . set <identifiersep> <identifier> ( integer . parse <identifiersep> int ( ( ( <identifier> != null && <identifier> . length ( ) > 0 ) ? <identifier> : <string_literal> ) ) ) ; \n \t9 <identifier> . set <identifiersep> <identifier> ( t . get <identifiersep> first ( field <identifiersep> key . <identifier> ) ) ; \n \t8 } catch ( number <identifiersep> format <identifiersep> exception | key <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t5 try { \n \t6 log . info ( <string_literal> ) ; \n \t6 if ( ! <identifier> <identifiersep> find . try <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t7 <identifier> ( <string_literal> ) ; } \n <ect>
\t3 method method = web <identifiersep> <identifier> . get <identifiersep> class ( ) . get <identifiersep> method ( <string_literal> ) ; \n \t3 object <identifier> = method . <identifier> ( web <identifiersep> <identifier> ) ; \n \t3 return ( map < string , object > ) <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t8 <comment> \n \t8 if ( group . equals ( <string_literal> + provider . to <identifiersep> string ( ) ) ) { \n \t9 for ( job <identifiersep> key job <identifiersep> key : <identifier> . get <identifiersep> job <identifiersep> <identifier> ( job <identifiersep> group <identifiersep> equals ( group ) ) ) { \n \t10 if ( find <identifiersep> first <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> provider ( job <identifiersep> key . get <identifiersep> name ( ) . <identifier> ( <string_literal> ) [ 0 ] ) == null ) { \n <ect>
\t3 if ( <identifier> <identifiersep> type . is <identifiersep> <identifier> ( ) ) { \n \t4 string id = null ; \n \t4 final string <identifier> <identifiersep> value = <identifier> <identifiersep> type . get ( ) . get <identifiersep> value ( ) ; \n \t4 if ( o <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> type ( <identifier> <identifiersep> value , o <identifiersep> <identifier> <identifiersep> <identifier> . client <identifiersep> <identifier> ) ) { \n <ect>
\t3 log <identifiersep> log . debug ( <string_literal> + service <identifiersep> info ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n \t3 log <identifiersep> log . warn ( <string_literal> , e ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n <ect>
\t7 s <identifiersep> logger . debug ( <string_literal> + host <identifiersep> id + <string_literal> + instance . get <identifiersep> id ( ) + <string_literal> ) ; \n \t6 <identifier> <identifiersep> message <identifiersep> <identifier> . <identifier> ( null , <identifier> <identifiersep> <identifier> <identifiersep> manager . <identifier> . vm <identifiersep> <identifier> <identifiersep> state , <identifier> <identifiersep> <identifier> . <identifier> , instance . get <identifiersep> id ( ) ) ; \n \t5 } else { \n <ect>
\t3 case <identifier> : \n \t4 process ( new <identifier> <identifiersep> <identifier> ( entity <identifiersep> <identifier> ) ) ; \n \t4 break ; \n \t3 default : \n <ect>
\t2 while ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( ) ) { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t2 if ( is <identifiersep> shutdown . get ( ) ) { \n <ect>
\t2 private <identifiersep> template = new vm <identifiersep> template <identifiersep> vo ( next <identifiersep> template <identifiersep> id , <identifier> <identifiersep> name , name , <identifier> <identifiersep> format . <identifier> , is <identifiersep> public , <identifier> , is <identifiersep> <identifier> , template <identifiersep> type . user , null , null , <identifier> <identifiersep> <identifier> <identifiersep> value , <identifier> <identifiersep> value , template <identifiersep> <identifier> . get <identifiersep> id ( ) , \n \t4 null , <identifier> , password <identifiersep> enabled <identifiersep> value , <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) , true , <identifier> <identifiersep> type , template <identifiersep> <identifier> , cmd . get <identifiersep> <identifier> ( ) ) ; \n \t2 if ( source <identifiersep> template <identifiersep> id != null ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void do <identifiersep> shutdown ( ) throws exception { \n \t2 for ( <identifier> <identifier> : <identifier> ) { \n \t3 try ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> id ( ) ) ) { \n <ect>
public get <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> uri ) { \n \t1 super ( <identifier> <identifiersep> uri ) ; } \n @ <identifier> \n public response <identifier> <identifiersep> handle ( http <identifiersep> request request ) throws json <identifiersep> exception { \n <ect>
\t3 string <identifier> = client <identifiersep> <identifier> . get <identifiersep> host <identifiersep> string ( ) + ' : ' + client <identifiersep> <identifier> . get <identifiersep> port ( ) + \n \t3 ' , ' + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> host <identifiersep> string ( ) + ' : ' + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> port ( ) + ' : ' + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> port ( ) ; \n \t3 try { \n <ect>
\t3 entity <identifiersep> manager . <identifier> ( <identifier> ) ; \n \t3 return <identifier> . id ; \n \t2 } ) ; \n \t2 do <identifiersep> in <identifiersep> <identifier> ( this : : entity <identifiersep> manager <identifiersep> factory , entity <identifiersep> manager - > { \n <ect>
\t1 if ( is <identifiersep> <identifier> ) { \n \t1 try { \n \t2 <identifier> <identifiersep> from <identifiersep> job <identifiersep> manager ( ) \n \t1 } catch { \n <ect>
\t4 <identifier> <identifiersep> message . to <identifiersep> string ( ) ) ; \n \t2 int <identifier> <identifiersep> value = <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <identifier> + <identifier> <identifiersep> <identifier> ) ; \n \t2 int <identifier> <identifiersep> <identifier> <identifiersep> value = <identifier> <identifiersep> message . get <identifiersep> message <identifiersep> <identifier> <identifiersep> byte ( <identifier> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 logger . debug ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) , <identifier> <identifiersep> value ) ; \n <ect>
\t2 int is <identifiersep> on = ( ( ( byte ) <identifier> ) > > <identifier> ) & <identifier> ; \n \t2 <comment> \n \t2 if ( <identifier> . contains <identifiersep> key ( item . get <identifiersep> name ( ) ) ) { \n \t3 if ( <identifier> . get ( item . get <identifiersep> name ( ) ) . contains <identifiersep> key ( <identifier> ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> . <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( get <identifiersep> <identifier> ( ) ) ; \n \t2 string <identifier> <identifiersep> id <identifiersep> <identifier> <identifiersep> <identifier> = <string_literal> ; \n \t2 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> id ( <identifier> <identifiersep> id <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t2 add <identifiersep> header <identifiersep> <identifier> <identifiersep> to <identifiersep> attribute ( method ) ; \n \t2 object [ ] values = get <identifiersep> <identifier> <identifiersep> for ( method ) ; \n \t2 <identifier> . add <identifiersep> all ( <identifier> ) ; \n \t2 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t2 return null ; } \n \t1 public double count ( ) { \n \t2 return count ( <identifier> ) ; } \n \t1 public void <identifier> ( ) { \n <ect>
<comment> \n \t1 public void object <identifiersep> <identifier> ( <identifier> <identifiersep> event <identifier> <identifiersep> event , destination <identifiersep> type destination <identifiersep> type , <identifier> <identifiersep> type <identifier> <identifiersep> type ) { \n \t2 <identifier> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> event . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> new <identifiersep> <identifier> = <identifier> <identifiersep> event . get <identifiersep> new <identifiersep> <identifier> ( ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public static string set <identifiersep> base <identifiersep> <identifier> <identifiersep> class <identifiersep> name ( string <identifier> , string class <identifiersep> name ) { \n \t2 if ( <identifier> <identifiersep> <identifier> != null ) \n <ect>
\t2 try { \n \t3 create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> table ( config ) ; \n \t3 return new execute <identifiersep> result ( execute <identifiersep> result . state . <identifier> , <identifier> <identifiersep> logger . get <identifiersep> <identifier> <identifiersep> log ( ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 return true ; } \n \t2 if ( last <identifiersep> update != null ) { \n \t3 <comment> \n \t3 if ( last <identifiersep> update . <identifier> ( <identifier> ) || last <identifiersep> update . equals ( <identifier> ) ) { \n <ect>
\t3 int <identifier> <identifiersep> of <identifiersep> the <identifiersep> <identifier> = <identifier> <identifiersep> of <identifiersep> <identifier> / <number_literal> ; \n \t3 int <identifier> <identifiersep> of <identifiersep> <identifier> = <number_literal> ; \n \t3 int <identifier> <identifiersep> time = <number_literal> ; \n \t3 for ( int <identifier> = 1 ; <identifier> < = <identifier> <identifiersep> of <identifiersep> <identifier> ; <identifier> ++ ) { \n <ect>
\t4 try { \n \t5 <identifier> = <identifier> <identifiersep> service . execute ( new <identifier> <identifiersep> <identifier> <identifiersep> get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) ; } \n \t4 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n \t5 log . warn ( <string_literal> , ex ) ; } \n <ect>
\t7 if ( <identifier> == 0 && <identifier> == 0 && <identifier> > 0 && <identifier> == 1 ) { \n \t8 output . write ( <string_literal> ) ; } } \n \t6 output . write ( <string_literal> ) ; \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 set <identifiersep> mode ( mode . <identifier> , <string_literal> , true ) ; \n \t3 set <identifiersep> mode ( mode . <identifier> , <string_literal> , true ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> service . instance . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 set <identifiersep> mode ( mode . <identifier> , <string_literal> , true ) ; \n <ect>
\t2 <identifier> <identifiersep> response response = client ( ) . <identifier> <identifiersep> <identifier> ( <string_literal> ) . set <identifiersep> <identifier> ( <string_literal> ) \n \t4 . set <identifiersep> query ( <identifier> <identifiersep> query ) . get ( ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> response ( response ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> count ( response , 0 ) ; \n <ect>
\t4 public <identifier> handle ( <identifier> <identifier> ) { \n \t6 return process <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 } ) ; \n if ( <identifier> ) { \n <ect>
\t1 interrupted = thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ; \n \t1 try { \n \t2 transaction . <identifier> ( ) ; \n \t1 } catch ( throwable <identifier> ) { \n <ect>
<comment> \n \t1 public synchronized void set <identifiersep> <identifier> <identifiersep> from <identifiersep> cache ( ) { \n \t1 if ( <identifier> . get ( ) != 0 ) { \n <ect>
\t3 return false ; } \n \t2 final string client <identifiersep> id = context . get <identifiersep> request <identifiersep> <identifier> ( o <identifiersep> <identifier> . client <identifiersep> id ) ; \n \t2 final o <identifiersep> <identifier> <identifiersep> registered <identifiersep> service registered <identifiersep> service = get <identifiersep> registered <identifiersep> service <identifiersep> by <identifiersep> client <identifiersep> id ( client <identifiersep> id ) ; \n \t2 if ( ! <identifier> . check <identifiersep> service <identifiersep> <identifier> ( registered <identifiersep> service ) ) { \n <ect>
\t3 try { \n \t4 <identifier> = key <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( <string_literal> , <identifier> <identifiersep> provider ) ; \n \t4 <identifier> . <identifier> ( <identifier> ) ; \n \t3 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 ) ; \n \t5 continue ; } \n \t4 <identifier> . add ( <identifier> ) ; } \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 logger . debug ( <string_literal> + this . <identifier> <identifiersep> <identifier> + <string_literal> + get <identifiersep> <identifier> ( ) + <string_literal> ) ; \n \t3 <identifier> < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > it = this . <identifier> <identifiersep> <identifier> . values ( ) . <identifier> ( ) ; \n \t3 while ( it . has <identifiersep> next ( ) ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = it . next ( ) ; \n <ect>
\t2 registered <identifiersep> service <identifiersep> access <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> service <identifiersep> access <identifiersep> is <identifiersep> <identifier> ( service , registered <identifiersep> service ) ; \n \t2 final boolean token <identifiersep> as <identifiersep> response = registered <identifiersep> service <identifiersep> property . registered <identifiersep> service <identifiersep> properties . token <identifiersep> as <identifiersep> response . is <identifiersep> <identifier> <identifiersep> to ( registered <identifiersep> service ) \n \t3 || registered <identifiersep> service <identifiersep> property . registered <identifiersep> service <identifiersep> properties . token <identifiersep> as <identifiersep> service <identifiersep> ticket . is <identifiersep> <identifier> <identifiersep> to ( registered <identifiersep> service ) ; \n \t2 if ( ! token <identifiersep> as <identifiersep> response ) { \n <ect>
\t2 if ( table != null ) { \n \t3 table . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 <identifier> . remove ( table <identifiersep> id ) ; \n <ect>
\t3 if ( ! <identifier> && <identifier> . throws <identifiersep> exception ) { \n \t4 log . error ( <string_literal> + <identifier> . <identifier> <identifiersep> name ) ; \n \t4 <identifier> ( ) ; } \n \t3 if ( ! <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> header ( ) . get <identifiersep> <identifier> ( ) . equals ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> + job . get <identifiersep> cmd ( ) + <string_literal> + job . get <identifiersep> cmd <identifiersep> info ( ) + <string_literal> + job . get <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> job ( job . get <identifiersep> id ( ) , job <identifiersep> info . status . failed , 0 , <string_literal> ) ; \n \t4 return ; } \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 <identifier> . end <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 } catch ( throwable e ) { \n <ect>
\t2 } catch ( socket <identifiersep> exception e ) { \n \t3 <comment> \n \t3 log . debug ( <string_literal> , e ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t4 s <identifiersep> logger . debug ( <string_literal> + user <identifiersep> id + <string_literal> + <identifier> <identifiersep> id ) ; } \n \t3 account <identifiersep> to <identifiersep> lock = <identifier> <identifiersep> account <identifiersep> dao . <identifier> <identifiersep> in <identifiersep> lock <identifiersep> table ( <identifier> <identifiersep> id ) ; \n \t3 if ( account <identifiersep> to <identifiersep> lock == null ) { \n <ect>
\t4 log . debug ( <string_literal> ) ; \n \t4 result . set <identifiersep> failure ( false ) ; } \n \t2 } catch ( exception e ) { \n \t3 <comment> \n <ect>
\t2 assert . assert <identifiersep> equals ( <string_literal> , <identifier> <identifiersep> url ( <string_literal> ) , <identifier> . get <identifiersep> first ( <string_literal> ) ) ; } \n \t1 @ <identifier> <identifiersep> <identifier> ( value = <string_literal> ) \n \t1 private void test <identifiersep> <identifier> ( response response ) { \n \t2 <identifier> <identifiersep> map <identifier> = response . get <identifiersep> <identifier> ( ) ; \n <ect>
\t3 while ( <identifier> <identifiersep> run ( ) ) { \n \t4 try { \n \t5 thread . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 public <identifier> <identifiersep> message build <identifiersep> get <identifiersep> message ( int type , integer . . . <identifier> <identifiersep> bytes ) { \n \t2 if ( type != user <identifiersep> number <identifiersep> get && type != user <identifiersep> code <identifiersep> get ) { \n \t3 logger . error ( <string_literal> , this . get <identifiersep> node ( ) . get <identifiersep> node <identifiersep> id ( ) , ( <identifier> & type ) ) ; \n \t3 return null ; } \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void on <identifiersep> new <identifiersep> state ( <identifier> <identifiersep> context context , state <identifiersep> <identifier> <identifier> ) { \n <ect>
\t3 } catch ( final <identifier> <identifiersep> api <identifiersep> exception <identifier> ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + <identifier> . to <identifiersep> string ( ) ) ; \n \t4 return new <identifier> <identifiersep> answer ( command , <string_literal> + <identifier> . to <identifiersep> string ( ) , false ) ; \n \t3 } catch ( final exception <identifier> ) { \n <ect>
private void remove <identifiersep> <identifier> <identifiersep> ip <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> and <identifiersep> id <identifier> <identifiersep> and <identifiersep> id ) { \n \t1 try { \n \t2 remove <identifiersep> <identifier> <identifiersep> ip <identifiersep> from <identifiersep> node <identifiersep> and <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> and <identifiersep> id ) ; \n \t1 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t1 logger . debug ( <string_literal> ) ; \n \t1 return security <identifiersep> configuration ; } \n \t1 string security <identifiersep> type <identifiersep> string = <identifier> . empty <identifiersep> to <identifiersep> null ( ( string ) security <identifiersep> properties . get ( type <identifiersep> property <identifiersep> id ) ) ; \n \t1 if ( security <identifiersep> type <identifiersep> string == null ) { \n <ect>
\t5 break ; } } \n \t3 try { thread . <identifier> ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception <identifier> ) { } \n \t3 <identifier> <identifiersep> log . info ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> + <string_literal> + <identifier> <identifiersep> close <identifiersep> <identifier> ) ; } \n \t2 <comment> \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> = <identifier> . create ( in ) ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t1 @ <identifier> \n \t1 @ path ( <string_literal> ) \n \t1 @ <identifier> ( { <string_literal> } ) \n \t1 public string add <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml <identifiersep> root <identifiersep> element <identifier> ) { \n <ect>
\t2 if ( <identifier> <identifiersep> key != null ) { \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> ( <string_literal> , \n \t5 <string_literal> ) ; } \n <ect>
\t2 assert <identifiersep> equals ( <string_literal> , <number_literal> , <identifier> . length ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 assert <identifiersep> equals ( <string_literal> + i , <identifier> [ i ] ) ; } } \n \t1 private void write <identifiersep> <identifier> <identifiersep> file ( ) throws exception { \n <ect>
\t2 file file = new file ( path ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> path = file . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t2 return null ; } \n \t1 public boolean remove <identifiersep> snapshot ( string snapshot <identifiersep> name , boolean remove <identifiersep> <identifier> ) throws exception { \n \t2 <identifier> <identifiersep> object <identifiersep> <identifier> <identifier> <identifiersep> snapshot = get <identifiersep> snapshot <identifiersep> <identifier> ( snapshot <identifiersep> name ) ; \n \t2 if ( <identifier> <identifiersep> snapshot == null ) { \n <ect>
<comment> \n \t1 public t <identifier> ( final principal <identifiersep> action <identifiersep> context in <identifiersep> context , final map < string , <identifier> > in <identifiersep> <identifier> ) \n \t1 { \n \t2 long <identifier> <identifiersep> item <identifiersep> id = long . value <identifiersep> of ( ( string ) in <identifiersep> <identifier> . get ( id <identifiersep> key ) ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> switch ( on <identifiersep> <identifier> <identifiersep> value state ) { \n \t2 if ( state == on <identifiersep> <identifier> <identifiersep> value . <identifier> ) { \n <ect>
\t2 <identifier> . builder builder = factory . new <identifiersep> instance ( type ) ; \n \t2 builder . <identifier> ( <identifier> <identifiersep> context ) ; \n \t2 <identifier> . add ( builder . build ( ) ) ; \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> service ) ; } \n \t2 if ( <identifier> <identifiersep> config . is <identifiersep> socket <identifiersep> server <identifiersep> enabled ( ) ) { \n \t3 request <identifiersep> handler <identifiersep> factory client <identifiersep> request <identifiersep> handler <identifiersep> factory = new client <identifiersep> request <identifiersep> handler <identifiersep> factory ( this . store <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 && <identifier> <identifiersep> content <identifiersep> <identifier> . get <identifiersep> length ( ) > \n \t3 <identifier> <identifiersep> conf . get <identifiersep> long <identifiersep> <identifier> ( conf , conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> content <identifiersep> <identifier> . get <identifiersep> length ( ) + <string_literal> + \n \t3 <identifier> <identifiersep> conf . get <identifiersep> long <identifiersep> <identifier> ( conf , conf <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) + <string_literal> ) ; \n <ect>
\t2 super <identifiersep> <identifier> <identifier> = get <identifiersep> super <identifiersep> <identifier> ( <identifier> ) ; \n \t2 list < string > request <identifiersep> url <identifiersep> <identifier> = new array <identifiersep> list < > ( ) ; \n \t2 list < <identifier> > <identifier> = <identifier> . get <identifiersep> data <identifiersep> table ( ) . get <identifiersep> <identifier> ( 0 , <identifier> . get <identifiersep> data <identifiersep> table ( ) . get <identifiersep> num <identifiersep> <identifier> ( ) , <identifier> ) ; \n \t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
<comment> \n \t1 protected message get <identifiersep> response <identifiersep> message ( exchange exchange , channel <identifiersep> handler <identifiersep> context <identifier> , object message ) throws exception { \n \t2 object body = message ; \n <ect>
void bean <identifiersep> cache <identifiersep> put <identifiersep> <identifier> ( entity <identifiersep> bean bean ) { \n \t1 <identifier> <identifiersep> bean <identifiersep> data bean <identifiersep> data = bean <identifiersep> <identifier> <identifiersep> data ( <identifier> , bean ) ; \n \t1 object id = <identifier> . get <identifiersep> id ( bean ) ; \n <ect>
\t2 try { \n \t3 remove <identifiersep> <identifier> ( <identifier> ) ; \n \t3 return true ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 string conf <identifiersep> path = conf <identifiersep> file . get <identifiersep> <identifier> ( ) ; \n \t2 string <identifier> <identifiersep> path = conf <identifiersep> path + <string_literal> ; \n \t2 file <identifier> <identifiersep> file = new file ( <identifier> <identifiersep> path ) ; \n \t2 boolean db <identifiersep> <identifier> = ( db <identifiersep> string != null && ! db <identifiersep> string . is <identifiersep> empty ( ) ) ; \n <ect>
<number_literal> <identifier> <identifiersep> transport . get <identifiersep> <identifier> <identifiersep> key ( ) , <identifier> ) ; \n \t3 <identifier> <identifiersep> transport . send ( <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> host <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 return false ; } \n \t1 log . warn ( <string_literal> , e ) ; \n \t1 return false ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 if ( ! <identifier> ) { \n \t1 long millis = configuration <identifiersep> type <identifiersep> <identifier> . get <identifiersep> time <identifiersep> in <identifiersep> millis ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t1 log . info ( <string_literal> , millis ) ; \n \t1 thread . <identifier> ( millis ) ; \n <ect>
\t2 if ( this . <identifier> . length == time <identifiersep> info <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t3 logger . debug ( <string_literal> + ( this . <identifier> [ 0 ] + <number_literal> ) ) ; \n \t3 logger . debug ( <string_literal> + ( ( ( this . <identifier> [ <number_literal> ] & <identifier> <identifiersep> <identifier> ) > > <number_literal> ) | ( ( this . <identifier> [ <number_literal> ] & <identifier> <identifiersep> <identifier> ) > > <number_literal> ) ) ) ; \n \t3 logger . debug ( <string_literal> + this . <identifier> [ 1 ] ) ; \n <ect>
\t4 found <identifiersep> <identifier> <identifiersep> <identifier> = true ; \n \t3 } catch ( final exception e ) { \n \t4 logger . debug ( e . get <identifiersep> message ( ) , e ) ; } } \n \t2 if ( ! found <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t1 public synchronized void <identifier> <identifiersep> <identifier> ( ) throws io <identifiersep> exception \n \t1 { \n \t2 if ( ! <identifier> ) \n \t2 { \n <ect>
\t1 public static string <identifier> ( final string value , final properties <identifier> ) { \n \t2 try { \n \t3 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( value , <identifier> ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { \n <ect>
<comment> \n <comment> \n \t1 @ <identifier> \n \t1 public void context <identifiersep> <identifier> ( <identifier> <identifiersep> context <identifiersep> event <identifier> ) { \n <ect>
\t7 <identifier> <identifiersep> system as = <identifier> <identifiersep> utils . create <identifiersep> <identifier> <identifiersep> system ( \n \t9 new configuration ( ) , \n \t9 new <identifier> < <identifier> . <identifier> < string , object > > ( new <identifier> . <identifier> < string , object > ( <identifier> . get <identifiersep> host <identifiersep> address ( ) , port ) ) ) ; \n \t7 as . shutdown ( ) ; \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 try { \n \t2 <identifier> = <identifier> <identifiersep> manager . create ( <identifier> <identifiersep> queue , <identifier> <identifiersep> conf , resource <identifiersep> <identifier> ) ; \n \t2 <identifier> . start ( ) ; \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> code ( ) { \n \t2 <identifier> . <identifier> ( ) . to ( get <identifiersep> account <identifiersep> url ( <identifier> . consumer <identifiersep> <identifier> <identifiersep> name ( ) ) ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t2 <identifier> . <identifier> ( ) . delete <identifiersep> all <identifiersep> <identifier> ( ) ; \n <ect>
\t1 public void update <identifiersep> job ( ) throws command <identifiersep> exception { \n \t2 <identifier> <identifiersep> utils . <identifier> <identifiersep> job <identifiersep> <identifier> ( <string_literal> , 1 , null ) ; \n \t2 <identifier> <identifiersep> job . set <identifiersep> <identifier> <identifiersep> time ( new date ( ) ) ; \n \t2 <identifier> <identifiersep> job . set <identifiersep> last <identifiersep> <identifier> <identifiersep> time ( new date ( ) ) ; \n <ect>
\t3 load <identifiersep> <identifier> <identifiersep> and <identifiersep> key <identifiersep> cache <identifiersep> <identifier> ( ) . get ( ) ; } \n \t2 catch ( throwable t ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> throwable ( t ) ; \n <ect>
\t4 float p <identifiersep> <identifier> = total <identifiersep> <identifier> / ( float ) <identifier> ; \n \t4 p <identifiersep> <identifier> = p <identifiersep> <identifier> * p <identifiersep> <identifier> * p <identifiersep> <identifier> ; \n \t4 if ( false && ( p <identifiersep> <identifier> >= <identifier> <identifiersep> context . <identifier> ( ) . next <identifiersep> float ( ) ) ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
{ \n \t1 final <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( ) { \n \t1 @ <identifier> \n \t1 protected void <identifier> ( ) { \n <ect>
<number_literal> s <identifiersep> logger . info ( <string_literal> ) ; \n <number_literal> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> test ( method . get <identifiersep> response <identifiersep> header ( <string_literal> ) . get <identifiersep> value ( ) ) ; } } \n \t9 if ( <identifier> == null ) { \n \t10 if ( <identifier> ) { \n <ect>
\t2 m <identifiersep> bean <identifiersep> server <identifier> <identifiersep> server = <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifiersep> server ( ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> server . <identifier> <identifiersep> m <identifiersep> bean ( object <identifiersep> name ) ; \n \t2 } catch ( throwable ex ) { \n <ect>
\t2 int <identifier> = 0 ; \n \t2 do { \n \t3 <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t3 time <identifiersep> unit . <identifier> . <identifier> ( 1 ) ; \n <ect>
\t4 send <identifiersep> error ( http <identifiersep> status . <identifier> <identifiersep> <identifier> <identifiersep> request , response , <identifier> , e ) ; \n \t3 } finally { \n \t4 <identifier> . close ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t1 current <identifiersep> state = current <identifiersep> state . next ( ) ; \n \t1 return current <identifiersep> state ; } } \n public static void <identifier> ( ) { \n \t1 if ( <identifier> <identifiersep> event <identifiersep> log . create ( ) ) { \n <ect>
\t2 string cache <identifiersep> key = <identifier> <identifiersep> cache <identifiersep> key <identifiersep> from <identifiersep> uri ( uri ) ; \n \t2 if ( endpoint <identifiersep> cache . contains <identifiersep> key ( cache <identifiersep> key ) ) { \n \t3 log . debug ( <string_literal> , uri <identifiersep> <identifier> . <identifier> <identifiersep> uri ( uri ) ) ; \n \t3 return endpoint <identifiersep> cache . get ( cache <identifiersep> key ) ; } \n <ect>
\t2 for ( key <identifiersep> listener listener : key <identifiersep> <identifier> ) { \n \t3 try { \n \t4 count += listener . count <identifiersep> <identifier> ( ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t2 this . <identifier> <identifiersep> <identifier> . add ( channel , <identifier> <identifiersep> <identifier> ) ; } \n \t1 public void <identifier> <identifiersep> all ( ) { \n \t2 for ( channel channel : this . <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> name = <identifier> . get <identifiersep> xml <identifiersep> <identifier> ( ) . get <identifiersep> class ( ) . get <identifiersep> name ( ) ; \n \t4 log . info ( <string_literal> + <identifier> <identifiersep> name ) ; \n \t4 system . set <identifiersep> property ( xml <identifiersep> <identifier> <identifiersep> key , <identifier> <identifiersep> name ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t5 session <identifiersep> id = result . get <identifiersep> session <identifiersep> id ( ) ; \n \t5 is <identifiersep> <identifier> <identifiersep> in = true ; \n \t5 return true ; <comment> \n \t3 } catch ( exception e ) { \n <ect>
\t3 logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> name ( ) , <identifier> <identifiersep> code ( ) ) ; \n \t3 logger . debug ( <string_literal> , get <identifiersep> queue <identifiersep> connection <identifiersep> factory ( ) , get <identifiersep> send <identifiersep> queue ( ) ) ; \n \t3 logger . debug ( <string_literal> , get <identifiersep> timeout ( ) ) ; \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> queue ( ) ) ; \n <ect>
\t6 <identifier> <identifiersep> server . <identifier> ( <identifier> <identifiersep> location , token <identifiersep> location , client <identifiersep> id , client <identifiersep> <identifier> , <identifier> <identifiersep> uri , token <identifiersep> response <identifiersep> class ) ; \n \t6 logger . info ( <string_literal> , <identifier> <identifiersep> server ) ; \n \t6 return <identifier> <identifiersep> server ; \n \t5 } catch ( throwable t ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> ; } \n \t3 <identifier> <identifiersep> id in <identifiersep> id = <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> id ( 0 ) ; \n \t3 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( 0 ) ; \n \t3 if ( ( in <identifiersep> id == null ) || ( <identifier> == null ) ) { \n <ect>
\t2 final map < string , object > attributes = principal . get <identifiersep> attributes ( ) ; \n \t2 logger . debug ( <string_literal> , principal . get <identifiersep> id ( ) , attributes ) ; \n \t2 if ( attributes != null && attributes . contains <identifiersep> key ( this . <identifier> <identifiersep> attribute <identifiersep> name ) ) { \n \t3 final set value = collection <identifiersep> utils . to <identifiersep> collection ( attributes . get ( this . <identifier> <identifiersep> attribute <identifiersep> name ) ) ; \n <ect>
<comment> \n log . trace ( <identifier> <identifiersep> config ) \n <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> connection <identifiersep> pool ( url , <identifier> <identifiersep> config ) ; } \n if ( <string_literal> . equals ( db <identifiersep> host ) ) { \n <ect>
\t3 <comment> \n \t3 check <identifiersep> session <identifiersep> attributes ( task <identifiersep> <identifier> , job <identifiersep> id . to <identifiersep> string ( ) , m ) ; \n \t3 collection < grid <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> > <identifier> = task <identifiersep> <identifier> . get <identifiersep> job <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifiersep> result = error ; } \n \t2 } else if ( list . size ( ) == 1 ) { \n \t2 <identifier> <identifiersep> result = to <identifiersep> <identifier> ( list . get ( 0 ) , field ) ; } \n \t2 if ( <identifier> <identifiersep> result == error ) { \n <ect>
\t1 private void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final request <identifiersep> context context ) { \n \t2 final string context <identifiersep> path = context . get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> context <identifiersep> path ( ) ; \n \t2 final string <identifier> <identifiersep> path = string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( context <identifiersep> path ) ? context <identifiersep> path + ' / ' : <string_literal> ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( this . warn <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ) { \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> table ( <identifier> ) && \n \t2 is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> enabled ( <identifier> ) && \n \t2 ! <identifier> <identifiersep> <identifier> . get <identifiersep> is <identifiersep> <identifier> ( ) && \n \t2 <identifier> <identifiersep> <identifier> && <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 <identifier> <identifiersep> <identifier> = null ; \n \t3 log . debug ( <string_literal> ) ; \n \t2 } else { \n <ect>
\t5 result . set <identifiersep> version ( <identifier> . get <identifiersep> version ( ) . to <identifiersep> string ( ) ) ; \n \t5 result . set <identifiersep> size ( files . size ( location ) ) ; \n \t5 channel <identifiersep> handler <identifiersep> context . get <identifiersep> channel ( ) . write ( <identifier> <identifiersep> data . <identifier> <identifiersep> message . new <identifiersep> builder ( ) . set <identifiersep> <identifier> <identifiersep> data <identifiersep> header ( result ) . build ( ) ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 if ( <identifier> > 0 ) { \n \t5 s <identifiersep> logger . info ( <string_literal> + <identifier> + <string_literal> ) ; \n \t5 thread . <identifier> ( <number_literal> ) ; } \n <ect>
\t9 string . value <identifiersep> of ( s . get <identifiersep> port ( ) ) ) ) ; \n \t4 log . error ( <string_literal> , <identifier> ) ; \n \t4 system . <identifier> ( 1 ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 protected void <identifier> <identifiersep> task ( final task task ) { \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( task ) ; \n \t2 } catch ( final exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> . <identifier> ( new <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> . task <identifiersep> id ( ) , <identifier> . <identifier> ( ) . get ( ) ) , self <identifiersep> <identifier> ) ; } } \n \t3 else if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( <identifier> <identifiersep> node . get <identifiersep> resource <identifiersep> id ( ) ) ) { \n \t4 log . info ( <string_literal> , <identifier> <identifiersep> node . get <identifiersep> resource <identifiersep> id ( ) ) ; } \n \t3 else { \n <ect>
\t3 logger . info ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t3 logger . warn ( <string_literal> , <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public <identifier> build ( final <identifier> <identifiersep> context context , final string client <identifiersep> id , final access <identifiersep> token <identifiersep> request <identifiersep> data <identifiersep> <identifier> <identifier> ) { \n \t2 final string <identifier> <identifiersep> uri = context . get <identifiersep> request <identifiersep> <identifier> ( o <identifiersep> <identifier> . <identifier> <identifiersep> uri ) ; \n \t2 logger . debug ( <string_literal> , client <identifiersep> id , <identifier> <identifiersep> uri ) ; \n \t2 final <identifier> < access <identifiersep> token , <identifier> <identifiersep> token > access <identifiersep> token = access <identifiersep> token <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n <ect>
<comment> \n \t1 private void with <identifiersep> client ( string <identifier> , final client <identifiersep> <identifier> <identifier> ) { \n \t2 final <identifier> <identifiersep> <identifier> <identifiersep> instance <identifier> = <identifier> . get ( <identifier> ) ; \n <ect>
\t4 try { \n \t5 <identifier> . <identifier> ( ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n \t5 throw <identifier> <identifiersep> exception . throw <identifiersep> as <identifiersep> <identifier> <identifiersep> exception ( e ) ; } } \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 set <identifiersep> <identifier> ( true ) ; } \n \t2 <comment> \n \t2 if ( is <identifiersep> <identifier> <identifiersep> set ( ) && is <identifiersep> <identifier> ( ) && <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t3 logger . <identifier> ( <string_literal> + name + <string_literal> ) ; \n \t3 return ; } \n \t2 <identifier> . put ( name , service <identifiersep> <identifier> ) ; \n \t2 create ( name ) ; \n <ect>
\t3 { \n \t4 <identifier> <identifiersep> out = ! <identifier> . <identifier> ( timeout , time <identifiersep> unit . <identifier> ) ; } \n \t3 catch ( interrupted <identifiersep> exception e ) \n \t3 { \n <ect>
\t2 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t2 try { \n \t3 <identifier> <identifiersep> factory . get <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifiersep> server ( ) . <identifier> <identifiersep> m <identifiersep> bean ( new <identifier> <identifiersep> m <identifiersep> bean ( this , client <identifiersep> <identifier> <identifiersep> status <identifiersep> m <identifiersep> bean . class ) , new object <identifiersep> name ( this . get <identifiersep> m <identifiersep> bean <identifiersep> name ( ) ) ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 } else { \n \t6 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + response . get <identifiersep> status ( ) ) ; } \n \t4 } catch ( exception e ) { \n \t5 <comment> \n <ect>
\t5 long <identifier> = <identifier> . get <identifiersep> long ( 1 ) ; \n \t5 long <identifier> = <identifier> . get <identifiersep> long ( <number_literal> ) ; \n \t5 return find <identifiersep> by <identifiersep> store <identifiersep> snapshot ( <identifier> , <identifier> , <identifier> ) ; } } \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> file = new <identifier> <identifiersep> file ( <identifier> <identifiersep> file ) ; \n \t4 <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> file . get <identifiersep> <identifier> ( ) ; \n \t4 if ( <identifier> == null ) { \n <ect>
\t10 <identifier> <identifiersep> <identifier> . add ( response <identifiersep> key ) ; \n \t9 } else { \n \t10 logger . warn ( <string_literal> , response <identifiersep> key ) ; } \n \t8 } catch ( throwable ex ) { \n <ect>
\t4 <identifier> <identifiersep> log . warn ( <string_literal> + <identifier> ) ; \n \t3 return ; } \n \t2 if ( ! key . equals ( <identifier> . get <identifiersep> current <identifiersep> key ( ) ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t5 final string <identifier> \t1 = <identifier> [ <number_literal> ] ; \n \t5 final string <identifier> \t1 = <identifier> [ <number_literal> ] ; \n \t5 return <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> , <identifier> ) ; } \n \t3 } else { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 try { \n \t5 <identifier> <identifiersep> service . delete ( context , <identifier> <identifiersep> <identifier> ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t3 assert <identifiersep> event <identifiersep> <identifier> ( ) ; \n \t3 try { \n \t4 do <identifiersep> close ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 try { \n \t6 <identifier> . run ( ) ; \n \t5 } catch ( exception ex ) { \n \t6 ex . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n <ect>
\t1 <identifier> . <identifier> ( self . execute <identifiersep> <identifier> ) \n <identifier> execute <identifiersep> <identifier> ( self ) : \n \t1 if self . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> : \n \t1 return \n <ect>
\t2 if ( <identifier> != null && ! this . <identifier> <identifiersep> as <identifiersep> <identifier> ) { \n \t3 try { \n \t4 <identifier> . remove ( ) ; } \n \t3 catch ( throwable ex ) { \n <ect>
\t2 <comment> \n \t2 if ( <identifier> . length != 1 ) { \n <ect>
\t2 if ( lock <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < <identifier> . get <identifiersep> lock <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 log . warn ( <string_literal> + <identifier> . get <identifiersep> lock <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) \n \t5 + <string_literal> + lock <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \n \t5 + <string_literal> ) ; } \n <ect>
\t2 http <identifiersep> method method = new get <identifiersep> method ( result <identifiersep> url ) ; \n \t2 while ( true ) { \n \t3 try { \n \t4 client . execute <identifiersep> method ( method ) ; \n <ect>
\t1 <comment> \n \t1 final string <identifier> = table <identifiersep> <identifier> [ 1 ] ; \n \t1 log . info ( <string_literal> , <identifier> ) ; \n \t1 c . table <identifiersep> <identifier> ( ) . create ( <identifier> ) ; \n <ect>
\t5 return <identifier> . <identifier> <identifiersep> <identifier> ( cache . get <identifiersep> <identifier> ( input ) ) ; \n \t4 } catch ( cache <identifiersep> <identifier> . <identifier> <identifiersep> cache <identifiersep> load <identifiersep> exception e ) { \n \t5 logger . debug ( <string_literal> , input ) ; \n \t4 } catch ( <identifier> <identifiersep> execution <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 context . <identifier> <identifiersep> <identifier> <identifiersep> system <identifiersep> state ( ) ; \n \t3 context . <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 logger . info ( <string_literal> , event ) ; \n \t3 collection < string > <identifier> = null ; \n \t3 try { \n \t4 <identifier> = this . context <identifiersep> <identifier> . <identifier> ( ) ; \n <ect>
\t2 . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t1 list < m <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > m <identifiersep> security <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> list = \n \t2 ( list < m <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > ) query . execute <identifiersep> with <identifiersep> array ( table <identifiersep> name , db <identifiersep> name , \n \t3 <identifier> <identifiersep> name , <identifier> <identifiersep> name ) ; \n <ect>
\t2 if ( current <identifiersep> size > <identifier> <identifiersep> <identifier> && channel . config ( ) . is <identifiersep> <identifier> <identifiersep> read ( ) ) \n \t2 { \n \t3 if ( log != null ) \n \t3 { \n <ect>
\t4 <identifier> . set <identifiersep> property ( <identifier> <identifiersep> <identifier> <identifiersep> factory . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> shutdown , <string_literal> ) ; } \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> <identifier> && ! <identifier> . contains <identifiersep> key ( <string_literal> ) ) { \n \t4 <identifier> . put ( <string_literal> , <string_literal> ) ; \n <ect>
\t3 logger . debug ( <string_literal> , \n \t5 new object [ ] { item <identifiersep> name , command . to <identifiersep> string ( ) , command . get <identifiersep> class ( ) . to <identifiersep> string ( ) } ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> connection . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
<comment> \n \t1 public void <identifier> ( ) { \n <ect>
\t3 super ( ) ; \n \t3 this . <identifier> = <identifier> ; } \n \t2 @ <identifier> \n \t2 public void <identifier> ( short <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 && <identifier> . is <identifiersep> <identifier> <identifiersep> by ( <identifier> <identifiersep> <identifier> ) ) { \n \t3 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) > 0 ) { \n \t4 logger . debug ( string . format ( <string_literal> , <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) , pool , <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) ) ; \n \t3 } else { \n <ect>
\t2 string user <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> = system . <identifier> ( <string_literal> ) ; \n \t2 string user <identifiersep> <identifier> <identifiersep> from <identifiersep> property = system . get <identifiersep> property ( <string_literal> ) ; \n \t2 if ( ! string <identifiersep> utils . equals ( user <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> , user <identifiersep> <identifier> <identifiersep> from <identifiersep> property ) ) { \n \t3 <identifier> <identifiersep> logger . logger . warn ( <string_literal> ) ; \n <ect>
<number_literal> final map < string , object > attributes , \n <number_literal> final registered <identifiersep> service registered <identifiersep> service ) { \n \t2 logger . debug ( <string_literal> ) ; \n \t2 final map < string , object > <identifier> <identifiersep> attributes = this . <identifier> <identifiersep> attribute <identifiersep> <identifier> . <identifier> <identifiersep> attributes ( attributes , registered <identifiersep> service ) ; \n <ect>
\t3 table . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t3 <identifier> . <identifier> <identifiersep> <identifier> ( table ) \n \t3 return <identifier> . write ( ) \n \t2 } catch ( e : exception ) { \n <ect>
\t2 return <identifier> <identifiersep> <identifier> ; } \n \t1 private query <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ( <identifier> <identifier> , node s , \n \t3 <identifier> <identifiersep> <identifier> <identifier> , execution <identifiersep> context <identifier> <identifiersep> <identifier> ) { \n \t2 if ( ! s . is <identifiersep> uri ( ) ) { \n <ect>
\t4 get <identifiersep> <identifier> ( ) . <identifier> ( \n \t5 <identifier> . get ( ) . <identifier> ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> property <identifiersep> end <identifiersep> failed <identifiersep> 0 ) , \n \t5 i <identifiersep> <identifier> <identifiersep> <identifier> . format <identifiersep> error ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 properties . load ( stream ) ; } \n \t2 catch ( exception e ) \n \t2 { \n \t3 <comment> \n <ect>
\t5 wait ( ) ; \n \t5 assert ( <identifier> ) ; \n \t5 return <identifier> ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t5 data [ i ] = <identifier> . <identifier> <identifiersep> package ( true ) ; \n \t4 } catch ( illegal <identifiersep> state <identifiersep> exception <identifier> ) { \n \t5 log . debug ( <string_literal> , <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception x ) { \n <ect>
\t5 <comment> \n \t5 if ( <identifier> . get <identifiersep> type ( ) == <identifier> . <identifier> <identifiersep> t <identifiersep> service <identifiersep> node <identifiersep> <identifier> ) { \n \t6 <comment> \n \t6 <comment> \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t1 this . <identifier> = <identifier> ; \n \t1 try { \n \t1 next <identifiersep> object = read <identifiersep> next <identifiersep> object ( this . <identifier> ) ; \n \t1 } catch ( end <identifiersep> of <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public void start <identifiersep> <identifier> ( string <identifier> , final string <identifier> ) { \n <ect>
\t1 final http <identifiersep> session session = request . get <identifiersep> session ( false ) ; \n \t1 final string <identifier> <identifiersep> token = ( session != null ? ( string ) session . get <identifiersep> attribute ( <identifier> <identifiersep> token <identifiersep> attribute <identifiersep> name ) : null ) ; \n \t1 final string <identifier> <identifiersep> token = request . get <identifiersep> header ( <identifier> <identifiersep> <identifier> <identifiersep> token <identifiersep> header ) ; \n \t1 if ( <identifier> <identifiersep> token == null && session != null ) \n <ect>
\t5 <identifier> = new <identifier> <identifiersep> <identifier> ( x , <identifier> , <identifier> ) ; \n \t4 } else if ( <identifier> . has <identifiersep> key ( <string_literal> ) ) { \n \t5 return read <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( <string_literal> ) ) ; \n \t4 } else { \n <ect>
\t5 string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> <identifier> ( ) ) \n \t7 && string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> key <identifiersep> id ( ) ) \n \t7 && string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> key <identifiersep> type ( ) ) ) . count ( ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> count == json <identifiersep> web <identifiersep> key <identifiersep> set . get <identifiersep> json <identifiersep> web <identifiersep> <identifier> ( ) . size ( ) ) { \n <ect>
\t5 <comment> \n \t5 boolean server <identifiersep> <identifier> <identifiersep> update = false ; \n \t5 if ( server == null ) { \n \t6 server <identifiersep> <identifier> <identifiersep> update = false ; \n <ect>
<identifier> do <identifiersep> <identifier> <identifiersep> dir <identifiersep> <identifier> ( self , path <identifiersep> list ) : \n \t1 if path <identifiersep> list : \n \t1 for a <identifiersep> path in path <identifiersep> list : \n \t2 path <identifiersep> <identifier> = <identifier> . <identifier> ( a <identifiersep> path ) \n <ect>
\t2 if ( <identifier> instanceof no <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 break ; } \n \t2 if ( <identifier> instanceof <identifier> <identifiersep> failed ) { \n \t2 <identifier> <identifiersep> failed error = ( <identifier> <identifiersep> failed ) <identifier> ; \n <ect>
\t3 if ( num <identifiersep> <identifier> > 0 ) { \n \t4 <identifier> ( ) ; \n \t4 return true ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 catch ( <identifier> <identifiersep> exception e ) { \n \t6 log . error ( <string_literal> , e ) ; } } \n \t4 catch ( io <identifiersep> exception e ) { \n \t5 create <identifiersep> error <identifiersep> <identifier> ( <identifier> <identifiersep> file , <string_literal> + e . get <identifiersep> message ( ) , null ) ; \n <ect>
\t2 <identifier> = session . create <identifiersep> <identifier> ( get <identifiersep> destination <identifiersep> name ( ) ) ; \n \t2 <identifier> = session . create <identifiersep> <identifier> ( <identifier> ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> <identifier> = session . create <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , get <identifiersep> <identifier> <identifiersep> name ( ) , null , false ) ; \n <ect>
\t6 msg ) ; \n \t4 return ; } \n \t3 if ( <identifier> <identifiersep> node <identifiersep> id . equals ( msg . <identifier> <identifiersep> node <identifiersep> id ( ) ) && ! msg . has <identifiersep> <identifier> ( <identifier> <identifiersep> node <identifiersep> id ) && msg . <identifier> <identifiersep> node <identifiersep> id ( ) != null ) { \n <ect>
\t3 this . cache <identifiersep> <identifier> <identifiersep> <identifier> = cache <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t3 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t2 @ <identifier> \n \t2 public void run ( ) { \n <ect>
\t1 private void send <identifiersep> <identifier> <identifiersep> response ( <identifier> node <identifiersep> id , grid <identifiersep> cache <identifiersep> <identifier> <identifiersep> response < <identifier> , v > <identifier> ) { \n \t2 try { \n \t3 <identifier> . io ( ) . send ( node <identifiersep> id , <identifier> ) ; \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> blank ( ticket <identifiersep> <identifier> <identifiersep> ticket <identifiersep> id ) ) { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 return success ( ) ; } \n \t2 if ( web <identifiersep> utils . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> public <identifiersep> <identifier> ( context ) ) { \n <ect>
\t3 result . e = ( remote <identifiersep> <identifier> <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> e <identifiersep> is <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t6 if ( is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> enabled ( ) && model <identifiersep> path != null ) { \n \t7 string path = model <identifiersep> path + file . <identifier> + entity . name ( ) + <string_literal> ; \n \t7 <identifier> <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> ( <identifier> , new <identifier> <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> class <identifiersep> array ) , path ) ; } \n \t5 } else { \n <ect>
\t4 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t4 if ( ! <identifier> . exists ( ) ) { \n \t5 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t5 <identifier> = new file ( file <identifiersep> server . get <identifiersep> file <identifiersep> server ( ) . get <identifiersep> base <identifiersep> dir ( ) , get <identifiersep> <identifier> <identifiersep> store <identifiersep> to <identifiersep> <identifier> ( ) ) ; \n <ect>
\t2 for ( <identifier> <identifiersep> model <identifier> <identifiersep> model : <identifier> <identifiersep> <identifier> . values ( ) ) { \n \t3 try { \n \t4 <identifier> <identifiersep> model . <identifier> ( this ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 level = <identifier> . debug if debug else <identifier> . info \n \t3 <identifier> <identifiersep> <identifier> ( <identifier> = <identifier> , <identifier> = level , \n \t6 <identifier> = <identifier> ) \n \t3 server = server <identifiersep> from <identifiersep> config ( ) \n <ect>
\t2 <identifier> . <identifier> ( ) . add <identifiersep> listener ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> node <identifiersep> <identifier> , <identifier> <identifiersep> node <identifiersep> <identifier> , <identifier> <identifiersep> node <identifiersep> failed ) ; } \n \t1 <comment> \n \t1 @ <identifier> public void on <identifiersep> <identifier> <identifiersep> start ( ) throws grid <identifiersep> exception { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 if ( ! string <identifiersep> utils . is <identifiersep> empty ( default <identifiersep> <identifier> ) ) { \n \t4 try { \n \t5 <identifier> . default <identifiersep> <identifier> = integer . parse <identifiersep> int ( ( string ) config . get ( <identifier> <identifiersep> key <identifiersep> default <identifiersep> <identifier> ) ) ; \n \t4 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t1 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t1 logger . error ( get <identifiersep> <identifier> <identifiersep> instance ( ) . get <identifiersep> string ( <string_literal> , e . get <identifiersep> message ( ) ) , e ) ; \n \t1 return build <identifiersep> status <identifiersep> response ( response . status . not <identifiersep> found ) ; \n \t1 } catch ( throwable e ) { \n <ect>
<comment> \n \t2 public boolean start <identifiersep> object <identifiersep> entry ( string key ) throws parse <identifiersep> exception \n \t2 { \n \t3 entry <identifiersep> <identifier> ++ ; \n <ect>
\t5 continue ; \n \t4 if ( p . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> id ) != null ) \n \t5 <identifier> <identifiersep> <identifier> . add ( p ) ; } \n \t3 catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> service <identifiersep> url + <string_literal> + method . get <identifiersep> <identifier> ( <string_literal> ) ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . error ( <string_literal> + <identifier> <identifiersep> service <identifiersep> url + <string_literal> + method . get <identifiersep> <identifier> ( <string_literal> ) ) ; \n \t2 } catch ( throwable e ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> info = get <identifiersep> context ( ) . <identifier> <identifiersep> manager ( ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> key , <identifier> <identifiersep> target ) ; \n \t3 is <identifiersep> <identifier> <identifiersep> <identifier> = false ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> info == null ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 if ( null != cluster ) { \n \t1 try { \n \t2 cluster . stop ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 logger . error ( <string_literal> , this . port ) ; \n \t2 } catch ( port <identifiersep> in <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> , this . port ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> operation <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( t ( <string_literal> ) ) \n \t4 <identifier> . add ( <identifier> ) \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , t ( <string_literal> ) , no <identifiersep> <identifier> , options . to <identifiersep> array ) \n \t4 <identifier> <identifiersep> update <identifiersep> check . set ( false ) } } } \n <ect>
\t7 if ( send <identifiersep> <identifier> && <identifier> . <identifier> <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> cluster <identifiersep> state <identifiersep> version <identifiersep> exception ) { \n \t8 logger . debug ( <string_literal> , node , <identifier> . get <identifiersep> <identifier> <identifiersep> message ( ) ) ; \n \t8 send <identifiersep> <identifier> <identifiersep> cluster <identifiersep> state ( cluster <identifiersep> state , <identifier> <identifiersep> <identifier> , node , <identifier> <identifiersep> timeout , <identifier> <identifiersep> <identifier> ) ; \n \t7 } else { \n <ect>
\t2 <identifier> <identifiersep> log . info ( <string_literal> ) ; \n \t1 check <identifiersep> create <identifiersep> files ( false ) ; } \n \t1 if ( <identifier> ( ) ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
<identifier> <identifier> <identifier> <identifier> in config <identifier> . <identifier> . <identifier> . <identifier> <identifier> the <identifier> <identifier> <identifier> , if <identifier> is <identifier> . \n <identifier> \n # <identifier> <identifier> - application . properties . xml file \n if <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> and <identifier> . stack <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> : \n <ect>
\t2 } else if ( <identifier> <identifiersep> <identifier> . <identifier> == <identifier> <identifiersep> <identifier> ) { \n \t3 if ( is <identifiersep> in <identifiersep> <identifier> <identifiersep> mode ( ) ) { \n \t4 <identifier> . execute ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> name + <string_literal> ) ; \n \t3 } else { \n <ect>
\t1 try ( <identifier> <identifiersep> connection connection = get <identifiersep> connection ( name , session ) ) { \n \t1 final <identifier> <identifiersep> connection <identifier> = connection . <identifier> ( <identifier> <identifiersep> connection . class ) ; \n \t1 <identifier> . get <identifiersep> cache <identifiersep> <identifier> ( null ) . <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 token < ? extends token <identifiersep> <identifier> > <identifier> <identifiersep> token = <identifier> <identifiersep> token <identifiersep> <identifier> . <identifier> <identifiersep> token ( \n \t2 new text ( ) , <identifier> . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t8 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } } } \n \t5 if ( <identifier> <identifiersep> config . get <identifiersep> state ( ) == <identifier> <identifiersep> config . <identifier> <identifiersep> state . <identifier> && <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> state ( <identifier> <identifiersep> config . event . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> config ) ; } } \n \t3 } catch ( throwable t ) { \n <ect>
\t4 <identifier> = ( <identifier> ) <identifier> <identifiersep> utils . build ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> file ( ) , <identifier> <identifiersep> <identifier> . t <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t4 if ( <identifier> != null ) { \n \t5 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . as <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t5 if ( ! ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) && ! ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) \n <ect>
\t2 super ( <identifier> ) ; \n \t2 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t2 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t2 this . not <identifiersep> found <identifiersep> <identifier> = not <identifiersep> found <identifiersep> <identifier> ; \n <ect>
\t3 try { \n \t4 <identifier> . add ( \n \t5 this . <identifier> <identifiersep> manager . < <identifier> <identifiersep> <identifier> > get <identifiersep> instance ( <identifier> <identifiersep> <identifier> . class , first <identifiersep> <identifier> <identifiersep> user <identifiersep> <identifier> . id ) ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> thread . start ( ) ; \n \t2 index <identifiersep> <identifier> index <identifiersep> <identifier> = client ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <string_literal> ) . get ( ) . get <identifiersep> index ( <string_literal> ) ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> : index <identifiersep> <identifier> . get <identifiersep> shards ( ) ) { \n \t3 assert <identifiersep> null ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get <identifiersep> user <identifiersep> data ( ) . get ( <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> id ) ) ; } \n <ect>
\t1 property <identifiersep> list <identifier> = <identifier> . parse <identifiersep> <identifier> <identifiersep> string ( <identifier> <identifiersep> <identifier> <identifiersep> info ) ; \n \t1 string <identifier> = <identifier> . get ( <identifier> <identifiersep> connection <identifiersep> properties . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . name ( ) ) ; \n \t1 if ( <identifier> != null ) { \n <ect>
\t3 logger . info ( <string_literal> + store <identifiersep> name \n \t5 + <string_literal> + <identifier> <identifiersep> <identifier> ) ; \n \t3 return ; } \n \t2 long max <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> * time . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n <ect>
\t2 return <identifier> <identifiersep> <identifier> ; \n \t1 } else { \n \t2 throw new service <identifiersep> exception ( <string_literal> + job <identifiersep> id ) ; } \n \t1 } catch ( <identifier> <identifiersep> client <identifiersep> exception e ) { \n <ect>
\t2 action . <identifier> <identifiersep> write ( ) ; \n \t2 try { \n \t3 target target = <identifier> <identifiersep> target ( action ) ; \n <ect>
\t2 transport <identifiersep> nodes <identifiersep> list <identifiersep> <identifier> <identifiersep> meta <identifiersep> state . nodes <identifiersep> <identifier> <identifiersep> meta <identifiersep> state nodes <identifiersep> state = list <identifiersep> <identifier> <identifiersep> meta <identifiersep> state . list ( nodes <identifiersep> <identifier> , null ) . action <identifiersep> get ( ) ; \n \t2 int <identifier> <identifiersep> <identifier> = <identifier> . max ( 1 , <identifier> <identifiersep> <identifier> <identifiersep> nodes ) ; \n \t2 if ( nodes <identifiersep> state . has <identifiersep> <identifier> ( ) ) { \n \t3 for ( failed <identifiersep> node <identifiersep> exception failed <identifiersep> node <identifiersep> exception : nodes <identifiersep> state . <identifier> ( ) ) { \n <ect>
\t2 logger . trace ( <string_literal> ) ; \n \t2 <comment> \n \t2 long time <identifiersep> <identifier> <identifiersep> last <identifiersep> event = ( system . current <identifiersep> time <identifiersep> millis ( ) - <identifier> . get <identifiersep> last <identifiersep> event <identifiersep> time ( ) ) / <number_literal> ; \n \t2 if ( time <identifiersep> <identifier> <identifiersep> last <identifiersep> event > context . get <identifiersep> config ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t7 config <identifiersep> <identifier> <identifiersep> <identifier> . put ( entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; } } \n \t5 config <identifiersep> map <identifiersep> <identifier> = config <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t4 config . update ( config <identifiersep> map <identifiersep> <identifier> ) ; \n \t3 } else { \n <ect>
\t2 # contains a build number \n \t2 self . <identifier> <identifiersep> version <identifiersep> with <identifiersep> build <identifiersep> number = self . <identifier> <identifiersep> version \n \t2 self . <identifier> <identifiersep> output [ <identifier> <identifiersep> <identifier> ] = self . <identifier> <identifiersep> version <identifiersep> with <identifiersep> build <identifiersep> number # this is the <identifier> value <identifier> <identifier> <identifier> . \n \t2 self . put <identifiersep> <identifier> <identifiersep> out ( self . <identifier> <identifiersep> output ) \n <ect>
\t2 if ( <string_literal> . equals ( m ) || <string_literal> . equals ( m ) || <string_literal> . equals ( m ) || <string_literal> . equals ( m ) ) { \n \t3 <identifier> = ( t ) new org . <identifier> . <identifier> . <identifier> . <identifier> . <identifier> . <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( device <identifiersep> id , host , \n \t5 port ) ; \n \t2 } else { \n <ect>
\t2 { \n \t3 final <identifier> <identifiersep> <identifier> <identifier> = in . get <identifiersep> file <identifiersep> header ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> != <identifier> <identifiersep> <identifier> . <identifier> ) { \n \t4 if ( <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t4 handle <identifiersep> get <identifiersep> <identifier> <identifiersep> <identifier> ( ( get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message ) message ) ; \n \t4 break ; \n \t3 default : \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . error ) ) \n <ect>
\t1 protected void run <identifiersep> in <identifiersep> context ( ) { \n \t2 try { \n \t3 <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 return new <identifier> <identifiersep> <identifier> <identifiersep> user <identifiersep> output <identifiersep> stream ( this , connection . get <identifiersep> <identifier> <identifiersep> file ( get <identifiersep> name ( ) ) ) ; } } \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) throws runtime <identifiersep> io <identifiersep> exception { \n \t2 if ( is <identifiersep> <identifier> <identifiersep> file ) { \n <ect>
\t2 if ( this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t3 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } \n \t2 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> queue <identifier> <identifiersep> queue ) { \n <ect>
\t3 <identifier> . handle ( new <identifier> ( <identifier> ) , <identifier> - > system . <identifier> ( 0 ) ) ; } \n \t2 catch ( throwable e ) \n \t2 { \n \t3 <comment> \n <ect>
\t4 . filter ( entry - > entry . get <identifiersep> key ( ) . equals ( name ) ) \n \t4 . map ( map . entry : : get <identifiersep> value ) \n \t4 . <identifier> ( to <identifiersep> set ( ) ) ; \n \t2 if ( <identifier> . size ( ) > 1 ) { \n <ect>
\t3 logger . warn ( <string_literal> , ex ) ; } \n \t2 <identifier> . set ( false ) ; \n \t2 <comment> \n \t2 if ( <identifier> <identifiersep> code != 0 ) { \n <ect>
\t2 <comment> \n \t2 string <identifier> = <string_literal> ; \n \t2 input <identifiersep> stream in = <identifier> . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <identifier> ) ; \n \t2 if ( in == null ) { \n <ect>
\t1 public void send <identifiersep> data ( byte <identifiersep> <identifier> <identifier> ) { \n \t2 if ( ! <identifier> && <identifier> <identifiersep> mode ) \n \t3 throw new runtime <identifiersep> exception ( <string_literal> + this + <string_literal> ) ; \n \t2 if ( <identifier> ) \n <ect>
\t1 instance ; \n \t1 private static final logger log = logger . get <identifiersep> logger ( update <identifiersep> connection <identifiersep> string <identifiersep> <identifier> . class ) ; \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( @ <identifier> class <identifier> ) { \n <ect>
\t1 for ( job job : all <identifiersep> <identifier> ) { \n \t2 job . set <identifiersep> session <identifiersep> <identifier> ( null ) ; } \n \t1 return all <identifiersep> <identifier> ; \n \t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n <ect>
\t5 i < update <identifiersep> <identifier> . length ; \n \t5 <identifier> += update <identifiersep> <identifier> [ i ] , i ++ ) \n \t4 { \n \t5 if ( update <identifiersep> <identifier> [ i ] == 0 ) { \n <ect>
\t4 } else if ( ( api . get <identifiersep> response <identifiersep> type ( ) != response <identifiersep> type . error ) && ( api . get <identifiersep> response <identifiersep> code ( ) == <number_literal> ) ) { \n \t5 <comment> \n \t5 if ( api . get <identifiersep> response <identifiersep> type ( ) == response <identifiersep> type . empty ) { \n \t6 if ( api . is <identifiersep> empty ( ) == true ) { \n <ect>
\t2 @ <identifier> \n \t2 public <identifier> <identifiersep> <identifier> execute ( ) throws <identifier> <identifiersep> exception { \n \t3 <identifier> < session > session = session <identifiersep> manager . instance . get <identifiersep> session ( session <identifiersep> id ) ; \n \t3 if ( ! session . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 for ( table <identifiersep> <identifier> table <identifiersep> <identifier> : <identifier> <identifiersep> metadata <identifiersep> manager . list <identifiersep> all <identifiersep> <identifier> ( null ) ) { \n \t3 logger . info ( <string_literal> + table <identifiersep> <identifier> + <string_literal> + target <identifiersep> <identifier> <identifiersep> name ) ; \n \t3 <identifier> <identifiersep> manager . add <identifiersep> table <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> . new <identifiersep> array <identifiersep> list ( table <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) ) . to <identifiersep> array ( new string [ 0 ] ) , target <identifiersep> <identifier> <identifiersep> name ) ; } \n \t2 for ( <identifier> <identifiersep> instance <identifier> : <identifier> <identifiersep> <identifier> <identifiersep> manager . list <identifiersep> all <identifiersep> <identifier> ( ) ) { \n <ect>
\t3 try { \n \t4 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; \n \t4 get <identifiersep> <identifier> ( new content <identifiersep> name ( <identifier> <identifiersep> name , integer . to <identifiersep> string ( id ) ) , count , handle ) ; \n \t4 handle . close ( ) ; \n <ect>
\t3 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 <identifier> . add <identifiersep> <identifier> <identifiersep> listener ( this ) ; } \n \t2 catch ( exception e ) \n \t2 { \n <ect>
\t3 if ( context . get <identifiersep> <identifier> ( ) . has <identifiersep> <identifier> ( context ) ) { \n \t4 try { \n \t5 <identifier> <identifiersep> <identifier> ( <identifier> , context , true ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t1 { \n \t2 set < string > <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> set < > ( ) ; \n \t2 { \n <ect>
\t2 { \n \t3 byte <identifiersep> <identifier> <identifier> = <identifier> . next ( ) ; \n \t3 if ( <identifier> . <identifier> ( ) >= on <identifiersep> <identifier> <identifiersep> index <identifiersep> builder . max <identifiersep> <identifier> <identifiersep> size ) \n \t3 { \n <ect>
\t2 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> case = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> case ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 string <identifier> = <string_literal> ; \n \t2 try { \n \t3 final network <identifier> = <identifier> <identifiersep> resource <identifiersep> base . find <identifiersep> or <identifiersep> create <identifiersep> <identifier> <identifiersep> network ( conn , command . get <identifiersep> network <identifiersep> name ( ) ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t8 <identifier> = <identifier> . get <identifiersep> request <identifiersep> context ( ) . remove <identifiersep> <identifier> <identifiersep> root ( <identifier> <identifiersep> config . get <identifiersep> <identifier> <identifiersep> root <identifiersep> path ( ) ) ; } } \n \t5 } else { \n \t6 <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> path ( <identifier> . read <identifiersep> resource ( element . get <identifiersep> <identifier> <identifiersep> id ( ) ) ) ; } \n \t4 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t3 { \n \t4 <identifier> . <identifier> ( ) ; } \n \t3 catch ( interrupted <identifiersep> exception e ) \n \t3 { \n <ect>
<number_literal> + <string_literal> \n <number_literal> + t . get <identifiersep> message ( ) ) . trace ( ) ; \n \t2 <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . set <identifiersep> exception ( t ) ; } } } \n private void <identifier> ( throwable t ) { \n <ect>
\t4 case <number_literal> : \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> date <identifiersep> time <identifier> <identifiersep> date <identifiersep> time = ( <identifier> <identifiersep> <identifier> <identifiersep> date <identifiersep> time ) <identifier> ; \n \t5 if ( <identifier> <identifiersep> date <identifiersep> time . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t6 <comment> \n <ect>
\t3 try { \n \t4 ( ( <identifier> <identifiersep> bean ) connection <identifiersep> provider ) . <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ) { \n \t4 log . info ( <string_literal> ) ; \n \t4 return true ; } \n \t3 else { \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 <comment> \n \t1 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> cache <identifiersep> <identifier> ( manager ( 0 ) ) ; \n \t1 cache <identifiersep> <identifier> . remove ( 0 ) ; \n <ect>
\t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw ex ; \n \t1 } catch ( exception ex ) { \n <ect>
\t4 total <identifiersep> <identifier> . add <identifiersep> all ( r . get <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } \n \t2 catch ( class <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> + this ) ; \n \t3 log . error ( <string_literal> + base <identifiersep> <identifier> . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; \n <ect>
\t5 <comment> \n \t5 <identifier> = true ; } \n \t4 <identifier> <identifiersep> consumer <identifiersep> failed <identifiersep> event ( <string_literal> , <identifier> , ex ) ; } \n \t3 catch ( <identifier> <identifiersep> listener <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 for ( <identifier> test : <identifier> ) { \n \t3 test . run ( ) ; } \n \t2 for ( throwable failure : <identifier> ) { \n \t3 if ( failure != null ) { \n <ect>
\t4 <identifier> ( ) ; } \n \t2 } else { \n \t3 log . error ( <string_literal> , get <identifiersep> class ( ) ) ; } } \n \t1 private void try <identifiersep> to <identifiersep> <identifier> <identifiersep> job ( ) { \n <ect>
\t3 case <identifier> <identifiersep> <identifier> : break ; \n \t3 case <identifier> <identifiersep> <identifier> : break ; \n \t3 case <identifier> : break ; \n \t3 default : \n <ect>
\t1 if ( \n \t1 config . get <identifiersep> boolean ( config <identifiersep> <identifier> . local <identifiersep> start <identifiersep> <identifier> , false ) && \n \t2 config . get <identifiersep> integer ( web <identifiersep> options . port , 0 ) >= 0 ) { \n \t1 <identifier> <identifier> <identifiersep> timeout = <identifier> <identifiersep> utils . to <identifiersep> time ( timeout ) \n <ect>
\t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( content ) ) { \n \t3 string device <identifiersep> id = content . <identifier> ( <string_literal> ) [ 0 ] ; \n \t3 string state = content . <identifier> ( <string_literal> ) [ 1 ] ; \n \t3 boolean set <identifiersep> to <identifiersep> on = state == <string_literal> ; \n <ect>
\t2 <comment> \n \t2 set < url > <identifier> <identifiersep> registered = new <identifier> <identifiersep> set < url > ( get <identifiersep> registered ( ) ) ; \n \t2 if ( ! <identifier> <identifiersep> registered . is <identifiersep> empty ( ) ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t3 <identifier> <identifiersep> http <identifiersep> user <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> request ( user <identifiersep> request ) ; \n \t3 logger . debug ( <string_literal> , <identifier> ) ; \n \t3 final string user <identifiersep> response = user <identifiersep> request . execute <identifiersep> http <identifiersep> request ( ) . body ( ) . string ( ) ; \n \t3 final string json <identifiersep> response = url <identifiersep> <identifier> . <identifier> ( user <identifiersep> response , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <number_literal> . name ( ) ) ; \n <ect>
<comment> \n \t2 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( long <identifier> , @ <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> store <identifier> <identifiersep> store ) { \n \t3 <identifier> = false ; \n \t3 long start = <identifier> . get <identifiersep> time ( ) ; \n <ect>
\t3 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t2 for ( string path : <identifier> <identifiersep> data . <identifier> ) { \n \t3 i <identifiersep> file file <identifiersep> by <identifiersep> path = context . i <identifiersep> factory . find <identifiersep> file <identifiersep> by <identifiersep> path ( context . <identifier> <identifiersep> path ( path ) ) ; \n \t3 if ( file <identifiersep> by <identifiersep> path == null || ! file <identifiersep> by <identifiersep> path . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t8 . parse ( <identifier> [ i ] + <string_literal> ) . get <identifiersep> time ( ) ; \n \t6 start <identifiersep> time = new date ( time ) ; } \n \t5 catch ( parse <identifiersep> exception e ) \n \t5 { \n <ect>
\t3 s <identifiersep> logger . warn ( <string_literal> + name + <string_literal> ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + name + <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 system . set <identifiersep> out ( <identifier> <identifiersep> <identifier> ) ; \n \t2 system . set <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 o <identifiersep> c = out <identifiersep> content . to <identifiersep> string ( ) ; \n \t2 string e <identifiersep> c = <identifier> <identifiersep> content . to <identifiersep> string ( ) ; \n <ect>
public o <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ( final string i <identifiersep> <identifier> <identifiersep> name ) { \n \t1 try { \n \t1 manager . set <identifiersep> <identifier> <identifiersep> status ( manager . get <identifiersep> local <identifiersep> node <identifiersep> name ( ) , i <identifiersep> <identifier> <identifiersep> name , o <identifiersep> <identifier> <identifiersep> server <identifiersep> manager . db <identifiersep> status . <identifier> ) ; \n \t1 } catch ( exception t ) { \n <ect>
\t3 current <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> = <identifier> <identifiersep> network <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> ( ) ; } \n \t2 long bytes <identifiersep> <identifier> = user <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> ( ) - current <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> ; \n \t2 long bytes <identifiersep> <identifier> = user <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> ( ) - current <identifiersep> <identifier> <identifiersep> bytes <identifiersep> <identifier> ; \n \t2 if ( bytes <identifiersep> <identifier> < 0 ) { \n <ect>
\t3 { \n \t4 to <identifiersep> remove . add ( <identifier> <identifiersep> session <identifiersep> entry . get <identifiersep> key ( ) ) ; } } \n \t2 if ( ! to <identifiersep> remove . is <identifiersep> empty ( ) ) \n \t2 { \n <ect>
\t2 public void <identifier> ( ) { \n \t3 synchronized ( this . <identifier> <identifiersep> <identifier> <identifiersep> lock ) { \n \t4 this . last <identifiersep> <identifier> <identifiersep> <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t4 this . <identifier> <identifiersep> <identifier> = true ; } \n <ect>
\t4 if ( request == null ) { \n \t5 logger . info ( <string_literal> , new object [ ] { request } ) ; \n \t5 return null ; } } } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get ( <identifier> <identifiersep> name ) ; \n \t2 if ( <identifier> != null ) { \n \t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 return true ; } \n <ect>
\t3 @ <identifier> \n \t3 public long write ( string path , <identifier> <identifiersep> byte <identifiersep> channel data , byte <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , \n \t5 boolean has <identifiersep> data , int <identifier> <identifiersep> element <identifiersep> <identifier> ) throws io <identifiersep> exception \n \t3 { \n <ect>
\t4 result = <identifier> <identifiersep> <identifier> <identifiersep> connection . list <identifiersep> directory ( <string_literal> ) ; \n \t4 if ( result != null ) { \n \t5 <identifier> = true ; } \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 if ( null != <identifier> <identifiersep> stream ) \n \t2 try { \n \t2 <identifier> <identifiersep> stream . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 final string <identifier> = <identifier> <identifiersep> cluster ( ) . start <identifiersep> node ( <identifier> . builder ( ) . put ( <identifier> <identifiersep> <identifier> ) . put ( <string_literal> , <string_literal> ) . build ( ) ) ; \n \t2 <comment> \n \t2 assert <identifiersep> that ( <identifier> <identifiersep> <identifier> ( \n \t4 ( ) - > { \n <ect>
\t2 input <identifiersep> stream is = <identifier> <identifiersep> <identifier> <identifiersep> resource <identifiersep> as <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> context , api <identifiersep> <identifier> ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( ) ; \n \t3 string json = <identifier> <identifiersep> context . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> <identifier> <identifiersep> to ( string . class , is ) ; \n <ect>
\t1 <identifier> = <identifier> . <identifier> . get ( <identifier> <identifiersep> command <identifiersep> <identifier> <identifiersep> set <identifiersep> entry . get <identifiersep> key ( ) ) ; \n \t1 if ( ! <identifier> . equals ( <identifier> ) ) { \n \t2 log . debug ( <string_literal> , <identifier> <identifiersep> command <identifiersep> <identifier> <identifiersep> set <identifiersep> entry . get <identifiersep> key ( ) . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> command <identifiersep> <identifier> <identifiersep> set <identifiersep> entry . get <identifiersep> key ( ) . get <identifiersep> cmd ( ) ) ; \n \t2 return 1 ; } } \n <ect>
\t6 log . debug ( <string_literal> + <identifier> <identifiersep> host + <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ) + <string_literal> ) ; } \n \t5 return null ; } \n \t4 } ) ; \n \t4 } else { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 if ( send <identifiersep> message ) { \n \t3 if ( channel == null ) { \n <ect>
\t4 result . <identifier> = false ; \n \t4 result . <identifier> <identifiersep> size <identifiersep> <identifier> = true ; } \n \t3 result . <identifier> <identifiersep> <identifier> <identifiersep> size += <identifier> . get <identifiersep> count ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> shutdown ( false ) } } } \n \t1 <comment> \n \t1 private <identifier> <identifier> <identifiersep> <identifier> ( ) { \n \t2 if <identifiersep> <identifier> <identifiersep> unit { \n <ect>
\t1 <comment> \n \t1 input <identifiersep> table <identifiersep> config table <identifiersep> config = get <identifiersep> input <identifiersep> table <identifiersep> config ( <identifier> , <identifier> . get <identifiersep> table <identifiersep> name ( ) ) ; \n \t1 log . debug ( <string_literal> + principal ) ; \n \t1 log . debug ( <string_literal> + table ) ; \n <ect>
\t1 @ <identifier> \n \t1 public object <identifier> ( <identifier> <identifier> ) throws io <identifiersep> exception { \n \t2 <identifier> input <identifiersep> <identifier> = this . get <identifiersep> input <identifiersep> <identifier> ( ) ; \n <ect>
\t3 assert <identifiersep> that ( e . <identifier> <identifiersep> <identifier> ( ) , instance <identifiersep> of ( routing <identifiersep> <identifier> <identifiersep> exception . class ) ) ; } \n \t2 logger . info ( <string_literal> ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 assert <identifiersep> that ( client ( ) . <identifier> <identifiersep> get ( index <identifiersep> or <identifiersep> <identifier> ( ) , <string_literal> , <string_literal> ) . set <identifiersep> routing ( routing <identifiersep> value ) . execute ( ) . action <identifiersep> get ( ) . is <identifiersep> exists ( ) , equal <identifiersep> to ( true ) ) ; } \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( false ) ; \n \t3 <identifier> . start ( ) ; \n \t3 <identifier> . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 element root <identifiersep> element = <identifier> . get <identifiersep> <identifier> <identifiersep> element ( ) ; \n \t3 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> . length ; i ++ ) { \n \t4 node <identifiersep> list target <identifiersep> nodes = root <identifiersep> element . get <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> <identifiersep> name ( <identifier> <identifiersep> <identifier> [ i ] ) ; \n \t4 if ( target <identifiersep> nodes . get <identifiersep> length ( ) < = 0 ) { \n <ect>
\t4 logger . info ( <string_literal> , <identifier> <identifiersep> <identifier> , load <identifiersep> <identifier> ) ; \n \t3 } else { \n \t4 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> , load <identifiersep> <identifier> ) ; } \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( string <identifier> <identifiersep> id , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . access access , date <identifier> <identifiersep> date , \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifier> ) { \n \t2 try { \n <ect>
\t3 if ( vm . get <identifiersep> <identifier> <identifiersep> type ( ) != <identifier> <identifiersep> type . <identifier> <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> storage <identifiersep> <identifier> . <identifier> ( <identifier> ) ; \n \t4 s <identifiersep> logger . debug ( <string_literal> + vm ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> utils . add <identifiersep> error <identifiersep> attribute ( model , e ) ; } \n \t2 model . add <identifiersep> attribute ( <string_literal> , <string_literal> ) ; \n \t2 model . add <identifiersep> attribute ( <string_literal> , cluster ) ; \n \t2 <identifier> <identifiersep> utils . add <identifiersep> <identifier> <identifiersep> attribute ( model , <string_literal> ) ; \n <ect>
\t3 } catch ( connection <identifiersep> exception e ) { \n \t4 throw new <identifier> <identifiersep> exception ( <string_literal> , e ) ; } } \n \t2 else { \n \t3 if ( <identifier> ) \n <ect>
\t3 thread <identifier> = new thread ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this ) ) ; \n \t3 <identifier> . set <identifiersep> name ( <string_literal> + this . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> ) ; \n \t3 <identifier> . start ( ) ; \n \t2 } else { \n <ect>
\t2 try { \n \t3 return new <identifier> <identifiersep> client <identifiersep> <identifier> ( string , <identifier> <identifiersep> key <identifiersep> <identifier> , \n \t5 new <identifier> <identifiersep> public <identifiersep> key ( get <identifiersep> <identifier> <identifiersep> group ( ) , <identifier> <identifiersep> key ) , <identifier> <identifiersep> key , <identifier> <identifiersep> key , <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t1 public void test <identifiersep> in <identifiersep> out ( ) throws exception { \n \t2 get <identifiersep> <identifier> <identifiersep> endpoint ( <string_literal> ) . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 string out = template . request <identifiersep> body ( <string_literal> , <string_literal> , string . class ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , out ) ; \n <ect>
\t3 string <identifier> <identifiersep> string = ( string ) config . get ( <string_literal> ) ; \n \t3 if ( is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> string ) ) { \n \t4 <identifier> = <identifier> <identifiersep> string ; \n \t3 } else { \n <ect>
\t1 { \n \t2 try { \n \t3 return create <identifiersep> <identifier> <identifiersep> url ( <identifier> , <identifier> , name , <identifier> , context ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t4 log . error ( <string_literal> , e ) ; } \n \t3 try { \n \t4 <identifier> . close ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 final <identifier> <identifiersep> <identifier> <identifier> = ( <identifier> <identifiersep> <identifier> ) <identifier> . <identifier> ( ) ; \n \t5 if ( <identifier> != null ) { \n \t6 <identifier> <identifiersep> with <identifiersep> <identifier> ( <identifier> , event . <identifier> <identifiersep> <identifier> ) ; \n \t5 } else { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> enum . <identifier> , false ) ; \n \t3 if ( <identifier> ) { \n \t4 add <identifiersep> <identifier> ( device . get <identifiersep> <identifier> ( ) . get <identifiersep> value ( ) , ( short ) <identifier> <identifiersep> <identifier> <identifiersep> enum . <identifier> . get <identifiersep> <identifier> <identifiersep> number ( ) ) ; \n \t3 } else { \n <ect>
\t8 } else { \n \t9 <identifier> . put ( <identifier> + <identifier> , new byte [ 0 ] ) ; } \n \t8 return data ; } } \n \t5 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 { \n \t2 <identifier> . event <identifiersep> <identifier> ( ) . <identifier> ( ( ) - > { \n \t3 if ( <identifier> <identifiersep> client . <identifier> <identifiersep> if <identifiersep> not <identifiersep> <identifier> ( <string_literal> + timeout ) ) \n \t3 { \n <ect>
\t3 if ( server <identifiersep> socket != null ) { \n \t4 try { \n \t5 server <identifiersep> socket . close ( ) ; \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; \n \t4 } catch ( io <identifiersep> exception io <identifiersep> e ) { \n <ect>
\t8 for ( string <identifier> <identifiersep> <identifier> <identifiersep> name : string <identifiersep> utils . <identifier> ( command . to <identifiersep> string ( ) , <string_literal> ) ) { \n \t9 <identifier> <identifier> <identifiersep> <identifier> = client . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> name ) ; \n \t9 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t10 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> ) ; } } \n <ect>
\t1 while true : \n \t2 self . <identifier> <identifiersep> <identifier> = false \n \t2 self . <identifier> <identifiersep> and <identifiersep> <identifier> ( ) \n \t2 if not self . <identifier> <identifiersep> <identifier> : \n <ect>
\t2 for ( map . entry < string , result <identifiersep> <identifier> . file <identifiersep> entry > <identifier> : files . entry <identifiersep> set ( ) ) { \n \t3 string key = <identifier> . get <identifiersep> key ( ) ; \n \t3 result <identifiersep> <identifier> . file <identifiersep> entry value = <identifier> . get <identifiersep> value ( ) ; \n \t3 try { \n <ect>
\t2 final <identifier> < <identifier> <identifiersep> registered <identifiersep> service <identifiersep> service <identifiersep> provider <identifiersep> metadata <identifiersep> <identifier> > <identifier> = \n \t4 <identifier> <identifiersep> registered <identifiersep> service <identifiersep> service <identifiersep> provider <identifiersep> metadata <identifiersep> <identifier> . get ( this . <identifier> <identifiersep> registered <identifiersep> service <identifiersep> <identifier> <identifiersep> metadata <identifiersep> <identifier> , \n \t6 <identifier> <identifiersep> registered <identifiersep> service . class . <identifier> ( registered <identifiersep> service ) , entity <identifiersep> id ) ; \n \t2 if ( ! <identifier> . is <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 delete <identifiersep> <identifier> ( id ) ; <comment> \n \t5 total <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> get ( ) ; } } \n \t3 catch ( io <identifiersep> exception e ) \n \t3 { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 if ( ! <identifier> . <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t9 logger . debug ( <string_literal> + <identifier> . group . num ( ) + <string_literal> + <identifier> . group . num ( ) ) ; } \n \t8 <identifier> . group . <identifier> <identifiersep> <identifier> ( <identifier> . group ) ; \n \t8 if ( <identifier> <identifiersep> <identifier> <identifiersep> debug ) { \n \t9 logger . debug ( <string_literal> + <identifier> . set <identifiersep> number + <string_literal> + <identifier> . set <identifiersep> number ) ; \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> state <identifiersep> meta <identifiersep> data load = <identifier> <identifiersep> state <identifiersep> meta <identifiersep> data . format . load <identifiersep> <identifier> <identifiersep> state ( logger , <identifier> <identifiersep> x <identifiersep> content <identifiersep> <identifier> . empty , path ) ; \n \t3 if ( load != null ) { \n \t4 if ( load . index <identifiersep> <identifier> . equals ( index <identifiersep> <identifier> ) == false && index <identifiersep> meta <identifiersep> data . index <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> value . equals ( load . index <identifiersep> <identifier> ) == false ) { \n <ect>
\t1 if ( <identifier> . size ( ) == 0 ) \n \t2 return null ; \n \t1 return host <identifiersep> and <identifiersep> port . from <identifiersep> string ( <identifier> . get ( 0 ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 catch ( throwable <identifier> ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> throwable ( <identifier> ) ; \n \t3 <comment> \n <ect>
\t6 logger . debug ( <string_literal> , p <identifiersep> command , command <identifiersep> <identifier> ) ; \n \t6 <identifier> . set <identifiersep> volume ( ( ( <identifier> <identifiersep> type ) command <identifiersep> <identifier> ) . int <identifiersep> value ( ) ) ; \n \t6 break ; } \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> . add <identifiersep> and <identifiersep> lock ( path , <identifier> ) ; \n \t4 log . debug ( <string_literal> , <identifier> ) ; \n \t3 } else { \n \t4 <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( path , current <identifiersep> version , <identifier> ) ; \n <ect>
\t2 . create <identifiersep> <identifier> <identifiersep> query ( <identifier> , string <identifiersep> <identifier> . get ( ) , string <identifiersep> <identifier> . get ( ) , string <identifiersep> <identifier> . get ( ) ) \n \t2 . set <identifiersep> <identifier> <identifiersep> <identifier> ( lock <identifiersep> manager <identifiersep> <identifier> . get <identifiersep> lock <identifiersep> manager <identifiersep> <identifier> ( ) ) . set <identifiersep> key ( lock . get <identifiersep> path ( ) ) ; \n \t1 <identifier> <identifiersep> query . set <identifiersep> <identifier> <identifiersep> <identifier> ( lock <identifiersep> name ) ; \n \t1 query <identifiersep> result < <identifier> <identifiersep> <identifier> < string , string > > query <identifiersep> result = <identifier> <identifiersep> query . execute ( ) ; \n <ect>
\t2 log . info ( <string_literal> , source . to <identifiersep> string ( ) ) ; \n \t1 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n \t2 throw ex ; \n \t1 } catch ( exception ex ) { \n <ect>
\t7 logger . trace ( <string_literal> , get <identifiersep> id ( ) , ex ) ; \n \t7 return ; \n \t6 } else { \n \t7 logger . warn ( <string_literal> , msg ) ; \n <ect>
# <identifier> the <identifier> server . \n # \n @ <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . default ) \n <identifier> stop ( <identifier> ) : \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 if ( ! <identifier> . is <identifiersep> <identifier> <identifiersep> empty ( ) ) { \n \t3 return null ; } \n <ect>
\t1 { \n \t2 try { \n \t3 context . put ( <identifier> <identifiersep> context <identifiersep> key , new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( this . <identifier> <identifiersep> manager ) ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t4 <identifier> <identifiersep> builder . put <identifiersep> <identifier> ( <identifier> <identifiersep> meta <identifiersep> data . type , <identifier> ) ; \n \t4 return cluster <identifiersep> state . builder ( current <identifiersep> state ) . meta <identifiersep> data ( <identifier> <identifiersep> builder ) . build ( ) ; } \n \t3 @ <identifier> \n \t3 public void on <identifiersep> failure ( string source , exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> . exists ( path ) == - 1 ) { \n \t4 log . debug ( <string_literal> , task <identifiersep> id ) ; \n \t4 return false ; } \n \t3 <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> and <identifiersep> try <identifiersep> remove ( path ) ; \n <ect>
\t5 <identifier> . <identifier> ( ) ; } \n \t4 <identifier> . <identifier> ( ) ; \n \t3 } catch ( sql <identifiersep> exception ex ) { \n \t4 ex . <identifier> <identifiersep> stack <identifiersep> trace ( ) ; \n <ect>
\t1 try { \n \t2 if ( ! object <identifiersep> state . <identifier> . equals ( entity . get <identifiersep> state ( ) ) ) { \n \t2 entity = object <identifiersep> manager . <identifier> <identifiersep> <identifier> ( entity ) ; } \n \t1 } catch ( exception e ) { \n <ect>
<comment> \n \t1 protected map < string , string > load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> map ( final file <identifier> <identifiersep> <identifier> <identifiersep> map <identifiersep> file ) { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( name , object , user <identifiersep> info ) ; \n \t6 log . debug ( <string_literal> , <identifier> ) ; \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 <identifier> <identifiersep> type = <identifier> <identifiersep> utils . <identifier> ( new <identifier> <identifiersep> input <identifiersep> stream ( get <identifiersep> content <identifiersep> input <identifiersep> stream ( <identifier> ) ) ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 final registered <identifiersep> service registered <identifiersep> service = this . <identifier> <identifiersep> manager . find <identifiersep> service <identifiersep> by ( <identifier> <identifiersep> service ) ; \n \t2 if ( ! service <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( registered <identifiersep> service ) ) { \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> service ) ; \n \t3 return null ; } \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public <identifier> < <identifier> <identifiersep> item > query ( filter <identifiersep> <identifier> filter ) { \n <ect>
\t8 store <identifiersep> name , \n \t8 read <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> version <identifiersep> id ( new file ( <identifier> <identifiersep> <identifier> . get ( node ) ) ) ) ; \n \t6 logger . info ( <string_literal> + node . <identifier> <identifiersep> to <identifiersep> string ( ) ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t4 if ( <identifier> != null ) { \n \t5 logger . debug ( <string_literal> , <identifier> . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; \n \t5 object <identifiersep> factory ( <identifier> ) ; } \n \t3 } catch ( exception ex ) { \n <ect>
\t2 if ( <identifier> <identifiersep> root == <identifier> <identifiersep> root ) { \n \t3 log . info ( <string_literal> ) ; \n \t3 trace <identifiersep> <identifier> = true ; \n \t2 } else { \n <ect>
\t1 @ <identifier> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( ) throws exception { } \n \t1 public void <identifier> ( ) throws sql <identifiersep> exception { \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t3 return null ; } \n \t2 final <identifier> <identifiersep> json <identifiersep> web <identifiersep> key key = ( <identifier> <identifiersep> json <identifiersep> web <identifiersep> key ) <identifier> . get <identifiersep> json <identifiersep> web <identifiersep> <identifier> ( ) . get ( 0 ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( key . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 try { \n \t3 execute <identifiersep> <identifier> <identifiersep> json <identifiersep> test ( <string_literal> , <string_literal> , false , <number_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void handle <identifiersep> application <identifiersep> command <identifiersep> request ( <identifier> <identifiersep> message <identifier> <identifiersep> message , int <identifier> , int endpoint ) { \n <ect>
\t4 log . warn ( <string_literal> + <identifier> . <identifier> + <string_literal> ) ; } \n \t3 if ( ! <identifier> . <identifier> . equals <identifiersep> ignore <identifiersep> case ( mode ) ) { \n \t4 log . debug ( <string_literal> + <identifier> . to <identifiersep> string ( ) ) ; \n <ect>
\t2 if ( time <identifiersep> service == null ) \n \t3 log . warn ( <string_literal> , local <identifiersep> <identifier> ) ; \n \t2 else { \n \t3 if ( time <identifiersep> service . <identifier> ( ) > timeout ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> = 0 ; \n \t3 logger . debug ( <string_literal> , url ) ; \n \t3 class . for <identifiersep> name ( <identifier> <identifiersep> class ) . new <identifiersep> instance ( ) ; \n \t3 connection = <identifier> <identifiersep> manager . get <identifiersep> connection ( url , user , password ) ; \n <ect>
\t4 . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> string ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> = session . create <identifiersep> <identifier> <identifiersep> <identifier> ( destination , <string_literal> ) ; \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \t3 msg = ( text <identifiersep> message ) <identifier> <identifiersep> <identifier> . <identifier> ( <number_literal> ) ; \n <ect>
\t4 log . debug ( <string_literal> + node <identifiersep> id + <string_literal> + <identifier> + ' ] ' ) ; \n \t3 <identifier> . io ( ) . send ( node <identifiersep> id , <identifier> ) ; } \n \t2 catch ( grid <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 } else { \n \t4 log . info ( <string_literal> + this . <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( ) ) ; \n \t4 this . <identifier> <identifiersep> provider . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 final set < string > <identifier> <identifiersep> header <identifiersep> values = new <identifier> <identifiersep> set < string > ( ) ; \n \t3 for ( final header header : <identifier> <identifiersep> <identifier> ) { \n \t4 <identifier> <identifiersep> header <identifiersep> values . add ( header . get <identifiersep> value ( ) ) ; } \n \t3 assert <identifiersep> true ( <string_literal> , <identifier> <identifiersep> header <identifiersep> values . contains ( <string_literal> ) ) ; \n <ect>
\t8 synchronized ( failed <identifiersep> map ) { \n \t9 <identifier> <identifiersep> map <identifiersep> value ( <identifier> , failed <identifiersep> map ) ; } \n \t8 if ( has <identifiersep> <identifier> <identifiersep> for <identifiersep> no <identifiersep> node ) { \n \t9 throw <identifier> ; } \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( user <identifiersep> id , vm <identifiersep> id ) == null ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + vm <identifiersep> instance ) ; \n \t5 return false ; \n \t4 } else { \n <ect>
\t5 provider , service . get <identifiersep> name ( ) ) ; \n \t3 final event event = <identifier> <identifiersep> event <identifiersep> id <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> context ( provider . get <identifiersep> id ( ) , context , \n \t5 build <identifiersep> event <identifiersep> attribute <identifiersep> map ( authentication . get <identifiersep> principal ( ) , service , provider ) ) ; \n \t3 return collection <identifiersep> utils . <identifier> <identifiersep> set ( event ) ; } \n <ect>
\t2 } catch ( runtime <identifiersep> exception <identifier> ) { \n \t3 log . error ( <string_literal> , <identifier> ) ; \n \t3 throw <identifier> ; \n \t2 } catch ( exception e ) { \n <ect>
\t6 time <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> time <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> user <identifiersep> <identifier> ( ) ; \n \t5 return ; } \n \t4 double this <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n \t4 if ( <identifier> < 0 ) { \n <ect>
\t4 <identifier> = true ; \n \t4 break ; } } \n \t2 if ( <identifier> ) { \n \t3 if ( <identifier> <identifiersep> debug <identifiersep> target == null ) { \n <ect>
\t1 import <identifier> \n \t1 <identifier> . set <identifiersep> <identifier> ( <identifier> ) \n \t1 <identifier> <identifiersep> <identifier> ( name = <identifier> ) \n \t1 <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( self , <identifier> , <identifier> <identifiersep> type = <identifier> ) : \n <ect>
\t4 if ( <identifier> < <identifier> ) <identifier> . <identifier> ( <identifier> ) ; \n \t4 <identifier> . <identifier> ( integer . to <identifiersep> <identifier> <identifiersep> string ( <identifier> ) ) ; } \n \t3 value <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . to <identifiersep> string ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t3 list < string > <identifier> <identifiersep> item <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> map . get ( <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> in <identifiersep> <identifier> ) ; \n \t3 synchronized ( <identifier> <identifiersep> item <identifiersep> <identifier> ) { \n \t4 logger . debug ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> in <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> item <identifiersep> <identifier> . <identifier> ( ) ; } \n <ect>
\t1 thread . current <identifiersep> thread ( ) . set <identifiersep> name ( <string_literal> ) ; \n \t1 int i = - 1 ; \n \t1 logger . trace ( <string_literal> + ++ i ) ; \n \t1 root . trace ( <string_literal> + i ) ; \n <ect>
\t1 public boolean is <identifiersep> <identifier> ( ) { \n \t2 return true ; } \n \t1 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t1 public void <identifier> <identifiersep> connection ( ) throws exception { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 s <identifiersep> logger . debug ( <string_literal> + network . get <identifiersep> state ( ) ) ; \n \t3 return false ; } \n \t2 boolean success = true ; \n \t2 if ( ! <identifier> <identifiersep> network <identifiersep> <identifier> ( network <identifiersep> id , <identifier> <identifiersep> account , context . get <identifiersep> <identifier> ( ) . get <identifiersep> id ( ) ) ) { \n <ect>
\t3 <identifier> . set <identifiersep> string ( 1 , key ) ; \n \t3 <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t3 return <identifier> . next ( ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 string <identifier> <identifiersep> name = null ; \n \t2 string first <identifiersep> <identifier> <identifiersep> name = <identifier> . get <identifiersep> next ( ) ; <comment> \n \t2 while ( <identifier> . has <identifiersep> next ( ) ) { \n \t3 <identifier> <identifiersep> name = <identifier> . next ( ) ; \n <ect>
\t3 string port = system . get <identifiersep> property ( port <identifiersep> key ) ; \n \t3 map < string , string > conf <identifiersep> map = <identifier> . new <identifiersep> <identifier> <identifiersep> map ( ) ; \n \t3 if ( ! string <identifiersep> utils . is <identifiersep> empty ( host ) ) { \n \t4 conf <identifiersep> map . put ( host <identifiersep> key , host ) ; \n <ect>
\t6 <identifier> <identifiersep> <identifier> . put ( value <identifiersep> of <identifiersep> <identifier> . to <identifiersep> string ( ) , integer . value <identifiersep> of ( ( ( org . <identifier> . bean . <identifier> <identifiersep> <identifier> . int ) <identifier> <identifiersep> <identifier> ) . get <identifiersep> value ( ) ) ) ; \n \t5 } else if ( null . class . is <identifiersep> instance ( <identifier> <identifiersep> <identifier> ) ) { \n \t6 <identifier> <identifiersep> <identifier> . put ( value <identifiersep> of <identifiersep> <identifier> . to <identifiersep> string ( ) , null ) ; } \n \t4 } else { \n <ect>
\t6 if ( field <identifiersep> object == null ) { \n \t7 try { \n \t8 field <identifiersep> object = field <identifiersep> type . new <identifiersep> instance ( ) ; \n \t7 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 <identifier> = <identifier> <identifiersep> host <identifiersep> <identifier> <identifiersep> service . remove ( <identifier> <identifiersep> host ) ; \n \t1 message = <string_literal> ; \n \t1 } else { \n \t1 message = <string_literal> ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifier> = null ; \n \t3 for ( int i = 0 ; i < <identifier> ; i ++ ) { \n \t4 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . add <identifiersep> <identifier> ( ) ; \n \t4 <identifier> . add <identifiersep> <identifier> ( <string_literal> , v ) ; \n <ect>
\t3 string msg = get <identifiersep> error <identifiersep> message ( file , line , \n \t5 <string_literal> + name + <string_literal> , \n \t5 e . get <identifiersep> message ( ) + <string_literal> + body ) ; \n \t3 throw new <identifier> <identifiersep> exception ( msg ) ; } \n <ect>
\t8 string [ ] <identifier> = text . <identifier> ( <string_literal> ) ; \n \t8 msg <identifiersep> id = <identifier> [ 0 ] ; \n \t8 msg <identifiersep> text = <identifier> [ 1 ] ; \n \t8 if ( <string_literal> . equals <identifiersep> ignore <identifiersep> case ( msg <identifiersep> id ) ) { \n <ect>
\t9 <identifier> <identifiersep> info . <identifier> ( <string_literal> ) ; \n \t9 no <identifiersep> <identifier> = false ; } \n \t8 catch ( exception e ) \n \t8 { \n <ect>
\t2 <identifier> ( ) ; } \n \t1 public void close ( ) { \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 log . info ( <string_literal> + <identifier> <identifiersep> id + <string_literal> + <identifier> <identifiersep> count + <string_literal> + failed <identifiersep> count ) ; \n <ect>
\t3 out <identifiersep> stream . <identifier> ( <string_literal> ) ; \n \t3 out <identifiersep> stream . <identifier> ( <string_literal> ) ; \n \t2 } catch ( exception ex ) \n \t2 { \n <ect>
\t1 log <identifiersep> log . debug ( <string_literal> + name \n \t2 + <string_literal> ) ; \n \t1 break ; \n \t1 default : \n <ect>
<comment> \n \t1 public boolean <identifier> <identifiersep> <identifier> <identifiersep> request ( <identifier> <identifiersep> request entity ) { \n \t2 string <identifier> = get <identifiersep> or <identifiersep> create <identifiersep> metadata ( entity ) . get <identifiersep> name ( ) ; \n <ect>
\t2 logger . info ( <string_literal> , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 logger . info ( <string_literal> , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 logger . info ( <string_literal> , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n <ect>
\t3 else if ( <identifier> . equals ( line ) ) { \n \t5 log . info ( <string_literal> + key ) ; } \n \t3 else { \n <ect>
\t3 } , time <identifiersep> unit . <identifier> . to <identifiersep> millis ( <number_literal> ) ) ) ; \n \t2 <comment> \n \t2 this . <identifier> <identifiersep> <identifier> . shutdown ( ) ; \n \t2 assert <identifiersep> true ( <string_literal> + <identifier> , <identifier> . is <identifiersep> empty ( ) ) ; \n <ect>
\t5 string <identifier> <identifiersep> path = <identifier> . <identifier> ( ) . next ( ) ; \n \t5 if ( <identifier> <identifiersep> path . <identifier> <identifiersep> with ( <string_literal> ) ) { \n \t6 <identifier> <identifiersep> path = <identifier> <identifiersep> path . <identifier> ( 0 , <identifier> <identifiersep> path . length ( ) - <number_literal> ) ; } \n \t5 base <identifiersep> uri = <identifier> . of ( base <identifiersep> server + <identifier> <identifiersep> path ) ; \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> ( ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> class . get <identifiersep> <identifier> <identifiersep> <identifier> ( map . class , <identifier> <identifiersep> context . class , string . class ) \n \t7 . new <identifiersep> instance ( <identifier> , <identifier> <identifiersep> context , <identifier> <identifiersep> name ) ; \n \t2 log . debug ( <string_literal> ) ; } \n \t1 catch ( exception ex ) { \n <ect>
\t3 long time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t3 thread . <identifier> ( <number_literal> ) ; \n \t3 long <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) - time ; \n \t3 long count = ( <identifier> / <number_literal> ) + 1 ; \n <ect>
\t2 try { \n \t3 if ( session != null ) { \n \t4 session . close ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t8 s <identifiersep> logger . debug ( <string_literal> + vm ) ; } \n \t7 return <identifier> <identifiersep> vm ; \n \t6 } else { \n <ect>
<comment> \n \t4 return ; } } \n \t2 <comment> \n <ect>
\t3 final <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ex = new <identifier> <identifiersep> <identifier> <identifiersep> value <identifiersep> exception ( <string_literal> ) ; \n \t3 throw ex ; } \n \t2 if ( vm . get <identifiersep> state ( ) != state . <identifier> ) { \n <ect>
\t4 <identifier> = - 1 ; \n \t3 } else if ( <identifier> > 0 ) { \n \t4 if ( this . <identifier> <identifiersep> <identifier> && <identifier> != this . default <identifiersep> <identifier> ) { \n \t5 <identifier> = this . default <identifiersep> <identifier> ; \n <ect>
\t3 } catch ( <identifier> <identifiersep> exception . <identifier> <identifiersep> version <identifiersep> exception e ) { \n \t4 <comment> \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 assert . <identifier> ( <string_literal> ) ; } \n <ect>
\t2 if ( port == null ) { \n \t3 s <identifiersep> logger . info ( <string_literal> ) ; \n \t3 system . <identifier> ( 1 ) ; } \n \t2 if ( url == null ) { \n <ect>
\t1 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( ex ) ; } \n \t1 try { \n \t1 <identifier> . <identifier> ( <identifier> <identifiersep> info . with <identifiersep> <identifier> <identifiersep> volume <identifiersep> id ( <identifier> <identifiersep> volume <identifiersep> id ) . with <identifiersep> size ( size ) ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 class . for <identifiersep> name ( configuration . <identifier> <identifiersep> in <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 try { \n \t3 <identifier> <identifiersep> manager . get <identifiersep> connection ( <identifier> <identifiersep> <identifier> <identifiersep> url ) ; \n \t2 } catch ( sql <identifiersep> <identifier> <identifiersep> transient <identifiersep> connection <identifiersep> exception <identifier> ) { \n <ect>
\t2 if ( <identifier> <identifiersep> file != null ) { \n \t3 <identifier> <identifier> <identifiersep> for <identifiersep> file = <identifier> <identifiersep> file <identifiersep> index . service . get <identifiersep> instance ( file . get <identifiersep> <identifier> ( ) ) . get <identifiersep> <identifier> <identifiersep> for <identifiersep> file ( <identifier> <identifiersep> file ) ; \n \t3 if ( <identifier> <identifiersep> for <identifiersep> file != null ) { \n \t4 return get <identifiersep> <identifier> ( <identifier> <identifiersep> for <identifiersep> file ) ; } } \n <ect>
<comment> \n \t1 private void stop <identifiersep> wait <identifiersep> and <identifiersep> <identifier> ( ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t5 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception ex ) { \n \t6 <comment> \n \t6 <comment> \n \t5 } catch ( exception ex ) { \n <ect>
\t2 throws operation <identifiersep> failed <identifiersep> exception , \n \t3 operation <identifiersep> not <identifiersep> <identifier> <identifiersep> exception \n \t1 { \n \t2 string test <identifiersep> <identifier> <identifiersep> name = test <identifiersep> <identifier> <identifiersep> base <identifiersep> name + <identifier> <identifiersep> id ++ ; \n <ect>
\t3 @ <identifier> \n \t3 public boolean is <identifiersep> <identifier> ( ) throws exception { \n \t4 return ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) != null ; } \n \t2 } ) ) ; \n <ect>
\t5 else \n \t6 thread . <identifier> ( wait <identifiersep> time ) ; } \n \t4 catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> configuration config = configuration ; \n \t2 if ( config == null ) { \n \t3 config = get <identifiersep> <identifier> <identifiersep> context ( ) . get <identifiersep> <identifier> <identifiersep> configuration ( <string_literal> , true ) ; } \n \t2 if ( config . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t7 send <identifiersep> request ( <identifier> . get <identifiersep> address ( ) , type . <identifier> <identifiersep> run , \n \t8 <identifier> . get <identifiersep> request <identifiersep> id ( ) , null ) ; } } \n \t5 else { \n <ect>
\t1 log . debug ( <string_literal> , <identifier> . channel ( ) . remote <identifiersep> address ( ) ) ; \n \t1 <identifier> . on <identifiersep> response ( transport <identifiersep> response <identifiersep> <identifier> . success ( new <identifiersep> response , <identifier> <identifiersep> <identifier> ) ) ; } \n \t1 else \n \t1 { \n <ect>
\t2 c <identifiersep> <identifier> <identifiersep> header <identifier> <identifiersep> header \n \t3 = ( c <identifiersep> <identifier> <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> <identifier> <identifiersep> header . name ) ; \n \t2 if ( <identifier> <identifiersep> header == null ) \n \t2 { \n <ect>
\t7 <identifier> <identifiersep> public <identifiersep> ip = <identifier> <identifiersep> user . get <identifiersep> public <identifiersep> ip ( ) . get ( <identifier> <identifiersep> user . get <identifiersep> public <identifiersep> ip ( ) . size ( ) - 1 ) ; \n \t7 if ( <identifier> <identifiersep> public <identifiersep> ip != null ) { \n \t8 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> public <identifiersep> ip + <string_literal> + <identifier> <identifiersep> user . get <identifiersep> user <identifiersep> name ( ) ) ; } \n \t7 else { \n <ect>
\t1 if ( <identifier> <identifiersep> client != null ) { \n \t2 <comment> \n \t2 <identifier> <identifiersep> client . start ( ) ; } \n \t1 } catch ( <identifier> ex ) { \n <ect>
\t4 synchronized ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t5 t = r . <identifier> . check ( type , r . method , id , current , max <identifiersep> wait ) ; \n \t5 if ( t != null ) { \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t4 principal <identifiersep> manager = ( ( <identifier> <identifiersep> session ) session ) . get <identifiersep> principal <identifiersep> manager ( ) ; } \n \t3 <identifier> <identifiersep> <identifier> = read <identifiersep> <identifier> <identifiersep> node <identifiersep> type <identifiersep> manager . get <identifiersep> instance ( root , name <identifiersep> path <identifiersep> <identifier> ) ; \n \t3 <identifier> = true ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t6 resource <identifiersep> type , \n \t6 <identifier> ) ; \n \t1 collection <identifiersep> model . set <identifiersep> <identifier> <identifiersep> resource <identifiersep> model ( <identifier> <identifiersep> resource <identifiersep> model ) ; \n \t1 add <identifiersep> resource <identifiersep> <identifier> ( collection <identifiersep> resource <identifiersep> class , collection <identifiersep> model ) ; \n <ect>
\t1 <identifier> <identifiersep> set < text > <identifier> = new <identifier> <identifiersep> set < > ( ) ; \n \t1 for ( i = 1 ; i < <identifier> . length ; i ++ ) { \n \t1 <identifier> . add ( new text ( <string_literal> + i ) ) ; } \n \t1 c . table <identifiersep> <identifier> ( ) . add <identifiersep> <identifier> ( metadata <identifiersep> table . name , <identifier> ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> ( final <identifier> <identifier> <identifiersep> session <identifiersep> id ) { \n \t2 synchronized ( lock ) { \n \t3 if ( shutdown ) { \n <ect>
\t7 return new answer ( cmd ) ; \n \t6 else \n \t7 return new answer ( cmd , false , <string_literal> ) ; } } \n \t3 } catch ( exception e ) { \n <ect>
\t1 public static void <identifier> ( configuration <identifier> <identifiersep> conf ) throws io <identifiersep> exception { \n \t2 <identifier> ( <identifier> <identifiersep> conf , utils . is <identifiersep> local ( <identifier> <identifiersep> conf ) ) ; } \n \t1 public static void <identifier> ( configuration <identifier> <identifiersep> conf , boolean is <identifiersep> local ) throws io <identifiersep> exception { \n \t2 if ( <identifier> != null ) { \n <ect>
\t3 <comment> \n \t3 if ( <identifier> . size ( ) >= <identifier> <identifiersep> count || ( is <identifiersep> <identifier> <identifiersep> <identifier> && <identifier> <identifiersep> id == null ) ) { \n \t4 return <identifier> ; } \n \t3 if ( <identifier> . size ( ) >= <number_literal> ) { \n <ect>
\t1 public boolean <identifier> <identifiersep> static <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> network ( long network <identifiersep> id , boolean continue <identifiersep> on <identifiersep> error , account <identifier> ) { \n \t2 list < <identifier> <identifiersep> <identifier> <identifiersep> vo > <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> dao . list <identifiersep> by <identifiersep> network <identifiersep> and <identifiersep> <identifier> ( network <identifiersep> id , <identifier> . static <identifiersep> <identifier> ) ; \n \t2 list < static <identifiersep> <identifier> <identifiersep> <identifier> > static <identifiersep> <identifier> <identifiersep> <identifier> = new array <identifiersep> list < static <identifiersep> <identifier> <identifiersep> <identifier> > ( ) ; \n \t2 if ( <identifier> . size ( ) == 0 ) { \n <ect>
<comment> \n <comment> \n <comment> \n <comment> \n <ect>
\t2 <identifier> < <identifier> > result = server . <identifier> <identifiersep> <identifier> ( load <identifiersep> <identifier> ) ; \n \t2 int count = 0 ; \n \t2 while ( ( result . next ( ) ) != null ) { \n \t3 count ++ ; } \n <ect>
\t2 access <identifiersep> <identifier> <identifiersep> manager <identifier> ; \n \t2 try { \n \t3 <identifier> = find <identifiersep> <identifier> ( name , handle ) ; \n \t3 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n <ect>
\t2 <comment> \n \t2 if ( <identifier> . get ( ) ) { \n \t2 log . info ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> session . get <identifiersep> session <identifiersep> id ( ) ) ; } \n \t1 } catch ( interrupted <identifiersep> exception | execution <identifiersep> exception e ) { \n <ect>
\t2 } catch ( interrupted <identifiersep> exception e ) { } \n \t2 logger . info ( <string_literal> , lock ) ; \n \t2 <comment> \n \t2 pool . <identifier> . <identifier> ( lock ) ; \n <ect>
\t2 time <identifiersep> unit . <identifier> ) , time <identifiersep> unit . <identifier> ) ; } } \n private static void start <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws throwable { \n \t1 long <identifier> = 0 , max <identifiersep> <identifier> = 1 ; \n \t1 while ( true ) { \n <ect>
\t6 boolean <identifier> <identifiersep> <identifier> = ( <identifier> != null ) && <identifier> <identifiersep> write <identifiersep> <identifier> <identifiersep> <identifier> . remove ( <identifier> ) ; \n \t6 if ( <identifier> <identifiersep> <identifier> ) { \n \t7 <comment> \n \t7 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 protected void run <identifiersep> in <identifiersep> context ( ) { \n \t3 try { \n \t4 final <identifier> <identifiersep> lock lock = <identifier> <identifiersep> lock . get <identifiersep> <identifier> <identifiersep> lock ( <string_literal> ) ; \n \t4 if ( lock == null ) { \n <ect>
\t3 logger . error ( <string_literal> + string + <string_literal> , <identifier> ) ; } \n \t2 return false ; } \n \t1 @ <identifier> \n \t1 public user <identifier> ( authentication <identifier> ) throws authentication <identifiersep> failed <identifiersep> exception { \n <ect>
\t1 public void <identifier> ( object msg <identifiersep> id ) { \n \t2 log . debug ( <string_literal> + msg <identifiersep> id ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( object msg <identifiersep> id ) { \n <ect>
\t2 logger . error ( <identifier> <identifiersep> type . <identifier> <identifiersep> group , new <identifier> <identifiersep> group <identifiersep> <identifier> ( <identifier> <identifiersep> group <identifiersep> id ) , \n \t4 <string_literal> , <string_literal> ) ; \n \t2 logger . error ( <identifier> <identifiersep> type . property , new property <identifiersep> <identifier> ( property <identifiersep> id ) , \n \t4 <string_literal> , <string_literal> ) ; \n <ect>
\t3 final <identifier> <identifiersep> test <identifiersep> server <identifier> <identifiersep> test <identifiersep> server = new <identifier> <identifiersep> test <identifiersep> server ( ) ; \n \t3 try { \n \t4 <identifier> <identifiersep> test <identifiersep> server . start ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 int <identifier> <identifiersep> <identifier> <identifiersep> type = - 1 ; \n \t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> type = integer . parse <identifiersep> int ( <identifier> <identifiersep> <identifier> <identifiersep> type <identifiersep> string ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t6 <identifier> . log . warn ( <string_literal> + <identifier> . key ( ) ) ; } \n \t3 } else { \n \t4 <identifier> . log . info ( <string_literal> + i + <string_literal> ) ; \n \t4 if ( <identifier> != null ) \n <ect>
\t3 return null ; } \n \t2 try { \n \t3 return new <identifier> <identifiersep> date <identifiersep> format ( date <identifiersep> time <identifiersep> format ) . parse ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t7 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; } \n \t5 catch ( operation <identifiersep> failed <identifiersep> exception e ) \n \t5 { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( <identifier> . get <identifiersep> id ( ) ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> host <identifiersep> exception <identifier> ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t2 out += ' ) { ' ; \n \t2 <identifier> <identifiersep> <identifier> += ' } ' ; } \n \t1 } else { \n \t2 if ( it . <identifier> . <identifier> && it . <identifier> . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 if ( result != null ) { \n \t4 s <identifiersep> logger . error ( <string_literal> + vm <identifiersep> name + <string_literal> + result ) ; \n \t4 return new check <identifiersep> <identifier> <identifiersep> answer ( cmd , <string_literal> + vm <identifiersep> name + <string_literal> + result ) ; } \n \t2 } catch ( final exception e ) { \n <ect>
\t5 msg <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> . msg ) ; \n \t4 } else if ( <identifier> . <identifier> <identifiersep> count < <number_literal> ) { \n \t5 <comment> \n \t5 <identifier> . <identifier> <identifiersep> count ++ ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> provider <identifiersep> map ( ) ; \n \t2 if ( <identifier> <identifiersep> provider <identifiersep> map . contains <identifiersep> key ( <identifier> <identifiersep> provider <identifiersep> <identifier> . value ( ) ) ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> provider = <identifier> <identifiersep> provider <identifiersep> map . get ( <identifier> <identifiersep> provider <identifiersep> <identifier> . value ( ) ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> provider == null ) { \n <ect>
\t1 } catch ( throwable t ) { \n \t2 log . error ( <string_literal> , t ) ; } \n \t2 log . debug ( <string_literal> + <identifier> <identifiersep> list . size ( ) ) ; \n <ect>
\t4 } catch ( table <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n \t5 logger . error ( <string_literal> , <identifier> ) ; \n \t5 throw new <identifier> <identifiersep> <identifier> <identifiersep> exception ( <identifier> ) ; \n \t4 } catch ( org . apache . <identifier> . <identifier> . table <identifiersep> exists <identifiersep> exception <identifier> ) { \n <ect>
\t4 <comment> \n \t4 return ; } \n \t3 if ( out <identifiersep> queue . size ( ) >= max <identifiersep> queue <identifiersep> length ) { \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> a <identifiersep> message ) { \n <ect>
\t3 <comment> \n \t3 <identifier> . set <identifiersep> <identifier> ( null ) ; \n \t4 <identifier> = system . current <identifiersep> time <identifiersep> millis ( ) ; \n <ect>
\t5 <identifier> [ ] <identifier> = <identifier> <identifiersep> entry <identifiersep> info ( entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; \n \t5 entry . set <identifiersep> <identifier> <identifiersep> nodes ( <identifier> ) ; \n \t5 if ( map <identifiersep> <identifier> != null ) map <identifiersep> <identifier> . object <identifiersep> <identifier> <identifiersep> <identifier> ( entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; \n \t4 } catch ( channel <identifiersep> exception x ) { \n <ect>
\t1 public void <identifier> <identifiersep> instance ( instance instance ) \n \t1 { \n \t2 <identifier> <identifiersep> <identifier> < instance > <identifier> <identifiersep> client = <identifier> . instance <identifiersep> client . <identifier> ( client , instance . get <identifiersep> type ( ) ) ; \n \t2 <identifier> <identifiersep> client . set ( instance ) . <identifier> ( e - > { \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> test <identifiersep> send <identifiersep> message ( ) \n \t1 { \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifiersep> input <identifiersep> <identifier> <identifiersep> node <identifier> ( channel in , <identifier> <identifiersep> input <identifiersep> node node ) { \n \t2 if ( in . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == <identifier> <identifiersep> <identifier> <identifiersep> type . <identifier> ) { \n \t3 if ( in . get <identifiersep> source ( ) . get <identifiersep> <identifier> <identifiersep> node ( ) instanceof <identifier> <identifiersep> node ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 <comment> \n \t2 int <identifier> <identifiersep> bytes = size - <identifier> ; \n <ect>
\t1 try { \n \t1 <identifier> <identifiersep> thread . <identifier> ( ) ; \n \t1 <identifier> <identifiersep> thread . <identifier> ( ) ; \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t7 ) \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( format <identifiersep> code = false ) ) . run ( <identifier> <identifiersep> <identifier> ! ! , <identifier> = null ) } \n \t5 } catch ( e : throwable ) { \n \t6 <comment> \n <ect>
\t2 if ( <identifier> . is <identifiersep> empty ( ) ) { \n \t3 if ( <identifier> <identifiersep> <identifier> instanceof file <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 log . warn ( <string_literal> + <identifier> <identifiersep> base <identifiersep> model . get <identifiersep> name ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> file ( ) ) ; \n \t3 } else { \n <ect>
\t2 assert <identifier> <identifiersep> <identifier> . <identifier> ( <number_literal> , <identifier> ) ; \n \t2 try { \n \t3 <identifier> . get ( ) ; } \n \t2 catch ( grid <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> in <identifiersep> <identifier> . remove ( id ) ; \n \t2 if ( <identifier> != null ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . <identifier> ( ) ) ; \n \t2 } else { \n <ect>
\t3 <identifier> . close ( ) ; \n \t3 <comment> \n \t3 <comment> \n \t3 <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
private void <identifier> <identifiersep> <identifier> ( ) { \n \t1 if ( <identifier> <identifiersep> system . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t1 <identifier> <identifiersep> system . <identifier> <identifiersep> object ( this ) ; } \n \t1 if ( ! <identifier> <identifiersep> system . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) || <identifier> <identifiersep> system . get ( i <identifiersep> <identifier> <identifiersep> service . class ) == null ) { \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> result = <identifier> <identifiersep> <identifier> <identifiersep> service . create <identifiersep> <identifier> <identifiersep> <identifier> ( this ) ; \n \t3 set <identifiersep> entity <identifiersep> id ( result . get <identifiersep> id ( ) ) ; \n \t2 } catch ( network <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 <comment> \n \t2 try { \n \t3 <identifier> <identifiersep> text = <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> text ) ; \n \t2 } catch ( illegal <identifiersep> <identifier> e ) { \n <ect>
private static final log log = log <identifiersep> factory . get <identifiersep> log ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> test . class ) ; \n public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws interrupted <identifiersep> exception { \n \t1 cache < string , string > cache = null ; \n \t1 cache = create <identifiersep> cache ( true , <string_literal> ) ; \n <ect>
\t7 <identifier> <identifiersep> device . <identifier> ( ) ; \n \t6 } catch ( <identifier> <identifiersep> exception e ) { \n \t7 logger . error ( <string_literal> + <identifier> <identifiersep> port + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t6 } catch ( throwable e ) { \n <ect>
\t3 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n \t4 logger . error ( <string_literal> , type <identifiersep> class . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t4 return null ; } \n \t2 } else { \n <ect>
\t4 session . delete ( <identifier> <identifiersep> property ) ; } \n \t3 <comment> \n \t3 for ( db <identifiersep> string <identifiersep> list <identifiersep> property new <identifiersep> property : new <identifiersep> properties ) { \n \t4 session . <identifier> ( new <identifiersep> property ) ; } \n <ect>
<comment> \n \t1 public boolean <identifier> <identifiersep> <identifier> ( content <identifiersep> name <identifier> ) { \n \t2 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) \n <ect>
<comment> \n \t1 private static public <identifiersep> key create <identifiersep> registered <identifiersep> service <identifiersep> public <identifiersep> key ( final registered <identifiersep> service registered <identifiersep> service ) throws exception { \n \t2 if ( registered <identifiersep> service . get <identifiersep> public <identifiersep> key ( ) == null ) { \n <ect>
\t3 <comment> \n \t3 logger . info ( <string_literal> + <identifier> <identifiersep> list . size ( ) + <string_literal> ) ; \n \t3 for ( load <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> list ) { \n \t4 <identifier> . <identifier> <identifiersep> start ( ) ; } \n <ect>
\t3 config <identifiersep> element . path <identifiersep> <identifier> <identifier> ; \n \t3 try { \n \t4 <identifier> = config <identifiersep> element . parse ( root <identifiersep> <identifier> , key ) ; \n \t3 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t4 log . trace ( <string_literal> , data . on <identifiersep> exception <identifiersep> <identifier> , exchange ) ; } \n \t3 data . on <identifiersep> exception <identifiersep> <identifier> . process ( exchange ) ; \n \t2 } catch ( throwable e ) { \n \t3 <comment> \n <ect>
\t5 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> state <identifiersep> handle ) ; \n \t5 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t6 <identifier> <identifiersep> <identifier> . add ( <identifier> <identifiersep> <identifier> ) ; } \n \t4 } catch ( exception e ) { \n <ect>
\t3 final map < string , list < <identifier> <identifiersep> device <identifiersep> <identifier> > > <identifier> = read <identifiersep> <identifier> <identifiersep> from <identifiersep> resource ( ) ; \n \t3 if ( ! <identifier> . is <identifiersep> empty ( ) ) { \n \t4 final list < <identifier> <identifiersep> device <identifiersep> <identifier> > <identifier> = <identifier> . get ( map <identifiersep> key <identifiersep> <identifier> ) ; \n \t4 final local <identifiersep> date <identifier> <identifiersep> date = local <identifiersep> date . <identifier> ( ) . <identifier> ( this . <identifier> <identifiersep> time , date <identifiersep> time <identifiersep> utils . to <identifiersep> <identifier> <identifiersep> unit ( this . <identifier> <identifiersep> time <identifiersep> unit ) ) ; \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> <identifiersep> to <identifiersep> string ( response ) ) ; \n \t2 <comment> \n \t2 try { \n \t3 if ( response . get <identifiersep> <identifier> <identifiersep> body ( ) . get <identifiersep> <identifier> ( ) != null ) { \n <ect>
\t3 if ( <identifier> != <identifier> . <identifier> ) \n \t3 { \n \t4 <identifier> <identifiersep> api . instance ( ) . <identifier> ( ) . <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t4 return ; } } \n <ect>
public delete <identifiersep> storage <identifiersep> volume <identifiersep> response <identifiersep> type delete <identifiersep> storage <identifiersep> volume ( delete <identifiersep> storage <identifiersep> volume <identifiersep> type request ) throws <identifier> <identifiersep> <identifier> <identifiersep> exception { \n \t1 final long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t1 delete <identifiersep> storage <identifiersep> volume <identifiersep> response <identifiersep> type <identifier> = ( delete <identifiersep> storage <identifiersep> volume <identifiersep> response <identifiersep> type ) request . get <identifiersep> <identifier> ( ) ; \n \t1 if ( ! storage <identifiersep> properties . <identifier> <identifiersep> storage ) { \n <ect>
\t1 @ <identifier> \n \t1 public void start <identifiersep> <identifier> <identifiersep> server ( ) throws exception { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> server = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> <identifiersep> server = server <identifiersep> builder . for <identifiersep> port ( <identifier> <identifiersep> test <identifiersep> port ) . add <identifiersep> service ( <identifier> <identifiersep> <identifier> <identifiersep> server ) . build ( ) . start ( ) ; \n <ect>
\t3 byte [ ] value = ( <string_literal> + thread . current <identifiersep> thread ( ) . get <identifiersep> name ( ) + <identifier> ) . get <identifiersep> bytes ( ) ; \n \t3 cache . put ( key , value ) ; } \n \t3 return null ; \n \t2 } finally { \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifiersep> principal <identifiersep> dao . <identifier> ( <identifier> ) ; } } } } } \n \t2 } else if ( check <identifiersep> <identifier> . equals <identifiersep> ignore <identifiersep> case ( <identifier> <identifiersep> command ) ) { \n \t2 list <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> out <identifier> <identifiersep> out = <identifier> . from <identifiersep> json ( <identifier> . get <identifiersep> <identifier> <identifiersep> out ( ) , list <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> out . class ) ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifier> : <identifier> <identifiersep> out . <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 s <identifiersep> logger . debug ( <string_literal> + vm + <string_literal> + state + <string_literal> ) ; \n \t2 if ( state == state . <identifier> ) { \n \t3 <identifier> <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> == <identifier> . <identifier> && ! <identifier> ) { \n <ect>
\t3 { \n \t4 <identifier> <identifiersep> <identifier> = ( <identifier> ) e ; \n \t4 if ( ! <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . equals ( <identifier> . get <identifiersep> <identifier> ( ) ) ) \n \t4 { \n <ect>
\t4 message <identifiersep> consumer consumer = session . create <identifiersep> consumer ( destination ) ; \n \t4 text <identifiersep> message msg = ( text <identifiersep> message ) consumer . <identifier> ( <number_literal> ) ; \n \t4 if ( msg != null ) { \n \t5 if ( msg != null && <identifier> . put ( msg . get <identifiersep> text ( ) , boolean . true ) != null ) { \n <ect>
\t5 has <identifiersep> error = true ; \n \t5 if ( ! <identifier> <identifiersep> nodes . contains ( node . get <identifiersep> id ( ) ) ) \n \t6 <identifier> <identifiersep> nodes . add ( node . get <identifiersep> id ( ) ) ; } } } \n \t2 if ( <identifier> == null ) { \n <ect>
\t3 assert log != null ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n \t3 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t5 <string_literal> + path , e ) ; \n \t3 context . get <identifiersep> <identifier> <identifiersep> context ( ) . index <identifiersep> update <identifiersep> failed ( <identifier> ) ; \n \t3 throw <identifier> ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n <ect>
\t6 + <identifier> <identifiersep> utils . get <identifiersep> local <identifiersep> host ( ) + <string_literal> + version . get <identifiersep> version ( ) \n \t6 + <string_literal> + get <identifiersep> timeout ( ) + <string_literal> ) ; \n \t3 } else { \n <ect>
\t2 try { \n \t3 logger . debug ( <string_literal> , this . <identifier> <identifiersep> <identifier> ) ; \n \t3 final object result = get <identifiersep> <identifier> <identifiersep> attribute <identifiersep> value ( principal , <identifier> ) ; \n \t3 if ( result != null ) { \n <ect>
\t5 cache <identifiersep> item = <identifier> [ index ] ; } \n \t4 if ( ! <identifier> || ! cache <identifiersep> item ) { \n \t5 <comment> \n \t5 return false ; } \n <ect>
\t5 <identifier> <identifiersep> <identifier> <identifier> = new <identifier> <identifiersep> <identifier> ( timeout ) ; \n \t5 map < string , string > options = new <identifier> <identifiersep> map < string , string > ( ) ; \n \t5 <identifier> . <identifier> ( source <identifiersep> file , <identifier> <identifiersep> file , options ) ; } \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 final <identifier> <identifiersep> directory <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = new default <identifiersep> <identifier> <identifiersep> directory <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . for <identifiersep> <identifier> ( c - > c . <identifier> <identifiersep> attribute <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t2 list . add <identifiersep> all ( <identifier> . get <identifiersep> attribute <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> ( list ) ; \n <ect>
\t1 <identifier> < string > <identifier> = db <identifiersep> client . <identifier> <identifiersep> properties <identifiersep> dao ( ) . <identifier> <identifiersep> by <identifiersep> key ( db <identifiersep> session , server <identifiersep> id <identifiersep> <identifier> ) ; \n \t1 if ( <identifier> . is <identifiersep> <identifier> ( ) ) { \n \t1 string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> value ( ) ) ; \n \t1 if ( ! <identifier> <identifiersep> <identifier> . equals ( <identifier> . get ( ) ) ) { \n <ect>
\t4 <comment> \n \t4 log . info ( <string_literal> + <identifier> <identifiersep> stream <identifiersep> name + <string_literal> ) ; \n \t4 put <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> stream ( ) ; \n \t4 <comment> \n <ect>
\t3 throws configuration <identifiersep> exception { \n \t2 if ( ! <identifier> <identifiersep> output <identifiersep> format ) { \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( \n \t5 <string_literal> ) ; } \n <ect>
\t1 private final <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t1 @ <identifier> . <identifier> \n \t1 public static collection < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> [ ] > get <identifiersep> test <identifiersep> <identifier> ( ) { \n \t2 string <identifier> <identifiersep> name = system . get <identifiersep> property ( <string_literal> ) ; \n <ect>
\t5 try { \n \t6 <identifier> . set <identifiersep> query <identifiersep> timeout ( get <identifiersep> query <identifiersep> timeout ( ) ) ; \n \t5 } catch ( sql <identifiersep> <identifier> <identifiersep> not <identifiersep> <identifier> <identifiersep> exception e ) { \n \t6 <comment> \n <ect>
\t4 <identifier> . set <identifiersep> <identifier> <identifiersep> name ( <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t4 return <identifier> ; } \n \t3 throw new <identifier> <identifiersep> exception ( server <identifiersep> error . <identifier> <identifiersep> error , <string_literal> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 logger . warn ( <string_literal> + ++ i ) ; \n \t1 logger . error ( <string_literal> + ++ i ) ; \n \t1 logger . <identifier> ( <string_literal> + ++ i ) ; \n \t1 exception e = new exception ( <string_literal> ) ; \n <ect>
\t3 char [ ] <identifier> = <identifier> . to <identifiersep> char <identifiersep> array ( ) ; \n \t3 if ( key <identifiersep> store <identifiersep> url . <identifier> ( ) . length ( ) > 0 ) { \n \t4 file <identifier> = new file ( key <identifiersep> store <identifiersep> url ) ; \n \t4 if ( <identifier> . exists ( ) ) { \n <ect>
\t1 log . warn ( message ) ; \n \t1 throw new stack <identifiersep> <identifier> <identifiersep> exception ( message ) ; } \n \t1 string <identifier> <identifiersep> config <identifiersep> json = ( string ) response . get <identifiersep> entity ( ) ; \n <ect>
\t6 } catch ( interrupted <identifiersep> exception e ) { } \n \t6 logger . info ( <string_literal> ) ; \n \t6 <identifier> <identifiersep> context . <identifier> <identifiersep> <identifier> <identifiersep> lock ( <string_literal> ) ; \n \t5 } else { \n <ect>
\t2 list < stream <identifiersep> <identifier> > <identifier> = <identifier> . get <identifiersep> <identifier> ( ) ; \n \t2 log . debug ( <string_literal> + <identifier> <identifiersep> id <identifiersep> to <identifiersep> remove ) ; \n \t2 for ( stream <identifiersep> <identifier> <identifier> : <identifier> ) \n \t2 { \n <ect>
\t7 start <identifiersep> <identifier> . remove ( node <identifiersep> id ) ; } \n \t5 catch ( grid <identifiersep> exception e ) { \n \t6 if ( e . has <identifiersep> <identifier> ( grid <identifiersep> <identifier> <identifiersep> exception . class ) ) { \n <ect>
\t2 try { \n \t2 lock = lock ( lock <identifiersep> object . get <identifiersep> <identifier> ( ) , lock <identifiersep> object . get <identifiersep> mode ( ) , <identifier> <identifiersep> <identifier> , true ) ; \n \t2 } catch ( lock <identifiersep> exception e ) { \n \t2 <identifier> . <identifier> <identifiersep> error ( <string_literal> ) ; \n <ect>
\t2 } , <identifier> <identifiersep> dir . get <identifiersep> <identifier> <identifiersep> path ( ) , <identifier> <identifiersep> result , <identifier> <identifiersep> result ) ; \n \t2 boolean success = ( result == 0 ) ; \n \t2 if ( success ) { \n \t3 <identifier> <identifiersep> result . <identifier> ( <string_literal> , <identifier> <identifiersep> path <identifiersep> in <identifiersep> <identifier> ) ; \n <ect>
\t2 class <identifiersep> <identifier> context <identifiersep> class <identifiersep> <identifier> = thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( ) ; \n \t2 try { \n \t3 start <identifiersep> time = new date ( ) ; \n \t3 thread . current <identifiersep> thread ( ) . set <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 add <identifiersep> <identifier> <identifiersep> <identifier> ( data , message <identifiersep> key <identifiersep> <identifier> <identifiersep> key , <identifier> <identifiersep> key ) ; \n \t3 if ( ! string <identifiersep> utils . is <identifiersep> empty ( event ) ) { \n \t4 add <identifiersep> <identifier> <identifiersep> <identifier> ( data , message <identifiersep> key <identifiersep> event , event ) ; \n \t3 } else { \n <ect>
\t7 if ( <identifier> < job <identifiersep> count ) { \n \t8 try { \n \t9 <identifier> . send ( new session <identifiersep> <identifier> <identifiersep> test <identifiersep> job ( <identifier> ) ) ; } \n \t8 catch ( grid <identifiersep> exception e ) { \n <ect>
\t2 <identifier> = test <identifiersep> next ( <identifier> , <identifier> [ <number_literal> ] ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> wait <identifiersep> for <identifiersep> put <identifiersep> <identifier> ( ) throws throwable { \t1 \n <ect>
\t5 <identifier> <identifiersep> log . info ( get <identifiersep> job <identifiersep> id ( ) + <string_literal> ) ; \n \t4 <identifier> ( ) ; \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t3 if ( <identifier> != null && ! <identifier> . is <identifiersep> <identifier> ( channel ) ) \n \t3 { \n \t4 throwable <identifier> = <identifier> . close ( null ) ; \n \t4 if ( <identifier> != null ) \n <ect>
\t8 if ( ++ <identifier> < = <number_literal> ) { \n \t9 log . info ( <string_literal> ) ; \n \t9 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } } \n \t7 exchange . get <identifiersep> in ( ) . set <identifiersep> body ( <string_literal> + body ) ; \n <ect>
\t5 total <identifiersep> <identifier> ++ ; \n \t5 total <identifiersep> bytes += request . byte <identifiersep> count ( ) ; } } \n \t3 catch ( throwable e ) \n \t3 { \n <ect>
\t6 } ) ; \n \t6 <identifier> <identifiersep> <identifier> . add ( task ) ; \n \t6 <identifier> <identifiersep> <identifier> . execute ( task ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t2 node <identifiersep> metadata node = null ; \n \t2 logger . debug ( <string_literal> , template . get <identifiersep> location ( ) . get <identifiersep> id ( ) , \n \t4 name , template . get <identifiersep> <identifier> ( ) . get <identifiersep> provider <identifiersep> id ( ) , template . get <identifiersep> <identifier> ( ) . get <identifiersep> provider <identifiersep> id ( ) ) ; \n \t2 node = add <identifiersep> node <identifiersep> with <identifiersep> group <identifiersep> <identifier> . create <identifiersep> node <identifiersep> with <identifiersep> group <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name ( group , name , template ) ; \n <ect>
\t2 } catch ( io <identifiersep> exception io <identifiersep> exception ) { \n \t3 logger . error ( <string_literal> , io <identifiersep> exception ) ; \n \t3 <identifier> = false ; \n \t2 } catch ( exception exception ) { \n <ect>
\t4 <comment> \n \t4 logger . debug ( <string_literal> , data <identifiersep> to <identifiersep> send ) ; \n \t4 byte [ ] <identifier> <identifiersep> data = <identifier> <identifiersep> message ( data <identifiersep> to <identifiersep> send ) ; \n \t4 if ( <identifier> <identifiersep> data == null ) { \n <ect>
\t3 if ( ! thread <identifiersep> pool . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t4 logger . warn ( <string_literal> ) ; \n \t3 } else { \n \t4 logger . info ( <string_literal> ) ; } } \n <ect>
\t3 if ( task != null ) { \n \t4 try { \n \t5 task . <identifier> ( conn ) ; \n \t4 } catch ( exception <identifier> ) { \n <ect>
\t7 ( ( attribute ) <identifier> ) . set <identifiersep> value ( <identifier> <identifiersep> string ( value ) ) ; \n \t6 } else if ( <identifier> instanceof text ) { \n \t7 ( ( text ) <identifier> ) . set <identifiersep> text ( <identifier> <identifiersep> string ( value ) ) ; \n \t6 } else { \n <ect>
\t3 log . warn ( <string_literal> , ex ) ; \n \t3 throw new <identifier> <identifiersep> job <identifiersep> exception ( error <identifiersep> code . <identifier> , ex . get <identifiersep> message ( ) , ex ) ; } \n \t2 catch ( io <identifiersep> exception ex ) { \n \t3 <comment> \n <ect>
\t1 public void <identifier> <identifiersep> test ( ) { \n \t2 for ( logger logger <identifiersep> to <identifiersep> <identifier> : this . <identifier> <identifiersep> to <identifiersep> <identifier> ) { \n \t3 this . <identifier> <identifiersep> <identifier> . add ( logger <identifiersep> to <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> level ( ) ) ; \n \t3 logger <identifiersep> to <identifiersep> <identifier> . set <identifiersep> level ( level . trace ) ; } \n <ect>
\t4 if ( <identifier> != null ) { \n \t5 logger . debug ( <string_literal> , <identifier> ) ; \n \t5 list . add ( <identifier> ) ; \n \t4 } else { \n <ect>
\t3 <identifier> the uri from <identifier> <identifier> network . <identifier> . <identifier> . <identifier> . uri . \n \t3 it <identifier> a <identifier> <identifier> <identifier> \n \t2 <string_literal> <string_literal> <identifier> test <identifiersep> <number_literal> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> all <identifiersep> <identifier> <string_literal> <ect>
\t5 log . info ( <string_literal> + key ) ; } \n \t3 else { \n \t4 log . error ( <string_literal> + key ) ; \n <ect>
\t5 map = new <identifier> <identifiersep> <identifier> <identifiersep> map < > ( ) ; } \n \t4 map . put ( key , entry . get <identifiersep> value ( ) ) ; \n \t4 <identifier> . put ( name , map ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <identifier> . end ( ) ; } } \n private void <identifier> <identifiersep> <identifier> <identifiersep> method <identifiersep> with <identifiersep> failure ( ) { \n <ect>
\t2 command . add ( <string_literal> ) ; \n \t2 command . add ( <string_literal> ) ; \n \t2 string result = command . execute ( ) ; \n \t2 if ( result != null ) { \n <ect>
\t5 <identifier> item = ( <identifier> ) <identifier> <identifiersep> <identifier> ; \n \t5 try { \n \t6 item . <identifier> <identifiersep> data ( ) ; \n \t5 } catch ( exception ex ) { \n <ect>
\t2 } catch ( final operation <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 return null ; \n \t2 } catch ( final exception e ) { \n <ect>
private final <identifier> <identifiersep> list < <identifier> <identifiersep> <identifier> <identifiersep> <identifier> > <identifier> ; \n private <identifier> <identifiersep> listener <identifier> <identifiersep> listener ; \n private <identifier> <identifiersep> <identifier> <identifiersep> debug <identifiersep> <identifier> <identifier> <identifiersep> debug <identifiersep> <identifier> ; \n public <identifier> <identifiersep> level <identifiersep> <identifier> <identifiersep> cache <identifiersep> policy ( ) { \n <ect>
\t6 set <identifiersep> header ( cache <identifiersep> <identifier> . cache <identifiersep> key , <identifier> ( <string_literal> ) ) . \n \t6 to ( <string_literal> ) ; } \n \t2 } ) ; \n \t2 context . start ( ) ; \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> file = <identifier> . node <identifiersep> query ( abstract <identifiersep> file . class ) . and ( <identifier> <identifiersep> <identifier> . key ( abstract <identifiersep> file . class , <string_literal> ) , file <identifiersep> path ) . get <identifiersep> first ( ) ; \n \t4 <identifier> . success ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t3 try { \n \t4 <identifier> . send <identifiersep> transaction ( new <identifier> <identifiersep> <identifier> <identifiersep> transaction ( <identifier> <identifiersep> code ) ) ; <comment> \n <number_literal> <comment> \n \t3 } catch ( exception ex ) { \n <ect>
\t3 check <identifiersep> index ( result , <identifier> ) ; } \n \t2 if ( result . <identifier> ) { \n \t3 log . info ( <string_literal> , index <identifiersep> path , <identifier> ) ; \n \t2 } else { \n <ect>
\t1 read <identifiersep> lock . lock ( ) ; \n \t1 try { \n \t1 for ( i <identifiersep> <identifier> <identifiersep> object <identifiersep> factory <identifier> : <identifier> ) { \n \t2 if ( <identifier> . object <identifiersep> <identifier> ( <identifier> ) ) { \n <ect>
\t2 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> enabled ( ) ) { \n \t3 logger . trace ( message ) ; \n \t3 return result ; } \n \t2 if ( result == null ) { \n <ect>
\t3 <comment> \n \t3 if ( ! map . contains <identifiersep> key ( <identifier> ) ) { \n \t4 map . put ( <identifier> , new <identifier> <identifiersep> set < string > ( ) ) ; } \n \t3 map . get ( <identifier> ) . add ( <identifier> . item ( i ) . get <identifiersep> node <identifiersep> value ( ) ) ; } \n <ect>
\t3 <identifier> . <identifier> ( 1 ) \n \t1 logger . debug ( <string_literal> . format ( <identifier> <identifiersep> file ) ) \n \t1 config = read <identifiersep> config ( logger , <identifier> . config ) \n \t1 if config is <identifier> : \n <ect>
\t3 if ( test <identifiersep> handler . <identifier> . is <identifiersep> empty ( ) ) { \n \t4 logger . debug ( <string_literal> ) ; \n \t3 } else { \n \t4 for ( throwable t : test <identifiersep> handler . <identifier> ) { \n <ect>
\t1 string <identifier> <identifiersep> name ) throws sql <identifiersep> exception { \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> action . <identifier> <identifiersep> <identifier> <identifiersep> server <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> principal , <identifier> <identifiersep> <identifier> <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) , <identifier> <identifiersep> <identifier> <identifiersep> file <identifiersep> path , \n \t4 <identifier> <identifiersep> name , <identifier> <identifiersep> access , group <identifiersep> name , group <identifiersep> access , null ) ; \n \t4 log . debug ( <string_literal> , principal , <identifier> <identifiersep> <identifier> <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n \t3 } else { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t3 <identifier> <identifiersep> context . set <identifiersep> application <identifiersep> name ( <identifier> <identifiersep> client <identifiersep> context . <identifier> <identifiersep> name ) ; } \n \t2 if ( <identifier> <identifiersep> client <identifiersep> context . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> >= 0 ) { \n \t3 <identifier> <identifiersep> context . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> client <identifiersep> context . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; } \n \t2 map < string , local <identifiersep> resource > local <identifiersep> <identifier> = new <identifier> <identifiersep> map < string , local <identifiersep> resource > ( ) ; \n <ect>
\t8 . put ( <string_literal> , <identifier> <identifiersep> location ) \n \t8 . put ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> of <identifiersep> length ( <number_literal> ) ) \n \t8 . put ( <string_literal> , 0 . <number_literal> ) ) ) ; \n \t2 <comment> \n <ect>
\t4 if ( result != 0 ) { \n \t5 logger . warn ( <string_literal> , <identifier> . error <identifiersep> text ( result ) ) ; \n \t5 <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t3 } else { \n <ect>
\t2 if ( <identifier> != null ) { \n \t2 if ( <identifier> . <identifier> ( ) ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t4 log . error ( <string_literal> + thread <identifiersep> local ) ; \n \t4 thread <identifiersep> <identifier> . put ( thread <identifiersep> local , value ) ; \n \t4 <comment> \n \t3 } else { \n <ect>
\t5 string class <identifiersep> type = string <identifiersep> utils . remove <identifiersep> end ( string <identifiersep> utils . <identifier> <identifiersep> <identifier> <identifiersep> last ( type , <string_literal> ) , <string_literal> ) ; \n \t5 if ( <identifier> <identifiersep> manager . has <identifiersep> <identifier> ( property <identifiersep> class <identifiersep> provider . class , class <identifiersep> type ) ) { \n \t6 provider = <identifier> <identifiersep> manager . get <identifiersep> instance ( property <identifiersep> class <identifiersep> provider . class , class <identifiersep> type ) ; \n \t5 } else { \n <ect>
\t3 if ( <identifier> . get <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) || ! <identifier> . get <identifiersep> <identifier> ( ) . get ( 0 ) . equals ( <identifier> ) ) { \n \t4 logger . error ( <string_literal> ) ; \n \t4 return null ; } \n \t3 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> <identifier> ( ) ) ) { \n <ect>
\t1 public class <identifier> <identifiersep> <identifier> <identifiersep> listener extends <identifier> <identifiersep> listener <identifiersep> <identifier> { \n \t2 @ <identifier> \n \t2 public void interface <identifiersep> <identifier> ( interface <identifier> ) { \n \t3 if ( <identifier> <identifiersep> operation != null && <identifier> <identifiersep> operation . get <identifiersep> interface ( ) . equals ( <identifier> ) ) { \n <ect>
\t4 <identifier> . request <identifiersep> <identifier> ( config ) ; \n \t4 try { \n \t5 thread . <identifier> ( request <identifiersep> <identifier> ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t7 command . add ( <string_literal> , snapshot <identifiersep> <identifier> . get <identifiersep> path ( ) ) ; \n \t7 command . add ( <string_literal> , snapshot <identifiersep> name ) ; \n \t7 final string result = command . execute ( ) ; \n \t7 if ( result != null ) { \n <ect>
\t1 protected event do <identifiersep> execute ( final request <identifiersep> context request <identifiersep> context ) { \n \t2 final http <identifiersep> <identifier> <identifiersep> request request = web <identifiersep> utils . get <identifiersep> http <identifiersep> <identifier> <identifiersep> request <identifiersep> from <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( request <identifiersep> context ) ; \n \t2 final string <identifier> <identifiersep> <identifier> <identifiersep> response = request . get <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> <identifiersep> <identifier> <identifiersep> response ) ) { \n <ect>
\t1 try { \n \t1 if ( connection != null ) { \n \t2 connection . close ( ) ; } \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> ex ) { \n <ect>
\t1 void delete ( <identifier> <identifiersep> <identifier> <identifier> ) \n \t1 { \n \t2 file <identifier> <identifiersep> file = new file ( <identifier> <identifiersep> directory , <identifier> . file <identifiersep> name ( ) ) ; \n \t2 if ( <identifier> <identifiersep> file . delete ( ) ) \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> process <identifiersep> template <identifiersep> <identifier> ( list < template <identifiersep> <identifier> > template <identifiersep> <identifier> ) { \n \t2 template <identifiersep> <identifier> . add ( new class <identifiersep> template <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class , <string_literal> ) ) ; \n <ect>
\t4 } else { \n \t5 assert <identifiersep> equals ( throwable . class , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) [ <number_literal> ] ) ; } } } \n \t2 assert <identifiersep> equals ( <number_literal> , <identifier> <identifiersep> message . class . get <identifiersep> <identifier> ( ) . length ) ; } \n \t1 public void check <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) { \n <ect>
\t2 if ( string <identifiersep> utils . has <identifiersep> text ( <identifier> ) && string <identifiersep> utils . has <identifiersep> text ( password ) && <identifier> . equals ( password ) ) { \n \t3 logger . debug ( <string_literal> , <identifier> ) ; \n \t3 return new default <identifiersep> authentication <identifiersep> handler <identifiersep> execution <identifiersep> result ( this , new <identifier> <identifiersep> <identifier> <identifiersep> meta <identifiersep> data ( <identifier> ) , \n \t5 this . principal <identifiersep> factory . create <identifiersep> principal ( <identifier> ) ) ; } \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> test , <identifier> <identifiersep> <identifier> , <identifier> , <identifier> <identifiersep> index ) ; \n \t2 <comment> \n \t2 <identifier> <identifier> <identifiersep> <identifier> = null ; \n \t2 for ( <identifier> <identifier> : <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> level <identifiersep> filter . process ( data , <identifier> , length , <identifier> , <identifier> ) ; \n \t4 end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; \n \t4 if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { \n \t5 if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { \n <ect>
\t5 int <identifier> <identifiersep> for = <identifier> <identifiersep> level . <identifier> <identifiersep> for ( <identifier> ) ; \n \t5 if ( <identifier> . is <identifiersep> <identifier> ( ) ) \n \t6 <identifier> . trace ( <string_literal> , <identifier> <identifiersep> for ) ; \n \t5 else \n <ect>
\t4 <identifier> <identifiersep> security <identifiersep> policy <identifiersep> name = policy <identifiersep> <identifier> . get <identifiersep> policy <identifiersep> name ( ) ; } \n \t3 } catch ( final exception ex ) { \n \t3 ; } \n \t2 } else { \n <ect>
\t5 thread . <identifier> ( <number_literal> ) ; \n \t4 } catch ( interrupted <identifiersep> exception e ) { } } \n \t3 logger . debug ( <string_literal> , path , <identifier> ) ; \n \t3 <identifier> = <identifier> ; } \n <ect>
\t2 { \n \t3 return get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> state ( a <identifiersep> <identifier> . get <identifiersep> key ( ) ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t4 <comment> \n \t4 continue ; } \n \t3 <comment> \n \t3 group group <identifiersep> <identifier> = group <identifiersep> service . find <identifiersep> by <identifiersep> name ( context , name ) ; \n <ect>
\t1 @ <identifier> private data <identifiersep> <identifier> <identifiersep> dao <identifier> <identifiersep> <identifier> <identifiersep> dao ; \n \t1 @ <identifier> private <identifier> <identifiersep> storage <identifiersep> vm <identifiersep> dao <identifier> <identifiersep> <identifier> <identifiersep> dao ; \n \t1 public void on <identifiersep> <identifier> <identifiersep> <identifier> ( object <identifier> , <identifier> <identifiersep> storage <identifiersep> vm <identifiersep> <identifier> <identifiersep> event <identifiersep> <identifier> <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> logger . trace ( <string_literal> ) ; \n \t3 <identifier> <identifiersep> process . <identifier> <identifiersep> value ( ) ; \n \t3 <identifier> <identifiersep> logger . trace ( <string_literal> ) ; \n \t2 } catch ( illegal <identifiersep> thread <identifiersep> state <identifiersep> exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> nodes <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> nodes , remote <identifiersep> store <identifiersep> <identifier> ) ; \n \t4 found <identifiersep> store = true ; \n \t4 break ; } } \n \t2 if ( ! found <identifiersep> store ) { \n <ect>
\t1 public <identifier> execute ( final principal <identifiersep> action <identifiersep> context in <identifiersep> action <identifiersep> context ) throws execution <identifiersep> exception \n \t1 { \n \t2 <identifier> <identifiersep> resource <identifiersep> request request = ( <identifier> <identifiersep> resource <identifiersep> request ) in <identifiersep> action <identifiersep> context . get <identifiersep> <identifier> ( ) ; \n \t2 long current <identifiersep> user <identifiersep> <identifier> <identifiersep> id = in <identifiersep> action <identifiersep> context . get <identifiersep> principal ( ) . get <identifiersep> id ( ) ; \n <ect>
\t1 default : \n \t1 throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; } } \n @ <identifier> \n public void <identifier> <identifiersep> <identifier> ( ) { \n <ect>
\t3 <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; \n \t3 <identifier> . set <identifiersep> password ( password ) ; \n \t3 <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> session <identifiersep> id <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
<comment> \n \t1 protected void <identifier> <identifiersep> size <identifiersep> <identifier> <identifiersep> <identifier> ( final size <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t2 <identifier> . add ( new <identifier> <identifiersep> message ( <string_literal> , <string_literal> , e . get <identifiersep> <identifier> <identifiersep> size ( ) , e . get <identifiersep> <identifier> <identifiersep> size ( ) ) ) ; \n <ect>
\t6 get <identifiersep> security <identifiersep> manager ( ) . get <identifiersep> security <identifiersep> config ( ) . get <identifiersep> filter <identifiersep> <identifier> ( ) . get <identifiersep> request <identifiersep> <identifier> <identifiersep> by <identifiersep> name ( <string_literal> ) ; \n \t4 log <identifiersep> out <identifiersep> <identifier> . do <identifiersep> <identifier> ( get <identifiersep> security <identifiersep> manager ( ) , http <identifiersep> <identifier> , http <identifiersep> <identifier> , get <identifiersep> name ( ) ) ; \n \t4 handler . process ( http <identifiersep> <identifier> , http <identifiersep> <identifier> ) ; \n \t3 } else \n <ect>
\t4 property <identifiersep> list <identifiersep> object = <identifier> <identifiersep> object ; } \n \t3 return property <identifiersep> list <identifiersep> object ; } \n \t2 public <identifier> property <identifiersep> list <identifiersep> <identifier> <identifiersep> with <identifiersep> url ( url url ) { \n \t3 if ( url == null ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> ) { \n \t4 log . warn ( <string_literal> , new object [ ] { transaction <identifiersep> key , <identifier> , <identifier> } ) ; \n \t3 } else { \n <ect>
\t2 for ( final <identifier> <identifier> : <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 final class < ? extends <identifier> > type = <identifier> . <identifier> <identifiersep> type ( ) ; \n \t3 <identifier> <identifier> = type . get <identifiersep> <identifier> ( <identifier> . class ) ; \n \t3 if ( <identifier> != null ) { \n <ect>
\t1 } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t1 log . info ( <string_literal> , e ) ; \n \t1 return 1 ; \n \t1 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class ) ) ; \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( <identifier> <identifiersep> local <identifiersep> resource . class ) ) ; \n <ect>
\t3 if ( key != null ) { \n \t4 final socket <identifiersep> channel <identifier> = ( socket <identifiersep> channel ) key . channel ( ) ; \n \t4 if ( <identifier> != null ) { \n \t5 socket = <identifier> . socket ( ) ; } } \n <ect>
\t4 if ( is <identifiersep> transaction <identifiersep> <identifier> ( <identifier> <identifiersep> transaction , <identifier> , transaction <identifiersep> timeout <identifiersep> millis ) ) \n \t4 { \n \t5 if ( <identifier> <identifiersep> transaction . <identifier> <identifiersep> for <identifiersep> <identifier> ( status . transaction . transaction <identifiersep> <identifier> <identifiersep> out ) ) \n \t5 { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> + network <identifiersep> <identifier> <identifiersep> id + <string_literal> + vm <identifiersep> id + <string_literal> + \n \t6 event . get <identifiersep> account <identifiersep> id ( ) + <string_literal> ) ; } \n \t3 for ( <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> vo no <identifiersep> vo : no <identifiersep> v <identifiersep> <identifier> ) { \n <ect>
\t5 break ; } \n \t3 } catch ( xml <identifiersep> <identifier> <identifiersep> exception e ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t1 if ( <identifier> == null ) \n \t1 try { \n \t2 <identifier> = this . context . get <identifiersep> <identifier> ( ) . table <identifiersep> <identifier> ( ) ; \n \t1 } catch ( <identifier> <identifiersep> exception | <identifier> <identifiersep> security <identifiersep> exception e ) { \n <ect>
\t1 log . info ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t1 object <identifiersep> name o <identifiersep> name = new object <identifiersep> name ( <identifier> <identifiersep> name ) ; \n \t1 <comment> \n \t1 if ( <identifier> . is <identifiersep> registered ( o <identifiersep> name ) ) { \n <ect>
\t3 + <string_literal> + default <identifiersep> timeout + <string_literal> ) ; } \n \t1 time <identifiersep> unit . <identifier> . <identifier> ( default <identifiersep> timeout ) ; } \n \t1 file <identifier> <identifiersep> output = <identifier> <identifiersep> output <identifiersep> dir <identifiersep> <identifier> [ 0 ] ; \n \t1 if ( ! files . to <identifiersep> string ( <identifier> <identifiersep> output , <identifier> . <identifier> <identifiersep> <number_literal> ) . equals ( <identifier> <identifiersep> output ) ) { \n <ect>
\t4 task . set <identifiersep> <identifier> <identifiersep> source ( null ) ; \n \t4 task . set <identifiersep> <identifier> <identifiersep> target ( null ) ; } \n \t3 if ( task . get <identifiersep> state ( ) . is <identifiersep> <identifier> <identifiersep> state ( ) ) { \n \t4 remove <identifiersep> from <identifiersep> queue ( task ) ; \n <ect>
\t1 if ( <identifier> != null ) { \n \t1 try { \n \t2 <identifier> . close ( ) ; \n \t1 } catch ( throwable t ) { \n <ect>
\t3 } else if ( <identifier> . get <identifiersep> <identifier> <identifiersep> stream <identifiersep> id ( ) > 0 ) { \n \t4 <identifier> <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t4 <identifier> += <identifier> . read ( bytes ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 log . <identifier> ( log . <identifier> <identifiersep> test , <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t4 assert . <identifier> ( ) ; } } \n <ect>
\t2 output <identifiersep> stream . close ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> connection <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t1 } catch ( io <identifiersep> exception e ) { \n \t2 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> connection <identifiersep> failed <identifiersep> count ( ) ; \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 try { \n \t2 <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> dir ) ; \n \t2 } catch ( io <identifiersep> exception ex ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t3 logger . error ( <string_literal> ) ; \n \t3 return ; } \n \t2 if ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> target . exists ( ) ) { \n <ect>
\t2 <comment> \n \t2 try { \n \t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> . <identifier> + <string_literal> + ip <identifiersep> id ) ; \n \t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> ip ( ip <identifiersep> id , <identifier> <identifiersep> user <identifiersep> id , <identifier> ) ) { \n <ect>
\t2 close <identifiersep> <identifier> . remove <identifiersep> all ( delete <identifiersep> <identifier> ) ; \n \t2 if ( close <identifiersep> <identifier> . size ( ) > 0 ) { \n \t3 for ( string index : close <identifiersep> <identifier> ) { \n \t4 if ( <identifier> <identifiersep> boolean ( ) ) { \n <ect>
\t4 <identifier> . <identifier> ( <string_literal> ) ; } \n \t3 if ( <identifier> <identifiersep> name <identifiersep> map . contains <identifiersep> key ( s [ i ] ) ) { \n \t4 s [ i ] = <identifier> <identifiersep> name <identifiersep> map . get ( s [ i ] ) . to <identifiersep> string ( ) ; \n \t3 } else { \n <ect>
\t1 <comment> \n \t1 shutdown <identifiersep> transport <identifiersep> <identifier> ( <identifier> <identifiersep> transport <identifiersep> <identifier> , service <identifiersep> name ) ; } \n void shutdown <identifiersep> <identifier> ( string service <identifiersep> name ) \n { \n <ect>
\t1 if ( <identifier> <identifiersep> session <identifiersep> path <identifiersep> lock <identifiersep> file != null ) { \n \t2 try { \n \t2 <identifier> <identifiersep> session <identifiersep> path <identifiersep> lock <identifiersep> file . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
public string configuration <identifiersep> name ( ) { \n \t1 return ( string ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . configuration <identifiersep> name <identifiersep> key ) ; } \n public void set <identifiersep> configuration <identifiersep> name ( string value ) { \n <ect>
\t3 try { \n \t4 file <identifiersep> output <identifiersep> stream <identifier> = new file <identifiersep> output <identifiersep> stream ( location ) ; \n \t4 <identifier> <identifiersep> <identifier> . write <identifiersep> xml ( <identifier> , <identifier> ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 self . check <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> cmd , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , int ( format ( <string_literal> ) ) , \n \t5 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> principal , <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> authentication , <identifier> . <identifier> <identifiersep> transport <identifiersep> mode , \n \t5 <identifier> . <identifier> <identifiersep> http <identifiersep> endpoint ) \n \t1 logger . info ( <string_literal> ) \n <ect>
\t3 c . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> and <identifiersep> create <identifiersep> <identifier> ( <identifier> ) ) ; \n \t3 return c ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> <identifiersep> update <identifiersep> factory . <identifier> <identifiersep> <identifier> <identifiersep> status <identifiersep> <identifier> ( <identifier> <identifiersep> id , <identifier> , this ) ; \n <ect>
\t5 <identifier> <identifiersep> log . info ( <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> + ( get <identifiersep> context ( ) . <identifier> ( ) . <identifier> ( ) - <identifier> <identifiersep> <identifier> <identifiersep> on ) ) ; \n \t4 get <identifiersep> context ( ) . <identifier> <identifiersep> manager ( ) . db <identifiersep> <identifier> <identifiersep> failed ( <identifier> <identifiersep> <identifier> ) ; \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . error ) ) \n <ect>
\t1 public static void put <identifiersep> config ( string conf <identifiersep> name , <identifier> <identifiersep> <identifier> <identifiersep> client <identifier> <identifiersep> client , file <identifier> , final string <identifier> <identifiersep> name , \n \t8 string <identifier> <identifiersep> name ) throws exception { \n \t2 file file = new file ( <identifier> , <string_literal> + file . <identifier> + <string_literal> + file . <identifier> + <identifier> <identifiersep> name ) ; \n \t2 if ( ! file . exists ( ) ) { \n <ect>
\t3 check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> manager ( <identifier> ) ; } \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = true ; } } \n \t1 if ( type != write <identifiersep> entity . type . table && \n \t2 type != write <identifiersep> entity . type . <identifier> ) { \n <ect>
\t1 @ <identifier> <identifiersep> on <identifiersep> <identifier> <identifiersep> bean ( name = <string_literal> ) \n \t1 @ bean \n \t1 public authentication <identifiersep> event <identifiersep> execution <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> authentication <identifiersep> event <identifiersep> execution <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 return <identifier> - > { \n <ect>
\t2 final <identifier> < void > security <identifiersep> group = client . delete <identifiersep> load <identifiersep> <identifier> <identifiersep> delete <identifiersep> security <identifiersep> group ( account <identifiersep> id , <identifier> , <identifier> <identifiersep> group ) ; } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> catch ( throwable e ) throws throwable { \n \t2 if ( e instanceof <identifier> <identifiersep> exception ) { \n <ect>
\t6 web <identifiersep> socket <identifiersep> data . set <identifiersep> result ( result ) ; } \n \t5 get <identifiersep> web <identifiersep> socket ( ) . send ( web <identifiersep> socket <identifiersep> data , true ) ; \n \t5 return ; \n \t4 } catch ( exception ex ) { \n <ect>
public void delete <identifiersep> file <identifiersep> <identifier> ( string <identifier> ) { \n \t1 try { \n \t1 file file = new file ( <identifier> + <string_literal> ) ; \n \t1 if ( file . delete ( ) ) { \n <ect>
\t2 <comment> \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) == null \n \t4 || <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . to <identifiersep> byte <identifiersep> array ( ) == null \n \t4 || <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . to <identifiersep> byte <identifiersep> array ( ) . length == 0 ) { \n <ect>
\t1 private void load <identifiersep> properties ( ) throws configuration <identifiersep> exception { \n \t2 final file file = properties <identifiersep> <identifier> . find <identifiersep> config <identifiersep> file ( <string_literal> ) ; \n \t2 if ( file == null ) { \n \t3 throw new configuration <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t4 logger . error ( <string_literal> , <identifier> <identifiersep> type ) ; } \n \t3 catch ( exception e ) \n \t3 { \n \t4 logger . error ( <string_literal> ) ; } } \n <ect>
\t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . node ( <string_literal> ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( 1 ) ) ; \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n \t3 logger . warn ( <string_literal> ) ; \n \t2 if ( ! <identifier> <identifiersep> manager . v ( ) . has <identifiersep> <identifier> ( <string_literal> ) ) \n <ect>
\t2 <identifier> . remove <identifiersep> value ( <string_literal> ) ; \n \t2 if ( <identifier> <identifiersep> type == node . <identifier> <identifiersep> message <identifiersep> type <identifiersep> <identifier> ) { \n \t3 handle <identifiersep> <identifier> <identifiersep> node <identifiersep> to <identifiersep> node <identifiersep> text <identifiersep> message <identifiersep> <identifier> <identifiersep> field <identifiersep> set ( <identifier> , source , file <identifiersep> number ) ; \n \t2 } else { \n <ect>
\t2 start <identifiersep> <identifier> ( <identifier> <identifiersep> service ) ; \n \t2 assert <identifiersep> true ( <string_literal> , <identifier> <identifiersep> service . is <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> ( ) ; \n \t2 assert <identifiersep> true ( <string_literal> , contains <identifiersep> destination ( new <identifier> <identifiersep> <identifier> <identifiersep> queue ( <string_literal> ) ) ) ; \n <ect>
\t3 <comment> \n \t3 <identifier> . put ( <string_literal> , <identifier> <identifiersep> test <identifiersep> message ) ; \n \t3 result = request <identifiersep> body <identifiersep> and <identifiersep> <identifier> ( <string_literal> , null , <identifier> ) ; \n \t3 assert <identifiersep> not <identifiersep> null ( <string_literal> , result ) ; \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> host <identifier> <identifiersep> host = get <identifiersep> <identifier> <identifiersep> host ( context ) ; \n \t3 assert ( <identifier> <identifiersep> host instanceof host <identifiersep> <identifier> ) ; \n \t3 if ( ! ( ( host <identifiersep> <identifier> ) <identifier> <identifiersep> host ) . is <identifiersep> <identifier> <identifiersep> host <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> to ( <identifier> <identifiersep> uri ) ; \n \t2 <identifier> <identifiersep> uri = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> service . <identifier> <identifiersep> url ( <identifier> <identifiersep> server <identifiersep> <identifier> . create <identifiersep> uri <identifiersep> builder ( ) ) . build ( <identifier> <identifiersep> <identifier> ) . to <identifiersep> string ( ) ; \n \t2 <identifier> <identifiersep> to ( <identifier> <identifiersep> uri ) ; } \n \t1 private string get <identifiersep> token ( o <identifiersep> <identifier> <identifiersep> client . access <identifiersep> token <identifiersep> response response , client http <identifiersep> client ) throws exception { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> nodes , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , number <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> nodes ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null || \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) == null || \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t2 <comment> \n \t2 if ( properties == null || properties . is <identifiersep> empty ( ) ) { \n \t3 logger . trace ( <string_literal> ) ; \n \t3 return ; } \n <ect>
\t6 <identifier> . end <identifiersep> object ( ) ; \n \t6 <identifier> . end <identifiersep> object ( ) ; \n \t6 <identifier> . <identifier> ( <identifier> . to <identifiersep> string ( ) ) ; \n \t5 } catch ( json <identifiersep> exception e ) { \n <ect>
\t3 byte <identifiersep> <identifier> num <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> = byte <identifiersep> <identifier> . <identifier> ( byte <identifiersep> utils . size <identifiersep> of <identifiersep> short ) ; \n \t3 try { \n \t4 get <identifiersep> current <identifiersep> <identifier> ( ) . read ( num <identifiersep> key <identifiersep> <identifier> <identifiersep> <identifier> , current <identifiersep> <identifier> <identifiersep> in <identifiersep> <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 <identifier> . create ( process <identifiersep> <identifier> . class , job <identifiersep> manager , log , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> code ) , \n \t4 <string_literal> ) ; } \n \t2 catch ( throwable t ) { \n \t3 <comment> \n <ect>
\t2 logger . info ( <string_literal> , output <identifiersep> dir ) ; \n \t2 files . create <identifiersep> <identifier> ( output <identifiersep> dir ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 json <identifiersep> node item <identifiersep> data <identifiersep> info = write <identifiersep> item <identifiersep> file ( source ) ; \n <ect>
<comment> \n @ <identifier> \n public void shutdown ( ) \n { \n <ect>
\t6 if ( ! answer . get <identifiersep> result ( ) ) { \n \t7 s <identifiersep> logger . warn ( <string_literal> + answer . get <identifiersep> <identifier> ( ) ) ; \n \t7 throw new <identifier> <identifiersep> runtime <identifiersep> exception ( <string_literal> + vm + <string_literal> + answer . get <identifiersep> <identifier> ( ) ) ; } } } } } \n <ect>
\t1 <identifier> <identifiersep> request <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> ) ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> ) ; \n \t1 return <identifier> ; \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 <identifier> <identifiersep> cache . put ( key , first <identifiersep> value ) ; \n \t1 assert <identifiersep> is <identifiersep> not <identifiersep> in <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> cache , key ) ; \n \t1 check <identifiersep> <identifier> check <identifiersep> <identifier> = new check <identifiersep> <identifier> ( ) ; \n \t1 wait <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> <identifiersep> lock ( <identifier> <identifiersep> <identifier> <identifiersep> cache , check <identifiersep> <identifier> ) ; \n <ect>
\t2 self . logger . debug ( <string_literal> <identifier> url ) \n \t2 <identifier> = self . send <identifiersep> cmd <identifiersep> to <identifiersep> <identifier> ( url , method = <string_literal> ) \n \t2 # remove <identifier> group \n \t2 url = <string_literal> + self . <identifier> + <string_literal> + <identifier> <identifiersep> group <identifiersep> id \n <ect>
\t5 } catch ( io <identifiersep> exception e ) { \n \t6 if ( exception == null ) { <comment> \n \t7 exception = e ; \n \t6 } else { \n <ect>
\t5 public void on <identifiersep> failure ( throwable e ) { \n \t6 logger . info ( <string_literal> , e ) ; } } \n \t3 ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t6 device <identifiersep> id ) ; \n \t4 continue ; } \n \t3 <identifier> <identifiersep> <identifier> <identifier> = device <identifiersep> config . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t1 public static <identifier> get <identifiersep> instance ( ) { \n \t1 synchronized ( <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> property <identifiersep> <identifier> . class ) { \n \t2 if ( <identifier> == null ) { \n \t2 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> service <identifiersep> property <identifiersep> <identifier> ( ) ; \n <ect>
\t1 account . add <identifiersep> user ( user , <string_literal> , true <comment> , info ) ; } \n private static void update <identifiersep> user ( <identifier> <identifiersep> account account , string user , map < string , string > map ) throws <identifier> <identifiersep> exception { \n \t1 log . debug ( <string_literal> + user + <string_literal> + account . get <identifiersep> name ( ) ) ; \n \t1 if ( map == null ) { \n <ect>
\t4 return ; } \n \t3 logger . debug ( <string_literal> , \n \t5 new object [ ] { item <identifiersep> name , type . to <identifiersep> string ( ) , type . get <identifiersep> class ( ) . to <identifiersep> string ( ) } ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t2 final principal <identifier> <identifiersep> principal = get <identifiersep> <identifier> <identifiersep> principal ( this . <identifier> , principal <identifiersep> attributes ) ; \n \t2 authentication <identifiersep> builder . set <identifiersep> principal ( <identifier> <identifiersep> principal ) ; \n \t2 logger . debug ( <string_literal> , <identifier> <identifiersep> principal ) ; \n \t2 authentication <identifiersep> builder . set <identifiersep> attributes ( authentication <identifiersep> attributes ) ; \n <ect>
\t1 <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> count = 0 ; \n \t1 } else { \n \t1 <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> count ++ ; \n \t1 if ( <identifier> <identifiersep> time <identifiersep> <identifier> <identifiersep> count > <number_literal> && <identifier> < <identifier> . max <identifiersep> <identifier> ( ) * 0 . <number_literal> ) { \n <ect>
\t1 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> class . get <identifiersep> <identifier> <identifiersep> method ( <string_literal> ) . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t2 log . debug ( <string_literal> ) ; } \n \t1 catch ( exception exception ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 <comment> \n <ect>
\t2 element <identifier> <identifiersep> properties = null ; \n \t2 try { \n \t3 <identifier> <identifiersep> properties = xml <identifiersep> utils . parse <identifiersep> xml ( action <identifiersep> xml ) ; } \n \t2 catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 out . close ( ) ; \n \t1 } catch ( java . io . io <identifiersep> exception e ) { \n \t2 <comment> \n \t2 <comment> \n <ect>
\t1 io <identifiersep> exception , uri <identifiersep> <identifier> <identifiersep> exception { \n \t1 http <identifiersep> <identifier> <identifiersep> request = <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> request ( <identifier> <identifiersep> <identifier> , http <identifiersep> <identifier> <identifiersep> request ) ; \n \t1 for ( object key : http <identifiersep> <identifier> <identifiersep> request . get <identifiersep> <identifier> <identifiersep> map ( ) . key <identifiersep> set ( ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> pool . get <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 if ( <identifier> <identifiersep> <identifier> == null ) { \n \t4 return new <identifier> <identifiersep> storage <identifiersep> <identifier> <identifiersep> answer ( <string_literal> + <identifier> <identifiersep> pool . get <identifiersep> <identifier> ( ) ) ; } \n \t3 <comment> \n <ect>
\t7 log . warn ( <string_literal> , e ) ; } \n \t6 <identifier> <identifiersep> cluster <identifiersep> <identifier> ( cluster <identifiersep> client ) ; \n \t6 continue <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( in , read <identifiersep> <identifier> <identifiersep> input ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t3 event <identifiersep> logger event <identifiersep> logger = event <identifiersep> log <identifiersep> manager . get <identifiersep> event <identifiersep> logger ( <identifier> ) ; \n \t3 assert <identifiersep> true ( event <identifiersep> logger . get <identifiersep> class ( ) . get <identifiersep> name ( ) , event <identifiersep> logger instanceof server <identifiersep> event <identifiersep> logger ) ; \n \t3 event <identifiersep> logger . info ( event <identifiersep> log <identifiersep> <identifier> . cluster , <string_literal> ) ; \n \t3 event <identifiersep> logger . info ( event <identifiersep> log <identifiersep> <identifier> . <identifier> , <string_literal> ) ; \n <ect>
\t3 <identifier> = conn . create <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> != null && ! <identifier> . is <identifiersep> empty ( ) ) { \n \t4 map < string , object > <identifier> = new <identifier> <identifiersep> map < string , object > ( <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> . set <identifiersep> properties ( <identifier> , <identifier> ) ; } \n <ect>
\t2 try { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . delete <identifiersep> <identifier> <identifiersep> policy ( <identifier> <identifiersep> name , \n \t3 policy , <identifier> . <identifier> <identifiersep> system <identifiersep> account ( ) ) ; \n \t2 } catch ( final exception ex ) { \n <ect>
\t3 return <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t2 } else if ( <identifier> == <identifier> . <identifier> ) { \n \t3 <identifier> <identifiersep> command <identifiersep> <identifier> <identifiersep> <identifier> . create <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> , network . get <identifiersep> id ( ) ) ; \n \t3 return <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> <identifier> <identifiersep> to <identifiersep> <identifier> ( <identifier> , <identifier> ) ; } \n <ect>
\t3 <comment> \n \t3 try { \n \t4 this . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t5 throw error ; } \n \t4 <comment> \n \t4 assert <identifiersep> cluster <identifiersep> state <identifiersep> <identifier> <identifiersep> node <identifiersep> state ( local <identifiersep> state , <identifier> <identifiersep> cluster <identifiersep> state <identifiersep> service ) ; } } \n \t2 <comment> \n <ect>
\t4 if ( <identifier> <identifiersep> <identifier> ) { \n \t5 try { \n \t6 <identifier> <identifiersep> vm <identifiersep> <identifier> <identifiersep> context ( host <identifiersep> id , vm , event . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t5 } catch ( operation <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 byte [ ] <identifier> <identifiersep> lock <identifiersep> data ; \n \t1 do { \n \t1 <identifier> <identifiersep> lock <identifiersep> data = <identifier> <identifiersep> lock . get <identifiersep> lock <identifiersep> data ( <identifier> , path , null ) ; \n \t1 if ( null != <identifier> <identifiersep> lock <identifiersep> data ) { \n <ect>
protected final set < instance <identifiersep> type > get <identifiersep> by <identifiersep> host <identifiersep> <identifier> ( string host ) { \n \t1 set < instance <identifiersep> type > by <identifiersep> host = node <identifiersep> to <identifiersep> instance <identifiersep> cache . get ( host ) ; \n \t1 by <identifiersep> host = ( by <identifiersep> host == null ) ? <identifier> . new <identifiersep> <identifier> <identifiersep> set ( ) : by <identifiersep> host ; \n <ect>
\t4 <identifier> <identifiersep> put <identifiersep> store . put ( key <identifiersep> byte <identifiersep> array , <identifier> <identifiersep> <identifier> , null ) ; \n \t4 <identifier> ( <string_literal> ) ; \n \t3 } catch ( <identifier> <identifiersep> exception <identifier> ) { \n \t4 <comment> \n <ect>
\t2 if ( host <identifiersep> name . length ( ) > <number_literal> || host <identifiersep> name . length ( ) < 1 ) { \n \t3 s <identifiersep> logger . warn ( <string_literal> ) ; \n \t3 return false ; \n \t2 } else if ( ! host <identifiersep> name . to <identifiersep> <identifier> <identifiersep> case ( ) . <identifier> ( <string_literal> ) ) { \n <ect>
\t2 socket <identifier> = new socket ( host , port ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifier> = null ; \n \t2 try { \n \t3 try { \n <ect>
\t5 table <identifiersep> property . <identifier> . get <identifiersep> <identifier> <identifiersep> message ( ) \n \t6 + <string_literal> \n \t6 + a <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> object ( ) . read <identifiersep> <identifier> ( current <identifiersep> session . get <identifiersep> <identifier> ( ) ) . get <identifiersep> name ( ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 try { \n \t2 if ( null != <identifier> ) { \n \t2 <identifier> . close ( ) ; } \n \t1 } catch ( exception ex ) { \n <ect>
\t3 <identifier> <identifiersep> set . <identifier> <identifiersep> of ( <identifier> . <identifier> ( <identifier> . <identifier> ( string . value <identifiersep> of ( new <identifiersep> value ) ) , <identifier> . <identifier> ( ) ) ) ; \n \t2 logger . info ( <string_literal> + <identifier> <identifiersep> property . get <identifiersep> <identifier> <identifiersep> name ( ) + <string_literal> + value ) ; \n \t2 ( ( <identifier> <identifiersep> <identifier> < set < string > > ) field . get ( null ) ) . set ( value ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> field <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t2 if ( volume . get <identifiersep> state ( ) . equals ( volume . state . <identifier> ) ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + volume . get <identifiersep> id ( ) + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> dao . remove ( volume . get <identifiersep> id ( ) ) ; } \n \t2 if ( volume . get <identifiersep> state ( ) . equals ( volume . state . <identifier> ) ) { \n <ect>
\t2 } else { \n \t2 <comment> \n \t2 log . warn ( <string_literal> , <identifier> . size ( ) ) ; } \n \t1 } else { \n <ect>
\t4 throw new <identifier> <identifiersep> vm ( ) ; } \n \t3 s <identifiersep> logger . debug ( <string_literal> + answer . get <identifiersep> state ( ) . to <identifiersep> string ( ) ) ; \n \t3 return answer . get <identifiersep> state ( ) == <identifier> <identifiersep> state . <identifier> <identifiersep> on ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> <identifier> ( json <identifiersep> object json , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception , json <identifiersep> exception { \n \t2 logger . warn ( <string_literal> ) ; } \n \t1 void on <identifiersep> <identifier> <identifiersep> <identifier> ( json <identifiersep> object json , stream <identifiersep> listener [ ] <identifier> ) throws <identifier> <identifiersep> exception , json <identifiersep> exception { \n <ect>
\t4 if ( target && <identifier> . last <identifiersep> <identifier> <identifiersep> id == = target . id ) { \n \t5 <identifier> id = target . id ; \n \t5 if ( <identifier> . <identifier> <identifiersep> last <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> response ) { \n \t6 <comment> \n <ect>
\t5 event <identifiersep> <identifier> <identifier> ; \n \t5 try { \n \t6 <identifier> = event . from ( conn , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> token , new double ( <number_literal> ) ) ; \n \t5 } catch ( final exception e ) { \n <ect>
\t1 throw new service <identifiersep> <identifier> <identifiersep> exception ( e ) ; } } \n private string <identifier> <identifiersep> <identifier> <identifiersep> table ( <identifier> <identifier> , string <identifier> <identifiersep> name , string <identifier> <identifiersep> table <identifiersep> name ) { \n \t1 try { \n \t1 string <identifier> <identifiersep> path = get <identifiersep> <identifier> <identifiersep> meta <identifiersep> store <identifiersep> location ( <identifier> <identifiersep> name , <identifier> <identifiersep> table <identifiersep> name ) ; \n <ect>
\t2 <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> . get ( ) ; \n \t2 <identifier> . <identifier> ( <identifier> . <identifier> <identifiersep> mode , <identifier> <identifiersep> public <identifiersep> key , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get ( ) ) ; \n \t2 return new string ( <identifier> . <identifier> ( <identifier> . do <identifiersep> final ( data . get <identifiersep> bytes ( ) ) ) ) ; } \n \t1 } catch ( exception e ) { \n <ect>
\t4 <identifier> . get <identifiersep> attributes ( ) . for <identifiersep> <identifier> ( <identifier> : : set <identifiersep> attribute ) ; \n \t4 logger . info ( <string_literal> , <identifier> . get <identifiersep> port ( ) ) ; \n \t3 } ) ; \n \t2 } else { \n <ect>
\t3 if ( response . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> status <identifiersep> code ( ) == http <identifiersep> status . <identifier> <identifiersep> <identifier> ) { \n \t4 method . <identifier> <identifiersep> connection ( ) ; \n \t4 response = <identifier> <identifiersep> client . execute ( method ) ; } \n \t2 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t2 for ( map . entry < string , string > <identifier> : <identifier> . entry <identifiersep> set ( ) ) { \n \t3 if ( <identifier> . get <identifiersep> key ( ) == null || <identifier> . get <identifiersep> value ( ) == null ) { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t3 <identifier> <identifiersep> <identifier> . put ( <identifier> . <identifier> ( <identifier> . get <identifiersep> key ( ) ) , <identifier> . get <identifiersep> value ( ) ) ; } \n <ect>
\t3 try { \n \t4 <identifier> . command <identifiersep> <identifier> ( event ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t4 m <identifiersep> <identifier> . add ( <identifier> ) ; } } } \n \t1 public void remove <identifiersep> listener ( msg <identifiersep> listener <identifier> ) { \n \t2 synchronized ( m <identifiersep> <identifier> ) { \n \t3 if ( m <identifiersep> <identifier> . remove ( <identifier> ) ) { \n <ect>
\t2 check <identifiersep> security ( ) ; \n \t2 if ( <identifier> == null ) \n \t2 { \n \t3 throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t3 channel <identifiersep> state <identifier> = connection <identifiersep> state ( channel . get <identifiersep> connection ( ) ) . channel <identifiersep> state . remove ( channel . get <identifiersep> channel <identifiersep> number ( ) ) ; \n \t3 if ( <identifier> != null ) { \n \t4 <identifier> <identifiersep> channel <identifiersep> count ( channel ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 <identifier> . client = create <identifiersep> client ( ) ; \n \t2 access <identifiersep> token access <identifiersep> token = get <identifiersep> access <identifiersep> token ( ) ; \n \t2 if ( access <identifiersep> token != null ) { \n \t3 <identifier> . client . set <identifiersep> o <identifiersep> <identifier> <identifiersep> access <identifiersep> token ( access <identifiersep> token ) ; \n <ect>
\t5 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n \t6 return ; } } \n \t4 break ; \n \t3 default : \n <ect>
\t3 try ( transaction <identifiersep> resource <identifier> = <identifier> . transaction <identifiersep> for ( snapshot <identifiersep> info . class ) ) { \n \t3 <identifier> . <identifier> ( snapshot <identifiersep> info ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 <identifier> . stop <identifiersep> <identifier> <identifiersep> <identifier> ( name ) ; } \n \t1 @ <identifier> <identifiersep> class \n \t1 public static void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> class ( ) throws exception { \n \t2 try { \n <ect>
\t1 if ( log <identifiersep> file != null ) { \n \t2 try { \n \t2 log <identifiersep> file . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t4 if ( <identifier> . class . is <identifiersep> instance ( <identifier> <identifiersep> object ) ) { \n \t5 log . debug ( <string_literal> + <identifier> <identifiersep> object . get <identifiersep> class ( ) ) ; \n \t5 context . add <identifiersep> <identifier> ( <identifier> , ( <identifier> ) <identifier> <identifiersep> object ) ; \n \t4 } else { \n <ect>
public class <identifier> <identifiersep> factory extends manager <identifiersep> factory { \n public static final log log = \n \t1 log <identifiersep> factory . get <identifiersep> log ( <identifier> <identifiersep> factory . class . get <identifiersep> name ( ) ) ; \n public <identifier> <identifiersep> factory ( ) { \n <ect>
\t4 logger . info ( s ) ; \n \t4 if ( delete ) { \n \t5 get <identifiersep> store ( ) . delete <identifiersep> resource ( s ) ; } } \n \t2 } else { \n <ect>
# # <identifier> \n <identifier> <identifier> <identifiersep> <identifier> ( . . . ) <identifier> is <identifier> in the <identifier> <identifier> - <identifier> <identifier> <identifier> <identifier> <identifier> <identifier> r - <identifier> <identifier> <identifier> <identifier> <identifier> a <identifier> <identifier> for <identifier> <identifier> and <identifier> <identifier> <identifier> . \n \t1 <identifier> <identifier> <identifiersep> <identifier> [ <identifier> : class <identifiersep> <identifier> ] ( a : <identifier> <identifiersep> <identifier> [ <identifier> ] , check <identifiersep> <identifier> <identifiersep> <identifier> : boolean = true ) : ( <identifier> <identifiersep> <identifier> [ <identifier> ] , <identifier> ) = { \t2 \n \t2 if ( <identifier> <identifiersep> a . <identifier> > <number_literal> ) \n <ect>
\t4 continue ; } \n \t3 try { \n \t4 <identifier> . add ( <identifier> . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ) ; \n \t4 if ( log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t6 time <identifiersep> unit . <identifier> , queue , <number_literal> , <number_literal> , <identifier> <identifiersep> <identifier> ( ) , \n \t6 <identifier> <identifiersep> <identifier> , time <identifiersep> value . time <identifiersep> value <identifiersep> millis ( 1 ) , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> thread <identifiersep> factory ( <string_literal> ) , \n \t6 new <identifier> <identifiersep> <identifier> <identifiersep> policy ( ) , context ) ; \n \t2 <identifier> . <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t3 <identifier> <identifiersep> content ( source ) ; \n \t2 } finally { \n \t3 get <identifiersep> source <identifiersep> <identifier> ( ) . close ( ) ; } \n \t2 string [ ] <identifier> = get <identifiersep> <identifier> ( ) ; \n <ect>
\t3 + <string_literal> + <identifier> ) ; \n \t2 continue ; } \n \t1 string <identifier> <identifiersep> method = db <identifiersep> <identifier> <identifiersep> for <identifiersep> type ( java <identifiersep> type ) ; \n \t1 if ( null == <identifier> <identifiersep> method ) { \n <ect>
\t3 if ( <identifier> . next ( ) ) { \n \t4 return long . value <identifiersep> of ( <identifier> . get <identifiersep> long ( 1 ) ) ; } \n \t3 return 0 ; \n \t2 } catch ( exception ex ) { \n <ect>
\t3 <identifier> . get <identifiersep> <identifier> ( ) , \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> manager . type . <identifier> \n \t2 ) ; \n \t2 if ( ticket == null ) { \n <ect>
\t3 } else { \n \t4 log . info ( <string_literal> ) ; \n \t4 <identifier> . wait <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t2 log . <identifier> ( <string_literal> + close <identifiersep> <identifier> <identifiersep> timeout <identifiersep> <identifier> + <string_literal> ) ; } \n \t1 else { \n \t2 log . info ( <string_literal> + <identifier> + <string_literal> ) ; } } \n \t1 else if ( <identifier> != null && ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 return ( token <identifiersep> filter ) <identifier> . new <identifiersep> instance ( <identifier> <identifiersep> values ) ; \n \t3 } catch ( illegal <identifiersep> argument <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception | <identifier> <identifiersep> exception | <identifier> <identifiersep> target <identifiersep> exception | security <identifiersep> exception e ) { \n \t4 log . error ( this , <string_literal> + class <identifiersep> name + <string_literal> + e . get <identifiersep> message ( ) , e ) ; \n \t3 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception ex ) { \n <ect>
\t5 final string value = <identifier> <identifiersep> <identifier> . get ( 1 ) . <identifier> ( ) ; \n \t5 logger . debug ( <string_literal> , name , value ) ; \n \t5 <identifier> . put ( name , value ) ; \n \t4 } else { \n <ect>
\t6 int address = - 1 ; \n \t6 try { \n \t7 address = <identifier> . get <identifiersep> address ( <identifier> <identifiersep> config . get <identifiersep> model ( ) ) ; \n \t6 } catch ( <identifier> <identifiersep> config <identifiersep> parse <identifiersep> exception exception ) { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 return false ; } \n \t2 } catch ( final throwable t ) { \n <ect>
\t3 <identifier> <identifiersep> vm . <identifier> vm = null ; \n \t3 try { \n \t4 vm = <identifier> <identifiersep> vm . get <identifiersep> <identifier> ( <identifier> <identifiersep> conn , vm <identifiersep> name ) ; \n \t3 } catch ( xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 string <identifier> = <string_literal> + <string_literal> + \n \t5 <identifier> . get <identifiersep> <identifier> ( ) . get ( <string_literal> ) + <string_literal> + <identifier> . null ; \n \t2 <identifier> <identifiersep> connection . send <identifiersep> <identifier> ( <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> error = <identifier> <identifiersep> connection . <identifier> ( ) ; \n <ect>
\t3 for ( <identifier> <identifiersep> operation <identifiersep> listener listener : <identifier> ) { \n \t4 try { \n \t5 listener . on <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> context ( context ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t7 <identifier> <identifiersep> <identifier> = <identifier> ; \n \t7 <identifier> <identifiersep> <identifier> = i . next <identifiersep> element ( ) ; \n \t7 break ; } } } \n \t4 if ( <identifier> <identifiersep> <identifier> == null ) { \n <ect>
\t4 <identifier> . <identifier> ( <identifier> . get <identifiersep> message <identifiersep> id ( ) ) ; \n \t3 } finally { \n \t4 <identifier> <identifiersep> lock . write <identifiersep> lock ( ) . <identifier> ( ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> server <identifier> <identifiersep> server = <identifier> <identifiersep> <identifier> <identifiersep> server . get <identifiersep> instance ( conf ) ; \n \t1 <identifier> <identifiersep> task <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> client <identifier> <identifiersep> <identifier> = \n \t2 <identifier> <identifiersep> server . <identifier> <identifiersep> <identifier> . registered <identifiersep> <identifier> . put <identifiersep> if <identifiersep> <identifier> ( request <identifiersep> info . task <identifiersep> <identifier> <identifiersep> id , this ) ; \n \t1 if ( <identifier> <identifiersep> <identifier> != null ) { \n <ect>
\t2 for ( long i = 0 ; i < <identifier> ; i ++ ) \n \t3 logger . debug ( <string_literal> , o ) ; \n \t2 long start = system . <identifier> <identifiersep> time ( ) ; \n \t2 for ( long i = 0 ; i < <identifier> ; i ++ ) \n <ect>
\t7 <identifier> <identifiersep> password = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> password ) \n \t2 logger . info ( <string_literal> . format ( address , server <identifiersep> port ) ) \n \t2 <identifier> <identifiersep> server <identifiersep> <identifier> = true \n \t1 <identifier> : \n <ect>
\t7 case <identifier> : \n \t8 listener . server <identifiersep> <identifier> ( ) ; \n \t8 break ; } \n \t5 } catch ( <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception | class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { \n <ect>
<comment> } \n \t3 if ( next <identifiersep> status == status . <identifier> ) { \n \t4 <comment> \n <ect>
\t3 if ( ! <identifier> . equals ( c ) ) \n \t4 log . warn ( <string_literal> ) ; \n \t2 } ) ; \n <ect>
\t5 state . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t4 } else { \n \t5 state . <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t5 if ( logger . is <identifiersep> <identifier> ( level . info ) ) { \n <ect>
\t4 <identifier> . config <identifiersep> log . info ( <string_literal> ) ; \n \t3 } else { \n \t4 if ( ! file <identifiersep> <identifier> . exists ( dir ) ) \n \t5 throw new cmd <identifiersep> exception ( <string_literal> + dir ) ; \n <ect>
\t5 <identifier> <identifiersep> string = action <identifiersep> request . get <identifiersep> <identifier> ( ) . to <identifiersep> string ( ) ; } \n \t4 catch ( exception <identifier> ) \n \t4 { \n \t5 <identifier> <identifiersep> string = <string_literal> + <identifier> . get <identifiersep> message ( ) + <string_literal> ; } } \n <ect>
\t6 <identifier> . add ( new <identifier> <identifiersep> <identifier> <identifiersep> query ( security <identifiersep> context , ( field ) <identifier> ) ) ; \n \t5 } else { \n \t6 logger . warn ( <string_literal> , <identifier> . get <identifiersep> class ( ) ) ; } } \n \t3 } else { \n <ect>
\t4 <identifier> <identifiersep> <identifier> = new thread ( ) { \n \t5 public void run ( ) { \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> exception = null ; \n \t6 if ( debug ) \n <ect>
private void <identifier> ( string <identifier> <identifiersep> config <identifiersep> name , <identifier> <identifiersep> code <identifiersep> o <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ) { \n \t1 try { \n \t1 stop <identifiersep> if <identifiersep> <identifier> ( <identifier> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t1 try { \n \t1 object <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> get <identifiersep> <identifier> <identifiersep> map . <identifier> ( <identifier> ) ; \n \t1 <identifier> <identifiersep> map = ( map < byte [ ] , <identifier> <identifiersep> map < byte [ ] , long > > ) <identifier> <identifiersep> <identifier> ; \n \t1 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t2 if ( <identifier> <identifiersep> boolean ( ) ) { \n \t3 <comment> \n \t3 for ( <identifier> <identifiersep> node node : cluster <identifiersep> state . nodes ( ) ) { \n \t4 if ( has <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to ( <identifier> , node . get <identifiersep> id ( ) ) == false && <string_literal> . equals ( node . get <identifiersep> id ( ) ) == false ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t3 boolean <identifier> <identifiersep> <identifier> <identifiersep> vm <identifiersep> from <identifiersep> <identifier> <identifiersep> pool = false ; \n \t3 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> from <identifiersep> <identifier> <identifiersep> pool ( data <identifiersep> <identifier> <identifiersep> id ) ; \n \t3 if ( <identifier> == null ) { \n <ect>
\t4 return ; } \n \t3 try { \n \t4 channel . send ( new message ( null , new request ( request . remove , <identifier> , key ) ) ) ; } \n \t3 catch ( exception ex ) { \n <ect>
\t7 name = ( ! string <identifiersep> utils . is <identifiersep> empty ( metadata ) && <identifier> . <identifier> ( <identifier> ( metadata ) ) . find ( ) ) ? \n \t8 <identifier> . group ( 1 ) : \n \t8 new file ( string <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <identifier> ( uri ) , <string_literal> ) ) . get <identifiersep> name ( ) ; \n \t6 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 log . debug ( <string_literal> , <string_literal> + name + <string_literal> + <identifier> ) ; \n \t2 return <identifier> ; } \n \t1 @ <identifier> \n \t1 public synchronized void set <identifiersep> class <identifiersep> <identifier> <identifiersep> status ( string class <identifiersep> name , boolean enabled ) { \n <ect>
<number_literal> <identifier> <identifiersep> key <identifiersep> name , \n <number_literal> resource ) ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> key <identifiersep> exception e ) \n \t2 { \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) == <identifier> <identifiersep> <identifier> . empty ) { \n \t2 log . debug ( <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> id ( ) + <string_literal> + <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> type <identifiersep> name ( ) \n \t3 + <string_literal> ) ; \n \t1 } else if ( <identifier> <identifiersep> <identifier> . <identifier> == null ) { \n <ect>
\t4 <string_literal> , cluster <identifiersep> entity . get <identifiersep> cluster <identifiersep> name ( ) , \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> state <identifiersep> <identifier> . get <identifiersep> service <identifiersep> name ( ) , <identifier> <identifiersep> <identifier> <identifiersep> state <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> name ( ) ) ) ; } \n \t3 check <identifiersep> <identifier> = check <identifiersep> <identifier> && ! <identifier> <identifiersep> check <identifiersep> failed ; } } } } \n \t1 if ( check <identifiersep> <identifier> ) { \n <ect>
<comment> \n private <identifier> <identifiersep> client <identifiersep> cache ( final int timeout , final int <identifier> <identifiersep> <identifier> , final int max <identifiersep> <identifier> , final boolean <identifier> <identifiersep> <identifier> ) { \n \t1 this . timeout = timeout ; \n \t1 this . <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ; \n <ect>
\t1 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null || <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) == 0 ) { \n \t1 <comment> \n \t1 return ; } \n \t1 if ( debug ) { \n <ect>
\t1 @ <identifier> ( <identifier> <identifiersep> type . application <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t1 @ <identifier> ( <string_literal> ) \n \t1 @ path ( <string_literal> ) \n \t1 public string get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( @ <identifier> <identifiersep> <identifier> ( <string_literal> ) string <identifier> <identifiersep> <identifier> ) { \n <ect>
<comment> \n \t1 protected void process <identifiersep> finally ( org . <identifier> . <identifier> . context context ) throws web <identifiersep> application <identifiersep> exception { \n \t2 if ( ( context != null ) && ( context . is <identifiersep> <identifier> ( ) ) ) { \n \t3 context . <identifier> ( ) ; \n <ect>
\t3 return ( url <identifiersep> stream <identifiersep> handler <identifiersep> factory ) field . get ( null ) ; \n \t2 } catch ( no <identifiersep> such <identifiersep> field <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> + field <identifiersep> name + <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> + e , e ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t1 i <identifiersep> <identifier> <identifiersep> execution <identifier> = <identifier> <identifiersep> system . get ( i <identifiersep> <identifier> <identifiersep> execution . class , null ) ; \n \t1 <identifier> . set <identifiersep> <identifier> ( <identifier> ) ; \n \t1 return <identifier> ; \n \t1 } catch ( exception ex ) { \n <ect>
\t2 try { \n \t2 get <identifiersep> web <identifiersep> <identifier> ( ) . switch <identifiersep> to ( ) . <identifier> ( new <identifiersep> <identifier> ) ; \n \t2 get <identifiersep> web <identifiersep> <identifier> ( ) . close ( ) ; } \n \t2 catch ( no <identifiersep> such <identifiersep> <identifier> <identifiersep> exception <identifier> <identifiersep> has <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t3 { \n \t4 version <identifiersep> <number_literal> . set <identifiersep> string ( <string_literal> , <identifier> ) ; } \n \t3 version <identifiersep> <number_literal> . set <identifiersep> string ( <string_literal> , <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> runtime <identifiersep> message ( <identifier> <identifiersep> <identifier> . instance ( ) , <string_literal> , <string_literal> , version <identifiersep> <number_literal> ) ; \n <ect>
\t1 <identifier> <identifiersep> <identifier> . log . debug ( <identifier> . get <identifiersep> instance ( ) . get <identifiersep> string ( <string_literal> , <identifier> . to <identifiersep> string ( ) ) ) ; <comment> \n \t1 try { \n \t1 <identifier> <identifiersep> <identifier> . get <identifiersep> session ( ) . <identifier> <identifiersep> or <identifiersep> update ( <identifier> ) ; \n \t1 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 return response . <identifier> ( ) . build ( ) ; } \n \t1 @ <identifier> \n \t1 @ path ( <string_literal> ) \n \t1 public response test ( ) { \n <ect>
\t2 try { \n \t3 if ( c != null ) \n \t4 c . close ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n <ect>
\t5 if ( <identifier> . message <identifiersep> type ( ) == <identifier> . type ) { \n \t6 <identifier> <identifier> = new <identifier> ( ) ; \n \t6 try { \n \t7 <identifier> . <identifier> ( <identifier> ) ; \n <ect>
\t2 long count = 0 ; \n \t2 for ( node <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t3 count ++ ; \n \t3 if ( count <identifier> <number_literal> == 0 ) { \n <ect>
\t1 <identifier> . remove ( key . get <identifiersep> key <identifiersep> id ( ) ) ; \n \t1 if ( key . get <identifiersep> key <identifiersep> id ( ) == current <identifiersep> key <identifiersep> id ) { \n \t2 token <identifiersep> store . update <identifiersep> <identifier> <identifiersep> key ( current <identifiersep> key <identifiersep> id , <identifier> <identifiersep> <identifier> ( key ) ) ; } } \n \t1 for ( <identifier> <identifiersep> key <identifier> <identifiersep> key : <identifier> . values ( ) ) { \n <ect>
\t3 result <identifiersep> set <identifier> = <identifier> . execute <identifiersep> query ( ) ; \n \t3 while ( <identifier> . next ( ) ) { \n \t4 result . add ( to <identifiersep> entity <identifiersep> bean ( <identifier> , false ) ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 write ( list , out ) ; \n \t3 byte [ ] data = out . to <identifiersep> byte <identifiersep> array ( ) ; \n \t3 <identifier> <identifiersep> client . create <identifiersep> object ( <identifier> , <identifier> , data ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 m <identifiersep> <identifier> <identifiersep> device <identifiersep> <identifier> . get <identifiersep> <identifier> ( ) . <identifier> ( ) ; } \n \t2 if ( device != null ) { \n \t3 <identifier> <identifiersep> <identifier> . remove ( device ) ; } \n \t2 <comment> \n <ect>
@ <identifier> \n public void update <identifiersep> entry <identifiersep> value ( object key , object value ) throws exception { \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cache <identifiersep> key <identifier> <identifiersep> cache <identifiersep> key = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> cache <identifiersep> key ) key ; \n \t1 <identifier> <identifiersep> <identifier> <identifiersep> cache <identifiersep> value <identifier> <identifiersep> <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> cache <identifiersep> value ) value ; \n <ect>
\t2 int model <identifiersep> num = 1 ; \n \t2 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < node , <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> model : this . <identifier> ) { \n \t3 logger . debug ( model <identifiersep> num ++ + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> model ) ; \n <ect>
\t3 @ <identifier> protected void body ( ) throws interrupted <identifiersep> exception , grid <identifiersep> interrupted <identifiersep> exception { \n \t4 try { \n \t5 task . <identifier> ( ) ; } \n \t4 catch ( exception e ) { \n <ect>
\t1 private string get <identifiersep> <identifier> <identifiersep> by <identifiersep> time ( long time , string type ) { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> type <identifier> <identifiersep> type = <identifier> <identifiersep> <identifier> <identifiersep> type . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) . get ( type ) ; \n \t2 string [ ] <identifier> = find <identifiersep> local <identifiersep> <identifier> ( true ) ; \n \t2 if ( <identifier> == null || <identifier> . length == 0 ) { \n <ect>
\t2 for ( entry < string , <identifier> <identifiersep> shutdown <identifiersep> <identifier> > <identifier> <identifiersep> entry : <identifier> . entry <identifiersep> set ( ) ) { \n \t3 <identifier> <identifiersep> shutdown <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> entry . get <identifiersep> value ( ) ; \n \t3 int n = <identifier> . <identifier> <identifiersep> shutdown ( ) ; \n <ect>
\t4 if ( m . find ( ) ) { \n \t5 try { \n \t6 thread <identifiersep> id = integer . value <identifiersep> of ( m . group ( 1 ) ) ; \n \t5 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t6 <comment> \n \t6 try { \n \t7 node . store ( <identifier> , false , <identifier> <identifiersep> write <identifiersep> client <identifiersep> cache , false , false ) ; \n \t6 } catch ( key <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t1 private string url <identifiersep> <identifier> ( string <identifier> ) { \n \t2 try { \n \t3 return url <identifiersep> <identifier> . <identifier> ( <identifier> , <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 return false ; } \n \t2 final string client <identifiersep> id = context . get <identifiersep> request <identifiersep> <identifier> ( o <identifiersep> <identifier> . client <identifiersep> id ) ; \n \t2 final o <identifiersep> <identifier> <identifiersep> registered <identifiersep> service registered <identifiersep> service = get <identifiersep> registered <identifiersep> service <identifiersep> by <identifiersep> client <identifiersep> id ( client <identifiersep> id ) ; \n \t2 if ( ! <identifier> . check <identifiersep> service <identifiersep> <identifier> ( registered <identifiersep> service ) ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> ; \n \t3 if ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 <identifier> = ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ; \n \t3 } else { \n <ect>
\t5 <identifier> , \n \t5 <string_literal> + message <identifiersep> <identifier> . info <identifiersep> string ( entity <identifiersep> <identifier> , <identifier> , get <identifiersep> factory ( ) ) , \n \t5 static <identifiersep> load <identifiersep> query . get <identifiersep> sql <identifiersep> <identifier> ( ) \n \t3 ) ; } \n <ect>
\t4 <comment> \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( vm , false ) ; \n \t3 } else if ( server <identifiersep> state == state . <identifier> ) { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> stop ( vm , host <identifiersep> id , <identifier> <identifiersep> type . <identifier> <identifiersep> stop ) ; \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> <identifier> <identifiersep> <identifier> create <identifiersep> <identifier> <identifiersep> from <identifiersep> token ( final <identifier> <identifier> ) { \n \t2 final <identifier> <identifiersep> date <identifiersep> time <identifier> <identifiersep> on = <identifier> <identifiersep> date <identifiersep> time . <identifier> ( ) ; \n <ect>
\t1 protected void load <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> xml ( input <identifiersep> stream stream , url <identifiersep> class <identifiersep> <identifier> c ) \n \t3 throws io <identifiersep> exception , <identifier> <identifiersep> exception { \n \t2 if ( stream == null ) { \n \t3 return ; } \n <ect>
\t2 } else if ( this . model <identifiersep> <identifier> . exists ( new <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n \t3 <comment> \n \t3 this . logger . warn ( <string_literal> , new <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 } else if ( ! has <identifiersep> access ( <identifier> . <identifier> , new <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
\t2 logger . debug ( <string_literal> , current <identifiersep> event ) ; \n \t2 final exception error = current <identifiersep> event . get <identifiersep> attributes ( ) . get ( <string_literal> , exception . class ) ; \n \t2 logger . debug ( <string_literal> , error . get <identifiersep> class ( ) , error . get <identifiersep> message ( ) ) ; \n \t2 final string event = handle ( error , request <identifiersep> context ) ; \n <ect>
\t2 assert <identifiersep> equals ( response <identifiersep> code , <number_literal> ) ; \n \t2 conn . <identifier> ( ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> get <identifiersep> all <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> key ( ) { \n <ect>
\t2 data <identifiersep> file data <identifiersep> file = null ; \n \t2 synchronized ( current <identifiersep> data <identifiersep> file ) { \n \t3 data <identifiersep> file = file <identifiersep> map . get ( key ) ; } \n \t2 if ( data <identifiersep> file == null ) { \n <ect>
<comment> \n \t1 protected void <identifier> <identifiersep> vm <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> v <identifiersep> <identifier> <identifiersep> size ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> vm <identifiersep> <identifier> , long <identifier> <identifiersep> <identifier> <identifiersep> size , <identifier> <identifiersep> <identifier> <identifiersep> config <identifiersep> <identifier> vm <identifiersep> config <identifiersep> <identifier> ) { \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> size <identifiersep> in <identifiersep> <identifier> ( ) . long <identifiersep> value ( ) != <identifier> <identifiersep> <identifier> <identifiersep> size ) { \n <ect>
\t6 storage <identifiersep> service . remove <identifiersep> <identifier> ( <identifier> , is <identifiersep> read <identifiersep> <identifier> , <identifier> . get <identifiersep> type ( ) , true ) ; \n \t6 throw new <identifier> <identifiersep> exception ( e ) ; } \n \t5 logger . info ( <string_literal> + <identifier> . get <identifiersep> name ( ) + <string_literal> ) ; \n \t4 } else { \n <ect>
\t2 max <identifiersep> node <identifiersep> id = <identifier> <identifiersep> <identifier> . node ( ) . get <identifiersep> max <identifiersep> id ( ) ; \n \t2 if ( <identifier> ) \n \t2 { \n \t3 <identifier> <identifiersep> configuration ( <identifier> , system . out ) ; } \n <ect>
\t5 } catch ( operation <identifiersep> <identifier> <identifiersep> exception e ) { \n \t6 s <identifiersep> logger . error ( <string_literal> + vm , e ) ; \n \t6 return null ; \n \t5 } catch ( resource <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 final security <identifiersep> context security <identifiersep> context = <identifier> . get <identifiersep> security <identifiersep> context ( ) ; \n \t2 final <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( security <identifiersep> context ) ; \n \t2 try ( final <identifier> <identifier> = <identifier> . <identifier> ( ) ) { \n \t3 if ( ! ( <identifier> . is <identifiersep> <identifier> ( <identifier> . delete , security <identifiersep> context ) ) ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < node , <identifier> <identifiersep> <identifier> > <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> process ( this . <identifier> <identifiersep> builder , <identifier> <identifiersep> <identifier> . get <identifiersep> default <identifiersep> <identifier> <identifiersep> <identifier> ( ) , null , false ) . get <identifiersep> <identifier> ( ) ; \n \t2 <comment> \n \t2 logger . debug ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> string ( <identifier> ) ) ; \n \t2 long <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> time <identifiersep> millis = system . current <identifiersep> time <identifiersep> millis ( ) - start ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> model model = <identifier> <identifiersep> model ; \n \t3 <identifier> ( ) ; \n \t3 if ( model != null ) { \n \t4 model . <identifier> <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ( ) , <identifier> <identifiersep> array ( ) , attribute <identifiersep> array ( ) ) ; } \n <ect>
<comment> \n \t1 public void set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( final string <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ) { \n <ect>
<comment> \n \t1 public boolean check <identifiersep> service <identifiersep> <identifier> ( final registered <identifiersep> service registered <identifiersep> service ) { \n \t2 if ( registered <identifiersep> service == null ) { \n <ect>
* \n * function <identifier> ( context ) { \n * \n * \t1 <identifier> <identifier> = user ? user . <identifier> : <string_literal> ; \n <ect>
\t1 <comment> \n \t1 private void <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> job <identifiersep> manager ( final job <identifiersep> id job <identifiersep> id ) { \n \t2 final job <identifiersep> manager <identifiersep> connection job <identifiersep> manager <identifiersep> connection = job <identifiersep> manager <identifiersep> table . get ( job <identifiersep> id ) ; \n \t2 if ( job <identifiersep> manager <identifiersep> connection == null ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public static boolean should <identifiersep> <identifier> ( boolean default <identifiersep> <identifier> <identifiersep> <identifier> , throwable throwable , log logger ) { \n <ect>
\t1 try { \n \t1 security <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> context . run <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t1 } catch { \n \t1 case e : exception = > \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> != null ) \n \t4 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . max ( <identifier> . as <identifiersep> list ( <identifier> , <identifier> <identifiersep> <identifier> ) ) ; \n \t3 <identifier> <identifiersep> <identifier> . put ( <identifier> . metadata . <identifier> <identifiersep> id , <identifier> ) ; } \n \t2 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> . values ( ) ) ; \n <ect>
<number_literal> return new <identifier> <identifiersep> answer ( cmd , msg ) ; } \n <number_literal> break ; } } } } } } } } \n \t3 return new <identifier> <identifiersep> answer ( cmd , false ) ; \n \t2 } catch ( xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 continue ; \n \t3 try { \n \t4 server . send ( e . client <identifiersep> <identifier> , out . <identifier> ( ) , 0 , out . <identifier> ( ) ) ; } \n \t3 catch ( exception ex ) { \n <ect>
\t4 logger . debug ( <string_literal> , line ) ; \n \t4 if ( command != null && status <identifiersep> map . get ( command ) . equals ( value ) ) { \n \t5 return ; \n \t4 } else { \n <ect>
\t4 name <identifiersep> <identifier> <identifiersep> response <identifiersep> message <identifier> = <identifier> . get <identifiersep> <identifier> <identifiersep> for <identifiersep> response ( ) ; \n \t4 name <identifiersep> <identifier> <identifiersep> response <identifiersep> message <identifiersep> object <identifier> <identifiersep> response = new name <identifiersep> <identifier> <identifiersep> response <identifiersep> message <identifiersep> object ( <identifier> <identifiersep> with <identifiersep> id , <identifier> , <identifier> <identifiersep> handle ) ; \n \t4 <identifier> <identifiersep> response . <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) , <identifier> ) ; \n \t4 result = true ; \n <ect>
\t2 base <identifiersep> output <identifiersep> <identifier> <identifiersep> <identifier> output <identifiersep> <identifier> = output <identifiersep> <identifier> . get ( <identifier> ) ; \n \t2 output <identifiersep> <identifier> base <identifiersep> <identifier> = output <identifiersep> <identifier> . get <identifiersep> base <identifiersep> <identifier> ( ) ; \n \t2 task <identifiersep> <identifier> <identifiersep> context <identifier> <identifiersep> context = output <identifiersep> <identifier> . get <identifiersep> context ( ) ; \n \t2 if ( base <identifiersep> <identifier> . <identifier> <identifiersep> task <identifiersep> <identifier> ( <identifier> <identifiersep> context ) ) { \n <ect>
\t4 . set <identifiersep> password ( password ) \n \t4 . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> default ( ) ) \n \t4 . set <identifiersep> time <identifiersep> <identifier> ( time <identifiersep> <identifier> . get <identifiersep> default ( ) ) ; \n \t2 try { \n <ect>
\t1 @ <identifier> \n \t1 protected event do <identifiersep> execute ( final request <identifiersep> context request <identifiersep> context ) { \n \t2 final authentication c = web <identifiersep> utils . get <identifiersep> authentication ( request <identifiersep> context ) ; \n \t2 if ( c == null ) { \n <ect>
\t2 if ( <identifier> > 0 ) \n \t3 throw new <identifier> <identifiersep> execution <identifiersep> exception ( <identifier> + <string_literal> ) ; } \n \t1 private void <identifier> ( file run <identifiersep> file , file <identifiersep> set <identifiersep> <identifier> file <identifiersep> set <identifiersep> <identifier> ) throws exception { \n \t2 if ( ! run <identifiersep> file . exists ( ) ) { \n <ect>
\t4 while ( true ) { \n \t5 try { \n \t6 <comment> \n \t6 if ( <string_literal> . equals ( current <identifiersep> url ) ) { \n <ect>
\t3 <identifier> [ 0 ] = <identifier> ; } \n \t2 method method = \n \t3 <identifier> <identifiersep> <identifier> . get <identifiersep> class ( ) . get <identifiersep> method ( method <identifiersep> name , <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 if ( <identifier> instanceof <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 ( ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) <identifier> ) . remove <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 <identifier> ( context , <identifier> , <identifier> , <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public void test <identifiersep> with <identifiersep> <identifier> ( ) { \n \t2 this . application <identifiersep> context . get <identifiersep> bean ( <identifier> <identifiersep> connection <identifiersep> factory . class ) . create <identifiersep> connection ( ) . close ( ) ; \n \t2 logger log = ( logger ) logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) ; \n \t2 log . info ( <string_literal> ) ; \n <ect>
\t2 <identifier> . set <identifiersep> <identifier> ( <string_literal> , store <identifiersep> id ) ; \n \t2 <identifier> . set <identifiersep> <identifier> ( <string_literal> , false ) ; \n \t2 list < snapshot <identifiersep> data <identifiersep> store <identifiersep> vo > <identifier> = list <identifiersep> by ( <identifier> ) ; \n \t2 if ( <identifier> != null ) { \n <ect>
\t4 result = <identifier> <identifiersep> store <identifiersep> query ( <identifier> ) ; \n \t4 result <identifiersep> array [ result <identifiersep> <identifier> ] = result ; \n \t3 } catch ( exception e ) { \n \t4 failure <identifiersep> count . <identifier> <identifiersep> and <identifiersep> get ( ) ; \n <ect>
\t2 this . ticket <identifiersep> <identifier> = ticket <identifiersep> <identifier> ; \n \t2 this . <identifier> <identifiersep> template = <identifier> <identifiersep> template ; \n \t2 this . <identifier> <identifiersep> collection = <identifier> <identifiersep> collection ; \n \t2 create <identifiersep> ticket <identifiersep> <identifier> ( ) ; \n <ect>
\t3 final int value = 1 ; \n \t3 char id = <identifier> ; \n \t3 log . debug ( <string_literal> , value , id ) ; \n \t3 template . send <identifiersep> body <identifiersep> and <identifiersep> header ( <string_literal> + size , value , <string_literal> , <string_literal> + id ) ; } \n <ect>
\t3 throwable e = <identifier> . get ( 0 ) ; \n \t3 for ( throwable <identifier> : <identifier> . <identifier> <identifiersep> list ( 1 , <identifier> . size ( ) ) ) { \n \t4 e . add <identifiersep> <identifier> ( <identifier> ) ; } \n \t3 throw e ; } \n <ect>
\t6 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) \n \t7 log . info ( log . <identifier> <identifiersep> <identifier> , <string_literal> , <identifier> ) ; \n \t6 if ( <identifier> > <identifier> <identifiersep> response <identifiersep> time * system <identifiersep> configuration . <identifier> <identifiersep> <identifier> && <identifier> <identifiersep> response <identifiersep> time > - 1 ) { \n \t7 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) \n <ect>
\t2 } else { \n \t3 if ( <identifier> <identifiersep> manager == null ) { \n \t4 <identifier> <identifiersep> manager = <identifier> <identifiersep> utils . get <identifiersep> service ( <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> provider <identifiersep> manager . class ) ; } \n \t3 if ( <identifier> <identifiersep> manager == null ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> vm ( vm <identifiersep> id ) ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + vm <identifiersep> id + <string_literal> ) ; \n \t2 } else { \n \t3 success = false ; \n <ect>
\t3 resource <identifier> <identifiersep> user <identifiersep> file = security ( ) . get ( <string_literal> ) ; \n \t3 if ( <identifier> <identifiersep> user <identifiersep> file . get <identifiersep> type ( ) != type . <identifier> ) { \n \t4 logger . <identifier> ( <identifier> <identifiersep> user <identifiersep> file . path ( ) + <string_literal> ) ; } \n \t3 return false ; <comment> \n <ect>
\t1 authentication <identifiersep> token token ; \n \t1 try { \n \t1 token = token <identifiersep> class . new <identifiersep> instance ( ) ; \n \t1 } catch ( <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t1 @ test ( timeout = <number_literal> * <number_literal> ) \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> log <identifiersep> files ( ) ; \n \t2 int job <identifiersep> count = <identifier> <identifiersep> store . get <identifiersep> job <identifiersep> <identifier> ( <string_literal> ) . get <identifiersep> all <identifiersep> <identifier> ( ) . size ( ) ; \n <ect>
\t2 string data = <string_literal> ; \n \t2 string <identifier> = <string_literal> ; \n \t2 version <identifiersep> test ( <identifier> , data . get <identifiersep> bytes ( ) , <identifier> . get <identifiersep> bytes ( ) ) ; \n \t2 version <identifiersep> test ( <identifier> , data . get <identifiersep> bytes ( ) , <identifier> . get <identifiersep> bytes ( ) ) ; \n <ect>
\t5 logger . debug ( <string_literal> , <identifier> ) ; } \n \t3 catch ( io <identifiersep> exception <identifier> ) \n \t3 { \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 try { \n \t2 <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 try { \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> handler . close ( ) ; } \n \t3 catch ( throwable t ) { \n \t4 <comment> \n <ect>
\t3 x <identifiersep> stream . <identifier> ( o , <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 return <identifier> . to <identifiersep> string ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 for ( int i = 0 ; i < <identifier> <identifiersep> <identifier> . size ( ) ; i ++ ) { \n \t3 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> . get ( i ) ; \n \t3 <identifier> . <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t2 logger . info ( <string_literal> , <identifier> <identifiersep> node ) ; \n \t2 <identifier> <identifiersep> node ( <identifier> , <identifier> <identifiersep> node ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 assert <identifiersep> <identifier> ( <identifier> . action <identifiersep> get ( ) ) ; \n <ect>
\t5 <identifier> = close ( <identifier> ) ; \n \t5 <identifier> = close ( <identifier> ) ; } \n \t3 } finally { \n \t4 connection = close ( connection ) ; } } \n <ect>
\t2 string <identifier> <identifiersep> dir = code <identifiersep> dir . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t2 <identifier> . add <identifiersep> to <identifiersep> class <identifiersep> path ( <identifier> <identifiersep> dir ) ; \n \t2 log . debug ( <string_literal> + <identifier> . get <identifiersep> class <identifiersep> path ( ) ) ; \n \t2 <identifier> . <identifier> ( <identifier> <identifiersep> dir , new java <identifiersep> <identifier> <identifiersep> <identifier> . java <identifiersep> source <identifiersep> from <identifiersep> string ( class <identifiersep> name , <identifier> <identifiersep> code <identifiersep> string ) ) ; \n <ect>
\t3 try { \n \t4 channel <identifiersep> <identifier> . close ( ) ; \n \t3 } catch ( final exception <identifier> ) { \n <ect>
\t3 <comment> \n \t3 log . debug ( <string_literal> ) ; } } } \n \t1 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t4 } else { \n \t5 s <identifiersep> logger . debug ( <string_literal> + vm . get <identifiersep> id ( ) + <string_literal> ) ; } } \n \t3 if ( vo != null && vo . get <identifiersep> state ( ) == new <identifiersep> state ) { \n \t4 <comment> \n <ect>
\t5 } catch ( exception e ) \n \t5 { \n \t6 error <identifiersep> msg = e . get <identifiersep> message ( ) ; \n \t6 user <identifiersep> info . set <identifiersep> object <identifiersep> for <identifiersep> key ( e , exception <identifiersep> key ) ; \n <ect>
\t1 protected void delete <identifiersep> <identifier> <identifiersep> meta ( string meta <identifiersep> url ) throws io <identifiersep> exception { \n \t2 int <identifier> = meta <identifiersep> url . index <identifiersep> of ( ' @ ' ) ; \n \t2 string path = meta <identifiersep> url . <identifier> ( 0 , <identifier> ) ; \n \t2 <identifier> <identifiersep> <identifier> . get <identifiersep> file <identifiersep> system ( path ) . delete ( new path ( path ) , true ) ; \n <ect>
\t4 public void run ( ) { \n \t5 try { \n \t6 do <identifiersep> <identifier> <identifiersep> connection ( false ) ; \n \t5 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> all <identifiersep> <identifier> <identifiersep> static <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> network ( network <identifiersep> id , <identifier> <identifiersep> user <identifiersep> id , <identifier> ) ) { \n \t4 s <identifiersep> logger . debug ( <string_literal> + network <identifiersep> id ) ; \n \t3 } else { \n \t4 success = false ; \n <ect>
\t6 log . debug ( \n \t7 <string_literal> + <identifier> + <string_literal> + element + <string_literal> + <identifier> + \n \t8 <string_literal> + <identifier> + <string_literal> + <identifier> ) ; } } \n \t3 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t7 log . info ( <string_literal> ) ; \n \t7 exchange . get <identifiersep> out ( ) . set <identifiersep> <identifier> ( true ) ; \n \t7 exchange . get <identifiersep> out ( ) . set <identifiersep> body ( <string_literal> ) ; \n \t6 } else if ( name . equals ( <string_literal> ) ) { \n <ect>
\t4 . set <identifiersep> query ( new <identifier> <identifiersep> query <identifiersep> builder ( <string_literal> , <string_literal> , <string_literal> , <string_literal> , null , null , null ) ) \n \t4 . get ( ) ; \n \t2 assert <identifiersep> <identifier> <identifiersep> count ( response , 1 ) ; \n \t2 assert <identifiersep> that ( response . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> ( 0 ) . get <identifiersep> id ( ) , equal <identifiersep> to ( <string_literal> ) ) ; \n <ect>
\t7 m <identifiersep> logger . debug ( <string_literal> ) ; \n \t7 if ( <identifier> <identifiersep> <identifier> <identifiersep> time == - 1 \n \t9 && m <identifiersep> <identifier> <identifiersep> listener . check <identifiersep> for <identifiersep> message ( <identifier> <identifiersep> listener . <identifier> \n \t9 <identifier> <identifier> <identifiersep> listener . start ) ) { \n <ect>
\t1 <identifier> . default <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> \t4 : <identifier> , \n \t1 <identifier> . <identifier> . ignore <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> : <identifier> , <comment> \n ] \n <identifier> <identifiersep> <identifier> . list <identifiersep> <identifier> ( ) . <identifier> { string context <identifiersep> name - > \n <ect>
\t5 continue ; \n \t4 try { \n \t5 <identifier> <identifiersep> to <identifiersep> <identifier> . add ( <identifier> <identifiersep> address . get <identifiersep> by <identifiersep> name ( <identifier> ) ) ; \n \t4 } catch ( <identifier> <identifiersep> host <identifiersep> exception <identifier> ) { \n <ect>
\t3 return new <identifier> <identifiersep> ticket <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t4 <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> key ( ) , \n \t4 <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> key ( ) , \n \t4 <identifier> . get <identifiersep> <identifier> ( ) ) ; } \n <ect>
\t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( string name , map < string , object > <identifier> ) throws configuration <identifiersep> exception { \n <ect>
\t2 if ( config . is <identifiersep> <identifier> <identifiersep> node <identifiersep> id ( ) || config . is <identifiersep> <identifier> <identifiersep> node <identifiersep> id <identifiersep> <identifier> ( ) ) { \n \t3 host <identifiersep> <identifier> <identifier> = config . get <identifiersep> node <identifiersep> id <identifiersep> <identifier> ( ) ; \n \t3 node <identifiersep> id <identifiersep> utils . <identifier> <identifiersep> node <identifiersep> id ( cluster , <identifier> , config . get <identifiersep> node <identifiersep> id ( ) ) ; \n \t2 } else { \n <ect>
\t3 for ( <identifier> <identifiersep> transaction <identifier> : <identifier> ) { \n \t4 try { \n \t5 <identifier> . <identifier> ( ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t4 log . error ( message , <identifier> ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> error ( message , <identifier> ) ; } } \n \t2 finally { \n \t3 try { \n <ect>
\t4 log . info ( format ( <string_literal> , action <identifiersep> id ) ) ; \n \t4 <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t4 log . info ( format ( <string_literal> , action <identifiersep> id ) ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 out ) ; \n \t1 long header <identifiersep> size = out . get <identifiersep> <identifier> ( ) - current <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t1 this . <identifier> <identifiersep> length += <identifier> <identifiersep> size + header <identifiersep> size ; \n \t1 this . <identifier> <identifiersep> length += <identifier> <identifiersep> <identifier> <identifiersep> size + header <identifiersep> size ; \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 <identifier> <identifiersep> user <identifiersep> <identifier> . send <identifiersep> message ( message . get <identifiersep> content ( ) ) ; } \n \t2 catch ( <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t2 string method <identifiersep> name = get <identifiersep> get <identifiersep> method <identifiersep> name ( <string_literal> , <identifier> <identifiersep> name ) ; \n \t2 try { \n \t3 method = o . get <identifiersep> class ( ) . get <identifiersep> method ( method <identifiersep> name ) ; \n \t2 } catch ( security <identifiersep> exception <identifier> ) { \n <ect>
\t3 } ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t3 logger . warn ( <string_literal> , e ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 count -- ; \n \t3 if ( <identifier> ( ) ) \n \t3 { \n \t4 log . debug ( <string_literal> ) ; \n <ect>
\t5 store , \n \t5 <identifier> \n \t3 ) ; \n \t2 } else { \n <ect>
\t3 list < node > <identifier> <identifiersep> nodes ) { \n \t2 if ( <identifier> <identifiersep> builder == null || \n \t4 <identifier> <identifiersep> nodes == null || \n \t4 <identifier> <identifiersep> nodes . is <identifiersep> empty ( ) ) { \n <ect>
\t1 { \n \t2 return <identifier> <identifiersep> server <identifiersep> info ; } \n \t1 synchronized void on <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> ) \n \t1 { \n <ect>
\t2 if ( ! has <identifiersep> <identifier> ( ) ) { \n \t3 return new <identifier> <identifiersep> result ( <identifier> ) . <identifier> ( <identifier> ) ; <comment> \n \t2 result . <identifier> ( <string_literal> , get <identifiersep> <identifier> ( ) ) ; \n \t2 <identifier> . <identifier> <identifiersep> request <identifiersep> map ( ) ; \n <ect>
\t2 try { \n \t3 <identifier> <identifiersep> remote <identifiersep> object . <identifier> <identifiersep> object ( this . <identifier> <identifiersep> object , true ) ; } \n \t2 catch ( no <identifiersep> such <identifiersep> object <identifiersep> exception ex ) { \n <ect>
\t4 current <identifiersep> state = null ; } \n \t3 synchronized ( base <identifiersep> <identifier> <identifiersep> <identifier> . this ) { \n \t4 <identifier> <identifiersep> put <identifiersep> <identifier> . remove ( this ) ; \n \t4 if ( put <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> metadata . remove ( this ) ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> ) ; \n \t4 return null ; } \n \t3 template <identifiersep> host <identifiersep> <identifier> = <identifier> <identifiersep> storage <identifiersep> <identifier> . find <identifiersep> vm <identifiersep> template <identifiersep> host ( template <identifiersep> id , pool ) ; \n \t3 if ( template <identifiersep> host <identifiersep> <identifier> == null || template <identifiersep> host <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> state ( ) != status . <identifier> ) { \n <ect>
\t3 if ( <identifier> <identifiersep> thread != null ) { \n \t4 <identifier> <identifiersep> thread . <identifier> ( 0 ) ; } \n \t3 <identifier> <identifiersep> thread = null ; \n \t2 } catch ( interrupted <identifiersep> exception <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifier> = conn . <identifier> <identifiersep> <identifier> ( <string_literal> + \n \t5 <string_literal> ) ; \n \t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . close ( ) ; \n <ect>
\t2 update ( vo , <identifier> ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> ip <identifiersep> address ( long id ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> ) \n \t3 <identifier> <identifiersep> manager . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) \n \t3 return <identifier> <identifiersep> manager . create ( ) . write ( ) \n \t2 } catch ( e : exception ) { \n <ect>
<comment> \n \t1 public void add <identifiersep> policy ( final enum name , final <identifier> <identifiersep> policy policy ) { \n <ect>
\t4 logger . error ( <string_literal> ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 logger . error ( <string_literal> , e ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> error ( <identifier> <identifiersep> exception e ) throws <identifier> <identifiersep> exception \n \t1 { \n <ect>
\t2 log . info ( <string_literal> ) ; } \n \t2 for ( map <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : map <identifiersep> <identifier> ) { \n <ect>
<comment> \n @ test \n public void test <identifiersep> <identifier> <identifiersep> table ( ) throws exception { \n <ect>
\t2 return true ; } \n \t1 @ <identifier> \n \t1 public boolean delete <identifiersep> remote <identifiersep> access <identifiersep> <identifier> ( network network , remote <identifiersep> access <identifiersep> <identifier> <identifier> , list < ? extends <identifier> <identifiersep> <identifier> > <identifier> ) throws resource <identifiersep> <identifier> <identifiersep> exception { \n \t2 if ( <identifier> == null || <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t1 status status = file <identifiersep> to <identifiersep> status . get ( <identifier> <identifiersep> name ) ; \n \t1 assert . assert <identifiersep> equals ( <string_literal> , false , status . get <identifiersep> <identifier> ( ) ) ; \n \t1 set < string > files <identifiersep> for <identifiersep> table = get <identifiersep> files <identifiersep> for <identifiersep> table ( table ) ; \n \t1 assert . assert <identifiersep> equals ( <string_literal> , 1 , files <identifiersep> for <identifiersep> table . size ( ) ) ; \n <ect>
\t3 } finally { \n \t4 try { \n \t5 is . close ( ) ; \n \t4 } catch ( final io <identifiersep> exception e ) { \n <ect>
\t2 log . debug ( <string_literal> , <identifier> . get <identifiersep> channel <identifiersep> type ( ) , <identifier> ) ; \n \t2 <identifier> . remove ( <identifier> . get <identifiersep> channel <identifiersep> type ( ) ) ; } \n \t1 @ <identifier> \n \t1 public void <identifier> ( <identifier> <identifiersep> channel <identifiersep> <identifier> <identifier> ) { \n <ect>
\t2 if ( <identifier> . length > 0 ) { \n \t3 string <identifiersep> builder <identifier> = new string <identifiersep> builder ( <identifier> [ 0 ] ) ; \n \t3 for ( int i = 1 ; i < <identifier> . length ; i ++ ) { \n \t4 if ( i <identifier> <identifier> <identifiersep> <identifier> <identifiersep> line == 0 ) { \n <ect>
\t4 log . debug ( <string_literal> ) ; \n \t4 return ; \n \t3 } else { \n \t4 <comment> \n <ect>
\t3 finally { \n \t4 try { \n \t5 <identifier> . close ( ) ; } \n \t4 catch ( throwable ex ) { \n <ect>
\t2 json <identifiersep> <identifier> <identifier> = factory . new <identifiersep> json <identifiersep> <identifier> ( ) ; \n \t2 @ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n \t2 map < string , object > json <identifiersep> data = <identifier> . parse <identifiersep> json ( <identifier> <identifiersep> config ) ; \n \t2 try { \n <ect>
\t3 break ; } } \n \t2 if ( ! <identifier> ) { \n \t2 log . warn ( <string_literal> ) ; } } \n \t1 } catch ( parse <identifiersep> exception <identifier> ) { \n <ect>
\t6 if ( socket <identifiersep> <identifier> . <identifier> ( socket ) ) { \n \t6 <comment> \n \t6 <identifier> <identifiersep> socket . <identifier> <identifiersep> and <identifiersep> set ( null , socket ) ; } \n \t5 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <comment> \n \t1 if ( ! has <identifiersep> <identifier> <identifiersep> a ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> manager . listener listener = <identifier> <identifiersep> manager . listener ; \n \t2 if ( listener != null ) { \n \t3 listener . start ( ) ; \n \t2 } else { \n <ect>
\t2 web <identifiersep> <identifier> web <identifiersep> <identifier> ; \n \t2 try { \n \t3 web <identifiersep> <identifier> = web <identifiersep> <identifier> <identifiersep> pool . get ( ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 if ( <identifier> == null ) { \n \t1 debug <identifiersep> log . warn ( <string_literal> , <identifier> ) ; \n \t1 return ; \n \t1 } else if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> ) ) { \n <ect>
public boolean has <identifiersep> <identifier> ( ) { \n \t1 return exception != null ; } \n public void <identifier> <identifiersep> exception ( ) { \n \t1 if ( exception != null ) { \n <ect>
\t5 read ++ ; \n \t5 <identifier> <identifiersep> content ( <identifier> , <identifier> <identifiersep> <identifier> , msg , read == <identifier> ) ; } \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 string error <identifiersep> code = <identifier> . of <identifiersep> <identifier> ( e . get <identifiersep> error <identifiersep> code ( ) ) . or <identifiersep> else ( <string_literal> ) ; \n <ect>
\t3 int <identifier> <identifiersep> <identifier> <identifiersep> id = task <identifiersep> end . <identifier> <identifiersep> <identifier> <identifiersep> id ( ) ; \n \t3 string <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> id + <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> id ; \n \t3 integer job <identifiersep> id = <identifier> <identifiersep> id <identifiersep> to <identifiersep> job <identifiersep> id . get ( <identifier> <identifiersep> id ) ; \n \t3 if ( job <identifiersep> id == null ) { \n <ect>
\t4 else { \n \t5 set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> name <identifiersep> array <identifiersep> <identifier> ( false ) ; } } } \n \t2 catch ( sql <identifiersep> exception ex ) { \n <ect>
\t3 result . <identifier> = ( <identifier> <identifiersep> security <identifiersep> exception ) e ; \n \t3 result . set <identifiersep> <identifier> <identifiersep> set ( true ) ; \n \t3 msg = result ; \n \t3 } else if ( e instanceof org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception ) { \n <ect>
\t4 try { \n \t5 double value = ( ( number ) <identifier> <identifiersep> <identifier> <identifiersep> utils . add ( <identifier> <identifiersep> entry . get <identifiersep> value ( ) , <identifier> . get ( key ) ) ) . double <identifiersep> value ( ) ; \n \t5 <identifier> . put ( key , value ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t2 if ( <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> token ( ) ) { \n \t3 <identifier> <identifiersep> token = <identifier> <identifiersep> <identifier> <identifiersep> token ( <identifier> ) ; \n \t3 logger . debug ( <string_literal> , <identifier> <identifiersep> token ) ; \n \t2 } else { \n <ect>
\t2 try { \n \t2 <identifier> . execute <identifiersep> update ( ) ; \n \t2 <identifier> <identifiersep> count ++ ; \n \t2 } catch ( sql <identifiersep> exception sql ) { \n <ect>
\t8 <identifier> <identifiersep> node . set <identifiersep> property ( <string_literal> , string <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> null <identifiersep> value ( <identifier> . get <identifiersep> <identifier> ( ) ) ) ; \n \t8 <identifier> <identifiersep> node . set <identifiersep> property ( <string_literal> , <identifier> . get <identifiersep> name ( ) ) ; \n \t8 session . <identifier> ( ) ; } } \n \t5 } else { <comment> \n <ect>
\t1 <identifier> <identifier> = <identifier> ( \n \t1 get <identifiersep> runtime <identifiersep> context . get <identifiersep> user <identifiersep> code <identifiersep> class <identifiersep> <identifier> , \n \t1 <identifier> <identifiersep> <identifier> . name , \n \t1 <identifier> <identifiersep> <identifier> . code ) \n <ect>
\t2 if ( name == null ) { \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t2 level level = <identifier> <identifiersep> <identifier> <identifiersep> configuration . logger <identifiersep> <identifier> <identifiersep> <identifier> . get ( name ) ; \n \t2 if ( level != null ) { \n <ect>
\t1 private final logger logger = log <identifiersep> manager . get <identifiersep> logger ( <string_literal> ) ; \n \t1 @ <identifier> \n \t1 public void on <identifiersep> test <identifiersep> start ( i <identifiersep> test <identifiersep> result result ) { \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t1 <comment> \n \t1 if ( string <identifiersep> utils . is <identifiersep> empty ( <identifier> ) ) { \n \t2 uri default <identifiersep> uri = file <identifiersep> system . get ( conf ) . get <identifiersep> uri ( ) ; \n \t2 <identifier> = default <identifiersep> uri . get <identifiersep> <identifier> ( ) ; } \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifier> = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> close <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n \t4 <identifier> . execute <identifiersep> update ( ) ; \n \t4 s <identifiersep> logger . debug ( <string_literal> ) ; \n \t3 } catch ( sql <identifiersep> exception ex ) { \n <ect>
<comment> \n @ <identifier> \n public void set <identifiersep> <identifier> ( long user <identifiersep> id , long item <identifiersep> id , float value ) throws <identifier> <identifiersep> exception { \n \t1 <identifier> . check <identifiersep> argument ( ! float . is <identifiersep> <identifier> <identifiersep> n ( value ) , <string_literal> ) ; \n <ect>
\t2 for ( int i = 0 ; i < msg <identifiersep> count ; i ++ ) { \n \t3 bytes <identifiersep> message message = session . create <identifiersep> bytes <identifiersep> message ( ) ; \n \t3 message . write <identifiersep> bytes ( <identifier> ) ; \n \t3 <identifier> . send ( message ) ; \n <ect>
<comment> \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> failed ( update <identifiersep> task task , string <identifier> , throwable t ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t9 <identifier> ( <identifier> . get <identifiersep> string ( <identifier> ) ) , \n \t9 <identifier> ( <identifier> <identifiersep> resource . get <identifiersep> name ( ) ) ) ) ; } \n \t3 catch ( request <identifiersep> execution <identifiersep> exception e ) \n \t3 { \n <ect>
\t2 this . bean = bean ; \n \t2 try { \n \t3 type <identifiersep> id = ( integer ) property <identifiersep> utils . get <identifiersep> property ( bean , <string_literal> ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception | <identifier> <identifiersep> target <identifiersep> exception | no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n <ect>
\t1 public org . <identifier> . <identifier> . api . <identifier> <identifier> <identifiersep> <identifier> ( final <identifier> <identifiersep> <identifier> <identifier> , \n <number_literal> final file <identifier> <identifiersep> directory , \n <number_literal> final <identifier> <identifiersep> options options ) throws <identifier> <identifiersep> exception { \n \t2 final string <identifier> <identifiersep> <identifier> <identifiersep> string = <identifier> <identifiersep> directory . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n <ect>
<comment> \n \t1 protected boolean is <identifiersep> <identifier> <identifiersep> policy <identifiersep> <identifier> <identifiersep> by ( final principal principal ) { \n \t2 final map < string , object > attributes = principal . get <identifiersep> attributes ( ) ; \n <ect>
\t2 for ( address <identifiersep> <identifier> < t > r : r <identifiersep> array ) { \n \t3 try { \n \t4 r . close ( ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t2 public boolean <identifier> ( long <identifier> , string <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> map . get ( <identifier> ) ; \n \t3 if ( <identifier> != null ) { \n \t4 return <identifier> . check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> ) ; } \n <ect>
\t4 session . <identifier> ( ) ; } } \n \t2 catch ( illegal <identifiersep> state <identifiersep> exception <identifier> ) { \n \t3 logger . debug ( <string_literal> , <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> exception | runtime <identifiersep> exception | error <identifier> ) { \n <ect>
\t2 max <identifiersep> <identifier> , true , 0 . 0 , false ) ; \n \t1 <comment> \n \t1 path out <identifiersep> <identifier> = new path ( output , <string_literal> ) ; \n \t1 path <identifier> <identifiersep> <identifier> = new path ( output , <string_literal> ) ; \n <ect>
\t2 current <identifiersep> value = <identifier> <identifiersep> <identifier> . read ( ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n \t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( e ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n \t4 <identifier> <identifiersep> log . debug ( <string_literal> + state ) ; \n \t2 } else { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 <comment> \n \t1 file <identifier> <identifiersep> <identifier> <identifiersep> dir = this . <identifier> <identifiersep> file . get <identifiersep> <identifier> <identifiersep> file ( ) ; \n \t1 log . debug ( <string_literal> ) ; \n \t1 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> dir . delete ( ) ) { \n <ect>
\t2 <identifier> <identifiersep> manager . level <identifiersep> <identifier> = log <identifiersep> level . warn \n \t2 <identifier> <identifiersep> manager . add <identifiersep> <identifier> <identifiersep> output <identifiersep> listener ( listener ) \n \t2 <identifier> <identifiersep> manager . add <identifiersep> <identifier> <identifiersep> error <identifiersep> listener ( listener ) \n \t2 <identifier> <identifiersep> manager . start ( ) \n <ect>
\t3 int <identifier> = conf . get <identifiersep> int <identifiersep> <identifier> ( <identifier> <identifiersep> conf . conf <identifiersep> <identifier> . <identifier> ) ; \n \t3 table <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new table <identifiersep> <identifier> ( 1 , <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> input <identifiersep> <identifier> ( false ) ; \n \t3 <identifier> . get <identifiersep> parse <identifiersep> info ( ) . set <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> ) ; \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> get <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
\t3 if ( client <identifiersep> socket != null && ! client <identifiersep> socket . is <identifiersep> <identifier> ( ) ) { \n \t4 try { \n \t5 client <identifiersep> socket . close ( ) ; \n \t4 } catch ( io <identifiersep> exception io <identifiersep> ex ) { \n <ect>
\t7 + <string_literal> + num <identifiersep> <identifier> + <string_literal> ) ; \n \t4 return true ; \n \t3 } else { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 logger . info ( <identifier> <identifiersep> <identifier> <identifiersep> root <identifiersep> element <identifiersep> collection ) ; \n \t2 response response = target . request ( ) . <identifier> ( entity . entity ( <identifier> <identifiersep> <identifier> <identifiersep> root <identifiersep> element <identifiersep> collection , <string_literal> ) ) ; \n \t2 assert . assert <identifiersep> equals ( http <identifiersep> response <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , response . get <identifiersep> status ( ) ) ; \n \t2 string entity = response . read <identifiersep> entity ( string . class ) ; \n <ect>
\t3 if ( start <identifiersep> <identifier> != null && start <identifiersep> <identifier> . get <identifiersep> count ( ) > 0 ) { \n \t4 log . info ( <string_literal> ) ; \n \t4 start <identifiersep> <identifier> . count <identifiersep> <identifier> ( ) ; \n \t3 } else { \n <ect>
\t2 <identifier> <identifiersep> connection connection = <identifier> . get <identifiersep> <identifier> <identifiersep> connection ( configuration ) ; \n \t2 string <identifier> = connection . get <identifiersep> <identifier> ( ) + <string_literal> ; \n \t2 <comment> \n \t2 if ( <identifier> . <identifier> <identifiersep> with ( <string_literal> ) ) { \n <ect>
\t3 <identifier> . <identifier> ( ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> && ! <identifier> <identifiersep> <identifier> ) { \n \t3 <comment> \n \t3 <comment> \n <ect>
\t2 try { \n \t3 if ( filter . <identifier> ( class <identifiersep> name ) ) { \n \t4 <identifier> <identifiersep> set . add ( class <identifiersep> name ) ; } \n \t2 } catch ( throwable e ) { <comment> \n <ect>
\t3 header <identifiersep> <identifier> header <identifiersep> <identifier> = new header <identifiersep> <identifier> ( <string_literal> , <identifier> <identifiersep> string ) ; \n \t3 <identifier> . add <identifiersep> header ( header <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> request ( request , <identifier> ) ; } \n \t2 catch ( exception e ) \n <ect>
\t2 content <identifiersep> name node <identifiersep> name = test <identifiersep> <identifier> . get <identifiersep> class <identifiersep> <identifier> ( ) . <identifier> ( \n \t4 content <identifiersep> name . from <identifiersep> native ( <string_literal> ) ) ; \n \t2 <identifier> <identifiersep> key <identifiersep> name = group <identifiersep> access <identifiersep> <identifier> <identifiersep> <identifier> . node <identifiersep> key <identifiersep> name ( node <identifiersep> name ) ; \n \t2 <identifier> <identifiersep> <identifier> = true ; \n <ect>
\t6 <identifier> <identifiersep> read = start ; <comment> \n \t6 <identifier> = true ; \n \t6 logger . debug ( <string_literal> + start ) ; } } \n \t4 <identifier> <identifiersep> destination . write ( bytes , 0 , <identifier> <identifiersep> read ) ; } \n <ect>
\t4 <identifier> <identifiersep> context . is <identifiersep> <identifier> . set ( false ) ; \n \t4 return false ; } \n \t3 if ( result . get <identifiersep> throwable ( ) != null ) \n \t3 { \n <ect>
\t1 public void <identifier> ( ) { \n \t2 super . <identifier> ( ) ; \n \t2 <identifier> = ( <identifier> ) <identifier> . get <identifiersep> <identifier> <identifiersep> stack ( ) . find <identifiersep> <identifier> ( <identifier> . class ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 return http <identifiersep> client ; } \n \t1 private void add <identifiersep> <identifier> <identifiersep> config ( http <identifiersep> client <identifiersep> builder builder , \n \t8 http <identifiersep> client <identifiersep> <identifier> <identifier> ) { \n \t2 if ( <identifier> . is <identifiersep> <identifier> <identifiersep> enabled ( ) ) { \n <ect>
\t2 <comment> \n \t2 try { \n \t2 transport = t <identifiersep> timeout <identifiersep> transport . create ( address , timeout ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
import org . <identifier> . logger <identifiersep> factory ; \n public class <identifier> <identifiersep> <identifier> { \n \t1 final static logger logger = logger <identifiersep> factory . get <identifiersep> logger ( <identifier> <identifiersep> <identifier> . class ) ; \n \t1 public static void <identifier> ( string [ ] <identifier> ) { \n <ect>
\t3 <identifier> <identifiersep> <identifier> ( index ) ; \n \t3 assert <identifiersep> <identifier> ( client ( ) . <identifier> <identifiersep> request ( <string_literal> , index + <string_literal> ) ) ; \n \t3 list < <identifier> > shards = build <identifiersep> shards ( index , nodes , new <identifiersep> node <identifiersep> client ) ; \n \t3 <identifier> <identifier> = build <identifiersep> shards ( index , nodes , new <identifiersep> node <identifiersep> client ) . stream ( ) . filter ( <identifier> : : is <identifiersep> <identifier> ) . find <identifiersep> first ( ) . get ( ) ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> ) ; } \n \t1 protected void handle <identifiersep> <identifier> <identifiersep> key <identifiersep> response ( public <identifiersep> key <identifier> <identifiersep> public <identifiersep> key , byte [ ] <identifier> <identifiersep> <identifier> <identifiersep> key , \n \t10 byte [ ] version , address <identifier> ) throws exception { \n \t2 <identifier> < <identifier> <identifiersep> key , byte [ ] > <identifier> = null ; \n <ect>
\t4 system . get <identifiersep> property ( <string_literal> ) + <string_literal> + file <identifiersep> system <identifiersep> <identifier> <identifiersep> configuration . get <identifiersep> group ( ) + <string_literal> ) ; } \n \t3 files . <identifier> ( <identifier> <identifiersep> path , file <identifiersep> path , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) ; \n \t3 return true ; \n \t2 } catch ( exception e ) { \n <ect>
\t5 if ( <identifier> != null ) { \n \t6 s = <string_literal> + <identifier> ; \n \t5 } else { \n \t6 s = <string_literal> ; } \n <ect>
\t3 if ( thread <identifiersep> pool . get <identifiersep> thread <identifiersep> <identifier> ( ) == 0 && <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t4 return ; } \n \t3 new <identifiersep> url <identifiersep> <identifier> . <identifier> ( empty <identifiersep> <identifier> <identifiersep> time , time <identifiersep> unit . <identifier> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t2 object stop = exchange . get <identifiersep> property ( exchange . <identifier> <identifiersep> stop ) ; \n \t2 if ( stop != null ) { \n \t3 boolean do <identifiersep> stop = exchange . get <identifiersep> context ( ) . get <identifiersep> type <identifiersep> <identifier> ( ) . <identifier> <identifiersep> to ( boolean . class , stop ) ; \n \t3 if ( do <identifiersep> stop ) { \n <ect>
\t2 } catch ( exception ex ) { \n \t3 return ( t ) <identifier> . handle ( object . class , ex , <string_literal> , type ) ; } } \n \t1 @ <identifier> \n \t1 public < t > t get ( class < t > type , string name ) { \n <ect>
\t5 <comment> \n \t5 if ( node . get <identifiersep> application <identifiersep> update <identifiersep> <identifier> ( ) == true ) { \n \t6 logger . debug ( <string_literal> , node . get <identifiersep> node <identifiersep> id ( ) ) ; \n \t6 break ; } \n <ect>
\t4 <identifier> ( ) ; \n \t4 <identifier> <identifiersep> <identifier> ( data ) ; \n \t3 } ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n <ect>
\t1 log . debug ( <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t1 if ( <identifier> . do <identifiersep> update ( ) ) { \n \t2 int <identifier> = <identifier> . execute <identifiersep> update ( ) ; \n \t2 conn . <identifier> ( ) ; \n <ect>
\t2 try { \n \t3 log . debug ( <string_literal> , location ) ; \n \t3 <identifier> <identifiersep> <identifier> = <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> ( location , request ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
<number_literal> io <identifiersep> <identifier> <identifiersep> size ) ) ; \n \t5 <identifier> <identifiersep> output <identifiersep> stream <identifiersep> array [ <identifier> <identifiersep> <identifier> ] = new data <identifiersep> output <identifiersep> stream ( new <identifier> <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( data <identifiersep> file ) , \n <number_literal> io <identifiersep> <identifier> <identifiersep> size ) ) ; \n \t5 <identifier> <identifiersep> <identifier> ++ ; } } } \n <ect>
\t4 table <identifiersep> state table <identifiersep> state = table <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> table <identifiersep> state ( table <identifiersep> id ) ; \n \t4 if ( table <identifiersep> state != null && table <identifiersep> state != table <identifiersep> state . <identifier> ) { \n \t5 <comment> \n \t5 if ( ! <identifier> <identifiersep> dir . <identifier> <identifiersep> with ( <identifier> . <identifier> <identifiersep> <identifier> ) ) \n <ect>
\t1 if ( <identifier> <identifiersep> key == null ) { \n \t1 log . error ( <string_literal> ) ; \n \t1 return null ; } \n \t1 if ( <identifier> == null ) { \n <ect>
\t1 boolean <identifier> = get <identifiersep> <identifier> ( conf ) ; \n \t1 log . info ( <string_literal> , <identifier> <identifiersep> size ) ; \n \t1 log . info ( <string_literal> , <identifier> . get <identifiersep> <identifier> <identifiersep> size <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 while ( <identifier> . has <identifiersep> next ( ) ) { \n \t4 <identifier> . next ( ) ; \n \t4 <identifier> . remove ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
\t3 <identifier> <identifiersep> name . set <identifiersep> text <identifiersep> content ( name ) ; \n \t3 name <identifiersep> node . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> name ) ; \n \t3 return <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> ) ; \n \t2 } catch ( <identifier> <identifiersep> configuration <identifiersep> exception e ) { \n <ect>
\t3 thread . <identifier> ( <number_literal> ) ; \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 throw new runtime <identifiersep> exception ( e ) ; } \n \t2 <identifier> . get <identifiersep> file ( ) . delete ( ) ; \n <ect>
\t3 string value = <identifier> <identifiersep> id <identifiersep> to <identifiersep> value . get ( <identifier> . get <identifiersep> id ( ) ) ; \n \t3 string <identifier> <identifiersep> in = <identifier> . get <identifiersep> <identifier> <identifiersep> in ( ) ; \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> in == null || <identifier> <identifiersep> in . <identifier> ( ) . length ( ) == 0 ) { \n <ect>
\t5 <identifier> <identifiersep> properties , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> ( ( <identifier> ) <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> data <identifiersep> exception | property <identifiersep> exception e ) { \n <ect>
\t3 result = <identifier> . get ( <identifier> <identifiersep> name ) ; \n \t3 if ( result == null && <identifier> <identifiersep> name != null && <identifier> <identifiersep> name . equals ( <identifier> <identifiersep> service . default <identifiersep> <identifier> <identifiersep> name ) ) { \n \t4 result = find <identifiersep> first ( ) ; \n \t4 if ( result != null ) { \n <ect>
\t2 file <identifiersep> output <identifiersep> stream <identifier> = new file <identifiersep> output <identifiersep> stream ( <string_literal> ) ; \n \t2 <identifier> . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; \n \t2 <identifier> . <identifier> ( ) ; \n \t2 <identifier> . close ( ) ; \n <ect>
\t1 <comment> void <identifier> <identifiersep> <identifier> ( transaction transaction ) { \n \t2 boolean <identifier> <identifiersep> queue = false ; \n \t2 synchronized ( this ) { \n \t3 if ( ! <identifier> <identifiersep> <identifier> . contains ( transaction ) ) \n <ect>
\t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t3 if ( static <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t4 static <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> application <identifiersep> context ( ) ; } } \n \t2 catch ( <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t5 e ) ; } \n \t2 catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n \t3 throw new api <identifiersep> exception ( <string_literal> , new object [ ] { default <identifiersep> value . get <identifiersep> class ( ) . get <identifiersep> name ( ) } , e ) ; } \n \t2 catch ( exception e ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t4 <identifier> . <identifier> ( <string_literal> , <identifier> , <identifier> <identifiersep> <identifier> . get <identifiersep> context ( ) ) ; \n \t4 <comment> \n \t4 return <identifier> <identifiersep> <identifier> . execute ( ( ( <identifier> <identifiersep> <identifier> ) <identifier> ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> , <identifier> , input , filter , <identifier> <identifiersep> <identifier> ) ; } \n <ect>
\t2 object result = null ; \n \t2 array <identifiersep> stack < object > <identifier> <identifiersep> stack = <identifier> <identifiersep> by <identifiersep> name . get ( stack <identifiersep> name ) ; \n \t2 if ( <identifier> <identifiersep> stack == null ) { \n <ect>
\t2 assert <identifiersep> that ( <identifier> <identifiersep> response . get <identifiersep> total <identifiersep> shards ( ) , equal <identifiersep> to ( num <identifiersep> shards . total <identifiersep> num <identifiersep> shards ) ) ; \n \t2 assert <identifiersep> that ( <identifier> <identifiersep> response . get <identifiersep> <identifier> <identifiersep> shards ( ) , equal <identifiersep> to ( num <identifiersep> shards . num <identifiersep> <identifier> ) ) ; \n \t2 assert <identifiersep> that ( <identifier> <identifiersep> response . get <identifiersep> failed <identifiersep> shards ( ) , equal <identifiersep> to ( 0 ) ) ; \n \t2 <identifier> <identifiersep> nodes ( <string_literal> , <number_literal> ) ; \n <ect>
\t3 if ( new <identifiersep> host <identifiersep> id != host <identifiersep> id ) { \n \t4 <comment> \n \t4 set <identifiersep> id ( new <identifiersep> host <identifiersep> id ) ; } \n <ect>
\t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> to , e ) ; } \n \t2 if ( ! dir . exists ( ) ) { \n \t3 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> to ) ; } \n \t2 <identifier> <identifiersep> to <identifiersep> dir = dir ; \n <ect>
\t2 while ( port <identifiersep> list . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 <identifier> <identifiersep> port <identifiersep> <identifier> id = ( <identifier> <identifiersep> port <identifiersep> <identifier> ) port <identifiersep> list . next <identifiersep> element ( ) ; \n \t3 if ( id . get <identifiersep> port <identifiersep> type ( ) == <identifier> <identifiersep> port <identifiersep> <identifier> . port <identifiersep> <identifier> ) { \n \t4 if ( id . get <identifiersep> name ( ) . equals ( port ) ) { \n <ect>
\t3 while ( line != null ) { \n \t4 <identifier> . <identifier> ( line ) ; \n \t4 <identifier> . <identifier> ( ' \\ <identifier> ) ; \n \t4 line = <identifier> <identifiersep> status <identifiersep> <identifier> . read <identifiersep> line ( ) ; } \n <ect>
\t4 logger . info ( e . get <identifiersep> message ( ) ) ; \n \t4 logger . debug ( utils . get <identifiersep> stack <identifiersep> trace ( e ) ) ; \n \t4 logger . debug ( <string_literal> , this . get <identifiersep> <identifier> ( ) ) ; } \n \t2 } else { \n <ect>
\t2 this . conf = conf ; } \n \t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> ( input <identifiersep> stream is , output <identifiersep> stream <identifier> , exchange exchange ) throws exception { \n \t2 log . debug ( <string_literal> , conf . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n <ect>
\t9 <identifier> . remove ( ) ; \n \t8 } catch ( io <identifiersep> exception ex ) { \n \t9 logger . debug ( ( ) - > new <identifier> <identifiersep> message ( <string_literal> , <identifier> <identifiersep> lock . get <identifiersep> <identifier> <identifiersep> id ( ) ) , ex ) ; } \n \t7 } else { \n <ect>
<comment> \n \t1 protected string get <identifiersep> registered <identifiersep> service <identifiersep> <identifier> <identifiersep> property ( final registered <identifiersep> service service , final registered <identifiersep> service <identifiersep> property . registered <identifiersep> service <identifiersep> properties <identifier> <identifiersep> name ) { \n \t2 if ( service == null || ! service . get <identifiersep> access <identifiersep> <identifier> ( ) . is <identifiersep> service <identifiersep> access <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 add <identifiersep> <identifier> <identifiersep> server ( <identifier> <identifiersep> server <identifiersep> name , <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> ip , <identifier> <identifiersep> port , load <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; } } \n \t3 <identifier> <identifiersep> configuration ( ) ; \n \t3 return new answer ( cmd ) ; \n \t2 } catch ( execution <identifiersep> exception e ) { \n <ect>
\t3 logger . info ( <string_literal> , wait <identifiersep> for ) ; \n \t3 <identifier> <identifiersep> <identifier> = total <identifiersep> num <identifiersep> <identifier> / <number_literal> ; \n \t3 wait <identifiersep> for += <identifier> <identifiersep> <identifier> ; \n \t3 <identifier> . continue <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; \n <ect>
\t3 stream <identifiersep> <identifier> . <identifier> ( process . get <identifiersep> input <identifiersep> stream ( ) , true ) ; \n \t3 int <identifier> = wait <identifiersep> for ( process ) ; \n \t3 if ( <identifier> == 0 ) { \n \t4 <identifier> = true ; \n <ect>
\t3 <identifier> . <identifier> <identifiersep> default <identifiersep> <identifier> ( ) ; \n \t3 <identifier> . set <identifiersep> <identifier> <identifiersep> header <identifiersep> value ( <identifier> <identifiersep> header <identifiersep> value ) ; \n \t3 <identifier> . set <identifiersep> <identifier> <identifiersep> method <identifiersep> header <identifiersep> <identifier> ( content <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 <identifier> . set <identifiersep> key ( <identifier> <identifiersep> key <identifiersep> <identifier> <identifiersep> key ) ; \n <ect>
\t1 public void process <identifiersep> <identifier> <identifiersep> configuration ( string context , item item , string <identifier> <identifiersep> config ) \n \t3 throws <identifier> <identifiersep> config <identifiersep> parse <identifiersep> exception { \n \t2 super . process <identifiersep> <identifier> <identifiersep> configuration ( context , item , <identifier> <identifiersep> config ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> config config = <identifier> . parse ( item , <identifier> <identifiersep> config ) ; \n <ect>
\t3 catch ( sql <identifiersep> exception ex ) { \n \t4 logger . debug ( <string_literal> , ex ) ; } \n \t3 catch ( throwable ex ) { \n \t4 <comment> \n <ect>
\t3 if ( <identifier> . get <identifiersep> type ( ) == null ) { \n \t4 logger . warn ( <string_literal> ) ; \n \t4 return false ; } \n \t3 if ( string <identifiersep> utils . is <identifiersep> blank ( <identifier> . get <identifiersep> <identifier> <identifiersep> url ( ) ) ) { \n <ect>
\t5 break ; } \n \t2 } catch ( exception e ) { \n \t3 throw new <identifier> <identifiersep> config <identifiersep> parse <identifiersep> exception ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> device <identifiersep> type ) ; } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> item <identifiersep> type == null ) { \n <ect>
\t8 response . <identifier> <identifiersep> or <identifiersep> transaction <identifiersep> <identifier> <identifiersep> not <identifiersep> <identifier> , \n \t8 request ) ; } \n \t3 catch ( parse <identifiersep> exception e ) \n \t3 { \n <ect>
\t3 <identifier> <identifier> = <identifier> . <identifier> ( <identifier> <identifiersep> name ) ; \n \t3 context = <identifier> . time ( ) ; \n \t3 exchange . set <identifiersep> property ( property <identifiersep> name , context ) ; \n \t2 } else { \n <ect>
\t2 return return <identifiersep> <identifier> ; \n \t1 } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception e ) { \n \t2 logger . debug ( <string_literal> , input . get <identifiersep> id ( ) ) ; \n \t2 public <identifiersep> ip <identifiersep> address return <identifiersep> <identifier> = <identifier> <identifiersep> ip <identifiersep> address <identifiersep> in <identifiersep> network ( input , client , <identifier> <identifiersep> <identifier> <identifiersep> job <identifiersep> <identifier> <identifiersep> and <identifiersep> return <identifiersep> result ) ; \n <ect>
\t2 log . info ( <string_literal> ) ; \n \t2 send <identifiersep> connection = create <identifiersep> send <identifiersep> connection ( ) ; \n \t2 log . info ( <string_literal> ) ; \n \t2 send <identifiersep> connection . start ( ) ; \n <ect>
\t3 response . set <identifiersep> <identifier> ( host <identifiersep> <identifier> ) ; \n \t3 response . set <identifiersep> response <identifiersep> name ( get <identifiersep> command <identifiersep> name ( ) ) ; \n \t3 this . set <identifiersep> response <identifiersep> object ( response ) ; \n \t2 } catch ( <identifier> <identifiersep> exception ex ) { \n <ect>
\t2 <comment> \n \t2 <comment> \n \t2 do <identifiersep> in <identifiersep> <identifier> ( this : : entity <identifiersep> manager <identifiersep> factory , entity <identifiersep> manager - > { \n \t3 <identifier> <identifier> = entity <identifiersep> manager . find ( <identifier> . class , <identifier> ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void output <identifiersep> <identifier> ( ) { \n \t2 final integer new <identifiersep> <identifier> = class <identifiersep> to <identifiersep> <identifier> <identifiersep> map . values ( ) . stream ( ) . map ( map : : values ) \n \t4 . <identifier> <identifiersep> map ( collection : : stream ) . <identifier> ( <identifier> <identifiersep> and <identifiersep> <identifier> ( to <identifiersep> set ( ) , set : : size ) ) ; \n <ect>
\t2 super ( configuration ) ; \n \t2 this . client = null ; } \n \t1 @ <identifier> \n \t1 public list < service <identifiersep> <identifier> > get <identifiersep> <identifier> ( string name ) { \n <ect>
\t3 return true ; } \n \t2 <comment> \n \t2 network <identifiersep> <identifier> <identifiersep> map <identifiersep> vo <identifier> <identifiersep> for <identifiersep> network = <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> map <identifiersep> dao . find <identifiersep> by <identifiersep> network <identifiersep> id ( network . get <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> <identifiersep> for <identifiersep> network == null ) { \n <ect>
\t3 <identifier> . add <identifiersep> and ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> . <identifier> , id ) ; \n \t3 <identifier> . add <identifiersep> and ( <string_literal> , <identifier> <identifiersep> <identifier> . <identifier> . null ) ; \n \t3 list < <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> policy <identifiersep> vo > <identifier> <identifiersep> v <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> load <identifiersep> <identifier> <identifiersep> policy <identifiersep> dao . <identifier> ( <identifier> , null ) ; \n \t3 if ( <identifier> <identifiersep> v <identifiersep> <identifier> . size ( ) > 1 ) { \n <ect>
\t2 this . data = data ; \n \t2 this . <identifier> <identifiersep> id = <identifier> <identifiersep> id ; } \n \t1 @ <identifier> \n \t1 public < t > object execute ( t . . . <identifier> ) { \n <ect>
\t5 s <identifiersep> logger . warn ( <string_literal> ) ; \n \t5 continue ; } \n \t4 if ( <identifier> <identifiersep> state == null ) { \n \t5 s <identifiersep> <identifier> . put ( <identifier> <identifiersep> cluster , host <identifiersep> <identifier> , vm , new <identifiersep> state ) ; \n <ect>
\t1 public void test <identifiersep> x <identifiersep> path <identifiersep> s <identifiersep> <identifier> <identifiersep> x <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n \t2 <identifier> <identifiersep> builder <identifier> = new <identifier> <identifiersep> builder ( context ) . <identifier> <identifiersep> <identifier> ( size ) . create ( ) ; \n \t2 boolean <identifier> = <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ; \n \t2 log . info ( <string_literal> + size + <string_literal> + time <identifiersep> utils . <identifier> <identifiersep> <identifier> ( <identifier> . stop ( ) ) ) ; \n <ect>
\t6 log . debug ( string . format ( <string_literal> , <identifier> . get <identifiersep> instance <identifiersep> id ( ) ) ) ; \n \t6 final create <identifiersep> <identifier> <identifiersep> task task = <identifier> . <identifier> ( <identifier> ) ; \n \t6 if ( task != null ) { \n \t7 create <identifiersep> <identifier> <identifiersep> <identifier> . put ( <identifier> . get <identifiersep> instance <identifiersep> id ( ) , task ) ; \n <ect>
\t1 if ( ! command . is <identifiersep> <identifier> ( ) ) { \n \t2 logger . error ( <string_literal> , command ) ; \n \t2 return false ; } \n \t1 if ( command . <identifier> <identifiersep> <identifier> <identifiersep> count ( ) > <identifier> <identifiersep> count <identifiersep> <identifier> ) { \n <ect>
\t4 if ( <identifier> != null ) { \n \t5 return <identifier> ; } \n \t3 } catch ( exception e ) { \n \t4 <comment> \n <ect>
\t3 <identifier> <identifiersep> <identifier> . update <identifiersep> <identifier> ( <identifier> <identifiersep> directory , <identifier> , <identifier> ) ; \n \t3 <identifier> <identifiersep> status . set <identifiersep> property ( <string_literal> , <identifier> . format ( current <identifiersep> time ) , type . date ) ; \n \t3 <identifier> = true ; \n \t2 } catch ( throwable e ) { \n <ect>
\t5 assert <identifier> . <identifier> ( ) || <identifier> . <identifier> <identifiersep> by <identifiersep> thread ( thread <identifiersep> id ) || is <identifiersep> <identifier> <identifiersep> <identifier> ( ) : \n \t6 <string_literal> + <identifier> + <string_literal> + this + \n \t7 <string_literal> + <identifier> . node <identifiersep> id ( ) + <string_literal> + thread <identifiersep> id + ' ] ' ; \n <ect>
\t6 log . debug ( <string_literal> + <identifier> . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) ) ; \n \t6 for ( int i = 0 ; i < <identifier> . get <identifiersep> number <identifiersep> of <identifiersep> <identifier> ( ) ; i ++ ) { \n \t7 log . debug ( <string_literal> + i + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) . get ( i ) . get <identifiersep> <identifier> <identifiersep> location ( ) ) ; \n \t7 log . debug ( <string_literal> + i + <string_literal> + <identifier> . get <identifiersep> <identifier> ( ) . get ( i ) . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t3 int length = <identifier> . get <identifiersep> <identifier> <identifiersep> count ( ) ; \n \t3 if ( length > 0 ) { \n \t4 content = <identifier> <identifiersep> string ( <identifier> ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t3 @ <identifier> \n \t3 public void <identifier> ( ) { \n \t4 try { \n \t5 <comment> <ect>
\t4 continue ; } \n \t3 final attribute attribute = attribute . for <identifiersep> name ( <identifier> . get <identifiersep> attribute <identifiersep> local <identifiersep> name ( i ) ) ; \n \t3 switch ( attribute ) { \n \t4 case version : \n <ect>
\t1 path <identifier> = new path ( <identifier> <identifiersep> <identifier> , <string_literal> ) ; \n \t1 if ( ! <identifier> . exists ( <identifier> ) ) { \n \t2 throw new exception ( <string_literal> + <identifier> ) ; \n \t1 } else if ( ! <identifier> . exists ( <identifier> ) ) { \n <ect>
\t5 map < string , string > server <identifiersep> <identifier> = get <identifiersep> server <identifiersep> config ( node . get <identifiersep> id ( ) , config <identifiersep> <identifier> <identifiersep> to <identifiersep> request ) ; \n \t5 for ( entry <identifier> <identifiersep> config : <identifier> <identifiersep> config <identifiersep> map . entry <identifiersep> set ( ) ) { \n \t6 string server <identifiersep> config <identifiersep> value = server <identifiersep> <identifier> . get ( <identifier> <identifiersep> config . get <identifiersep> key ( ) ) ; \n \t6 if ( server <identifiersep> config <identifiersep> value == null ) { \n <ect>
\t1 private int get <identifiersep> <identifier> <identifiersep> value ( <identifier> <identifiersep> <identifier> <identifiersep> provider provider , string <identifier> <identifiersep> id , int address , string <identifier> <identifiersep> address , \n \t3 boolean <identifier> <identifiersep> <identifier> ) throws <identifier> <identifiersep> exception { \n \t2 integer value = provider . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> value ( address ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> || value == null ) { \n <ect>
\t2 public void on <identifiersep> failure ( exception e ) { \n \t3 if ( <identifier> . <identifier> <identifiersep> or <identifiersep> <identifier> ( ) ) { \n \t4 logger . trace ( <string_literal> , e ) ; \n \t3 } else { \n <ect>
\t4 <identifier> <identifiersep> log . debug ( <string_literal> + <identifier> + <string_literal> + <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . add ( <identifier> , <identifier> ) ; \n \t2 } catch ( illegal <identifiersep> argument <identifiersep> exception <identifier> ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 configuration job <identifiersep> conf = null ; \n \t2 try { \n \t3 job <identifiersep> conf = new x <identifiersep> configuration ( new string <identifiersep> <identifier> ( job . get <identifiersep> conf ( ) ) ) ; } \n \t2 catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t7 <identifier> <identifiersep> io . write ( <identifier> <identifiersep> <identifier> , file <identifiersep> <identifier> , out <identifiersep> stream ) ; \n \t7 resource <identifiersep> service . <identifier> <identifiersep> content ( <identifier> <identifiersep> content ( file <identifiersep> name , <identifier> <identifiersep> path ) , user <identifiersep> <identifier> <identifiersep> context . get <identifiersep> <identifier> ( ) , \n \t9 new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( out <identifiersep> stream . to <identifiersep> byte <identifiersep> array ( ) ) , <identifier> <identifiersep> <identifier> . get <identifiersep> account <identifiersep> id ( ) ) ; \n \t6 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 <comment> \n \t2 for ( int <identifier> = 0 ; <identifier> < <identifier> . get <identifiersep> length ( ) ; <identifier> ++ ) { \n \t3 element group = ( element ) <identifier> . item ( <identifier> ) ; \n \t3 string name = group . get <identifiersep> attribute ( <identifier> <identifiersep> <identifier> . name ) ; \n <ect>
\t2 } catch ( final <identifier> <identifiersep> api <identifiersep> exception e ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> , e ) ; \n \t3 error <identifiersep> msg = e . to <identifiersep> string ( ) ; \n \t2 } catch ( final xml <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 this ( <identifier> <identifiersep> file , <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; } \n \t1 @ <identifier> \n \t1 synchronized public void load ( transaction <identifier> ) throws io <identifiersep> exception { \n \t2 if ( <identifier> . <identifier> <identifiersep> and <identifiersep> set ( false , true ) ) { \n <ect>
\t4 <comment> \n \t4 <comment> \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) { \n \t5 long <identifier> = <identifier> - <identifier> <identifiersep> <identifier> <identifiersep> set . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> date ( ) ; \n <ect>
\t6 assert job <identifiersep> <identifier> != null ; \n \t6 assert job <identifiersep> <identifier> <identifiersep> bean == <identifier> <identifiersep> bean ; \n \t6 log . info ( <string_literal> + log ) ; \n \t6 log . info ( <string_literal> + <identifier> ) ; \n <ect>
\t3 boolean <identifier> <identifiersep> <identifier> = false ; \n \t3 synchronized ( this ) { \n \t4 if ( <identifier> && ! <identifier> ) { \n \t5 if ( ! <identifier> ) \n <ect>
\t4 <identifier> . stop ( ) ; \n \t4 s <identifiersep> logger . error ( <string_literal> + response + <string_literal> + <identifier> <identifiersep> service <identifiersep> url + <string_literal> + method . get <identifiersep> <identifier> ( <string_literal> ) + <string_literal> + \n \t6 <identifier> . get <identifiersep> <identifier> <identifiersep> in <identifiersep> millis ( ) ) ; } \n \t2 } catch ( final http <identifiersep> exception e ) { \n <ect>
\t3 <identifier> , <identifier> <identifiersep> <identifier> , <identifier> ) ; } \n \t1 @ <identifier> \n \t1 protected void do <identifiersep> catch ( throwable e ) throws throwable { \n \t2 state = <identifier> <identifiersep> <identifier> <identifiersep> state . <identifier> <identifiersep> failed ; \n <ect>
\t2 { \n \t3 debug <identifiersep> listener . path <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> operation ( <identifier> ) ; } \n \t2 if ( client . get <identifiersep> state ( ) == <identifier> <identifiersep> <identifier> <identifiersep> state . <identifier> ) \n \t2 { \n <ect>
\t1 protected static class <identifier> <identifiersep> server { \n \t2 private map < string , object > <identifier> ; \n \t2 public string process ( @ <identifier> map < string , object > <identifier> , string body ) { \n \t3 this . <identifier> = <identifier> ; \n <ect>
protected void log <identifiersep> and <identifiersep> <identifier> ( <identifier> <identifiersep> server server , string query ) throws io <identifiersep> exception { \n \t1 log <identifiersep> and <identifiersep> <identifier> ( server , query , 1 ) ; } \n protected void log <identifiersep> and <identifiersep> <identifier> ( <identifier> <identifiersep> server server , string query , int line <identifiersep> number ) throws io <identifiersep> exception { \n \t1 assert line <identifiersep> number > 0 : <string_literal> ; \n <ect>
\t3 <identifier> . get <identifiersep> <identifier> ( ) . put ( <identifier> . <identifier> . response . <identifier> <identifiersep> id , <identifier> <identifiersep> id ) ; \n \t3 try { \n \t4 send <identifiersep> to <identifiersep> <identifier> ( <identifier> ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 for ( source in <identifier> ) { \n \t3 url url \n \t3 if ( is <identifiersep> <identifier> ) { \n \t4 source = source . <identifier> <identifiersep> all ( ' \\ \\ \\ \\ ' , ' ' ) } \n <ect>
\t7 throw new exception ( <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> path + <string_literal> + <identifier> <identifiersep> host <identifiersep> name ) ; } \n \t6 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> source <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( get <identifiersep> service <identifiersep> context ( ) , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> source ) ; \n \t6 string <identifier> <identifiersep> host <identifiersep> value = <identifier> <identifiersep> <identifier> <identifiersep> host . get <identifiersep> <identifier> ( ) . get <identifiersep> value ( ) ; \n \t6 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> source <identifiersep> <identifier> . is <identifiersep> <identifier> <identifiersep> to <identifiersep> host ( <identifier> <identifiersep> host <identifiersep> value ) ) { \n <ect>
\t3 return get <identifiersep> <identifier> <identifiersep> for <identifiersep> user <identifiersep> request ( command <identifiersep> <identifier> ) ; \n \t2 } else if ( <identifier> . <identifier> == <identifier> . value <identifiersep> of ( get <identifiersep> <identifier> ( ) . name ( ) ) ) { \n \t3 return get <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( command <identifiersep> <identifier> ) ; \n \t2 } else { \n <ect>
\t2 <identifier> <identifiersep> context context = <identifier> <identifiersep> context . get <identifiersep> instance ( <string_literal> ) ; \n \t2 context . <identifier> ( ( key <identifiersep> manager [ ] ) null , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , ( <identifier> <identifiersep> <identifier> ) null ) ; \n \t2 this . <identifier> <identifiersep> socket <identifiersep> factory = context . get <identifiersep> socket <identifiersep> factory ( ) ; \n \t1 } catch ( exception ex ) { \n <ect>
\t4 break ; \n \t3 default : \n \t4 break ; } \n \t2 } catch ( content <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t5 this . store . stop ( ) ; \n \t4 } catch ( exception e ) { \n \t5 log . error ( <string_literal> , this . name , e ) ; } } } } \n \t1 void <identifier> <identifiersep> job ( job <identifiersep> location job ) throws illegal <identifiersep> state <identifiersep> exception , io <identifiersep> exception { \n <ect>
\t3 result . set <identifiersep> success <identifiersep> is <identifiersep> set ( true ) ; \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n <ect>
\t1 <identifier> . write ( <identifier> <identifiersep> <identifier> . <identifier> ( content ) ) ; \n \t1 } catch ( final <identifier> <identifiersep> runtime <identifiersep> exception e ) { \n \t1 on <identifiersep> exception ( e ) ; \n \t1 final string resource <identifiersep> uri = resource == null ? string <identifiersep> utils . empty : <string_literal> + resource . get <identifiersep> uri ( ) + <string_literal> ; \n <ect>
\t2 <identifier> ( ) . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) . <identifier> ( consumer : : is <identifiersep> <identifier> ) ; \n \t2 <comment> \n \t2 <comment> \n \t2 <comment> \n <ect>
\t1 } else { \n \t2 log . info ( <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> instance <identifiersep> id ( ) + \n \t2 <string_literal> ) ; } \n \t1 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> = <identifier> ; \n \t2 <identifier> <identifiersep> dao <identifier> <identifiersep> dao = <identifier> . get <identifiersep> <identifier> <identifiersep> network <identifiersep> <identifier> <identifiersep> factory ( ) . get <identifiersep> <identifier> <identifiersep> dao ( ) ; \n \t2 <identifier> <identifier> = <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id ( <identifier> <identifiersep> remote <identifiersep> access <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> state ( ) != state . <identifier> ) { \n <ect>
\t3 <comment> \n \t3 <identifier> . <identifier> ( <string_literal> , <identifier> . empty <identifiersep> map ( ) ) ; \n \t3 <identifier> . success ( ) ; \n \t2 } catch ( throwable t ) { \n <ect>
\t1 return out ; } \n public list < web <identifiersep> socket <identifiersep> filter > get <identifiersep> <identifier> ( ) { \n \t1 return <identifier> ; } \n protected void <identifier> <identifiersep> filter <identifiersep> <identifier> <identifiersep> error ( throwable throwable , string filter <identifiersep> class <identifiersep> name , logger logger ) { \n <ect>
\t4 if ( host != null ) { \n \t5 s <identifiersep> logger . warn ( <string_literal> + <identifier> . name ) ; \n \t5 answer answer = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send ( host . get <identifiersep> id ( ) , <identifier> ( <identifier> . name ) ) ; \n \t5 if ( ! answer . get <identifiersep> result ( ) ) { \n <ect>
\t4 s <identifiersep> logger . warn ( <string_literal> , e ) ; } \n \t3 break ; \n \t2 case <identifier> : \n \t2 case <identifier> : \n <ect>
\t5 <string_literal> + num <identifiersep> <identifier> <identifiersep> <identifier> . get ( ) ) ; \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> byte <identifiersep> <identifier> ) { \n \t4 log . info ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> string ( <string_literal> , <identifier> . <identifier> <identifiersep> first <identifiersep> key <identifiersep> size ) ) ; \n \t4 log . info ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> to <identifiersep> string ( <string_literal> , <identifier> . <identifier> <identifiersep> next <identifiersep> first <identifiersep> key <identifiersep> size ) ) ; \n <ect>
\t4 <comment> \n \t4 if ( in == null && new file ( file ) . exists ( ) ) \n \t5 in = new file <identifiersep> input <identifiersep> stream ( new file ( file ) ) ; \n \t4 if ( in == null ) { \n <ect>
\t1 <comment> \n \t1 protected void <identifier> <identifiersep> <identifier> ( ) { \n \t2 string <identifier> <identifiersep> url = this . config . get <identifiersep> <identifier> <identifiersep> url ( ) ; \n \t2 if ( ( <identifier> <identifiersep> url != null ) && this . config . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> on <identifiersep> close ( ) ) { \n <ect>
\t3 file class <identifiersep> file = new file ( java <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) . <identifier> ( <string_literal> , <string_literal> ) ) ; \n \t3 class <identifiersep> file . delete <identifiersep> on <identifiersep> <identifier> ( ) ; \n \t3 assert . assert <identifiersep> true ( class <identifiersep> file . exists ( ) ) ; \n \t3 class <identifiersep> files . add ( class <identifiersep> file ) ; \n <ect>
\t2 { \n \t3 throw new <identifier> <identifiersep> error ( e ) ; <comment> \n \t2 catch ( request <identifiersep> execution <identifiersep> exception e ) \n \t2 { \n <ect>
\t3 <comment> \n \t3 <identifier> . <identifier> ( ) ; \n \t3 return response ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 assert . assert <identifiersep> true ( <string_literal> . equals ( s ) ) ; \t2 \n \t2 s = set . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <string_literal> ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> + s ) ; \n \t2 assert . assert <identifiersep> true ( <string_literal> . equals ( s ) ) ; \n <ect>
\t5 synchronized ( <identifier> <identifiersep> <identifier> <identifiersep> lock ) { \n \t6 <identifier> = ( <identifier> <identifiersep> connection ) <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> . put ( <identifier> , <identifier> ) ; } \n \t5 if ( <identifier> != null ) { \n \t6 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 return false ; } \n \t2 final string <identifier> <identifiersep> <identifier> = method . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> method <identifiersep> <identifier> <identifiersep> <identifier> . equals ( <identifier> <identifiersep> <identifier> ) && method . is <identifiersep> public ( ) && method . is <identifiersep> static ( ) ) { \n \t3 if ( is <identifiersep> <identifier> ( ) ) { \n <ect>
\t1 public void message <identifiersep> <identifier> ( <identifier> <identifiersep> session session , int msg <identifiersep> id , long size ) { } \n \t1 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> session session , int <identifier> ) { } \n \t1 public void <identifier> ( <identifier> <identifiersep> session session ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 throw new <identifier> <identifiersep> operation <identifiersep> exception ( <string_literal> ) ; } \n \t1 @ <identifier> \n \t1 public list < string > list ( string <identifier> ) throws exception { \n \t2 list < string > <identifier> = get <identifiersep> <identifier> ( ) . list ( <identifier> ) ; \n <ect>
\t4 try { \n \t5 if ( connection != null ) { \n \t6 connection . close ( ) ; } \n \t4 } catch ( exception e ) { \n <ect>
\t9 <identifier> . <identifier> ( <identifier> ) ; \n \t9 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( 0 , <identifier> . size ( ) - 1 ) ; } } } \n \t5 } catch ( exception e ) { \n \t6 thread <identifiersep> <identifier> . add <identifiersep> error ( e ) ; \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> host <identifier> <identifiersep> host = host <identifiersep> service . get <identifiersep> <identifier> <identifiersep> host ( context , cmd ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> vm <identifiersep> <identifier> = <identifier> <identifiersep> host . find <identifiersep> vm <identifiersep> on <identifiersep> <identifier> <identifiersep> host ( cmd . get <identifiersep> vm <identifiersep> name ( ) ) ; \n \t3 if ( vm <identifiersep> <identifier> == null ) { \n <ect>
\t2 <comment> \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> instance ( ) . delete <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> group ( <identifier> <identifiersep> name , true , \n \t3 <identifier> . <identifier> <identifiersep> system <identifiersep> account ( ) ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t2 string <identifier> <identifiersep> property = system . get <identifiersep> property ( <identifier> <identifiersep> system <identifiersep> property ) ; \n \t2 if ( <identifier> <identifiersep> property != null ) { \n \t3 try { \n \t4 <identifier> = integer . parse <identifiersep> int ( <identifier> <identifiersep> property ) ; \n <ect>
\t4 <identifier> <identifiersep> with <identifiersep> catch ( <identifier> ) ; } \n \t2 } , <identifier> <identifiersep> manager . get <identifiersep> <identifier> ( <identifier> . <identifier> ) ) ; \n \t2 boolean <identifier> = <identifier> <identifiersep> <identifier> . add ( <identifier> ) ; \n \t2 if ( ! <identifier> ) \n <ect>
\t3 <identifier> . config <identifiersep> log . info ( <string_literal> + <identifier> <identifiersep> port ) ; \n \t3 <identifier> <identifiersep> server = <identifier> <identifiersep> server . create <identifiersep> <identifier> <identifiersep> server ( <identifier> <identifiersep> port ) ; \n \t3 try { <identifier> <identifiersep> server . start ( ) ; } \n \t3 catch ( java . <identifier> . <identifier> <identifiersep> exception ex ) \n <ect>
\t3 string line ; \n \t3 while ( ( line = <identifier> . read <identifiersep> line ( ) ) != null ) { \n \t4 <identifier> <identifiersep> filter . put ( line ) ; } \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 get <identifiersep> context ( ) . <identifier> <identifiersep> manager ( ) . add <identifiersep> <identifier> <identifiersep> data ( <string_literal> , get <identifiersep> context ( ) . <identifier> ( ) . <identifier> ( ) - <identifier> <identifiersep> send <identifiersep> time ) ; \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( index ) ; \n \t2 <identifier> = client ( ) . <identifier> <identifiersep> <identifier> ( index ) . set <identifiersep> query ( <identifier> <identifiersep> all <identifiersep> query ( ) ) . get ( ) ; \n \t2 assert <identifiersep> that ( <string_literal> , <identifier> . get <identifiersep> <identifier> ( ) . get <identifiersep> total <identifiersep> <identifier> ( ) , equal <identifiersep> to ( <identifier> ) ) ; \n \t2 <comment> \n <ect>
\t2 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> file ( <identifier> <identifiersep> i <identifiersep> stream , <identifier> <identifiersep> o <identifiersep> stream , <identifier> , <identifier> <identifiersep> files ) ; \n \t2 file <identifiersep> input <identifiersep> stream <identifier> <identifiersep> result <identifiersep> stream = new file <identifiersep> input <identifiersep> stream ( <identifier> + <string_literal> ) ; \n \t2 input <identifiersep> stream <identifier> = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> string . get <identifiersep> bytes ( <string_literal> ) ) ; \n \t2 <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> result <identifiersep> stream ) ; \n <ect>
\t3 log . info ( <string_literal> ) ; \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> <identifier> = create <identifiersep> <identifier> <identifiersep> session <identifiersep> <identifier> <identifiersep> response ( ! session <identifiersep> <identifier> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> . process <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t3 log . <identifier> ( <string_literal> , host ) ; \n \t3 return true ; \n \t2 } catch ( server <identifiersep> request . http <identifiersep> failure failure ) { \n \t3 log . error ( <string_literal> ) ; \n <ect>
\t3 <identifier> <identifier> = <identifier> . new <identifiersep> <identifier> ( ) ; \n \t3 <comment> \n \t3 input <identifiersep> stream <identifier> <identifiersep> item <identifiersep> input <identifiersep> stream = xml <identifiersep> <identifier> . get <identifiersep> input <identifiersep> stream ( <identifier> <identifiersep> item <identifiersep> url ) ; \n \t3 <identifier> . <identifier> ( new stream <identifiersep> source ( <identifier> <identifiersep> item <identifiersep> input <identifiersep> stream ) ) ; \n <ect>
\t3 { <comment> \n \t4 logger . error ( <string_literal> , data ) ; \n \t4 throwable <identifier> = <identifier> . <identifier> ( ( throwable ) null , data : : <identifier> ) ; \n \t4 if ( <identifier> != null ) \n <ect>
\t2 if ( <identifier> == null ) { \n \t3 <identifier> <identifiersep> file <identifiersep> <identifier> . value = true ; <comment> \n \t2 return result ; \n \t2 } catch ( throwable t ) { \n <ect>
\t5 log . warn ( <string_literal> + e . get <identifiersep> message ( ) + <string_literal> + <identifier> . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; } \n \t4 return false ; } \n \t2 } ) ; \n \t2 if ( found <identifiersep> file != null ) { \n <ect>
\t3 logger . debug ( <string_literal> , <identifier> <identifiersep> and <identifiersep> name ) ; \n \t3 security <identifiersep> group <identifiersep> api . get ( ) . delete ( security <identifiersep> group . get <identifiersep> id ( ) ) ; \n \t3 <comment> \n \t3 security <identifiersep> group <identifiersep> map . <identifier> ( <identifier> <identifiersep> and <identifiersep> name ) ; \n <ect>
\t1 private static map < string , string > get <identifiersep> <identifier> <identifiersep> from <identifiersep> json <identifiersep> resource ( final resource json <identifiersep> resource ) { \n \t2 if ( ! resource <identifiersep> utils . <identifier> <identifiersep> resource <identifiersep> <identifier> ( json <identifiersep> resource ) ) { \n \t3 final boolean <identifier> = json <identifiersep> resource . get <identifiersep> file ( ) . create <identifiersep> new <identifiersep> file ( ) ; \n \t3 if ( <identifier> ) { \n <ect>
\t3 try { \n \t4 e . remove <identifiersep> lock ( lock <identifiersep> <identifier> ) ; } \n \t3 catch ( grid <identifiersep> cache <identifiersep> entry <identifiersep> <identifier> <identifiersep> exception ignore ) { \n <ect>
\t5 <identifier> <identifiersep> context . <identifier> <identifiersep> manager ( ) . add <identifiersep> <identifier> <identifiersep> data ( <string_literal> , 1 ) ; \n \t5 return ; <comment> \n \t4 if ( <identifier> <identifiersep> context . <identifier> ( ) . is <identifiersep> <identifier> ( from . get <identifiersep> ip ( ) ) ) { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t3 try { \n \t4 transaction . execute ( new transaction <identifiersep> <identifier> <identifiersep> no <identifiersep> return ( ) { \n \t5 @ <identifier> \n \t5 public void do <identifiersep> in <identifiersep> transaction <identifiersep> <identifier> <identifiersep> result ( transaction <identifiersep> status status ) { \n <ect>
\t4 <comment> \n \t4 process <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> message , <identifier> , endpoint ) ; \n \t4 break ; \n \t3 case <identifier> <identifiersep> get : \n <ect>
\t3 if ( transaction != null ) \n \t4 transaction . <identifier> ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n \t3 this . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> exception ( e ) ; \n <ect>
\t3 return new <identifier> <identifiersep> <identifier> <identifiersep> client <identifiersep> <identifier> <identifiersep> <identifier> ( connection <identifiersep> map ) ; } } \n \t1 public static void authentication <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> client <identifiersep> <identifier> <identifier> ) throws authentication <identifiersep> exception { \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> authentication <identifiersep> result <identifier> <identifiersep> result = <identifier> <identifiersep> <identifier> <identifiersep> access ( <identifier> , false ) ; \n \t2 if ( <identifier> <identifiersep> result == null || ! <identifier> <identifiersep> result . is <identifiersep> success ( ) ) { \n <ect>
@ <identifier> \n public synchronized void create <identifiersep> host <identifiersep> <identifier> ( set < service <identifiersep> <identifier> <identifiersep> host <identifiersep> request > <identifier> ) \n \t1 throws <identifier> <identifiersep> exception , <identifier> <identifiersep> exception { \n \t1 if ( <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t1 if ( <identifier> <identifiersep> value == null ) { \n \t2 log . debug ( <string_literal> , key ) ; \n \t1 } else { \n <ect>
\t2 list < group > <identifier> = new array <identifiersep> list < > ( ) ; \n \t2 try { \n \t3 <identifier> = authentication <identifiersep> service . get <identifiersep> <identifier> <identifiersep> <identifier> ( context , request ) ; \n \t2 } catch ( sql <identifiersep> exception e ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 msg <identifiersep> type = org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . exception ; \n \t3 msg = ( org . apache . thrift . t <identifiersep> application <identifiersep> exception ) e ; \n \t3 } else { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t5 <identifier> . close ( ) ; } \n \t3 } catch ( sql <identifiersep> exception e ) { } } \n \t2 s <identifiersep> logger . debug ( <string_literal> ) ; } \n \t1 private void <identifier> <identifiersep> host <identifiersep> <identifier> ( connection conn ) { \n <ect>
\t3 } catch ( org . apache . thrift . transport . t <identifiersep> transport <identifiersep> exception e ) { \n \t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 } catch ( java . <identifier> . exception e ) { \n <ect>
\t4 s <identifiersep> logger . error ( <string_literal> , ex ) ; } } \n \t2 protected void <identifier> <identifiersep> to <identifiersep> update <identifiersep> queue ( final list < network <identifiersep> vo > <identifier> ) throws interrupted <identifiersep> exception { \n \t3 for ( final network <identifiersep> vo network : <identifier> ) { \n \t4 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> update <identifiersep> queue . <identifier> ( network . get <identifiersep> id ( ) , <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> to <identifiersep> local <identifiersep> <identifier> <identifiersep> authentication ( ) { \n <ect>
\t1 for ( <identifier> <identifiersep> update <identifiersep> event . type type : <identifier> <identifiersep> update <identifiersep> event . type . values ( ) ) { \n \t1 <identifier> . put ( type , <identifier> ) ; } } \n @ <identifier> \n public void start ( ) { \n <ect>
\t4 input <identifiersep> stream input = method . get <identifiersep> response <identifiersep> body <identifiersep> as <identifiersep> stream ( ) ; \n \t4 element <identifier> = query <identifiersep> <identifier> <identifiersep> job <identifiersep> result ( server , input ) ; \n \t4 map < string , string > values = get <identifiersep> <identifier> <identifiersep> value <identifiersep> from <identifiersep> xml ( <identifier> , new string [ ] { <string_literal> , <string_literal> } ) ; \n \t4 if ( ( values . get ( <string_literal> ) == null ) || ( values . get ( <string_literal> ) == null ) ) { \n <ect>
\t2 synchronized ( this ) { \n \t3 if ( state != <identifier> ) return ; \n \t3 if ( <identifier> <identifiersep> key != null ) { \n \t4 if ( key . equals ( <identifier> <identifiersep> key ) ) return ; <comment> \n <ect>
\t2 return manager ; } \n \t1 @ <identifier> \n \t1 public void <identifier> <identifiersep> manager ( manager manager ) { \n \t2 if ( ! ( manager instanceof cluster <identifiersep> manager ) ) { \n <ect>
\t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 <comment> \n \t2 <identifier> ++ ; } \n \t2 if ( <identifier> <identifiersep> server . get <identifiersep> state ( ) != server <identifiersep> <identifier> . server <identifiersep> state <identifiersep> shutdown ) { \n <ect>
\t3 if ( this . attribute <identifiersep> <identifier> == null ) { \n \t4 final application <identifiersep> context context = application <identifiersep> context <identifiersep> provider . get <identifiersep> application <identifiersep> context ( ) ; \n \t4 if ( context != null ) { \n \t5 return context . get <identifiersep> bean ( <string_literal> , i <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao . class ) ; } \n <ect>
\t1 int length = is . read <identifiersep> int ( ) ; \n \t1 byte [ ] <identifier> = new byte [ length ] ; \n \t1 is . read <identifiersep> <identifier> ( <identifier> ) ; \n \t1 string <identifier> = new string ( <identifier> , <identifier> <identifiersep> <identifier> . <identifier> ) ; \n <ect>
\t3 if ( value != null ) { \n \t4 date value <identifiersep> time = get <identifiersep> date ( 0 , 0 , 0 , value . get <identifiersep> <identifier> ( ) , value . get <identifiersep> <identifier> ( ) , value . get <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> . set <identifiersep> value <identifiersep> <identifier> ( value <identifiersep> time ) ; \n \t3 } else { \n <ect>
\t3 catch ( throwable t ) { \n \t4 if ( <identifier> != null ) \n \t5 <identifier> . send ( <identifier> <identifiersep> <identifier> ? new <identifier> <identifiersep> target <identifiersep> exception ( t ) : t , true ) ; \n \t4 else \n <ect>
\t1 <identifier> <identifiersep> <identifier> <identifiersep> server new <identifiersep> server ; \n \t1 try { \n \t2 new <identifiersep> server = start <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> server ( <identifier> , port ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t3 cluster <identifiersep> client < application <identifiersep> id > <identifier> <identifiersep> cluster = null ; \n \t3 try { \n \t4 <identifier> <identifiersep> cluster = cluster <identifiersep> <identifier> . <identifier> <identifiersep> session <identifiersep> cluster ( cluster <identifiersep> <identifier> ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 try { \n \t3 data = new <identifier> <identifiersep> lock <identifiersep> object <identifiersep> data ( new string ( <identifier> <identifiersep> <identifier> . get <identifiersep> data ( ) . <identifier> ( ) . for <identifiersep> path ( <identifier> <identifiersep> <identifier> ) ) ) ; \n \t3 data . set <identifiersep> client <identifiersep> ip ( client <identifiersep> ip ) ; \n \t2 } catch ( exception e ) { \n <ect>
protected void <identifier> <identifiersep> set <identifiersep> <identifier> ( ) throws exception { \n \t1 <identifier> <identifiersep> add <identifiersep> event <identifiersep> listener <identifiersep> <identifier> ( ) ; \n \t1 super . <identifier> <identifiersep> set <identifiersep> <identifier> ( ) ; \n \t1 final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) ; \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> <identifier> . stop <identifiersep> <identifier> <identifiersep> request ( node <identifiersep> id , <identifier> <identifiersep> id ) ; \n \t5 logger . info ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t3 <identifier> . trace ( <string_literal> , <identifier> <identifiersep> to ) ; \n \t3 <identifier> <identifiersep> service . instance ( ) . send <identifiersep> <identifier> ( response . create <identifiersep> message ( ) , id , <identifier> <identifiersep> to ) ; } \n \t2 catch ( io <identifiersep> exception e ) \n \t2 { \n <ect>
<comment> \n public string build ( final string . . . options ) { \n <ect>
\t2 list < string > <identifier> <identifiersep> to <identifiersep> remove = <identifier> . as <identifiersep> list ( this . <identifier> ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t3 <identifier> <identifiersep> to <identifiersep> remove = new array <identifiersep> list < > ( <identifier> <identifiersep> to <identifiersep> remove ) ; \n \t3 <identifier> <identifiersep> to <identifiersep> remove . add <identifiersep> all ( <identifier> . as <identifiersep> list ( <identifier> <identifiersep> <identifier> ) ) ; } \n <ect>
\t3 string read <identifiersep> <identifier> = parse <identifiersep> boolean ( <identifier> , <string_literal> ) \n \t9 ? <string_literal> : <string_literal> ; \n \t3 options <identifiersep> map . put ( <string_literal> , <identifier> <identifiersep> list ( read <identifiersep> <identifier> ) ) ; \n <ect>
\t1 private void parse <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = <identifier> . list <identifiersep> <identifier> ( null , <identifier> . type , \n \t4 test <identifiersep> <identifier> . <identifier> ) ; \n \t2 if ( ! <identifier> <identifiersep> <identifier> . has <identifiersep> next ( ) ) { \n <ect>
\t2 finally { \n \t3 <identifier> <identifiersep> <identifier> . log <identifiersep> <identifier> <identifiersep> for <identifiersep> operation ( <identifier> <identifiersep> log , <string_literal> ) ; \n \t3 <identifier> <identifiersep> application . <identifier> <identifiersep> end <identifiersep> request ( ) ; } \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \t3 for ( string s : update <identifiersep> <identifier> <identifiersep> table <identifiersep> host <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) { \n \t4 logger . info ( s ) ; } \n \t2 } else { \n <ect>
\t4 ) , <identifier> ) ) ) ; \n \t2 cluster <identifiersep> info <identifiersep> service <identifier> = new cluster <identifiersep> info <identifiersep> service ( ) { \n \t3 @ <identifier> \n \t3 public cluster <identifiersep> info get <identifiersep> cluster <identifiersep> info ( ) { \n <ect>
\t5 <comment> \n \t4 if ( null != <identifier> <identifiersep> content ) { \n \t5 if ( log . is <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , level . info ) ) { \n \t6 log . info ( <identifier> <identifiersep> <identifier> , <string_literal> , <identifier> <identifiersep> key <identifiersep> id , <identifier> ) ; \n <ect>
\t2 final properties <identifier> = new properties ( ) ; \n \t2 final list < string > <identifier> = get <identifiersep> application <identifiersep> <identifier> ( <identifier> ) ; \n \t2 final string <identifier> = build <identifiersep> <identifier> <identifiersep> for <identifiersep> configuration <identifiersep> file <identifiersep> <identifier> ( config , <identifier> ) ; \n \t2 final collection < file > config <identifiersep> files = <identifier> <identifiersep> for <identifiersep> configuration <identifiersep> files <identifiersep> by <identifiersep> <identifier> ( config , <identifier> ) ; \n <ect>
public final void on <identifiersep> <identifier> <identifiersep> load ( ) { \n \t1 <identifier> . set <identifiersep> <identifier> <identifiersep> exception <identifiersep> handler ( new <identifier> <identifiersep> exception <identifiersep> handler ( ) { \n \t1 @ <identifier> \n \t1 public void on <identifiersep> <identifier> <identifiersep> exception ( throwable e ) { \n <ect>
\t2 <identifier> <identifiersep> log . debug ( <string_literal> + <identifier> ) ; \n \t2 if ( <identifier> ) { \n \t3 <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> context , <identifier> <identifiersep> <identifier> <identifiersep> in , <identifier> <identifiersep> event <identifiersep> handler ) ; \n \t3 <identifier> <identifiersep> <identifier> . start <identifiersep> <identifier> ( ) ; \n <ect>
\t3 try { \n \t4 file <identifiersep> utils . write <identifiersep> string <identifiersep> to <identifiersep> file ( new file ( output <identifiersep> dir <identifiersep> name , file <identifiersep> name ) , \n <number_literal> new cluster <identifiersep> <identifier> ( ) . write <identifiersep> cluster ( cluster ) ) ; \n \t3 } catch ( io <identifiersep> exception e ) { \n <ect>
\t2 system . out . <identifier> ( i ) ; } \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws exception { \n <ect>
\t6 log . debug ( <string_literal> + <identifier> <identifiersep> ex ) ; \n \t6 break ; } \n \t5 log . error ( <identifier> . get <identifiersep> message ( <string_literal> ) , <identifier> <identifiersep> ex ) ; } \n \t4 catch ( throwable ex ) { \n <ect>
\t8 <identifier> <identifiersep> id = ( long ) value . get ( 0 ) ; \n \t8 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id , ( long ) value . get ( 1 ) ) ; \n \t8 break ; \n \t7 default : \n <ect>
\t2 int i = 0 ; \n \t2 for ( <identifier> <identifiersep> entry e : <identifier> ) { \n \t3 if ( e . id == null || e . data == null ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t1 logger . info ( <string_literal> . format ( string <identifiersep> utils . <identifier> ( <identifier> . status . to <identifiersep> string ) + <string_literal> , <identifier> . function . <identifier> ) ) \n \t1 logger . debug ( <string_literal> + <identifier> . <identifier> ) \n \t1 logger . debug ( <string_literal> + <identifier> . <identifier> ) \n <ect>
\t4 return ; } \n \t3 try { \n \t4 state <identifiersep> <identifier> <identifiersep> to ( vm , <identifier> <identifiersep> <identifier> . event . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , null ) ; \n \t3 } catch ( final no <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t4 source , \n \t4 <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> instance ( i , <identifier> ) ) ; \n \t2 } catch ( out <identifiersep> of <identifiersep> <identifier> <identifiersep> error e ) { \n <ect>
\t1 byte [ ] <identifier> <identifiersep> bytes = <identifier> . do <identifiersep> final ( text ) ; \n \t1 <identifier> <identifiersep> bytes = <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> bytes ) ; \n \t1 string <identifier> = new string ( <identifier> <identifiersep> bytes , <string_literal> ) ; \n <ect>
\t2 map < string , string > <identifier> <identifiersep> properties ; \n \t2 configuration <identifiersep> factory configuration <identifiersep> factory ; \n \t2 if ( <identifier> <identifiersep> configuration <identifiersep> properties == null ) { \n \t3 <comment> \n <ect>
\t2 <comment> \n \t2 try { \n \t3 <identifier> <identifiersep> <identifier> = load <identifiersep> or <identifiersep> create <identifiersep> <identifier> ( context , <identifier> , <identifier> ) ; \n \t2 } catch ( sql <identifiersep> exception ex ) { \n <ect>
\t1 @ <identifier> \n \t1 public void stop ( ) { \n \t2 lock . lock ( ) ; \n \t2 try { \n <ect>
\t2 return null ; } \n \t1 @ <identifier> \n \t1 public string build <identifiersep> <identifier> <identifiersep> query ( integer <identifier> , integer <identifier> , string query ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 } catch ( sql <identifiersep> exception e ) { \n \t3 handle ( <string_literal> , e ) ; } } \n \t1 public void remove ( string key ) { \n \t2 <identifier> <identifiersep> if <identifiersep> <identifier> ( ) ; \n <ect>
\t1 try { \n \t1 do <identifiersep> process ( in , out ) ; \n \t1 } catch ( final io <identifiersep> exception ex ) { \n \t1 final string resource <identifiersep> uri = resource == null ? string <identifiersep> utils . empty : <string_literal> + resource . get <identifiersep> uri ( ) + <string_literal> ; \n <ect>
\t4 logger . debug ( <string_literal> + <identifier> <identifiersep> node <identifiersep> id ) ; \n \t4 <identifier> <identifiersep> node . set <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( \n \t6 new <identifier> <identifiersep> type <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> , <identifier> <identifiersep> node , <number_literal> , <identifier> ) ) ; \n \t4 if ( <identifier> <identifiersep> node . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t6 try { \n \t7 long number = long . parse <identifiersep> long ( value <identifiersep> text ) ; \n \t7 answer . put ( new file ( dir , key <identifiersep> text ) , number ) ; \n \t6 } catch ( number <identifiersep> format <identifiersep> exception e ) { \n <ect>
\t1 protected void create <identifiersep> root <identifiersep> dir ( ) { \n \t2 try { \n \t3 <identifier> <identifiersep> client . create <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 for ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t2 list <identifiersep> <identifier> . <identifier> ( <string_literal> ) . <identifier> ( i ) . <identifier> ( <string_literal> ) ; \n \t2 <identifier> <identifiersep> list ( list <identifiersep> <identifier> , <identifier> , null ) ; } \n \t1 } catch ( throwable t ) { \n <ect>
\t4 list < <identifier> <identifiersep> <identifier> > <identifier> <identifiersep> run <identifiersep> <identifier> = <identifier> . get <identifiersep> run <identifiersep> <identifier> ( ) ; \n \t4 if ( <identifier> <identifiersep> run <identifiersep> <identifier> == null ) \n \t5 <identifier> <identifiersep> run <identifiersep> <identifier> = new array <identifiersep> list < > ( ) ; \n \t4 string <identifier> <identifiersep> <identifier> <identifiersep> string = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> run <identifiersep> <identifier> ) ; \n <ect>
\t2 <comment> \n \t2 boolean is <identifiersep> <identifier> <identifiersep> put <identifiersep> <identifier> <identifiersep> key <identifiersep> to <identifiersep> <identifier> <identifiersep> new <identifiersep> <identifier> ; \n \t2 if ( <identifier> <identifiersep> version . is <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> . get <identifiersep> version ( ) ) ) { \n \t3 is <identifiersep> <identifier> <identifiersep> put <identifiersep> <identifier> <identifiersep> key <identifiersep> to <identifiersep> <identifier> <identifiersep> new <identifiersep> <identifier> = false ; \n <ect>
\t2 result . set <identifiersep> response <identifiersep> data ( read <identifiersep> file ( <string_literal> ) ) ; \n \t2 <identifier> . set <identifiersep> <identifier> <identifiersep> file <identifiersep> name ( find <identifiersep> test <identifiersep> path ( <string_literal> ) ) ; \n \t2 <identifier> <identifiersep> result <identifier> = <identifier> . get <identifiersep> result ( <identifier> . get <identifiersep> <identifier> <identifiersep> result ( ) ) ; \n \t2 test <identifiersep> log . debug ( <string_literal> + <identifier> . is <identifiersep> error ( ) + <string_literal> + <identifier> . is <identifiersep> failure ( ) ) ; \n <ect>
\t2 logger . error ( e ) ; \n \t2 return null ; } \n \t2 if ( data == null ) \n \t2 { \n <ect>
<comment> \n \t1 public <identifier> <identifiersep> user get <identifiersep> current <identifiersep> user ( ) { \n \t2 try { \n <ect>
\t2 if ( url == null ) { \n \t3 s <identifiersep> logger . info ( <string_literal> ) ; \n \t3 system . <identifier> ( 1 ) ; } \n \t2 if ( <identifier> == null ) { \n <ect>
\t4 throw new <identifier> <identifiersep> exception ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } } \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception e ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t3 byte <identifiersep> <identifier> <identifier> = e . get <identifiersep> byte <identifiersep> <identifier> ( ) ; \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> c = <identifier> . find <identifiersep> <identifier> ( <identifier> ) ; \n \t3 if ( c == null ) { \n <ect>
\t3 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) ; } \n \t2 if ( ! <identifier> ) { \n \t3 <comment> \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t10 s <identifiersep> logger . trace ( <string_literal> + info . get <identifiersep> key ( ) ) ; \n \t10 s <identifiersep> logger . trace ( <string_literal> + info . get <identifiersep> <identifier> ( ) ) ; } } } } \n \t5 } catch ( throwable e ) { \n <ect>
\t6 log . debug ( <string_literal> , e . get <identifiersep> message ( ) ) ; } } \n \t4 <identifier> . shutdown <identifiersep> <identifier> ( ) ; \n \t4 try { \n \t5 if ( ! <identifier> . <identifier> <identifiersep> <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n <ect>
\t4 break ; \n \t3 if ( ! to <identifiersep> try . is <identifiersep> empty ( ) && ! <identifier> <identifiersep> from . is <identifiersep> empty ( ) && \n \t4 <identifier> . <identifier> ( to <identifiersep> try . first ( ) , <identifier> <identifiersep> from . first ( ) ) >= 0 ) { \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t2 check <identifiersep> values ( values ) ; } \n \t1 @ test \n \t1 public void delete <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception { \n \t2 string [ ] [ ] values = <identifier> <identifiersep> values ( ) ; \n <ect>
\t5 this . <identifier> . start <identifiersep> <identifier> ( this ) ; \n \t5 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> name , from <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t5 <identifier> <identifiersep> <identifier> new <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . set <identifiersep> <identifier> <identifiersep> <identifier> ( new <identifier> <identifiersep> <identifier> ( to <identifiersep> <identifier> <identifiersep> id ) ) ; \n <ect>
\t5 true , \n \t5 <identifier> . <identifier> <identifiersep> dir + <string_literal> ) ; \n \t3 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> json ( this . <identifier> <identifiersep> builder . get <identifiersep> <identifier> ( ) , <identifier> . <identifier> <identifiersep> dir + <string_literal> + <identifier> . <identifier> <identifiersep> json <identifiersep> file <identifiersep> <identifier> , true , true ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 public void <identifier> ( ) { \n \t2 try { \n \t3 close ( ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t1 <identifier> <identifiersep> group . <identifier> <identifiersep> and <identifiersep> get ( <string_literal> ) ; \n \t1 } catch ( exception ex ) { \n \t1 transaction . <identifier> ( ) ; \n \t1 <identifier> <identifiersep> group . <identifier> <identifiersep> and <identifiersep> get ( <string_literal> ) ; \n <ect>
\t2 # <number_literal> ) <identifier> <identifier> - to - <identifier> <identifier> for <identifier> \n \t2 <identifier> <identifiersep> response = <identifier> . create <identifiersep> <identifier> <identifiersep> <identifier> ( self . <identifier> , <identifier> . id ) \n \t2 self . assert <identifiersep> <identifier> ( \n \t3 <identifier> <identifiersep> response is not <identifier> , <string_literal> ) \n <ect>
\t4 info ( <string_literal> ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> message ( <identifier> <identifiersep> import <identifiersep> status , <string_literal> ) ; \n \t4 files . <identifier> <identifiersep> file <identifiersep> <identifier> ( <identifier> , new <identifier> <identifiersep> import <identifiersep> <identifier> ( <identifier> , <identifier> <identifiersep> conf ) ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t1 query query = null ; \n \t1 list < string > <identifier> <identifiersep> <identifier> = new array <identifiersep> list < > ( ) ; \n \t1 try { \n \t1 <identifier> <identifiersep> transaction ( ) ; \n <ect>
\t6 <identifier> . close ( ) ; } } \n \t4 else { \n \t5 <identifier> . close ( ) ; } } \n \t3 catch ( <identifier> . <identifier> . illegal <identifiersep> state <identifiersep> exception ex ) { \n <ect>
\t4 state . <identifier> . <identifier> ( state . <identifier> <identifiersep> index , entry . log <identifiersep> entry ( ) . <identifier> ( ) ) ; } } \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> last <identifiersep> header ) \n \t2 { \n \t3 <identifier> <identifiersep> header header = new <identifier> <identifiersep> header ( state . <identifier> <identifiersep> index , <identifier> <identifiersep> version , state . <identifier> <identifiersep> index , state . <identifier> . <identifier> ( ) ) ; \n <ect>
\t2 <identifier> . <identifier> <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . <identifier> <identifiersep> in ( <identifier> <identifiersep> <identifier> <identifiersep> file ) ; \n \t2 p <identifiersep> file = <identifier> <identifiersep> <identifier> <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n \t2 string endpoint = string <identifiersep> utils . has <identifiersep> content ( local <identifiersep> endpoint ) ? local <identifiersep> endpoint : <identifier> . get <identifiersep> name ( ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> context == null ) { \n \t3 string <identifier> = get <identifiersep> <identifier> ( ) ; \n \t3 if ( <identifier> == null ) { \n \t4 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n <ect>
\t3 <identifier> . put ( <string_literal> , boolean . true ) ; \n \t2 } else { \n \t3 <identifier> . put ( <string_literal> , boolean . false ) ; } \n \t2 <identifier> <identifiersep> file = null ; \n <ect>
\t6 list < boolean > pool <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> . all <identifiersep> as <identifiersep> list ( <identifier> ) . get ( ) ; \n \t6 <comment> \n \t6 <comment> \n \t6 if ( <identifier> . <identifier> ( pool <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> . equal <identifiersep> to ( false ) ) ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> socket ( client <identifiersep> socket ) ; } \n \t2 } catch ( <identifier> <identifiersep> socket <identifiersep> exception socket <identifiersep> ex ) { \n \t3 <comment> \n \t3 if ( ! <identifier> <identifiersep> <identifier> . is <identifiersep> empty ( ) ) { \n <ect>
\t3 <identifier> . execute <identifiersep> update ( ) ; \n \t3 <identifier> . <identifier> ( ) ; \n \t2 } catch ( exception ex ) { \n \t3 <identifier> . <identifier> ( ) ; \n <ect>
\t6 <string_literal> \n \t8 + object . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) \n \t4 ) ; } } \n \t2 catch ( exception e ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <comment> \n \t3 if ( <identifier> == null ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void do <identifiersep> stop ( ) throws exception { \n \t2 super . do <identifiersep> stop ( ) ; \n \t2 log . debug ( <string_literal> ) ; \n <ect>
\t2 return false ; } \n \t1 string group <identifiersep> name = group . to <identifiersep> string ( ) ; \n \t1 return ( <identifier> <identifiersep> <identifier> . contains <identifiersep> key ( group <identifiersep> name ) && <identifier> <identifiersep> <identifier> . <identifier> ( <identifier> , <identifier> <identifiersep> <identifier> . get ( group <identifiersep> name ) ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <comment> \n \t2 transport = new transport <identifiersep> filter ( transport ) { \n \t3 @ <identifier> \n \t3 public void stop ( ) throws exception { \n <ect>
\t4 version <identifiersep> service . class . get <identifiersep> name ( ) , \n \t4 new version <identifiersep> service <identifiersep> <identifier> ( ) , \n \t4 null ) ; \n <ect>
\t2 consumer <identifiersep> <identifier> <identifiersep> exchange consumer <identifiersep> exchange = get <identifiersep> consumer <identifiersep> <identifier> <identifiersep> exchange ( <identifier> . get <identifiersep> consumer <identifiersep> id ( ) ) ; \n \t2 if ( consumer <identifiersep> exchange != null ) { \n \t3 <identifier> . <identifier> ( consumer <identifiersep> exchange , <identifier> ) ; \n \t2 } else if ( <identifier> . is <identifiersep> in <identifiersep> transaction ( ) ) { \n <ect>
<comment> \n private void <identifier> <identifiersep> <identifier> ( string db <identifiersep> type ) throws exception { \n <ect>
\t2 object <identifiersep> name queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifiersep> name = assert <identifiersep> registered <identifiersep> object <identifiersep> name ( <identifier> + <string_literal> + queue <identifiersep> with <identifiersep> options ) ; \n \t2 queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean queue = m <identifiersep> bean <identifiersep> server <identifiersep> <identifier> <identifiersep> handler . new <identifiersep> <identifier> <identifiersep> instance ( <identifier> <identifiersep> server , queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean <identifiersep> name , queue <identifiersep> <identifier> <identifiersep> m <identifiersep> bean . class , true ) ; \n \t2 assert <identifiersep> equals ( <string_literal> , queue <identifiersep> with <identifiersep> options , queue . get <identifiersep> name ( ) ) ; \n \t2 string options = queue . get <identifiersep> options ( ) ; \n <ect>
\t4 logger . trace ( <string_literal> ) ; \n \t4 execute <identifiersep> update ( conn , <string_literal> ) ; \n \t3 } catch ( sql <identifiersep> exception <identifier> ) { \n \t4 if ( <identifier> . get <identifiersep> error <identifiersep> code ( ) != <number_literal> ) { <comment> \n <ect>
\t1 { \n \t1 <identifier> <identifiersep> <identifier> . on <identifiersep> <identifier> ( <identifier> ) ; } \n \t1 catch ( throwable ex ) \n \t1 { \n <ect>
\t5 <identifier> , <identifier> <identifiersep> state ) ; \n \t4 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ; } \n \t3 catch ( exception ex ) \n \t3 { \n <ect>
\t2 if ( <identifier> == <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ) \n \t2 { \n \t3 if ( this . get <identifiersep> state ( ) == <identifier> <identifiersep> <identifier> . failed ) \n \t3 { \n <ect>
\t7 + <identifier> <identifiersep> <identifier> <identifiersep> utils . get <identifiersep> <identifier> <identifiersep> text <identifiersep> <identifier> ( <identifier> ) + <string_literal> ) ; } \n \t4 <identifier> . <identifier> ( <identifier> , type ) ; \n \t3 } else { \n \t4 <comment> \n <ect>
\t1 public static <identifier> <identifiersep> address get <identifiersep> local <identifiersep> <identifier> <identifiersep> address ( ) { \n \t2 try { \n \t3 return <identifier> <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) ; \n \t2 } catch ( final <identifier> <identifiersep> host <identifiersep> exception e ) { \n <ect>
\t2 try { \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> ( index <identifiersep> meta <identifiersep> data , <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> , true ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 if ( string <identifiersep> utils . is <identifiersep> empty ( <identifier> <identifiersep> out <identifiersep> dir ) ) { \n \t1 log . error ( <string_literal> ) ; \n \t1 return ; } \n \t1 if ( string <identifiersep> utils . is <identifiersep> empty ( <identifier> <identifiersep> host ) ) { \n <ect>
\t4 boolean <identifier> = <identifier> . get <identifiersep> storage ( ) . <identifier> ( ) ; \n \t4 if ( <identifier> ) \n \t5 update <identifiersep> status ( <identifier> ) ; \n \t4 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t1 { \n \t2 <identifier> . <identifier> ( ) ; \n \t2 if ( msg . <identifier> <identifiersep> <identifier> <identifiersep> id ( ) < = 0 ) \n \t2 { \n <ect>
\t4 <identifier> . set <identifiersep> <identifier> <identifiersep> timeout ( socket <identifiersep> timeout ) ; \n \t4 <identifier> . set <identifiersep> enabled <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) ; \n \t4 <identifier> . start <identifiersep> <identifier> ( ) ; \n \t4 <identifier> <identifiersep> session <identifier> <identifiersep> session = <identifier> . get <identifiersep> session ( ) ; \n <ect>
\t3 final int <identifier> = <identifier> . <identifier> <identifiersep> <identifier> ( this . <identifier> <identifiersep> <identifier> , response <identifiersep> code ) ; \n \t3 if ( <identifier> >= 0 ) { \n \t4 logger . debug ( <string_literal> , response <identifiersep> code ) ; \n \t4 return true ; } \n <ect>
\t1 <comment> \n \t1 file code <identifiersep> <identifier> <identifiersep> dir <identifiersep> file = new file ( code <identifiersep> <identifier> <identifiersep> dir ) ; \n \t1 file class <identifiersep> <identifier> <identifiersep> dir <identifiersep> file = new file ( <identifier> <identifiersep> <identifier> <identifiersep> dir ) ; \n \t1 if ( code <identifiersep> <identifier> <identifiersep> dir <identifiersep> file . exists ( ) ) { \n <ect>
\t4 <identifier> <identifiersep> type <identifiersep> info <identifier> <identifiersep> type = read <identifiersep> <identifier> <identifiersep> type ( <identifier> <identifiersep> info <identifiersep> <identifier> , <identifier> <identifiersep> type <identifiersep> directory ) ; \n \t4 if ( <identifier> <identifiersep> type == null ) { \n \t5 continue ; } \n \t4 <identifier> . add ( <identifier> <identifiersep> type ) ; \n <ect>
\t2 <identifier> current <identifiersep> time = <identifier> . get <identifiersep> instance ( ) ; \n \t2 current <identifiersep> time . set <identifiersep> time <identifiersep> in <identifiersep> millis ( <identifier> ) ; \n \t2 boolean update <identifiersep> <identifier> = should <identifiersep> update <identifiersep> <identifier> ( current <identifiersep> time ) ; \n \t2 if ( <identifier> == null && update <identifiersep> <identifier> ) { \n <ect>
\t4 vm <identifiersep> name += <string_literal> + <identifier> <identifiersep> name + <string_literal> ; } } \n \t2 string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t2 <identifier> . <identifier> ( <string_literal> ) . <identifier> ( <identifier> <identifiersep> <identifier> ( vm <identifiersep> name ) ) . <identifier> ( <string_literal> \\ <string_literal> ) ; \n <ect>
\t2 logger . warn ( <string_literal> ) \n \t2 output <identifiersep> file . set ( <identifier> ) } \n \t1 @ <identifier> \n \t1 void user <identifiersep> output <identifiersep> file ( <identifier> ) { \n <ect>
\t4 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> account . get ( ) + <string_literal> + host ) ; \n \t4 boolean is <identifiersep> <identifier> = conn . <identifier> <identifiersep> with <identifiersep> password ( <string_literal> , \n \t6 password ) ; \n \t4 if ( is <identifiersep> <identifier> == false ) { \n <ect>
\t3 grid <identifiersep> cache <identifiersep> <identifier> <identifiersep> check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < <identifier> , v > <identifier> = new grid <identifiersep> cache <identifiersep> <identifier> <identifiersep> check <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> < > ( \n \t4 <identifier> , <identifier> , <identifier> <identifiersep> node <identifiersep> id ) ; \n \t3 <identifier> . <identifier> ( ) . add <identifiersep> <identifier> ( <identifier> ) ; \n <ect>
\t8 logger . warn ( <string_literal> , <identifier> <identifiersep> class <identifiersep> name , <identifier> <identifiersep> name ) ; } \n \t6 } else { \n \t7 logger . warn ( <string_literal> , <identifier> <identifiersep> name , <identifier> <identifiersep> name ) ; } \n \t5 } else { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , result , org . apache . thrift . <identifier> . t <identifiersep> message <identifiersep> type . <identifier> , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception e ) { \n <ect>
\t2 debug ( <identifier> . <identifier> <identifiersep> name + <string_literal> ) } } \n \t1 <identifier> all = <identifier> . <identifier> ( <identifier> ) \n \t1 all . on <identifiersep> <identifier> { \n \t1 case success ( <identifier> <identifiersep> <identifier> ) = > debug ( <string_literal> ) \n <ect>
\t4 <identifier> <identifiersep> context <identifier> = <identifier> <identifiersep> context . get <identifiersep> instance ( <identifier> <identifiersep> <identifier> ) ; \n \t4 <identifier> . <identifier> ( get <identifiersep> <identifier> <identifiersep> key <identifiersep> <identifier> ( key <identifiersep> <identifier> ) , null , null ) ; \n \t4 <identifier> <identifiersep> socket <identifiersep> factory <identifier> <identifiersep> factory = <identifier> . get <identifiersep> socket <identifiersep> factory ( ) ; \n \t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . put ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> factory ) ; \n <ect>
protected void set <identifiersep> ip <identifiersep> address ( final t <identifiersep> <identifier> in ) { \n \t1 t <identifiersep> transport transport = in . get <identifiersep> transport ( ) ; \n \t1 t <identifiersep> socket t <identifiersep> socket = get <identifiersep> <identifier> <identifiersep> socket <identifiersep> from <identifiersep> transport ( transport ) ; \n \t1 if ( t <identifiersep> socket == null ) { \n <ect>
\t3 <identifier> += num <identifiersep> <identifier> <identifiersep> bytes ; } \n \t2 <identifier> [ <identifier> ] = <identifier> ; <comment> \n \t2 <identifier> ++ ; \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t5 if ( pool . get <identifiersep> pool <identifiersep> type ( ) == storage <identifiersep> pool <identifiersep> type . <identifier> && ! <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> nodes ( pool . get <identifiersep> cluster <identifiersep> id ( ) ) ) { \n \t6 throw new connection <identifiersep> exception ( true , <string_literal> + pool . get <identifiersep> id ( ) ) ; } \n \t5 long host <identifiersep> id = host . get <identifiersep> id ( ) ; \n <ect>
\t4 log . debug ( <string_literal> ) ; \n \t4 <identifier> . <identifier> ( ) ; } \n \t2 } catch ( interrupted <identifiersep> exception e ) { \n \t3 thread . current <identifiersep> thread ( ) . <identifier> ( ) ; \n <ect>
\t1 public void execute ( <identifier> input ) { \n \t2 object value = input . get <identifiersep> value ( 0 ) ; \n \t2 if ( input . get <identifiersep> source <identifiersep> stream <identifiersep> id ( ) . equals ( <identifier> <identifiersep> <identifier> . user <identifiersep> <identifier> <identifiersep> stream ) ) { \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> message message = ( <identifier> <identifiersep> <identifier> <identifiersep> message ) value ; \n <ect>
\t5 thread . <identifier> ( <number_literal> ) ; } \n \t4 s <identifiersep> logger . info ( <string_literal> + host + <string_literal> + <identifier> ) ; \n \t4 connection conn = new connection ( host ) ; \n \t4 conn . <identifier> ( null , <number_literal> , <number_literal> ) ; \n <ect>
\t1 } catch ( web <identifiersep> application <identifiersep> exception ex ) { \n \t1 log . error ( <string_literal> , ex ) ; \n \t1 throw ex ; \n \t1 } catch ( exception ex ) { \n <ect>
\t3 if ( <identifier> != null ) { \n \t4 try { \n \t5 <identifier> . close ( ) ; } \n \t4 catch ( sql <identifiersep> exception e ) { \n <ect>
\t2 { \n \t3 action . <identifier> ( ) ; } \n \t2 catch ( interrupted <identifiersep> exception e ) \n \t2 { \n <ect>
\t2 try { \n \t3 runtime . get <identifiersep> runtime ( ) . remove <identifiersep> shutdown <identifiersep> <identifier> ( <identifier> ) ; \n \t3 log . debug ( <string_literal> , <identifier> ) ; \n \t2 } catch ( illegal <identifiersep> state <identifiersep> exception e ) { \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public collection < registered <identifiersep> service > load ( final file file ) { \n \t2 if ( ! file . <identifier> <identifiersep> read ( ) ) { \n <ect>
\t4 if ( <identifier> != null ) { \n \t5 try { \n \t6 <identifier> . close ( ) ; } \n \t5 catch ( exception e ) { \n <ect>
\t4 log . info ( entity <identifiersep> utils . to <identifiersep> string ( entity ) ) ; } \n \t3 entity <identifiersep> utils . <identifier> ( entity ) ; \n \t3 <identifier> = true ; \n \t2 } catch ( exception e ) { \n <ect>
\t6 final <identifier> <identifiersep> command <identifier> = ( <identifier> <identifiersep> command ) cmd ; \n \t6 answer = <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> <identifiersep> url ( ) , <identifier> ) ; \n \t5 } else if ( cmd instanceof shutdown <identifiersep> command ) { \n \t6 shutdown <identifiersep> command shutdown = ( shutdown <identifiersep> command ) cmd ; \n <ect>
\t1 logger . info ( <string_literal> + ++ i ) ; \n \t1 root . info ( <string_literal> + i ) ; \n \t1 logger . warn ( <string_literal> + ++ i ) ; \n \t1 root . warn ( <string_literal> + i ) ; \n <ect>
\t2 <comment> \n \t2 if ( entity <identifiersep> manager <identifiersep> factory == null ) { \n \t3 log . warn ( <string_literal> ) ; } \n \t2 if ( transaction <identifiersep> manager == null ) { \n <ect>
\t3 } else { \n \t4 log . error ( <string_literal> + name + <string_literal> ) ; \n \t4 return new <identifier> <identifiersep> default <identifiersep> <identifier> <identifiersep> create <identifiersep> handler ( ) ; } \n \t2 } catch ( exception e ) { \n <ect>
public file <identifiersep> item <identifiersep> <identifier> ( file data <identifiersep> file , long <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) { \n \t1 <identifier> . check <identifiersep> argument ( data <identifiersep> file != null , <string_literal> ) ; \n \t1 <identifier> . check <identifiersep> argument ( data <identifiersep> file . exists ( ) && ! data <identifiersep> file . is <identifiersep> directory ( ) , \n \t1 <string_literal> , data <identifiersep> file ) ; \n <ect>
\t1 @ <identifier> \n \t1 public void on <identifiersep> client <identifiersep> <identifier> ( ) { } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> client <identifiersep> close ( ) { \n <ect>
\t3 <comment> \n \t3 <comment> \n \t3 <identifier> . <identifier> ( ) ; \t3 \n \t2 } catch ( exception e ) { \n <ect>
\t6 logger . error ( <string_literal> + node . get <identifiersep> id ( ) + <string_literal> + \n \t8 node <identifiersep> <identifier> + <string_literal> ) ; \n \t6 throw e ; \n \t5 } else { \n <ect>
\t2 <identifier> : \n \t2 <identifier> <identifiersep> manager . level <identifiersep> <identifier> = log <identifiersep> level . warn \n \t2 <identifier> <identifiersep> manager . start ( ) \n \t2 logger . warn ( <string_literal> ) \n <ect>
\t5 . for <identifiersep> <identifier> ( info <identifiersep> header <identifiersep> line - > log . info ( <string_literal> + info <identifiersep> header <identifiersep> line . get <identifiersep> id ( ) ) ) ; \n \t3 out <identifiersep> header . get <identifiersep> format <identifiersep> header <identifiersep> <identifier> ( ) \n \t5 . stream ( ) \n \t5 . filter ( format <identifiersep> header <identifiersep> line - > ! <identifier> . get <identifiersep> file <identifiersep> header ( ) . has <identifiersep> info <identifiersep> line ( format <identifiersep> header <identifiersep> line . get <identifiersep> id ( ) ) ) \n <ect>
\t2 node result = null ; \n \t2 try { \n \t3 result = x <identifiersep> path <identifiersep> api . <identifier> <identifiersep> <identifier> <identifiersep> node ( xml , node <identifiersep> list <identifiersep> x <identifiersep> path ) ; \n \t2 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 { \n \t2 <identifier> <identifiersep> socket socket = <identifier> . get ( long . value <identifiersep> of ( socket <identifiersep> <identifier> ) ) ; \n \t2 if ( socket == null ) \n \t2 { \n <ect>
<comment> \n protected void <identifier> <identifiersep> import ( job job ) throws io <identifiersep> exception , import <identifiersep> exception { } \n protected void <identifier> <identifiersep> import ( string table <identifiersep> name , configuration conf , job job ) \n \t1 throws import <identifiersep> exception { \n <ect>
\t6 <identifier> <identifiersep> log . warn ( <string_literal> + new date ( send <identifiersep> on ) + <string_literal> + <identifier> + \n \t8 <string_literal> + state ) ; \n \t4 } else { \n \t5 if ( <identifier> <identifiersep> log . should <identifiersep> warn ( ) ) \n <ect>
\t1 private boolean is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> by <identifiersep> <identifier> ( long <identifier> <identifiersep> id ) { \n \t2 boolean <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = false ; \n \t2 service <identifiersep> <identifier> <identifiersep> vo <identifier> = service <identifiersep> <identifier> <identifiersep> dao . find <identifiersep> by <identifiersep> id <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> id ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 <identifier> <identifiersep> <identifier> ( <identifier> , <identifier> ) ; \n \t2 connection <identifiersep> uri = <string_literal> ; \n \t2 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> connection <identifiersep> factory ( connection <identifiersep> uri ) ; \n \t2 <identifier> . start ( ) ; \n <ect>
\t4 return bytes <identifiersep> <identifier> <identifiersep> host ; \n \t3 } catch ( io <identifiersep> exception e ) { \n \t4 log . warn ( <string_literal> , e ) ; } \n \t2 } else { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t1 } catch ( sql <identifiersep> exception <identifier> ) { \n \t2 logger . error ( <string_literal> , <identifier> ) ; } \n \t1 } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> <identifiersep> context context = <identifier> <identifiersep> context . get <identifiersep> instance ( <string_literal> ) ; \n \t2 context . <identifier> ( null , <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , null ) ; \n \t2 <identifier> <identifiersep> socket <identifiersep> factory = context . get <identifiersep> socket <identifiersep> factory ( ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 system . set <identifiersep> property ( <string_literal> , <identifier> <identifiersep> path ) ; } \n \t1 private string get <identifiersep> <identifier> <identifiersep> path ( ) { \n \t2 url <identifier> <identifiersep> url = <identifier> <identifiersep> test <identifiersep> configuration . class . get <identifiersep> resource ( <string_literal> ) ; \n \t2 string <identifier> <identifiersep> path = new file ( <identifier> <identifiersep> url . get <identifiersep> file ( ) ) . get <identifiersep> <identifier> <identifiersep> path ( ) ; \n <ect>
\t2 if ( <identifier> <identifiersep> <identifier> >= test <identifiersep> <identifier> ) { \n \t3 is <identifiersep> <identifier> = true ; \n \t3 logger . warn ( <string_literal> + <identifier> <identifiersep> <identifier> ) ; } \n \t2 else { \n <ect>
\t1 files . create <identifiersep> <identifier> <identifiersep> <identifier> ( new file ( <identifier> <identifiersep> dir , <string_literal> ) ) ; \n \t1 file = file . create <identifiersep> <identifier> <identifiersep> file ( get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , <string_literal> , <identifier> <identifiersep> dir ) ; \n \t1 logger . info ( <string_literal> , file ) ; \n \t1 meta = file . create <identifiersep> <identifier> <identifiersep> file ( get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , <string_literal> , <identifier> <identifiersep> dir ) ; \n <ect>
\t2 <identifier> < header > <identifier> = <identifier> <identifiersep> utils . <identifier> ( in <identifiersep> message . get <identifiersep> all <identifiersep> <identifier> ( ) ) ; \n \t2 while ( <identifier> . has <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n \t3 header header = <identifier> . next <identifiersep> element ( ) ; \n \t3 string [ ] value = message . get <identifiersep> header ( header . get <identifiersep> name ( ) ) ; \n <ect>
\t8 remove <identifiersep> <identifier> . next ( ) ; \n \t8 remove <identifiersep> <identifier> . remove ( ) ; \n \t8 if ( remove <identifiersep> count ++ > <identifier> ) { \n \t9 break ; } } } \n <ect>
\t2 <identifier> . close ( ) ; } \n \t2 if ( null != manager ) { \n \t2 manager . close ( ) ; } \n \t1 } catch ( sql <identifiersep> exception sql <identifiersep> e ) { \n <ect>
\t4 index <identifiersep> provider provider = provider <identifiersep> map . <identifier> ( provider <identifiersep> <identifier> ) ; \n \t4 <identifier> <identifiersep> index <identifiersep> state <identifier> <identifiersep> state = provider . get <identifiersep> <identifier> <identifiersep> state ( index <identifiersep> id , <identifier> ) ; \n \t4 index <identifiersep> <identifier> . <identifier> <identifiersep> if <identifiersep> <identifier> ( <identifier> <identifiersep> state , <identifier> <identifiersep> index <identifiersep> state - > new array <identifiersep> list < > ( ) ) \n \t4 . add ( new index <identifiersep> log <identifiersep> <identifier> ( index <identifiersep> id , <identifier> ) ) ; \n <ect>
\t3 <identifier> <identifiersep> delete ( <identifier> ) ; } \n \t2 try { \n \t3 <identifier> . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 return ; } \n \t2 if ( is <identifiersep> <identifier> ( ) ) { \n \t3 <comment> \n \t3 if ( user == null ) { \n <ect>
\t3 if ( factory <identifiersep> class != null ) { \n \t4 method method = factory <identifiersep> class . get <identifiersep> method ( <string_literal> , new class < ? > [ 0 ] ) ; \n \t4 return ( session <identifiersep> factory ) method . <identifier> ( null , new object [ 0 ] ) ; } \n \t2 } catch ( exception ex ) { \n <ect>
\t3 log . debug ( config <identifiersep> info ( <string_literal> , <identifier> <identifiersep> port <identifiersep> <identifier> ) ) ; \n \t3 log . debug ( config <identifiersep> info ( <string_literal> , thread <identifiersep> <identifier> ) ) ; \n \t3 log . debug ( config <identifiersep> info ( <string_literal> , <identifier> <identifiersep> timeout ) ) ; \n \t3 log . debug ( config <identifiersep> info ( <string_literal> , <identifier> <identifiersep> timeout ) ) ; \n <ect>
\t2 if ( transport != null ) { \n \t3 try { \n \t4 transport . close ( ) ; \n \t3 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t3 if ( on <identifiersep> find <identifiersep> job != null ) \n \t4 <identifier> <identifiersep> context . job <identifiersep> queue ( ) . add <identifiersep> job ( on <identifiersep> find <identifiersep> job ) ; \n \t2 } else if ( is <identifiersep> <identifier> <identifiersep> <identifier> ( key ) ) { \n \t3 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . warn ) ) \n <ect>
\t1 m . <identifier> ( builder , null ) ; \n \t1 } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { \n \t1 log . debug ( <string_literal> ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t5 log <identifiersep> <identifier> , web <identifiersep> options . log <identifiersep> path ) ; \n \t4 return new log <identifiersep> file <identifiersep> location ( null , null ) ; } \n \t3 string out <identifiersep> file <identifiersep> path = log <identifiersep> file <identifiersep> path . <identifier> ( 0 , log <identifiersep> file <identifiersep> path . length ( ) - <number_literal> ) . <identifier> ( <string_literal> ) ; \n \t3 log . info ( <string_literal> , log <identifiersep> file <identifiersep> path ) ; \n <ect>
\t3 return ; \n \t2 close <identifiersep> <identifier> ( ) ; } \n \t1 protected void close <identifiersep> <identifier> ( ) { \n <ect>
this function <identifier> <identifier> the <identifier> ticket if security is enabled . \n : return : \n <identifier> \n import <identifier> \n <ect>
\t5 set <identifiersep> <identifier> ( <identifier> <identifiersep> task , <string_literal> ) ; \n \t5 try { \n \t6 channel . send <identifiersep> response ( e ) ; \n \t5 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
<comment> \n \t1 protected void handle <identifiersep> listener <identifiersep> exception ( throwable ex ) { \n <ect>
\t1 <identifier> . check <identifiersep> not <identifiersep> null ( key , <string_literal> ) ; \n \t1 boolean <identifier> = <identifier> <identifiersep> <identifier> . remove ( key ) ; \n \t1 if ( <identifier> ) { \n <ect>
\t6 map < string , <identifier> > <identifier> <identifiersep> <identifier> , \n \t6 list < <identifier> > <identifier> <identifiersep> <identifier> ) { \n \t1 <identifier> <identifiersep> api <identifiersep> <identifier> <identifier> <identifiersep> api <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> is . get ( <identifier> ) ; \n \t1 if ( null != <identifier> <identifiersep> api <identifiersep> <identifier> ) { \n <ect>
\t3 try { \n \t4 if ( <identifier> <identifiersep> files != null && ! <identifier> <identifiersep> files . is <identifiersep> empty ( ) ) { \n \t5 file <identifier> = new file ( root <identifiersep> dir , <identifier> + <identifier> . get <identifiersep> file <identifiersep> name <identifiersep> <identifier> ( ) ) ; \n \t5 <identifier> ( <identifier> <identifiersep> files , <identifier> , true ) ; \n <ect>
<comment> \n \t1 @ <identifier> <identifiersep> <identifier> \n \t1 @ <identifier> <identifiersep> throws \n \t1 public void <identifier> ( ) { \n <ect>
\t3 <identifier> <identifiersep> logger . error ( <string_literal> , e ) ; \n \t3 <identifier> . close ( ) ; \n \t3 return ; \n \t3 } else if ( e instanceof org . apache . thrift . t <identifiersep> application <identifiersep> exception ) { \n <ect>
\t3 nodes . add ( node ) ; \n \t3 <identifier> [ i ] = new thread ( new abstract <identifiersep> <identifier> ( ) { \n \t4 @ <identifier> \n \t4 public void on <identifiersep> failure ( exception e ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 return ; } \n \t1 string <identifier> <identifiersep> path = <string_literal> + <identifier> <identifiersep> name ; \n <ect>
\t1 { \n \t2 @ <identifier> \n \t2 public void on <identifiersep> error ( throwable e ) \n \t2 { \n <ect>
\t6 <identifier> . put ( new <identifiersep> <identifier> , entry ) ; \n \t5 } else { \n \t6 log . warn ( <string_literal> , <identifier> <identifiersep> <identifier> ) ; } } } \n \t2 } catch ( <identifier> <identifiersep> name <identifiersep> exception e ) { \n <ect>
\t3 if ( ! <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) \n \t4 <identifier> <identifiersep> context . job <identifiersep> queue ( ) . add <identifiersep> job ( <identifier> <identifiersep> short <identifiersep> <identifier> <identifiersep> data <identifiersep> job ) ; } } \n \t1 private void do <identifiersep> short <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> data ( <identifier> <identifiersep> message message <identifiersep> body , <identifier> from ) { \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . debug ) ) \n <ect>
\t2 <identifier> <identifier> <identifiersep> class = class <identifiersep> <identifier> . find <identifiersep> <identifier> <identifiersep> class ( class <identifiersep> id ) ? : return null \n \t2 <identifier> class <identifiersep> header = <identifier> <identifiersep> class . class <identifiersep> header \n \t2 <identifier> data = class <identifiersep> header . data \n \t2 if ( data == null ) { \n <ect>
\t3 service <identifiersep> <identifier> <identifiersep> dao . remove <identifiersep> registered <identifiersep> service ( service ) ; \n \t3 logger . debug ( <string_literal> , service . get <identifiersep> name ( ) ) ; \n \t3 service <identifiersep> <identifier> <identifiersep> dao . <identifier> <identifiersep> event ( new <identifier> <identifiersep> registered <identifiersep> service <identifiersep> <identifier> <identifiersep> event ( this , service ) ) ; \n \t2 } else { \n <ect>
public string name ( ) { \n \t1 return ( string ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> <identifier> . name <identifiersep> key ) ; } \n public void set <identifiersep> name ( string value ) { \n <ect>
\t2 string table = <identifier> . group ( group <identifiersep> no ) ; \n \t2 if ( db <identifiersep> type . equals ( <string_literal> ) ) \n \t3 table = table . <identifier> <identifiersep> all ( <string_literal> , <string_literal> ) ; \n \t2 table <identifiersep> list . add ( table . to <identifiersep> <identifier> <identifiersep> case ( ) ) ; \n <ect>
\t1 <identifier> <identifiersep> <identifier> . delete ( get <identifiersep> conf ( ) , output ) ; } \n \t1 int <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . default <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t1 if ( get <identifiersep> <identifier> ( <string_literal> ) != null ) { \n \t1 <identifier> <identifiersep> <identifier> = integer . parse <identifiersep> int ( get <identifiersep> <identifier> ( <string_literal> ) ) ; } \n <ect>
\t1 <identifier> . add ( <string_literal> ) ; \n \t1 <identifier> . add ( get <identifiersep> <identifier> <identifiersep> string ( ) ) ; \n \t1 <identifier> . add ( <string_literal> ) ; \n \t1 <identifier> . add ( <string_literal> ) ; \n <ect>
\t3 try { \n \t4 <identifier> . io ( ) . send ( <identifier> <identifiersep> node <identifiersep> id , <identifier> ) ; } \n \t3 catch ( grid <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 <identifier> . put ( <string_literal> , <string_literal> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n \t2 <comment> \n \t2 <identifier> . put ( <string_literal> , <string_literal> ) ; \n <ect>
\t3 if ( <identifier> <identifiersep> type != null ) { \n \t4 try { \n \t5 <identifier> <identifiersep> message . set <identifiersep> <identifier> <identifiersep> type ( <identifier> <identifiersep> type ) ; } \n \t4 catch ( exception ex ) { \n <ect>
\t6 <comment> \n \t6 <comment> \n \t6 <identifier> . on <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n <ect>
\t2 <identifier> <identifiersep> time <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> last <identifiersep> version <identifiersep> as <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> name ) ; \n \t2 content <identifiersep> name name = new content <identifiersep> name ( <identifier> <identifiersep> name , <identifier> ) ; \n \t2 if ( ! name . equals ( <identifier> <identifiersep> name ) ) \n \t3 <identifier> ( ) ; \n <ect>
\t3 http <identifiersep> url <identifiersep> connection url <identifiersep> connection = new conn <identifiersep> builder ( <identifier> , <identifier> <identifiersep> name , null ) . get <identifiersep> connection ( ) ; \n \t3 response response = do <identifiersep> read <identifiersep> operation ( url <identifiersep> connection ) ; \n \t3 if ( ! response . is <identifiersep> success <identifiersep> code ( ) ) { \n \t4 if ( response . is <identifiersep> <identifier> <identifiersep> <identifier> ( ) ) { \n <ect>
\t5 return false ; } \n \t3 } catch ( <identifier> <identifiersep> value <identifiersep> exception ex ) { \n \t4 logger . error ( <string_literal> , ex . get <identifiersep> message ( ) ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception ex ) { \n <ect>
\t3 msg = new org . apache . thrift . t <identifiersep> application <identifiersep> exception ( org . apache . thrift . t <identifiersep> application <identifiersep> exception . <identifier> <identifiersep> error , e . get <identifiersep> message ( ) ) ; } \n \t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 } catch ( java . <identifier> . exception ex ) { \n <ect>
\t1 process . input <identifiersep> client . <identifier> \n \t2 ( task <identifiersep> type . map , \n \t2 job . get ( <identifier> <identifiersep> job . input <identifiersep> <identifier> ) , \n \t2 <identifier> <identifiersep> job . get <identifiersep> map <identifiersep> output <identifiersep> <identifier> ( job ) . to <identifiersep> string ( ) ) ; \n <ect>
<number_literal> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> <identifier> , root <identifiersep> <identifier> . get <identifiersep> version ( ) ) ; \n \t1 try { \n \t1 return <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) . get <identifiersep> <identifier> ( ) . get <identifiersep> file ( ) ; \n \t1 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t4 service . stop ( ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n \t4 <identifier> . add ( e ) ; \n \t4 logger . error ( e ) ; } } \n <ect>
\t2 try { \n \t3 this . web <identifiersep> application <identifiersep> context = <identifier> <identifiersep> web <identifiersep> application <identifiersep> context ( ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 catch ( <identifier> <identifiersep> exception | runtime <identifiersep> exception ex ) { \n <ect>
\t1 void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) { \n \t2 list < <identifier> <identifiersep> <identifier> <identifiersep> vo > <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> vm <identifiersep> map <identifiersep> dao . list <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> != null ) { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) > 0 ) { \n <ect>
\t2 <identifier> . execute ( <identifier> ) ; \n \t2 <identifier> . add <identifiersep> all ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n \t2 for ( string s : <identifier> ) { \n \t3 if ( s . contains ( local <identifiersep> root <identifiersep> path ) ) { \n <ect>
\t6 log . debug ( <string_literal> + entry ) ; \n \t5 if ( <identifier> != null ) { \n \t6 <identifier> . <identifier> <identifiersep> entry ( entry . key ( ) ) ; \n <ect>
\t3 if ( ! url . contains <identifiersep> query <identifiersep> <identifier> ( session <identifiersep> id <identifiersep> key ) ) { \n \t4 url . set <identifiersep> query <identifiersep> <identifier> ( session <identifiersep> id <identifiersep> key , session . session <identifiersep> id ( ) ) ; } \n \t3 return url . to <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 catch ( <identifier> <identifiersep> url <identifiersep> exception e ) { \n <ect>
\t5 log . warn ( <string_literal> + <identifier> <identifiersep> info . get <identifiersep> host <identifiersep> name ( ) + <string_literal> ) ; \n \t4 } else { \n \t5 <identifier> . put ( <identifier> <identifiersep> id , <identifier> <identifiersep> info ) ; } } \n \t2 } else { \n <ect>
\t7 + <string_literal> , \n \t6 operation <identifiersep> failed <identifiersep> exception . <identifier> <identifiersep> error ) ; } } \n \t2 catch ( <identifier> <identifiersep> exception <identifier> ) \n \t2 { \n <ect>
\t2 if ( store <identifiersep> type != null && ! store <identifiersep> type . equals ( <identifier> ) ) { \n \t3 try { \n \t4 return this . <identifier> <identifiersep> manager . get <identifiersep> instance ( <identifier> <identifiersep> <identifier> <identifiersep> store . class , store <identifiersep> type ) ; \n \t3 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t3 else if ( ( api . get <identifiersep> response <identifiersep> type ( ) != response <identifiersep> type . error ) && ( api . get <identifiersep> response <identifiersep> code ( ) == <number_literal> ) ) { \n \t4 <comment> \n \t4 if ( api . get <identifiersep> response <identifiersep> type ( ) == response <identifiersep> type . empty ) { \n \t5 if ( api . is <identifiersep> empty ( ) == true ) { \n <ect>
\t3 @ <identifier> <identifiersep> <identifier> ( name = <string_literal> , text = <string_literal> ) string <identifier> <identifiersep> name , \n \t3 @ <identifier> <identifiersep> <identifier> ( name = <string_literal> , text = <string_literal> ) string <identifier> , \n \t3 @ <identifier> <identifiersep> <identifier> ( name = <string_literal> , text = <string_literal> ) string message ) { \n \t2 if ( ! <identifier> <identifiersep> action <identifiersep> service . is <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> <identifiersep> <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( id <identifiersep> <identifier> , id <identifiersep> <identifier> <identifiersep> name , \n <number_literal> id <identifiersep> <identifier> , id <identifiersep> url ) ; \n \t4 <identifier> . add <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> ) ; } \n \t2 } catch ( x <identifiersep> path <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws <identifier> <identifiersep> exception , <identifier> <identifiersep> exception { \n \t2 <comment> \n \t2 thread . current <identifiersep> thread ( ) . set <identifiersep> context <identifiersep> class <identifiersep> <identifier> ( <identifier> <identifiersep> class <identifiersep> <identifier> . get <identifiersep> instance ( ) ) ; \n <ect>
\t2 return <identifier> <identifiersep> type . <identifier> ; } \n \t1 @ <identifier> \n \t1 public host <identifiersep> vo create <identifiersep> host <identifiersep> vo <identifiersep> for <identifiersep> <identifier> <identifiersep> <identifier> ( host <identifiersep> vo host , \n \t3 <identifier> <identifiersep> command [ ] cmd ) { \n <ect>
\t7 <comment> \n \t7 <comment> \n \t7 <comment> \n \t5 catch ( throwable t ) { \n <ect>
\t1 if response . status == <number_literal> : \n \t1 logger . info ( <string_literal> ) \n \t1 break \n \t1 else : \n <ect>
\t5 <identifier> . version <identifiersep> <identifier> ( ) . on <identifiersep> node <identifiersep> <identifier> ( node ) ; \n \t5 if ( ! is <identifiersep> <identifier> ) { \n \t6 if ( ! is <identifiersep> <identifier> <identifiersep> <identifier> ) { \n <ect>
\t2 <identifier> . find <identifiersep> element ( by . <identifier> ( <string_literal> ) ) . <identifier> ( ) ; } \n \t1 public void <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> application ( string application ) { \n \t2 web <identifiersep> element <identifier> = get <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> <identifiersep> text ( application ) ; \n \t2 if ( <identifier> == null ) { \n <ect>
\t2 while ( handler == null && exception <identifiersep> class != throwable . class ) { \n \t3 exception <identifiersep> class = exception <identifiersep> class . get <identifiersep> <identifier> ( ) ; \n \t3 handler = this . exception <identifiersep> handler <identifiersep> map . get ( exception <identifiersep> class ) ; } \n <ect>
\t5 log . info ( log . <identifier> <identifiersep> <identifier> , <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) , in <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) , out <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) , <identifier> <identifiersep> <identifier> , ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) + in <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) + out <identifiersep> of <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) + <identifier> <identifiersep> <identifier> ) ) ; \n \t4 <comment> \n \t4 i = null ; \n \t4 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) \n <ect>
\t4 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . get <identifiersep> resource ( ) . get <identifiersep> <identifier> ( ) , \n \t6 <identifier> . get <identifiersep> resource ( ) . get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> . get <identifiersep> node <identifiersep> id ( ) . get <identifiersep> host ( ) ) ; \n \t4 <identifier> . add ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t1 map < string , channel > channel <identifiersep> map = channel <identifiersep> cache . get ( channel <identifiersep> <identifier> ) ; \n \t1 if ( channel <identifiersep> map != null ) { \n \t2 for ( string channel <identifiersep> name : <identifier> <identifiersep> not <identifiersep> <identifier> . get ( channel <identifiersep> <identifier> ) ) { \n \t2 if ( channel <identifiersep> map . remove ( channel <identifiersep> name ) != null ) { \n <ect>
\t1 log . debug ( <string_literal> , queue <identifiersep> key , path ) ; \n \t1 <identifier> <identifiersep> queue . add <identifiersep> <identifier> ( queue <identifiersep> key , path . to <identifiersep> string ( ) ) ; \n \t1 <identifier> <identifiersep> <identifier> . add ( queue <identifiersep> key ) ; \n \t1 } catch ( <identifier> <identifiersep> exception | interrupted <identifiersep> exception e ) { \n <ect>
\t2 case <identifier> : \n \t2 if ( <identifier> <identifiersep> count == 0 ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> . on <identifiersep> success ( <identifier> <identifiersep> properties ) ; } \n <ect>
\t2 return new <identifier> <identifiersep> command [ ] { cmd } ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( string name , map < string , object > <identifier> ) throws configuration <identifiersep> exception { \n \t2 if ( ! super . <identifier> ( name , <identifier> ) ) { \n <ect>
\t3 log . debug ( <string_literal> , e ) ; \n \t2 } catch ( instance <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t3 log . debug ( <string_literal> , e ) ; \n \t2 } catch ( <identifier> <identifiersep> object <identifiersep> name <identifiersep> exception e ) { \n <ect>
\t2 return - 1 ; } \n \t1 public int get <identifiersep> total <identifiersep> <identifier> <identifiersep> count ( ) { \n \t2 if ( <identifier> . get <identifiersep> <identifier> ( ) instanceof <identifier> <identifiersep> <identifier> ) { \n \t3 return ( ( <identifier> <identifiersep> <identifier> ) <identifier> . get <identifiersep> <identifier> ( ) ) . get <identifiersep> total <identifiersep> <identifier> <identifiersep> count ( <identifier> ) ; } \n <ect>
\t5 logger . debug ( <string_literal> , \n \t7 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . this . to <identifiersep> string ( ) , socket <identifiersep> timeout ) ; \n \t4 } catch ( exception e ) { \n \t5 if ( interrupted != true && this . is <identifiersep> interrupted ( ) != true ) { \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 return <identifier> . <identifier> ( ) ; } \n \t1 if ( <identifier> <identifiersep> result instanceof execution <identifiersep> failed ) { \n \t1 execution <identifiersep> failed error = ( execution <identifiersep> failed ) <identifier> <identifiersep> result ; \n <ect>
\t3 assert <identifier> != null ; <comment> \n \t3 try { \n \t4 <identifier> . close <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; \n \t3 } catch ( throwable t ) { \n <ect>
\t3 <identifier> = new <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> vo ( from , to , key , network <identifiersep> id ) ; \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> vo lock = \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> network <identifiersep> dao . <identifier> <identifiersep> in <identifiersep> lock <identifiersep> table ( long . value <identifiersep> of ( 1 ) ) ; \n \t3 if ( lock == null ) { \n <ect>
\t1 <comment> \n \t1 <comment> \n \t1 <comment> \n \t1 for ( write <identifiersep> entity output : <identifier> . get <identifiersep> <identifier> ( ) ) { \n <ect>
\t2 return new <identifier> <identifiersep> <identifier> <identifiersep> map ( ) ; } \n \t1 map <identifier> = ( map ) map . get ( <identifier> . get ( <string_literal> ) ) ; \n \t1 if ( <identifier> == null ) { \n \t2 string [ ] <identifier> = ( string [ ] ) map . key <identifiersep> set ( ) . to <identifiersep> array ( new string [ 0 ] ) ; \n <ect>
\t3 if ( command . get <identifiersep> <identifier> <identifiersep> id ( ) != 0 ) { \n \t4 <identifier> . set <identifiersep> <identifier> <identifiersep> id ( command . get <identifiersep> <identifier> <identifiersep> id ( ) ) ; } \n \t3 <identifier> <identifiersep> <identifier> <identifiersep> api . update <identifiersep> <identifier> <identifiersep> switch <identifiersep> port <identifiersep> <identifier> ( <identifier> <identifiersep> switch <identifiersep> <identifier> , <identifier> <identifiersep> switch <identifiersep> port . get <identifiersep> <identifier> ( ) , <identifier> ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> api <identifiersep> exception e ) { \n <ect>
\t3 if ( cache == null && get <identifiersep> cache <identifiersep> provider ( ) != null ) { \n \t4 try { \n \t5 cache = get <identifiersep> cache <identifiersep> provider ( ) . get <identifiersep> cache ( cache <identifiersep> name , cache <identifiersep> config ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t5 if ( <identifier> <identifiersep> <identifier> . <identifier> ( <number_literal> , time <identifiersep> unit . <identifier> ) ) { \n \t6 log . debug ( <string_literal> ) ; \n \t6 server . stop ( ) ; } \n \t4 } catch ( io <identifiersep> exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> ) return ; \n \t3 <identifier> <identifiersep> <identifier> = true ; \n \t3 super . success ( ) ; } \n \t2 if ( <identifier> <identifiersep> log . should <identifiersep> log ( log . info ) ) \n <ect>
\t3 string <identifiersep> <identifier> <identifier> = new string <identifiersep> <identifier> ( ) ; \n \t3 ex . <identifier> <identifiersep> stack <identifiersep> trace ( new <identifier> <identifiersep> <identifier> ( <identifier> ) ) ; \n \t3 return <identifier> . to <identifiersep> string ( ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t2 lock . lock ( ) ; \n \t2 try { \n \t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == null ) return ; \n \t3 check <identifiersep> not <identifiersep> null ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <string_literal> ) ; \n <ect>
\t1 @ <identifier> \n \t1 protected void do <identifiersep> <identifier> ( ) throws exception { \n \t2 try { \n \t3 event <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> context <identifiersep> <identifier> ( this ) ; \n <ect>
\t2 for ( on <identifiersep> test <identifiersep> <identifier> <identifiersep> <identifier> <identifier> : <identifier> ) { \n \t3 try { \n \t4 <identifier> . start <identifiersep> <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> test , <identifier> <identifiersep> test <identifiersep> service ) ; \n \t3 } catch ( exception e ) { \n <ect>
\t6 <identifier> <identifiersep> filter ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) \n \t2 { \n \t3 <identifier> <identifiersep> <identifier> = null ; \n <ect>
\t7 } catch ( number <identifiersep> format <identifiersep> exception e ) { } } \n \t6 <identifier> <identifiersep> of <identifiersep> <identifier> . add ( text ) ; } } \n \t3 <identifier> <identifiersep> of <identifiersep> <identifier> . add ( <identifier> <identifiersep> of <identifiersep> <identifier> ) ; } } \n \t2 end = db <identifiersep> <identifier> . size ( ) < <identifier> <identifiersep> size + 1 ; \n <ect>
\t4 log . debug ( <string_literal> , source ) ; \n \t4 source . <identifier> ( ) ; \n \t4 source <identifiersep> list . add ( source ) ; \n \t3 } else { \n <ect>
\t1 <identifier> <identifiersep> job job = null ; \n \t1 try { \n \t2 job = get <identifiersep> resource <identifiersep> manager ( ) . read ( job <identifiersep> id ) ; \n \t1 } catch ( item <identifiersep> not <identifiersep> found item <identifiersep> not <identifiersep> found ) { \n <ect>
\t2 { \n \t3 <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) ; } \n \t2 catch ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> exception e ) \n \t2 { \n <ect>
\t4 for ( <identifier> <identifiersep> listener <identifier> : <identifier> <identifiersep> <identifier> ) { \n \t5 <identifier> . <identifier> <identifiersep> <identifier> ( this ) ; } } \n \t3 error <identifiersep> handler . <identifier> ( <identifier> <identifiersep> context ) ; \n \t2 } catch ( exception ex ) { \n <ect>
\t1 if ( <identifier> != null ) { \n \t2 try { \n \t2 <identifier> = ( i <identifiersep> <identifier> <identifiersep> instance <identifiersep> <identifier> ) class . for <identifiersep> name ( <identifier> ) . new <identifiersep> instance ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t7 logger . warn ( <identifier> <identifiersep> <identifier> <identifiersep> name + <string_literal> + \n \t9 <string_literal> + <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> for <identifiersep> <identifier> ) ; } \n \t6 if ( access <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> meta <identifiersep> data ) { \n <ect>
\t5 <identifier> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . get ( <identifier> <identifiersep> id ) ; \n \t5 if ( <identifier> != null ) { \n \t6 <identifier> . try <identifiersep> <identifier> ( timeout <identifiersep> <identifier> , time <identifiersep> unit . <identifier> ) ; \n \t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . remove ( <identifier> ) ; } \n <ect>
\t2 try { <identifier> <identifiersep> context . message <identifiersep> <identifier> ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . in <identifiersep> <identifier> <identifiersep> message <identifiersep> pool ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . client <identifiersep> message <identifiersep> pool ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n \t2 try { <identifier> <identifiersep> context . session <identifiersep> key <identifiersep> manager ( ) . shutdown ( ) ; } catch ( throwable t ) { <identifier> <identifiersep> log . error ( <string_literal> , t ) ; } \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> <identifier> ( <identifier> <identifiersep> list <identifier> ) \n \t1 { \n \t2 if ( <identifier> != null ) \n <ect>
\t2 final test <identifiersep> <identifier> <identifiersep> handler < long > count <identifiersep> handler = new test <identifiersep> <identifier> <identifiersep> handler < long > ( ) ; \n \t2 <identifier> <identifiersep> <identifier> . read ( <identifier> , <identifier> + count <identifiersep> <identifier> , null , null , count <identifiersep> handler ) ; \n \t2 long count = count <identifiersep> handler . <identifier> ( ) ; \n \t2 assert <identifiersep> equals ( <number_literal> , count . int <identifiersep> value ( ) ) ; \n <ect>
\t1 throws io <identifiersep> exception { \n \t1 if ( input == null ) { \n \t1 throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } \n \t1 try { \n <ect>
\t1 protected string <identifier> <identifiersep> for <identifiersep> java <identifiersep> <identifier> ( string <identifier> ) { \n \t2 try { \n \t3 <identifier> = string <identifiersep> <identifier> <identifiersep> utils . <identifier> <identifiersep> java <identifiersep> <identifier> ( <identifier> ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( <identifier> <identifiersep> id != null ) { \n \t4 m <identifiersep> device < ? > <identifier> <identifiersep> device = ( m <identifiersep> device < ? > ) device . e <identifiersep> <identifier> ( ) ; \n \t4 <comment> \n \t4 if ( ! <identifier> <identifiersep> device . get <identifiersep> enabled <identifiersep> a ( ) . get ( ) ) { \n <ect>
\t5 byte [ ] <identifier> <identifiersep> bytes = <identifier> != null ? <identifier> . config ( ) . get <identifiersep> <identifier> ( ) . <identifier> ( <identifier> ) : null ; \n \t5 send <identifiersep> with <identifiersep> <identifier> ( <identifier> <identifiersep> node <identifiersep> id , new grid <identifiersep> <identifier> <identifiersep> response ( <identifier> <identifiersep> id , <identifier> <identifiersep> bytes ) ) ; } \n \t4 catch ( grid <identifiersep> exception e ) { \n \t5 if ( ! e . has <identifiersep> <identifier> ( grid <identifiersep> <identifier> <identifiersep> exception . class ) ) \n <ect>
\t4 <identifier> <identifiersep> <identifier> . add ( node ) ; } \n \t3 p . get <identifiersep> input <identifiersep> stream ( ) . close ( ) ; \n \t2 } catch ( exception e ) \n \t2 { \n <ect>
\t2 log . debug ( <string_literal> , <identifier> ) ; \n \t2 return <identifier> ; } \n \t1 @ <identifier> \n \t1 public void close ( ) throws io <identifiersep> exception { \n <ect>
\t7 ++ count ; \n \t6 } else if ( <identifier> <identifiersep> all ) { \n \t7 ++ count ; } } } } \n \t2 } catch ( exception e ) { \n <ect>
\t5 io <identifiersep> utils . <identifier> <identifiersep> bytes ( <identifier> <identifiersep> input , <identifier> <identifiersep> output ) ; \n \t5 <comment> \n \t5 new file ( target <identifiersep> path . to <identifiersep> string ( ) ) . set <identifiersep> <identifier> ( <identifier> ) ; \n \t4 } catch ( io <identifiersep> exception <identifier> ) { \n <ect>
\t2 if ( <identifier> != null && ! <identifier> . is <identifiersep> empty ( ) ) { \n \t3 network <identifiersep> vo public <identifiersep> <identifier> = <identifier> . get ( 0 ) ; \n \t3 public <identifiersep> <identifier> <identifiersep> id = public <identifiersep> <identifier> . get <identifiersep> id ( ) ; \n \t2 } else { \n <ect>
\t3 if ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> pool ) \n \t4 return <identifier> <identifiersep> <identifier> <identifiersep> pool . <identifier> <identifiersep> pool ( ) ; \n \t3 int num <identifiersep> <identifier> = runtime . get <identifiersep> runtime ( ) . <identifier> <identifiersep> <identifier> ( ) ; \n \t3 if ( max <identifiersep> <identifier> > num <identifiersep> <identifier> ) \n <ect>
\t6 try { \n \t7 <identifier> = <identifier> <identifiersep> host <identifiersep> <identifier> <identifiersep> dao . start <identifiersep> <identifier> <identifiersep> <identifier> ( host <identifiersep> id , node . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> node <identifiersep> id ) ; \n \t7 answer [ ] answer = send <identifiersep> <identifier> <identifiersep> command ( node . get <identifiersep> <identifier> ( ) , host <identifiersep> id , node . get <identifiersep> <identifier> ( ) , <identifier> <identifiersep> node <identifiersep> id , event . request <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t7 if ( answer == null ) { \n <ect>
\t4 } catch ( exception e ) { \n \t5 log . error ( <string_literal> , e ) ; } } \n \t3 <identifier> <identifiersep> <identifier> . <identifier> ( ) ; \n \t3 string path = <string_literal> + client . get <identifiersep> <identifier> ( ) ; \n <ect>
public list < input <identifiersep> <identifier> > <identifier> ( configuration conf , result <identifiersep> set <identifier> , \n \t1 string <identifier> <identifiersep> name ) throws sql <identifiersep> exception { \n \t1 log . warn ( <string_literal> ) ; \n \t1 log . warn ( <string_literal> ) ; \n <ect>
\t3 if ( <identifier> . execute <identifiersep> in <identifiersep> <identifier> ( ) && ( current != null && current == <identifier> ) ) { \n \t4 send <identifiersep> next ( <identifier> ) ; } \n \t3 throw e ; \n \t2 } catch ( exception e ) { \n <ect>
\t1 } catch ( final exception <identifier> ) { \n \t2 log . error ( <string_literal> + account <identifiersep> number + <string_literal> + name , <identifier> ) ; \n \t2 throw new <identifier> <identifiersep> failure <identifiersep> exception ( <string_literal> + name ) ; } \n \t1 } catch ( final exception e ) { \n <ect>
\t2 int <identifier> <identifiersep> <identifier> = location <identifiersep> index ; \n \t2 while ( location <identifiersep> index == - 1 || key . <identifier> <identifiersep> to ( <identifier> <identifiersep> <identifier> . get ( location <identifiersep> index ) ) > 0 ) \n \t3 location <identifiersep> index ++ ; \n \t2 if ( <identifier> <identifiersep> <identifier> >= 0 ) \n <ect>
\t6 <comment> \n \t6 <identifier> = false ; \n \t6 break ; } } \n \t3 } else { \n <ect>
\t3 { \n \t3 @ <identifier> \n \t3 public void on <identifiersep> error ( throwable e ) \n \t3 { \n <ect>
\t7 log . warn ( <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> ex ) ; } \n \t6 try { \n \t7 client <identifiersep> socket . close ( ) ; \n \t6 } catch ( io <identifiersep> exception io <identifiersep> ex ) { \n <ect>
\t2 response . close ( ) ; \n \t2 <comment> \n \t2 response = client . target ( <identifier> <identifiersep> url ( <string_literal> ) ) . request ( ) . get ( ) ; \n \t2 string entity = response . read <identifiersep> entity ( string . class ) ; \n <ect>
\t2 string <identifier> <identifiersep> address ; \n \t2 try { \n \t3 <identifier> <identifiersep> address = url <identifiersep> <identifier> . <identifier> ( address , <string_literal> ) ; \n \t2 } catch ( <identifier> <identifiersep> <identifier> <identifiersep> exception ex ) { \n <ect>
\t3 <comment> \n \t3 string <identifier> <identifiersep> cmd = <identifier> <identifiersep> utils . <identifier> + ( <identifier> <identifiersep> utils . <identifier> <identifiersep> <identifier> ? <string_literal> : <string_literal> ) ; \n \t3 return process <identifiersep> utils . <identifier> ( <identifier> <identifiersep> cmd + <identifier> <identifiersep> dir + <string_literal> + target <identifiersep> dir + <string_literal> , <identifier> . root <identifiersep> dir ) == 0 ; \n \t2 } else { \n <ect>
<comment> \n \t1 @ test \n \t1 public void test <identifiersep> get <identifiersep> <identifier> ( ) { \n \t2 <identifier> <identifier> = get <identifiersep> as <identifiersep> <identifier> ( <string_literal> ) ; \n <ect>
<number_literal> final registered <identifiersep> service <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , \n <number_literal> final registered <identifiersep> service registered <identifiersep> service ) { \n \t2 final string <identifier> <identifiersep> attribute = <identifier> <identifiersep> attributes <identifiersep> to <identifiersep> <identifier> . remove ( <identifier> <identifiersep> attribute <identifiersep> name ) ; \n \t2 if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( <identifier> <identifiersep> attribute ) ) { \n <ect>
\t3 <identifier> . close ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n \t4 log . debug ( <string_literal> , e ) ; } } \n <ect>
\t2 <comment> \n \t2 final node <identifiersep> shards <identifiersep> result node <identifiersep> shards <identifiersep> result = build <identifiersep> node <identifiersep> shards <identifiersep> result ( <identifier> <identifiersep> <identifier> , snapshot <identifiersep> <identifier> , \n \t3 <identifier> . get <identifiersep> ignore <identifiersep> nodes ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> id ( ) ) , in <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> , <identifier> <identifiersep> state , logger ) ; \n \t2 final boolean <identifier> <identifiersep> <identifier> <identifiersep> found = node <identifiersep> shards <identifiersep> result . <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . size ( ) > 0 ; \n <ect>
\t1 @ <identifier> \n \t1 public boolean <identifier> <identifiersep> start ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifier> , long host <identifiersep> id , <identifier> <identifier> , <identifier> <identifiersep> context context ) { \n \t2 check <identifiersep> <identifier> <identifiersep> answer answer = ( check <identifiersep> <identifier> <identifiersep> answer ) <identifier> . get <identifiersep> answer ( <string_literal> ) ; \n \t2 if ( answer == null || ! answer . get <identifiersep> result ( ) ) { \n <ect>
\t3 <identifier> = uri <identifiersep> <identifier> . parse <identifiersep> <identifier> ( <identifier> <identifiersep> uri ) ; \n \t3 <comment> \n \t3 <identifier> <identifiersep> <identifier> . set <identifiersep> properties ( get <identifiersep> <identifier> <identifiersep> <identifier> ( ) , <identifier> ) ; \n \t2 } catch ( uri <identifiersep> <identifier> <identifiersep> exception e ) { \n <ect>
\t2 string path = <identifier> <identifiersep> context . get <identifiersep> <identifier> <identifiersep> path ( <string_literal> ) ; \n \t2 path += file . <identifier> + <string_literal> + file . <identifier> + <string_literal> ; \n \t2 file <identifier> = new file ( path ) ; \n \t2 if ( ! <identifier> . exists ( ) ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t5 logger . error ( <identifier> . to <identifiersep> string ( ) ) ; } } \n \t2 } ; \n \t2 t . start ( ) ; \n \t2 <identifier> . <identifier> ( ) ; \n <ect>
\t2 i <identifiersep> connection conn = null ; \n \t2 <identifier> <identifiersep> <identifier> node <identifiersep> port = task <identifiersep> to <identifiersep> node <identifiersep> port . get ( task <identifiersep> id ) ; \n \t2 if ( node <identifiersep> port == null ) { \n \t3 string error <identifiersep> msg = <string_literal> + task <identifiersep> id + <string_literal> ; \n <ect>
\t2 catch ( exception e ) \n \t2 { \n \t3 data = null ; \n \t3 <identifier> = - 1 ; \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> message ( <string_literal> , <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . send <identifiersep> message ( <string_literal> , <string_literal> , <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . class . get <identifiersep> <identifier> <identifiersep> name ( ) ) ; } \n \t1 @ <identifier> . event <identifiersep> handler \n \t1 public void <identifier> ( <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> event event ) { \n <ect>
\t3 create <identifiersep> result <identifiersep> <identifier> ( java <identifiersep> context , <identifier> <identifiersep> authentication <identifiersep> result ) } } } \n \t2 <identifier> <identifiersep> result . on <identifiersep> failure { case x = > log . error ( <string_literal> , x ) } \n \t2 <identifier> <identifiersep> result \n \t1 case <identifier> = > \n <ect>
\t6 this . <identifier> . max <identifiersep> <identifier> <identifiersep> msg <identifiersep> <identifier> ( data , true ) ; \n \t6 break ; \n \t5 default : \n \t6 <comment> \n <ect>
<comment> \n \t1 @ <identifier> \n \t1 public void stop ( <identifier> <identifiersep> context <identifier> ) throws exception { \n \t2 context = null ; \n <ect>
\t2 < p > <identifier> this <identifier> with <identifier> <identifier> , <identifier> text and <identifier> the log <identifier> . . . < / p > \n \t2 message : \n \t2 < input type = <string_literal> <identifier> - model = <string_literal> / > \n \t2 < <identifier> <identifier> - <identifier> = <string_literal> > log < / <identifier> > \n <ect>
\t1 public cluster <identifiersep> service get <identifiersep> <identifier> <identifiersep> service ( string <identifier> <identifiersep> <identifier> ) throws remote <identifiersep> exception { \n \t2 try { \n \t3 <identifier> ( ) ; \n \t2 } catch ( configuration <identifiersep> exception e ) { \n <ect>
\t4 throw new resource <identifiersep> <identifier> <identifiersep> exception ( <string_literal> + type <identifiersep> string + <string_literal> , data <identifiersep> <identifier> . class , <identifier> . get <identifiersep> data <identifiersep> <identifier> <identifiersep> id ( ) ) ; } \n \t2 } else if ( <identifier> . get <identifiersep> state ( ) == state . <identifier> || <identifier> . get <identifiersep> state ( ) == state . <identifier> ) { \n \t3 s <identifiersep> logger . debug ( <string_literal> + <identifier> . get <identifiersep> instance <identifiersep> name ( ) + <string_literal> + <identifier> . get <identifiersep> state ( ) + <string_literal> + type <identifiersep> string + <string_literal> ) ; \n \t2 } else { \n <ect>
\t3 client <identifiersep> context context = new client <identifiersep> context ( instance , new <identifier> ( principal , token ) , \n \t4 client <identifiersep> conf ) ; \n \t3 <identifier> = new <identifier> <identifiersep> <identifier> ( context , table . id . of ( base <identifiersep> <identifier> . get <identifiersep> table <identifiersep> id ( ) ) , <identifier> ) ; } \n \t2 if ( is <identifiersep> <identifier> ) { \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \t4 return false ; } \n \t3 resource resource = <identifier> . get <identifiersep> store <identifiersep> factory ( ) . get <identifiersep> resource <identifiersep> store ( ) . find <identifiersep> by <identifiersep> name ( get <identifiersep> resource <identifiersep> name ( to ) , server . get <identifiersep> id ( ) ) ; \n \t3 if ( resource == null ) { \n <ect>
\t3 logger . error ( <string_literal> + <identifier> + <string_literal> ) ; \n \t3 throw new <identifier> <identifiersep> exception ( <string_literal> + <identifier> + <string_literal> ) ; } \n \t2 if ( ! metadata <identifiersep> dir . exists ( ) && ! metadata <identifiersep> dir . <identifier> ( ) ) \n \t2 { \n <ect>
\t3 if ( <identifier> <identifiersep> info != null ) \n \t4 set <identifiersep> <identifier> <identifiersep> info ( <identifier> <identifiersep> info ) ; } \n \t2 catch ( <identifier> <identifiersep> exception <identifier> ) \n \t2 { \n <ect>
\t3 assert . assert <identifiersep> true ( <string_literal> , result == null ) ; \n \t2 } catch ( exception e ) { \n \t3 log . info ( log . <identifier> <identifiersep> test , <string_literal> + e . get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + e . get <identifiersep> message ( ) ) ; \n \t3 assert . <identifier> ( e . get <identifiersep> message ( ) ) ; } \n <ect>
\t6 log . debug ( <string_literal> + update <identifiersep> count ) ; \n \t5 } else if ( update <identifiersep> count == <identifier> . success <identifiersep> no <identifiersep> info ) { \n \t6 log . debug ( <string_literal> ) ; \n \t5 } else if ( update <identifiersep> count == <identifier> . execute <identifiersep> failed ) { \n <ect>
\t1 <identifier> <identifiersep> delete <identifiersep> <identifier> = object <identifiersep> metadata <identifiersep> <identifier> . get <identifiersep> instance ( ) . <identifier> <identifiersep> object <identifiersep> to <identifiersep> state ( <identifier> <identifiersep> delete <identifiersep> <identifier> , object <identifiersep> state . <identifier> ) ; \n \t1 <identifier> . <identifier> ( ) ; \n \t1 return <identifier> <identifiersep> delete <identifiersep> <identifier> ; \n \t1 } catch ( exception e ) { \n <ect>
\t2 <identifier> <identifiersep> response response = <identifier> <identifiersep> <identifier> . create <identifiersep> response <identifiersep> in <identifiersep> context ( null ) ; \n \t2 <identifier> <identifiersep> resource <identifiersep> manager resource <identifiersep> manager = <identifier> <identifiersep> <identifier> . resource <identifiersep> manager ( ) ; \n \t2 <identifier> <identifiersep> <identifier> <identifiersep> element <identifiersep> data a <identifiersep> resource <identifiersep> data <identifiersep> object = resource <identifiersep> manager . <identifier> <identifiersep> <identifier> <identifiersep> data <identifiersep> for <identifiersep> key ( a <identifiersep> resource <identifiersep> key ) ; \n \t2 if ( a <identifiersep> resource <identifiersep> data <identifiersep> object == null ) { \n <ect>
\t6 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> ; \n \t6 break ; } \n \t4 } catch ( interrupted <identifiersep> exception e ) { \n \t5 interrupted = true ; \n <ect>
\t2 @ <identifier> \n \t2 public void close ( ) throws io <identifiersep> exception { \n \t3 super . close ( ) ; \n \t3 if ( files . delete <identifiersep> if <identifiersep> exists ( file . to <identifiersep> path ( ) ) ) { \n <ect>
\t7 . end <identifiersep> object ( ) \n \t6 . end <identifiersep> object ( ) \n \t5 . end <identifiersep> object ( ) ) \n \t3 . get ( ) . is <identifiersep> <identifier> ( ) , equal <identifiersep> to ( true ) ) ; \n <ect>
\t4 <identifier> <identifiersep> state . connection <identifiersep> failed , \n \t4 <identifier> <identifiersep> state <identifiersep> <identifier> <identifiersep> event . <identifier> <identifiersep> <identifier> <identifiersep> error , null ) ; } \n \t2 catch ( <identifier> <identifiersep> exception ex ) \n \t2 { \n <ect>
\t3 out . <identifier> ( ( char ) read <identifiersep> char ) ; } \n \t2 input . close ( ) ; \n \t2 <identifier> . close ( ) ; \n \t2 <identifier> <identifiersep> value = p . wait <identifiersep> for ( ) ; \n <ect>
\t2 if ( authentication == null ) { \n \t3 log . warn ( <string_literal> ) ; \n \t3 return ; } \n \t2 else if ( ! <identifier> <identifiersep> authentication <identifiersep> token . class . is <identifiersep> <identifier> <identifiersep> from ( authentication . get <identifiersep> class ( ) ) ) { \n <ect>
\t4 try { \n \t5 <identifier> <identifiersep> security <identifiersep> <identifier> <identifier> <identifiersep> info = <identifier> . read <identifiersep> value ( json , <identifier> <identifiersep> security <identifiersep> <identifier> . class ) ; \n \t5 <identifier> <identifiersep> info <identifiersep> map . put ( <identifier> , <identifier> <identifiersep> info ) ; \n \t4 } catch ( exception e ) { \n <ect>
\t6 <identifier> . <identifier> ( ) ; \n \t5 } else { \n \t6 <identifier> . close ( ) ; } } \n \t3 } catch ( runtime <identifiersep> exception e ) { \n <ect>
\t3 response = provider <identifiersep> get <identifiersep> put ( provider , request , request <identifiersep> user , metadata <identifiersep> <identifier> ) ; \n \t3 } else { \n \t3 log . warn ( <string_literal> ) ; \n \t3 throw ex ; } } \n <ect>
\t3 while ( true ) { \n \t4 if ( target <identifiersep> name . is <identifiersep> empty ( ) ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \t4 if ( target <identifiersep> name . char <identifiersep> <identifier> ( 0 ) == ' / ' ) { \n \t5 target <identifiersep> name = target <identifiersep> name . <identifier> ( 1 ) ; \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n \t2 logger . debug ( <string_literal> ) ; \n \t2 logger . info ( <string_literal> ) ; \n <ect>
\t3 status = response . get <identifiersep> status ( ) ; \n \t2 } catch ( io <identifiersep> exception e ) { \n \t3 logger . debug ( <string_literal> , e ) ; } \n \t2 if ( status != <number_literal> ) { \n <ect>
\t4 int <identifier> = integer . parse <identifiersep> int ( <identifier> ) ; \n \t4 port = <identifier> ; \n \t4 <identifier> <identifiersep> log . info ( <string_literal> + port ) ; \n \t3 } catch ( number <identifiersep> format <identifiersep> exception <identifier> ) { \n <ect>
\t4 throw ( exception ) exception . get <identifiersep> <identifier> ( ) ; } \n \t3 throw exception ; } \n \t2 catch ( throwable throwable ) { \n \t3 if ( trace ) { \n <ect>
\t1 test <identifiersep> <identifier> ( int thread <identifiersep> count ) { \n \t2 <identifier> <identifiersep> queue < <identifier> > queue = new <identifier> <identifiersep> queue < > ( ) ; \n \t2 <identifier> = new thread <identifiersep> pool <identifiersep> <identifier> ( thread <identifiersep> count , thread <identifiersep> count , <identifier> , time <identifiersep> unit . <identifier> , queue ) ; } \n \t1 public void stop ( ) { \n <ect>
<comment> \n public static void add <identifiersep> <identifier> ( job job , <identifier> <identifiersep> options options ) throws io <identifiersep> exception { \n \t1 if ( configuration <identifiersep> <identifier> . is <identifiersep> local <identifiersep> job <identifiersep> <identifier> ( job . get <identifiersep> configuration ( ) ) ) { \n <ect>
\t4 <identifier> . close ( ) ; } \n \t2 } catch ( exception e ) { \n \t3 log . info ( <identifier> <identifiersep> <identifier> , <string_literal> , id , key <identifiersep> file . get <identifiersep> <identifier> <identifiersep> path ( ) , e . get <identifiersep> class ( ) . get <identifiersep> name ( ) , e . get <identifiersep> message ( ) ) ; \n \t3 return ; } \n <ect>
\t4 <identifier> <identifier> <identifiersep> remote = new <identifier> ( <identifier> <identifiersep> host , user , <identifier> <identifiersep> password ) ; \n \t4 <identifier> <identifiersep> remote . execute ( <string_literal> + local <identifiersep> dir + <string_literal> + instance <identifiersep> name + <string_literal> ) ; \n \t3 } catch ( exception <identifier> ) { \n \t4 log . error ( <identifier> ) ; \n <ect>
\t3 connection . <identifier> ( new <identifier> ( ) ) ; \n \t2 } catch ( throwable e ) { \n \t3 failure = e ; } \n \t2 if ( failure != null ) { \n <ect>
<number_literal> <string_literal> , <identifier> <identifiersep> level . name ( ) ) ; \n \t3 <identifier> . instance . <identifier> ( <string_literal> , trace <identifiersep> <identifier> ) ; } \n \t2 else \n \t2 { \n <ect>
\t3 return super . get <identifiersep> configuration <identifiersep> <identifier> ( file <identifiersep> name ) ; } } \n \t1 protected url find <identifiersep> in <identifiersep> file <identifiersep> system ( string file <identifiersep> name ) throws io <identifiersep> exception { \n \t2 url url = null ; \n \t2 file file = new file ( file <identifiersep> name ) ; \n <ect>
\t5 <string_literal> ) ; \n \t2 } else { \n \t3 logger . debug ( <string_literal> ) ; \n \t3 <comment> \n <ect>
\t1 @ <identifier> \n \t1 public <identifier> < boolean , principal > <identifier> ( final request <identifiersep> context request <identifiersep> context , final <identifier> <identifier> ) { \n \t2 final principal principal = web <identifiersep> utils . get <identifiersep> principal <identifiersep> from <identifiersep> request <identifiersep> context ( request <identifiersep> context , this . ticket <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 if ( is <identifiersep> <identifier> <identifiersep> policy <identifiersep> <identifier> <identifiersep> by ( principal ) ) { \n <ect>
\t3 start . count <identifiersep> <identifier> ( ) ; \n \t3 try { \n \t4 t result = <identifier> . <identifier> ( ) ; \n \t4 if ( debug ) { \n <ect>
\t2 <string_literal> + info . id ; \n \t2 log . debug ( <string_literal> + s + <string_literal> ) ; \n \t2 int <identifier> <identifiersep> <identifier> = <identifier> . execute <identifiersep> update ( s ) ; \n \t2 if ( <identifier> <identifiersep> <identifier> != 1 ) { \n <ect>
\t3 try { \n \t3 <identifier> . send <identifiersep> response ( <identifier> , msg , msg <identifiersep> type , <identifier> ) ; \n \t3 return ; \n \t3 } catch ( exception ex ) { \n <ect>
\t3 task <identifiersep> execution <identifiersep> <identifier> execution <identifiersep> <identifier> = task <identifiersep> <identifier> <identifiersep> state . get <identifiersep> execution <identifiersep> <identifier> ( ) ; \n \t3 set < file > output <identifiersep> files = execution <identifiersep> <identifier> . get <identifiersep> output <identifiersep> files ( ) ; \n \t3 if ( output <identifiersep> files . is <identifiersep> empty ( ) ) { \n \t4 state . set <identifiersep> <identifier> ( task <identifiersep> execution <identifiersep> <identifier> . no <identifiersep> source ) ; \n <ect>
\t2 return null ; } } \n \t1 if ( <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) != null \n \t2 && ! <identifier> <identifiersep> <identifier> . get <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ( ) . is <identifiersep> empty ( ) ) { \n <ect>
\t2 <identifier> end = start . <identifier> <identifiersep> <identifier> ( <number_literal> * ( <identifier> <identifiersep> job <identifiersep> manager <identifiersep> <identifier> . job <identifiersep> <identifier> <identifiersep> <identifier> . value ( ) + <identifier> <identifiersep> job <identifiersep> manager <identifiersep> <identifier> . job <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . value ( ) ) * <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ) ; \n \t2 <identifier> <identifier> = <identifier> . <identifier> ( ) ; \n \t2 if ( s <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> v <identifiersep> <identifier> . value ( ) && <identifier> . is <identifiersep> <identifier> ( end ) ) { \n <ect>
\t5 <identifier> <identifiersep> key key = key <identifiersep> <identifier> . next ( ) ; \n \t5 key <identifiersep> <identifier> . remove ( ) ; \n \t5 handle <identifiersep> key ( key ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t1 @ <identifier> \n \t1 public void <identifier> ( host <identifiersep> <identifier> host , host <identifiersep> event event ) { \n \t1 host <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> event e = ( host <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> event ) event ; \n \t1 <comment> \n <ect>
\t5 <identifier> . get <identifiersep> <identifier> <identifiersep> value ( <string_literal> , <string_literal> ) , \n \t5 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . find <identifiersep> <identifier> <identifiersep> <identifier> ( log , <identifier> . has <identifiersep> <identifier> ( <string_literal> ) ) ) ; } \n \t1 catch ( throwable e ) \n \t1 { \n <ect>
\t3 <identifier> . load ( <identifier> ) ; \n \t3 <identifier> <identifiersep> file <identifiersep> name = <identifier> . get <identifiersep> property ( <string_literal> ) ; \n \t3 s <identifiersep> logger . info ( <string_literal> + <identifier> <identifiersep> file <identifiersep> name ) ; \n \t3 string <identifier> <identifiersep> file <identifiersep> name = <identifier> . get <identifiersep> property ( <string_literal> ) ; \n <ect>
\t3 this . <identifier> <identifiersep> <identifier> = ( options ) in . read <identifiersep> object ( ) ; \n \t3 this . system <identifiersep> id = ( string ) in . read <identifiersep> object ( ) ; \n \t3 this . <identifier> = ( list < string > ) in . read <identifiersep> object ( ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t2 set <identifiersep> <identifier> <identifiersep> action <identifiersep> result <identifiersep> and <identifiersep> <identifier> ( <identifier> <identifiersep> action . timeout ) ; } \n \t1 @ <identifier> \n \t1 public void on <identifiersep> error ( <identifier> <identifiersep> event <identifier> <identifiersep> event ) throws io <identifiersep> exception { \n \t2 throwable e = <identifier> <identifiersep> event . get <identifiersep> throwable ( ) ; \n <ect>
\t2 synchronized ( event <identifiersep> list ) { \n \t3 if ( ! event <identifiersep> list . is <identifiersep> empty ( ) ) { \n \t3 <identifier> <identifiersep> event <identifiersep> <identifier> ( event <identifiersep> list ) ; } } \n \t2 } catch ( exception e ) { \n <ect>
\t3 logger . warn ( <string_literal> ) ; } \n \t2 <comment> \n \t2 if ( ! this . <identifier> <identifiersep> <identifier> && this . <identifier> <identifiersep> bean == null && this . <identifier> <identifiersep> properties != null ) { \n \t3 if ( ( this . <identifier> <identifiersep> properties . get ( user ) == null ) && this . <identifier> == null ) { \n <ect>
\t1 # : <identifier> <identifiersep> <identifier> = > <string_literal> , \n \t1 try : \n \t1 return int ( self . data <identifiersep> return <identifiersep> first ( <string_literal> , self . data <identifiersep> <identifier> <identifiersep> output ) ) \n \t1 <identifier> value <identifiersep> error : \n <ect>
\t3 <identifier> . start ( ) ; } \n \t2 catch ( throwable e ) \n \t2 { \n \t3 <comment> \n <ect>
\t4 } else { \n \t5 <identifier> <identifiersep> <identifier> . remove ( vm <identifiersep> name ) ; } } } } \n \t1 protected answer execute ( <identifier> <identifiersep> entry <identifiersep> command cmd ) { \n <ect>
public string <identifier> <identifiersep> name ( ) { \n \t1 return ( string ) <identifier> <identifiersep> value <identifiersep> for <identifiersep> key ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> name <identifiersep> key ) ; } \n public void set <identifiersep> <identifier> <identifiersep> name ( string value ) { \n <ect>
\t2 routing <identifiersep> table <identifier> <identifiersep> routing <identifiersep> table = routing <identifiersep> table . builder ( ) \n \t4 . add <identifiersep> as <identifiersep> new ( meta <identifiersep> data . index ( <string_literal> ) ) \n \t4 . build ( ) ; \n \t2 cluster <identifiersep> state cluster <identifiersep> state = cluster <identifiersep> state . builder ( org . <identifier> . cluster . cluster <identifiersep> name . cluster <identifiersep> name <identifiersep> <identifier> . get <identifiersep> default ( <identifier> . empty ) ) . meta <identifiersep> data ( meta <identifiersep> data ) . routing <identifiersep> table ( <identifier> <identifiersep> routing <identifiersep> table ) . build ( ) ; \n <ect>
<number_literal> <string_literal> + template <identifiersep> pool <identifiersep> vo . get <identifiersep> pool <identifiersep> id ( ) + <string_literal> ) ; \n \t10 continue ; } \n \t9 <identifier> <identifiersep> <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> template <identifiersep> from <identifiersep> storage <identifiersep> pool ( template <identifiersep> pool <identifiersep> vo ) ; } \n \t7 } catch ( exception e ) { \n <ect>
\t3 return null ; } \n \t2 try { \n \t3 <identifier> = ( <identifier> ) <identifier> <identifiersep> class . new <identifiersep> instance ( ) ; \n \t2 } catch ( <identifier> <identifiersep> exception | illegal <identifiersep> access <identifiersep> exception t ) { \n <ect>
\t2 try { \n \t3 return request <identifiersep> from <identifiersep> text <identifiersep> factory . create <identifiersep> request ( message ) ; \n \t2 } catch ( exception ex ) { \n \t3 logger . error ( <string_literal> , message , <string_literal> ) ; \n <ect>
\t3 if ( <identifier> . get <identifiersep> location ( ) != null ) { \n \t4 final <identifier> <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao dao = new <identifier> <identifiersep> <identifier> <identifiersep> attribute <identifiersep> dao ( new <identifier> <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> dao ( application <identifiersep> context , <identifier> <identifiersep> properties ) ) ; \n \t4 dao . set <identifiersep> case <identifiersep> <identifier> <identifiersep> <identifier> ( <identifier> . is <identifiersep> case <identifiersep> <identifier> ( ) ) ; \n \t4 dao . set <identifiersep> <identifier> ( <identifier> . get <identifiersep> <identifier> ( ) ) ; \n <ect>
\t4 return } \n \t3 filter <identifiersep> exception = get <identifiersep> exception <identifiersep> type ( e , resource <identifiersep> not <identifiersep> found <identifiersep> exception : : class . java ) \n \t3 if ( filter <identifiersep> exception != null ) { \n \t4 response . send <identifiersep> error ( http <identifiersep> <identifier> <identifiersep> response . <identifier> <identifiersep> not <identifiersep> found ) \n <ect>
\t3 if ( <identifier> <identifiersep> group ( ) instanceof <identifier> <identifiersep> <identifier> <identifiersep> group ) { \n \t4 all <identifiersep> <identifier> <identifiersep> count = ( ( <identifier> <identifiersep> <identifier> <identifiersep> group < ? > ) <identifier> <identifiersep> group ( ) ) . <identifier> <identifiersep> <identifier> ( ) \n \t6 . count ( ) ; \n \t3 } else { \n <ect>
\t2 <identifier> <identifiersep> logger . set <identifiersep> level ( level . <identifier> ) ; \n \t2 logger . error ( error <identifiersep> message <identifiersep> with <identifiersep> no <identifiersep> <identifier> ) ; \n \t2 logger . warn ( <identifier> <identifiersep> message <identifiersep> with <identifiersep> no <identifiersep> <identifier> ) ; \n \t2 logger . info ( info <identifiersep> message <identifiersep> with <identifiersep> no <identifiersep> <identifier> ) ; \n <ect>
\t5 try { \n \t6 if ( ! <identifier> ( task ) ) { \n \t7 <identifier> . add ( task ) ; } \n \t5 } catch ( exception e ) { \n <ect>
\t2 string <identifier> <identifiersep> map <identifiersep> name = exchange . get <identifiersep> in ( ) . get <identifiersep> header ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> name , string . class ) ; \n \t2 string <identifier> <identifiersep> name = exchange . get <identifiersep> in ( ) . get <identifiersep> header ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> name , string . class ) ; \n \t2 <identifier> <identifiersep> map < string , string > config <identifiersep> map <identifiersep> data = exchange . get <identifiersep> in ( ) . get <identifiersep> header ( <identifier> <identifiersep> <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> data , <identifier> <identifiersep> map . class ) ; \n \t2 if ( object <identifiersep> <identifier> . is <identifiersep> empty ( <identifier> <identifiersep> map <identifiersep> name ) ) { \n <ect>
\t3 log . error ( <string_literal> , content . get <identifiersep> class ( ) . get <identifiersep> <identifier> <identifiersep> name ( ) , e ) ; \n \t2 } catch ( <identifier> <identifiersep> target <identifiersep> exception e ) { \n \t3 log . error ( <string_literal> , e ) ; \n \t2 } catch ( illegal <identifiersep> access <identifiersep> exception e ) { \n <ect>
\t3 location <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> <identifiersep> <identifier> ? <identifier> . get <identifiersep> next <identifiersep> location ( null ) : last <identifiersep> <identifier> <identifiersep> <identifier> ; \n \t3 if ( <identifier> <identifiersep> <identifier> != null ) { \n \t4 int <identifier> <identifiersep> <identifier> = 0 ; \n \t4 int data <identifiersep> file <identifiersep> <identifier> <identifiersep> <identifier> = <identifier> <identifiersep> <identifier> . get <identifiersep> data <identifiersep> file <identifiersep> id ( ) ; \n <ect>
\t4 event . event ( event <identifiersep> type . <identifier> ) ; \n \t4 event . error ( <identifier> . user <identifiersep> session <identifiersep> not <identifiersep> found ) ; \n \t4 return error <identifiersep> <identifier> . error ( session , null , response . status . <identifier> <identifiersep> request , <identifier> . <identifier> <identifiersep> provider <identifiersep> <identifier> <identifiersep> error ) ; } \n \t3 if ( user <identifiersep> session . get <identifiersep> state ( ) != user <identifiersep> session <identifiersep> model . state . <identifier> <identifiersep> out ) { \n <ect>
\t2 byte [ ] bytes = <identifier> . <identifier> ( s ) ; \n \t2 try { \n \t3 return data <identifiersep> set . delete ( bytes ) ; \n \t2 } catch ( exception e ) { \n <ect>
\t3 if ( test <identifiersep> case == null || name . equals <identifiersep> ignore <identifiersep> case ( test <identifiersep> case ) ) { \n \t4 run <identifiersep> test <identifiersep> case ( <identifier> . get <identifiersep> test <identifiersep> case <identifiersep> <identifier> ( c ) ) ; \n \t4 test <identifiersep> case <identifiersep> count ++ ; \n \t3 } else { \n <ect>
\t3 <identifier> <identifiersep> count ++ ; } \n \t2 public synchronized void <identifier> <identifiersep> <identifier> ( status status ) { \n \t3 <identifier> ++ ; \n \t3 if ( <identifier> <identifier> <identifier> <identifiersep> <identifier> <identifiersep> <identifier> == 0 ) { \n <ect>
\t1 logger . warn ( <identifier> ( e ) ) \n \t1 <identifier> . <identifier> ( ) \n if result != 0 : \n \t1 <identifier> \n <ect>
\t6 <identifier> <identifiersep> output <identifiersep> key . set ( <identifier> <identifiersep> <identifier> . get <identifiersep> json <identifiersep> object ( i ) . to <identifiersep> string ( ) ) ; } \n \t5 <identifier> <identifiersep> output <identifiersep> value . set ( <identifier> <identifiersep> <identifier> . get <identifiersep> json <identifiersep> object ( i ) . to <identifiersep> string ( ) ) ; \n \t5 context . write ( <identifier> <identifiersep> output <identifiersep> key , new text ( <identifier> <identifiersep> output <identifiersep> value ) ) ; \n \t4 } catch ( array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
\t2 for ( class < ? extends <identifier> <identifiersep> <identifier> > i : <identifier> ) { \n \t3 if ( ! <identifier> . <identifier> <identifiersep> <identifier> ( ) . contains ( i . get <identifiersep> name ( ) ) \n \t5 && ( ! check <identifiersep> <identifier> || check <identifiersep> default ( i ) ) ) { \n \t4 try { \n <ect>
\t5 create <identifiersep> template <identifiersep> <identifier> ( <identifier> , store , null ) ; } } } } \n \t1 @ <identifier> \n \t1 public void handle <identifiersep> template <identifiersep> <identifier> ( data <identifiersep> store store ) { \n \t2 if ( store == null ) { \n <ect>
\t2 public void <identifier> <identifiersep> <identifier> ( <identifier> <identifiersep> event <identifier> ) \n \t2 { \n \t3 synchronized ( this ) \n \t3 { \n <ect>
\t2 <identifier> <identifiersep> <identifier> <identifiersep> class . get <identifiersep> <identifier> <identifiersep> method ( <string_literal> , long . class , long . class ) \n \t3 . <identifier> ( <identifier> <identifiersep> <identifier> , <identifier> , <identifier> ) ; \n \t2 log . debug ( <string_literal> ) ; \n \t1 } catch ( exception exception ) { \n <ect>
\t5 <string_literal> + <identifier> <identifiersep> <identifier> + <string_literal> ) ; } \n \t2 file [ ] dir <identifiersep> <identifier> = dir . list <identifiersep> files ( ) ; \n \t2 if ( dir <identifiersep> <identifier> == null ) { \n <ect>
\t3 try { \n \t4 class < ? > <identifier> <identifiersep> class = class . for <identifiersep> name ( <identifier> <identifiersep> policy <identifiersep> <identifier> ) ; \n \t4 this . <identifier> <identifiersep> policy = ( <identifier> <identifiersep> node <identifiersep> <identifier> <identifiersep> policy ) <identifier> <identifiersep> class . new <identifiersep> instance ( ) ; \n \t3 } catch ( exception ex ) { \n <ect>
\t2 logger . debug ( <string_literal> , <identifier> ) ; \n \t2 final json <identifiersep> web <identifiersep> <identifier> <identifier> = new json <identifiersep> web <identifiersep> <identifier> ( ) ; \n \t2 final string json <identifiersep> <identifier> = <identifier> . to <identifiersep> json ( ) ; \n \t2 <identifier> . set <identifiersep> <identifier> ( json <identifiersep> <identifier> ) ; \n <ect>
\t5 if ( <identifier> <identifiersep> mode == session . session <identifiersep> <identifier> ) { \n \t6 try { \n \t7 consumer <identifiersep> session . <identifier> ( ) ; \n \t6 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
@ <identifier> <identifiersep> <identifier> ( <string_literal> ) \n public class content <identifiersep> exception <identifiersep> test extends test <identifiersep> case { \n private logger logger = log <identifiersep> manager . get <identifiersep> logger ( content <identifiersep> exception <identifiersep> test . class ) ; \n public void test <identifiersep> content <identifiersep> <identifier> ( ) { \n <ect>
\t2 try { \n \t3 log . info ( <string_literal> , <identifier> <identifiersep> json . <identifier> <identifiersep> string ( this ) , state <identifiersep> file . exists ( ) ? state <identifiersep> file . length ( ) : 0 ) ; \n \t3 <identifier> <identifiersep> files . write ( state <identifiersep> file , <identifier> <identifiersep> bytes . to <identifiersep> bytes ( <identifier> <identifiersep> json . <identifier> <identifiersep> string ( this ) ) , false ) ; \n \t2 } catch ( io <identifiersep> exception io ) { \n <ect>
public void test <identifiersep> <identifier> <identifiersep> token <identifiersep> with <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws throwable { \n \t1 <comment> \n \t1 user <identifiersep> group <identifiersep> <identifier> root = user <identifiersep> group <identifiersep> <identifier> . <identifier> <identifiersep> user <identifiersep> from <identifiersep> <identifier> <identifiersep> and <identifiersep> return <identifiersep> <identifier> ( \n \t2 root <identifiersep> user . get <identifiersep> principal ( ) , root <identifiersep> user . get <identifiersep> <identifier> ( ) . get <identifiersep> <identifier> <identifiersep> path ( ) ) ; \n <ect>
\t2 <identifier> < <identifier> <identifiersep> entry > <identifier> = <identifier> . <identifier> ( ) ; \n \t2 if ( ! <identifier> . has <identifiersep> next ( ) ) { \n \t3 <identifier> . for <identifiersep> <identifier> <identifiersep> <identifier> ( c - > c . <identifier> <identifiersep> start ( ) ) ; \n \t3 return ; } \n <ect>
\t1 } else if ( request instanceof put <identifiersep> object <identifiersep> type ) { \n \t2 <identifier> <identifiersep> log <identifiersep> entry . <identifier> ( <string_literal> + ( ( put <identifiersep> object <identifiersep> type ) request ) . get <identifiersep> content <identifiersep> <identifier> ( ) ) ; } \n \t1 log . trace ( <identifier> <identifiersep> log <identifiersep> entry . to <identifiersep> string ( ) ) ; \n \t1 } catch ( exception e ) { \n <ect>
\t6 <comment> \n \t3 } catch ( exception e ) { \n \t4 log . warn ( <string_literal> , e ) ; } } } \n \t1 protected void <identifier> <identifiersep> <identifier> <identifiersep> event ( final <identifier> <identifiersep> state <identifier> <identifiersep> state ) { \n <ect>
\t2 <identifier> = false \n \t2 for line in self . file <identifiersep> body [ 0 : <number_literal> ] : \n \t3 if self . is <identifiersep> <identifier> <identifiersep> line ( line ) and self . <identifier> . is <identifiersep> <identifier> <identifiersep> <identifier> <identifiersep> line ( line ) : \n \t4 <identifier> = true \n <ect>
\t1 private void add <identifiersep> <identifier> <identifiersep> service <identifiersep> provider ( connection conn , long <identifier> <identifiersep> network <identifiersep> id , long <identifier> <identifiersep> id ) { \n \t2 <identifier> <identifiersep> <identifier> <identifier> <identifiersep> update = null ; \n \t2 try { \n \t3 <comment> \n <ect>
\t4 s <identifiersep> logger . debug ( <identifier> . to <identifiersep> string ( ) ) ; \n \t4 s = conn . <identifier> <identifiersep> <identifier> <identifiersep> xml ( <identifier> . to <identifiersep> string ( ) ) ; \n \t4 s . set <identifiersep> value ( <identifier> . <identifier> <identifiersep> <identifier> ( user <identifiersep> info <identifiersep> <identifier> [ 1 ] ) ) ; \n \t3 } catch ( <identifier> <identifiersep> exception e ) { \n <ect>
\t1 put <identifiersep> request . set <identifiersep> meta <identifiersep> data ( user <identifiersep> metadata ) ; \n \t1 <identifier> < put <identifiersep> object <identifiersep> response <identifiersep> type > put <identifiersep> <identifier> = new <identifier> < put <identifiersep> object <identifiersep> response <identifiersep> type > ( ) { \n \t2 @ <identifier> \n \t2 public put <identifiersep> object <identifiersep> response <identifiersep> type <identifier> ( ) throws exception { \n <ect>
<comment> \n \t1 public static boolean <identifier> <identifiersep> load <identifiersep> and <identifiersep> <identifier> <identifiersep> class ( string name ) { \n \t2 try { \n \t3 class . for <identifiersep> name ( name , true , unit <identifiersep> <identifier> . class . get <identifiersep> class <identifiersep> <identifier> ( ) ) ; \n <ect>
\t5 <identifier> . <identifier> <identifiersep> handler ( ) ; \n \t5 <comment> \n \t4 } catch ( throwable t ) { \n \t5 <identifier> . <identifier> <identifiersep> handler ( ) ; \n <ect>
\t2 } ) ; \n \t1 } catch ( <identifier> <identifiersep> metadata <identifiersep> not <identifiersep> found <identifiersep> exception e ) { \n \t2 log . debug ( <string_literal> + <identifier> <identifiersep> id ) ; \n \t1 } catch ( throwable t ) { \n <ect>
\t4 ) ; \n \t4 return null ; } } \n \t2 ) ; \n \t1 } catch ( <identifier> <identifiersep> metadata <identifiersep> exception e ) { \n <ect>
\t1 return default <identifiersep> error <identifiersep> <identifier> ; } \n public void <identifier> <identifiersep> and <identifiersep> <identifier> ( final message message ) { \n \t1 logger . debug ( <string_literal> , message . get <identifiersep> <identifier> ( ) ) ; \n \t1 if ( get <identifiersep> state ( ) == <identifier> <identifiersep> state . local <identifiersep> <identifier> ) { \n <ect>
\t7 break ; \n \t6 case <identifier> <identifiersep> <identifier> <identifiersep> info . data <identifiersep> <identifier> <identifiersep> type : \n \t7 break ; \n \t6 default : \n <ect>
\t3 <identifier> <identifiersep> <identifier> <identifiersep> object = get <identifiersep> <identifier> <identifiersep> object <identifiersep> for <identifiersep> node <identifiersep> if <identifiersep> exists ( <identifier> <identifiersep> name ) ; \n \t3 if ( null != <identifier> <identifiersep> <identifier> <identifiersep> object ) { \n \t4 if ( <identifier> <identifiersep> <identifier> <identifiersep> object . is <identifiersep> <identifier> ( ) ) { \n \t5 if ( log . is <identifiersep> <identifier> ( log . <identifier> <identifiersep> <identifier> , level . info ) ) { \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \t2 cluster <identifiersep> state = <identifier> . <identifier> <identifiersep> <identifier> <identifiersep> shards ( cluster <identifiersep> state , cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) ) ; \n \t2 logger . info ( <string_literal> ) ; \n \t2 assert <identifiersep> that ( cluster <identifiersep> state . get <identifiersep> routing <identifiersep> nodes ( ) . shards <identifiersep> with <identifiersep> state ( <identifier> ) . size ( ) , equal <identifiersep> to ( <number_literal> ) ) ; \n <ect>
\t3 else if ( files . exists ( <identifier> ) ) { \n \t4 current <identifiersep> to <identifiersep> be = <number_literal> ; } \n \t3 else { \n \t4 <comment> \n <ect>
\t2 test <identifiersep> <identifier> ( queue . <identifier> ( ) , <identifier> [ <number_literal> ] ) ; \n \t2 log . info ( log . <identifier> <identifiersep> test , <string_literal> ) ; } \n \t1 @ test \n \t1 public void test <identifiersep> <identifier> <identifiersep> <identifier> ( ) throws throwable { \t1 \n <ect>
\t3 if ( result != null && result . equals ( <string_literal> ) ) { \n \t4 return key ; } \n \t3 return null ; \n \t2 } catch ( final exception e ) { \n <ect>
\t1 log . info ( <string_literal> ) ; \n \t1 log . info ( metadata ) ; \n \t1 assert <identifiersep> true ( metadata + <string_literal> <identifier> . <identifier> \\ <string_literal> true \\ <string_literal> , metadata . <identifier> ( <string_literal> <identifier> . <identifier> \\ <string_literal> true \\ <string_literal> ) ) ; \n \t1 import <identifiersep> command <identifier> <identifiersep> import <identifiersep> cmd = new import <identifiersep> command ( db <identifiersep> name , table <identifiersep> name , null , <identifier> <identifiersep> location , false , <identifier> ) ; \n <ect>
\t4 <comment> \n <ect>
\t1 public static message <identifiersep> type get <identifiersep> <identifier> ( integer <identifier> <identifiersep> id , boolean <identifier> <identifiersep> log ) { \n \t2 message <identifiersep> type id = <identifier> <identifiersep> <identifier> . get ( <identifier> <identifiersep> id ) ; \n \t2 if ( id == null ) { \n \t3 if ( ! <identifier> <identifiersep> log ) \n <ect>
\t2 this ( collection <identifiersep> utils . <identifier> <identifiersep> list ( authentication <identifiersep> result <identifiersep> code . <identifier> <identifiersep> <identifier> ) ) ; } \n \t1 @ <identifier> \n \t1 public boolean <identifier> ( final authentication <identifiersep> response response ) { \n \t2 if ( response == null ) { \n <ect>
\t7 continue <identifier> ; } } } \n \t4 <identifier> = true ; } \n \t3 while ( ! <identifier> && <identifier> < = max <identifiersep> <identifier> ) ; \n \t3 if ( <identifier> > max <identifiersep> <identifier> ) { \n <ect>
\t4 this . set <identifiersep> response <identifiersep> object ( response ) ; \n \t3 } else { \n \t4 throw new server <identifiersep> api <identifiersep> exception ( base <identifiersep> cmd . <identifier> <identifiersep> error , <string_literal> ) ; } \n \t2 } catch ( resource <identifiersep> <identifier> <identifiersep> exception <identifier> ) { \n <ect>
