\t6 return toProcessorDeclarations ( processorClassNames , Collections . < String , IncrementalAnnotationProcessorType > emptyMap ( ) ) ; } \n \n \t4 } finally { \n \n \t5 zipFile . close ( ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 public static void unregisterMbean ( ObjectName name ) { \n \n \t2 try { \n \n \t3 ManagementFactory . getPlatformMBeanServer ( ) . unregisterMBean ( name ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 if ( null != client ) { \n \n \t2 tservers = client . getActiveTservers ( tinfo , context . rpcCreds ( ) ) ; } \n \n \t1 } catch ( TException e ) { \n \n \t1 <comment> \n \n <ect>
\t2 val binaryClass = classFinder . findKotlinClass ( classId ) ? : return null \n \n \t2 val classHeader = binaryClass . classHeader \n \n \t2 val data = classHeader . data \n \n \t2 if ( data == null ) { \n \n <ect>
\t9 <string_literal> , jobId ) ; } } \n \n \t5 } , \n \n \t5 getMainThreadExecutor ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 responseHandler . reset ( ) ; \n \n \t2 olingoApp . read ( edm , TEST_PEOPLE , null , null , responseHandler ) ; \n \n \t2 entity = responseHandler . await ( ) ; \n \n \t2 assertEquals ( <string_literal> , entity . getProperty ( <string_literal> ) . getValue ( ) . toString ( ) ) ; \n \n <ect>
\t5 @ Override public Object execute ( ) throws GridException { \n \n \t6 assert taskSes != null ; \n \n \t6 thread = Thread . currentThread ( ) ; \n \n <ect>
\t3 . filter ( Optional : : isPresent ) \n \n \t3 . map ( Optional : : get ) \n \n \t3 . map ( SamlRegisteredServiceServiceProviderMetadataFacade : : getMetadataResolver ) \n \n \t3 . collect ( Collectors . toList ( ) ) ; \n \n <ect>
\t1 JavaCompiler compiler = ToolProvider . getSystemJavaCompiler ( ) ; \n \n \t1 if ( null == compiler ) { \n \n \t1 LOG . error ( <string_literal> ) ; \n \n \t1 LOG . error ( <string_literal> ) ; \n \n <ect>
\t3 while ( ( consumerThread . isAlive ( ) || producerThread . isAlive ( ) ) && \n \n \t4 ( producerError . get ( ) == null && consumerError . get ( ) == null ) ) { \n \n \t4 Thread . sleep ( <number_literal> ) ; \n \n \t4 if ( System . currentTimeMillis ( ) >= deadline ) { \n \n <ect>
\t1 try { \n \n \t1 if ( connectionAvailable ( ) ) { \n \n \t2 write ( socket , metrics ) ; } \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 log . debug ( <string_literal> + mailErrorTemplate ) ; \n \n \t3 if ( mailErrorTemplate == null ) \n \n \t3 { \n \n <ect>
\t1 MemPageWriter pageWriter = pageWriters . get ( descriptor ) ; \n \n \t1 if ( pageWriter == null ) { \n \n \t1 throw new UnknownColumnException ( descriptor ) ; } \n \n \t1 List < DataPage > pages = new ArrayList < DataPage > ( pageWriter . getPages ( ) ) ; \n \n <ect>
\t2 Channel answer = channelFuture . getChannel ( ) ; \n \n \t2 <comment> \n \n \t2 allChannels . add ( answer ) ; \n \n <ect>
\t1 } catch ( ClassNotFoundException e2 ) { \n \n \t1 logger . error ( <string_literal> , e2 ) ; \n \n \t1 migrationresult . setError ( <string_literal> + e2 . getMessage ( ) ) ; \n \n \t1 } catch ( PropertyVetoException e ) { \n \n <ect>
\t3 for ( final String itemName : provider . getItemNames ( ) ) { \n \n \t4 if ( provider . isInBound ( itemName ) && credentialsMatch ( provider , itemName , oauthCredentials ) \n \n \t6 && thermostats . containsKey ( provider . getThermostatIdentifier ( itemName ) ) ) { \n \n \t5 final State newState = getState ( provider , thermostats , itemName ) ; \n \n <ect>
\t1 } catch ( ElementNotVisibleException e ) { \n \n \t1 SelendroidLogger . debug ( <string_literal> ) ; \n \n \t1 return new SelendroidResponse ( getSessionId ( request ) , StatusCode . ELEMENT_NOT_VISIBLE , e ) ; \n \n \t1 } catch ( StaleElementReferenceException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 @ Test \n \n \t1 public void testVersionNumber ( ) throws Exception { \n \n <ect>
\t1 } catch ( IOException e ) { \n \n \t1 logger . debug ( <string_literal> , e ) ; \n \n \t1 throw new ServletException ( e ) ; \n \n \t1 } catch ( JSONException e ) { \n \n <ect>
\t2 ivScheduledExecutorService . shutdown ( ) ; \n \n \t2 try { \n \n \t3 if ( ivScheduledExecutorService . awaitTermination ( cvScheduledExecutorServiceShutdownTimeout , \n \n \t5 TimeUnit . SECONDS ) ) { \n \n <ect>
\t4 bodyElements . add ( getElement ( bodyObj , name ) ) ; } } \n \n \t2 for ( Object headerObj : headerParts ) { \n \n \t3 QName name = elementNameStrategy . findQNameForSoapActionOrType ( soapAction , headerObj . getClass ( ) ) ; \n \n \t3 if ( name == null ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void allBindingsChanged ( BindingProvider provider ) { \n \n \t2 logger . trace ( <string_literal> ) ; \n \n \t2 if ( mKNXConnectionEstablished ) { \n \n <ect>
\t4 newVol . setPath ( destVolume . getPath ( ) + nfsStore . getPathSeparator ( ) + destVolumeUUID + <string_literal> ) ; \n \n \t4 newVol . setSize ( srcVolume . getSize ( ) ) ; \n \n \t4 return new CopyCmdAnswer ( newVol ) ; \n \n \t3 } catch ( final Exception e ) { \n \n <ect>
<comment> \n \n \t2 public void classDescriptionNeededForClass ( NSNotification n ) { \n \n \t3 Class c = ( Class ) n . object ( ) ; \n \n <ect>
\t2 root . ptrs . copy ( splitIdx + 1 , right . ptrs , 0 , root . params . MaxPtr - ( splitIdx + 1 ) ) ; \n \n \t2 right . count = root . maxRecords ( ) - ( splitIdx + 1 ) ; \n \n \t2 if ( logging ( ) ) \n \n \t2 { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void visit ( final OpUnion opUnion ) { \n \n <ect>
\t1 public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { \n \n \t1 if ( isPomFile ( file . toFile ( ) ) ) { \n \n \t2 Model model = readMavenPomFile ( file . toFile ( ) ) ; \n \n \t2 Path location = file . getParent ( ) ; \n \n <ect>
\t1 @ ConditionalOnMissingBean ( name = <string_literal> ) \n \n \t1 @ Bean \n \n \t1 public AuthenticationEventExecutionPlanConfigurer ldapAuthenticationEventExecutionPlanConfigurer ( ) { \n \n \t2 return plan - > ldapAuthenticationHandlers ( ) . forEach ( handler - > { \n \n <ect>
\t1 public void testFind ( ) throws Exception { \n \n \t2 <comment> \n \n \t2 final com . braintreegateway . Subscription result = requestBody ( <string_literal> , null ) ; \n \n \t2 assertNotNull ( <string_literal> , result ) ; \n \n <ect>
\t1 return Transactions . find ( searchExample ) ; \n \n \t1 } catch ( NoSuchElementException e ) { \n \n \t1 throw new NoSuchEntityException ( bucketName ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 log . info ( <string_literal> ) ; \n \n \t4 MapRedUtil . setupStreamingDirsConfMulti ( pigContext , conf ) ; \n \n \t4 boolean disableCounter = conf . getBoolean ( <string_literal> , false ) ; \n \n \t4 if ( disableCounter ) { \n \n <ect>
\t4 ClassLoader resultClassLoader = result . getClassLoader ( ) ; \n \n \t4 LOG . info ( <string_literal> + name + <string_literal> + resultClassLoader + <string_literal> \n \n \t6 + Thread . currentThread ( ) . getContextClassLoader ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 try { \n \n \t2 String groupDn = ldap . findGroupDn ( groupId ) ; \n \n \t2 groupDns . add ( groupDn ) ; \n \n \t2 } catch ( NamingException e ) { \n \n <ect>
\t3 item . setMd5 ( md5Checksum ) ; \n \n \t3 item . setStoredSize ( contentLength ) ; \n \n \t3 PersistContext . getSession ( ) . save ( item ) ; \n \n \t2 } catch ( OutOfStorageException e ) { \n \n <ect>
\t1 BucketLifecycleManagers . getInstance ( ) . deleteLifecycleRules ( bucketToDelete . getBucketUuid ( ) ) ; \n \n \t1 <comment> \n \n \t1 BucketTaggingManagers . getInstance ( ) . deleteBucketTagging ( bucketToDelete . getBucketUuid ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 criteriaSelectionLayout . fillSearchFieldInfo ( fieldInfo ) ; \n \n \t4 searchContainer . addComponent ( criteriaSelectionLayout ) ; \n \n \t3 } ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 _ipAddressDao . update ( ipId , ip ) ; \n \n \t2 try { \n \n \t3 boolean success = applyIpAssociations ( network , false ) ; \n \n \t3 if ( success ) { \n \n <ect>
\t4 default : \n \n \t5 logger . warn ( <string_literal> , commmandType ) ; \n \n \t5 break ; } \n \n \t2 } catch ( EpsonProjectorException e ) { \n \n <ect>
\t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 final String grantType = context . getRequestParameter ( OAuth20Constants . GRANT_TYPE ) ; \n \n \t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . CLIENT_ID ) ) { \n \n <ect>
\t6 U . warn ( log , <string_literal> + \n \n \t7 <string_literal> + thiefId + <string_literal> + top . size ( ) + ' ] ' ) ; \n \n \t6 thief = null ; } \n \n <ect>
public String name ( ) { \n \n \t1 return ( String ) storedValueForKey ( _RentalTerms . NAME_KEY ) ; } \n \n public void setName ( String value ) { \n \n <ect>
\t4 if ( isTransactionExpired ( activeTransaction , now , transactionTimeoutMillis ) ) \n \n \t4 { \n \n \t5 if ( activeTransaction . markForTermination ( Status . Transaction . TransactionTimedOut ) ) \n \n \t5 { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t1 protected static void resetStreamsAndSendOutput ( ) { \n \n \t2 System . setOut ( ORIGINAL_STDOUT ) ; \n \n \t2 System . setErr ( ORIGINAL_STDERR ) ; \n \n \t2 System . setIn ( ORIGINAL_STDIN ) ; \n \n <ect>
\t3 if ( ( buf = con . getNextReadBuf ( ) ) == null ) \n \n \t4 return ; \n \n \t3 EstablishState est = con . getEstablishState ( ) ; \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 <comment> \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n <ect>
\t3 TunnelPool inbound = _clientInboundPools . get ( h ) ; \n \n \t3 TunnelPool outbound = _clientOutboundPools . get ( h ) ; \n \n \t3 if ( inbound != null || outbound != null ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 rawObject = requestView ; <comment> \n \n \t4 } else { \n \n \t5 listRequestView . add ( requestView ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 public boolean apply ( Allocation allocInfo ) throws MetadataException { \n \n \t1 RunInstancesType request = allocInfo . getRequest ( ) ; \n \n \t1 String zoneName = request . getAvailabilityZone ( ) ; \n \n \t1 if ( Clusters . list ( ) . isEmpty ( ) ) { \n \n <ect>
\t4 for ( Object o : overallTooltipConfigMap . entrySet ( ) ) { \n \n \t5 Map . Entry entry = ( Map . Entry ) o ; \n \n \t5 addParameter ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; } } \n \n \t3 else { \n \n <ect>
\t3 int curPage = overflowPage ; \n \n \t3 bf . freePage ( page ) ; \n \n \t3 freeContinuationPages ( curPage ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t2 if ( relocation != null ) { \n \n \t3 if ( groupId != null && artifactId != null && artifactId . equals ( relocation . getName ( ) ) && groupId . equals ( relocation . getGroup ( ) ) ) { \n \n \t4 LOGGER . error ( <string_literal> , \n \n \t6 mdBuilder . getComponentIdentifier ( ) , relocation ) ; \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 final URI urlMetadataNetwork = new URI ( GCE_HOST . get ( settings ) ) . resolve ( <string_literal> ) . resolve ( metadataPath ) ; \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 store . saveXWikiCollection ( refererStat , this . context , true ) ; \n \n \t2 } catch ( XWikiException e ) { \n \n <ect>
\t6 LOGGER . trace ( <string_literal> ) ; \n \n \t5 } catch ( IOException e ) { \n \n \t6 LOGGER . error ( <string_literal> , e ) ; \n \n \t5 } catch ( GSSException e ) { \n \n <ect>
\t3 for ( Map . Entry < String , Object > entry : amqpMessageProperties . getHeaders ( ) . entrySet ( ) ) { \n \n \t4 headers . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t5 } catch ( IllegalStateException e ) { \n \n \t6 logger . info ( <string_literal> , line , e ) ; } } \n \n \t4 continue ; } \n \n \t3 if ( commandId != null && ! ResponseParser . isCorrectCommandResponse ( line , commandId ) ) { \n \n <ect>
\t4 log . warn ( <string_literal> + jobId + <string_literal> \n \n \t6 + workflow . getId ( ) + <string_literal> ) ; } } \n \n \t2 catch ( InterruptedException e ) { \n \n \t3 queueCallable ( new CoordActionUpdateCommand ( workflow ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n <ect>
\t3 PortForwardingRule result = _rulesService . createPortForwardingRule ( this , virtualMachineId , privateIp , getOpenFirewall ( ) , isDisplay ( ) ) ; \n \n \t3 setEntityId ( result . getId ( ) ) ; \n \n \t3 setEntityUuid ( result . getUuid ( ) ) ; \n \n \t2 } catch ( NetworkRuleConflictException ex ) { \n \n <ect>
\t1 public CqlPreparedResult prepare_cql3_query ( ByteBuffer query , Compression compression ) \n \n \t1 throws InvalidRequestException , TException \n \n \t1 { \n \n <ect>
\t4 && bundle . getVersion ( ) . getMajor ( ) != version . getMajor ( ) ) { \n \n \t3 return ; } \n \n \t2 final Collection < String > ebinDirs = bundle . getEbinDirs ( context ) ; \n \n \t2 if ( ebinDirs == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 executionResult = executionResult . addEvent ( ( int ) latency , eventType ) ; \n \n \t2 if ( isUnrecoverable ( originalException ) ) { \n \n <ect>
\t5 this . makeMetadataValueInfo ( titleField , title ) ; \n \n \t4 try { \n \n \t5 this . addUniqueMetadata ( context , info , item ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
\t2 } catch ( Exception ex ) <comment> \n \n \t2 { \n \n \t3 log . warn ( <string_literal> , ex ) ; } \n \n <ect>
\t3 byte [ ] encryptedBytes = mac . doFinal ( ) ; \n \n \t3 String computedSignature = Base64 . encodeBase64String ( encryptedBytes ) ; \n \n \t3 boolean equalSig = ConstantTimeComparator . compareStrings ( signature , computedSignature ) ; \n \n \t3 if ( ! equalSig ) { \n \n <ect>
\t5 role . setRole ( roleName ) ; \n \n \t5 role . setDescription ( entry . getValue ( ) ) ; \n \n \t5 Context . getUserService ( ) . saveRole ( role ) ; } } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t4 return parseWorkerMetricMeta ( parts ) ; \n \n \t3 } else { \n \n \t4 return parseTaskMetricMeta ( parts ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t7 logger . info ( <string_literal> , segment . getSegmentId ( ) , e ) ; \n \n \t7 continue ; } \n \n \t6 TrackingSegmentWorker trackingSegmentWorker = new TrackingSegmentWorker ( segment ) ; \n \n \t6 if ( threadFactory . activeThreads ( ) < maxThreadCount ) { \n \n <ect>
\t4 name = com . mongodb . hadoop . mapred . MongoInputFormat . class . getName ( ) ; \n \n \t3 } else { \n \n \t4 name = MongoInputFormat . class . getName ( ) ; } \n \n \t3 entries . add ( new Pair < String , String > ( JOB_INPUT_FORMAT , name ) ) ; \n \n <ect>
\t6 externalType = adaptor . externalTypeForJDBCType ( jdbcType ) ; } } } \n \n \t3 finally { \n \n \t4 typeInfoMethod . setAccessible ( oldAccessible ) ; } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t2 while ( System . currentTimeMillis ( ) - startTick < = timeOutMs ) { \n \n \t3 morNetwork = hostMo . getNetworkMor ( networkName ) ; \n \n \t3 if ( morNetwork != null ) { \n \n \t4 break ; } \n \n <ect>
\t3 classLoader . addURL ( new File ( pluginFolder , plugin . getJar ( ) ) . toURI ( ) . toURL ( ) ) ; \n \n \t3 logger . debug ( <string_literal> + plugin . getClassName ( ) ) ; \n \n \t3 return ( MatchType ) Class . forName ( plugin . getTypeName ( ) , true , classLoader ) . getConstructor ( ) . newInstance ( ) ; \n \n \t2 } catch ( ClassNotFoundException ex ) { \n \n <ect>
\t1 public void initCombosForTestUriOptionsWork ( ) { \n \n \t2 initSharedCombos ( ) ; } \n \n \t1 public void testUriOptionsWork ( ) throws Exception { \n \n \t2 String uri = prefix + bindAddress + postfix ; \n \n <ect>
\t5 return resultSec * <number_literal> ; \n \n \t4 } else { \n \n \t5 throw new DocumentStoreException ( <string_literal> ) ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 WorkspaceInfo wkspace = catalog . getWorkspaceByName ( workspaceName ) ; \n \n \t2 if ( wkspace == null ) { \n \n \t3 throw new ResourceNotFoundException ( <string_literal> + workspaceName + <string_literal> ) ; } \n \n \t2 LOGGER . info ( <string_literal> + workspaceName ) ; \n \n <ect>
\t2 if ( printMessages ) \n \n \t3 logger . debug ( <string_literal> + g . getBody ( ) . getMethod ( ) + <string_literal> ) ; \n \n \t2 doFlowInsensitiveAnalysis ( ) ; \n \n \t2 if ( printMessages ) \n \n <ect>
\t2 Settings commonSettings = Settings . builder ( ) \n \n \t4 . put ( ThrottlingAllocationDecider . CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING . getKey ( ) , 1 ) \n \n \t4 . put ( ThrottlingAllocationDecider . CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING . getKey ( ) , 1 ) \n \n \t4 . build ( ) ; \n \n <ect>
\t4 setChildrenSelection ( defaultChildKey ( ) != null ? \n \n \t6 ( NSArray ) NSKeyValueCodingAdditions . Utility . valueForKeyPath ( parentSelection ( ) , defaultChildKey ( ) + <string_literal> ) : NSArray . EmptyArray ) ; \n \n \t4 appendChildPopupStringWithParent ( returnString , new NSArray ( aParent ) ) ; } } \n \n \t2 returnString . append ( <string_literal> ) ; \n \n <ect>
\t2 try { \n \n \t3 List < SQLStatement > stmtList = SQLUtils . parseStatements ( sql , JdbcConstants . MYSQL ) ; \n \n \t3 return stmtList . get ( 0 ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 LOG . debug ( <string_literal> + job . getJobId ( ) + <string_literal> + job . getId ( ) ) ; \n \n \t2 try { \n \n \t3 job = resourceManager . read ( job . getId ( ) ) ; \n \n \t2 } catch ( ItemNotFound itemNotFound ) { \n \n <ect>
\t2 <comment> \n \n \t2 EucalyptusActivityTasks . getInstance ( ) . deleteAutoScalingGroup ( asgName , true , \n \n \t3 lb . useSystemAccount ( ) ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 PigJob job = null ; \n \n \t1 try { \n \n \t2 job = getResourceManager ( ) . read ( jobId ) ; \n \n \t1 } catch ( ItemNotFound itemNotFound ) { \n \n <ect>
<comment> \n \n \t1 protected Object newSessionBeanInstance ( ) throws NamingException , InvocationTargetException { \n \n <ect>
<comment> \n \n \t1 public void clearLists ( ) \n \n \t2 throws Exception \n \n \t1 { \n \n <ect>
\t4 if ( prevLevels [ i ] == this ) { \n \n \t5 prevLevels [ i ] = levels [ i ] ; \n \n \t4 } else if ( prevLevels [ i ] != null ) { \n \n \t5 <comment> \n \n <ect>
\t3 unbindThread ( oldCCL ) ; } \n \n \t2 <comment> \n \n \t2 if ( ok ) { \n \n <ect>
\t2 configFiles . forEach ( Unchecked . consumer ( f - > { \n \n \t3 LOGGER . debug ( <string_literal> , f ) ; \n \n \t3 if ( f . getName ( ) . toLowerCase ( ) . endsWith ( <string_literal> ) ) { \n \n \t4 final Map < String , Object > pp = loadYamlProperties ( new FileSystemResource ( f ) ) ; \n \n <ect>
\t1 @ Deactivate \n \n \t1 public void deactivate ( ) { \n \n \t2 ScheduledExecutorService ses = getScheduler ( ) ; \n \n \t2 if ( ses == null ) { \n \n <ect>
\t2 NetworkOffering oldNetworkOffering = _networkOfferingDao . findByIdIncludingRemoved ( oldNetworkOfferingId ) ; \n \n \t2 NetworkOffering newNetworkOffering = _networkOfferingDao . findById ( newNetworkOfferingId ) ; \n \n \t2 <comment> \n \n \t2 if ( areServicesSupportedByNetworkOffering ( oldNetworkOfferingId , Service . SecurityGroup ) != areServicesSupportedByNetworkOffering ( newNetworkOfferingId , Service . SecurityGroup ) ) { \n \n <ect>
\t3 s_logger . warn ( <string_literal> + resourceName , e ) ; \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n \t3 s_logger . warn ( <string_literal> + resourceName , e ) ; \n \n \t2 } catch ( InvocationTargetException e ) { \n \n <ect>
\t2 assertThat ( response . getResponses ( ) [ 1 ] . getFailureMessage ( ) , nullValue ( ) ) ; \n \n \t2 assertThat ( response . getResponses ( ) [ 1 ] . getResponse ( ) . getHits ( ) . getHits ( ) . length , equalTo ( 1 ) ) ; \n \n \t2 assertThat ( response . getResponses ( ) [ <number_literal> ] . getFailureMessage ( ) , nullValue ( ) ) ; \n \n \t2 assertThat ( response . getResponses ( ) [ <number_literal> ] . getResponse ( ) . getHits ( ) . getHits ( ) . length , equalTo ( <number_literal> ) ) ; \n \n <ect>
\t3 try { \n \n \t4 LOG . debug ( <string_literal> , anAppContext , beanName ) ; \n \n \t4 return anAppContext . getBean ( beanName ) ; \n \n \t3 } catch ( NoSuchBeanDefinitionException e ) { \n \n <ect>
\t4 } catch ( final SecurityException e ) { \n \n \t5 LOGGER . warn ( e . getMessage ( ) , e ) ; \n \n \t4 } finally { \n \n \t5 if ( ! valid ) { \n \n <ect>
\t2 } ; \n \n \t2 GenericType < List < XmlJavaTypeAdapterAlien > > alienListType = new GenericType < List < XmlJavaTypeAdapterAlien > > ( ) { \n \n \t2 } ; \n \n \t2 List < XmlJavaTypeAdapterAlien > response = target . request ( ) . post ( Entity . entity ( entity , MediaType . APPLICATION_XML_TYPE ) , alienListType ) ; \n \n <ect>
\t4 return retry ( cmd , numRetries ) ; \n \n \t3 } else { \n \n \t4 return new Answer ( cmd , e ) ; } \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t4 public void run ( ) { \n \n \t5 try { \n \n \t6 rebalanceKit . rebalance ( ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t2 } else { \n \n \t2 s = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; } \n \n \t2 HibernateUtil . threadSession . set ( s ) ; } \n \n \t1 } catch ( HibernateException ex ) { \n \n <ect>
<comment> \n \n \t1 public void messageAvailable ( I2PSession session , int msgId , long size ) { \n \n <ect>
\t1 if ( isAsync ) return false ; <comment> \n \n \t1 try { \n \n \t1 session . close ( false ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t5 withNewMetadata ( ) . withName ( FABRIC8_ARQUILLIAN ) . addToAnnotations ( createConfigMapAnnotations ( session , status ) ) . endMetadata ( ) . \n \n \t5 build ( ) ; \n \n \t3 return client . configMaps ( ) . inNamespace ( session . getNamespace ( ) ) . withName ( FABRIC8_ARQUILLIAN ) . createOrReplace ( configMap ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 double timeMs = ( System . nanoTime ( ) - startTime ) / <number_literal> . 0 ; \n \n \t1 LOG . debug ( <string_literal> + len + <string_literal> + timeMs + <string_literal> ) ; \n \n \t1 return result ; \n \n \t1 } catch ( HiveException ex ) { \n \n <ect>
\t5 final String exceptionMessage = <string_literal> ; \n \n \t5 resetSocket ( socket , exceptionMessage ) ; \n \n \t5 throw new MllpSocketException ( exceptionMessage , ioEx ) ; } \n \n \t3 } else { \n \n <ect>
\t3 closeConditionalWriter_result result = new closeConditionalWriter_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t6 repository . login ( credentials ) , context ) ) ; \n \n \t4 jobs . add ( thread ) ; \n \n \t4 thread . start ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 throw new RuntimeException ( <string_literal> + ex ) ; } } \n \n \t2 if ( p != null ) { \n \n \t3 HashSet < String > ignoreUrls = SettingsManager . getIntance ( ) . getIgnoreUrls ( ) ; \n \n \t3 update ( 0 , cardsToDownload . size ( ) ) ; \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testGetFeatureContent ( ) throws Exception { \n \n \t2 Document doc = getAsDOM ( <string_literal> ) ; \n \n <ect>
\t3 if ( apps . size ( ) == 1 ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 tmpAppId = apps . get ( 0 ) . getApplicationId ( ) ; \n \n <ect>
\t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n \t6 _log . warn ( <string_literal> ) ; \n \n \t4 } else { \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 MessageProp msgProp = new MessageProp ( false ) ; \n \n \t3 final byte [ ] nameBytes = gssContext . unwrap ( token , 0 , token . length , msgProp ) ; \n \n \t3 return new String ( nameBytes , GSSTestConstants . CHAR_ENC ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
public NSTimestamp datePaid ( ) { \n \n \t1 return ( NSTimestamp ) storedValueForKey ( _Fee . DATE_PAID_KEY ) ; } \n \n public void setDatePaid ( NSTimestamp value ) { \n \n <ect>
\t2 if ( idpMetadata == null || nameId == null || nameId . isEmpty ( ) ) { \n \n \t3 try { \n \n \t4 resp . sendRedirect ( SAML2AuthManager . SAMLCloudStackRedirectionUrl . value ( ) ) ; \n \n \t3 } catch ( IOException ignored ) { \n \n <ect>
\t3 attribute . setFriendlyName ( e . getKey ( ) ) ; } \n \n \t2 addAttributeValuesToSaml2Attribute ( e . getKey ( ) , e . getValue ( ) , attribute . getAttributeValues ( ) ) ; \n \n \t2 if ( ! configuredNameFormats . isEmpty ( ) && configuredNameFormats . containsKey ( attribute . getName ( ) ) ) { \n \n \t3 final String nameFormat = configuredNameFormats . get ( attribute . getName ( ) ) ; \n \n <ect>
\t2 assertAcked ( admin ( ) . indices ( ) . prepareAliases ( ) \n \n \t4 . addAliasAction ( AliasActions . add ( ) . index ( <string_literal> ) . alias ( <string_literal> ) . routing ( <string_literal> ) ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client ( ) . prepareIndex ( <string_literal> , <string_literal> , <string_literal> ) . setSource ( <string_literal> , <string_literal> ) . setRefreshPolicy ( RefreshPolicy . IMMEDIATE ) . get ( ) ; \n \n <ect>
\t5 el . setProperty ( prop ) ; } \n \n \t4 reader . moveUp ( ) ; } \n \n \t3 return el ; \n \n \t2 } catch ( InstantiationException | IllegalAccessException e ) { \n \n <ect>
\t2 _context = ctx ; \n \n \t2 _log = ctx . logManager ( ) . getLog ( getClass ( ) ) ; \n \n \t2 _data = new ConcurrentHashMap < Hash , DatabaseEntry > ( <number_literal> ) ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 sleep ( ) ; \n \n \t4 commitTxIfNecessary ( ) ; } \n \n \t2 } finally { \n \n \t3 if ( client . isDurable ( ) && client . isUnsubscribe ( ) ) { \n \n <ect>
\t2 ProtocolProviderService provider = \n \n \t3 ( ProtocolProviderService ) IcqSlickFixture . bc . getService ( icqServiceRef ) ; \n \n \t2 RegistrationFailedEventCollector regFailedEvtCollector = \n \n \t3 new RegistrationFailedEventCollector ( ) ; \n \n <ect>
<number_literal> true ) ; \n \n \t7 return \n \n \t8 new NameEnvironmentAnswer ( classFileReader , null ) ; } \n \n \t5 } catch ( IOException exc ) { \n \n <ect>
\t2 { \n \n \t3 logger . warn ( <string_literal> ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
public BigDecimal revenue ( ) { \n \n \t1 return ( BigDecimal ) storedValueForKey ( <string_literal> ) ; } \n \n public void setRevenue ( Double value ) { \n \n <ect>
\t3 if ( componentSeparator == hl7MessageBytes [ j ] ) { \n \n \t4 msh92start = j ; \n \n \t4 break ; } } \n \n \t2 if ( - 1 == msh92start ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 String nodeB = internalCluster ( ) . startNode ( ) ; \n \n \t2 ensureGreen ( ) ; \n \n \t2 <comment> \n \n <ect>
+ \t2 try { \n \n + \t2 MetricsReporting reporter = MetricsReporting . valueOf ( metricsReportingName . trim ( ) . toUpperCase ( ) ) ; \n \n + \t2 finalReporterList . add ( reporter ) ; \n \n + \t2 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t1 return new Xid [ 0 ] ; } \n \n @ Override \n \n public void rollback ( Xid xid ) throws XAException { \n \n \t1 this . rollbackExecuted = true ; \n \n <ect>
\t3 methodInfo = defaultMethod ; } \n \n \t2 if ( methodInfo != null ) { \n \n \t3 LOG . trace ( <string_literal> , methodInfo , pojo ) ; \n \n \t3 return methodInfo . createMethodInvocation ( pojo , methodInfo . hasParameters ( ) , exchange ) ; } \n \n <ect>
\t1 for ( MediaType rangePattern : supportedMimeTypes ) { \t1 \n \n \t1 if ( isMimeTypeMatch ( mediaType , rangePattern ) ) { \n \n \t2 return true ; } } \n \n <ect>
private static Logger LOG = ProcessEngineLogger . TEST_LOGGER . getLogger ( ) ; \n \n public List < String > events = new ArrayList < String > ( ) ; \n \n public void notify ( DelegateExecution execution ) throws Exception { \n \n \t1 PvmExecutionImpl executionImpl = ( PvmExecutionImpl ) execution ; \n \n <ect>
\t3 try { \n \n \t4 Msg m = Msg . s_makeMessage ( <string_literal> ) ; \n \n \t4 writeMessage ( m ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t6 List < StoragePoolVO > storagePools = _storagePoolDao . listAll ( ) ; \n \n \t6 for ( StoragePoolVO pool : storagePools ) { \n \n \t7 try { \n \n \t8 List < VMTemplateStoragePoolVO > unusedTemplatesInPool = _tmpltMgr . getUnusedTemplatesInPool ( pool ) ; \n \n <ect>
\t2 assertThat ( Files . exists ( shardDirectory ( node_1 , index , 0 ) ) , equalTo ( true ) ) ; \n \n \t2 assertThat ( Files . exists ( shardDirectory ( node_2 , index , 0 ) ) , equalTo ( true ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 String node_3 = internalCluster ( ) . startNode ( ) ; \n \n <ect>
<comment> \n \n \t1 private void loadIfStale ( PropertySource source ) { \n \n \t2 if ( source . isStale ( ) ) { \n \n <ect>
\t2 if ( assets . isEmpty ( ) ) { \n \n \t3 if ( kModule instanceof FileKieModule ) { \n \n \t4 log . warn ( <string_literal> + kBaseModel . getName ( ) + <string_literal> + kModule . getFile ( ) ) ; \n \n \t3 } else { \n \n <ect>
def main ( argv : Array [ String ] ) { \n \n \t1 val qCommandLine = new QCommandLine \n \n \t1 val shutdownHook = new Thread { \n \n \t1 override def run ( ) { \n \n <ect>
\t5 barrier . await ( <number_literal> , TimeUnit . SECONDS ) ; \n \n \t5 logger . debug ( <string_literal> ) ; \n \n \t4 } catch ( Exception e ) { \n \n \t5 fail ( <string_literal> , e ) ; } } \n \n <ect>
\t3 ValidationComplexInterfaceSuper . t = <string_literal> ; \n \n \t3 ValidationComplexInterfaceSub . u = <string_literal> ; \n \n \t3 Response response = client . target ( generateURL ( BASIC_DEPLOYMENT , <string_literal> , ValidationComplexInterfaceSub . class . getSimpleName ( ) ) ) \n \n \t5 . request ( ) . post ( Entity . entity ( <string_literal> , MediaType . TEXT_PLAIN_TYPE ) ) ; \n \n <ect>
\t3 deferred = _deferredSearches . size ( ) ; } \n \n \t2 if ( ! ok ) { \n \n \t3 <comment> \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t3 logger . debug ( <string_literal> , e . getMessage ( ) ) ; } \n \n \t2 catch ( NoSuchMethodError e ) \n \n \t2 { \n \n <ect>
\t5 null , String . format ( Messages . getString ( <string_literal> ) , file . getAbsolutePath ( ) ) , null , JOptionPane . INFORMATION_MESSAGE ) ; \n \n \t4 reload ( ( JComponent ) e . getSource ( ) ) ; } } } \n \n \t1 private void reload ( JComponent c ) { \n \n \t2 <comment> \n \n <ect>
\t3 Thread . sleep ( <number_literal> ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 throw new RuntimeException ( e ) ; } \n \n \t2 stat . getFile ( ) . delete ( ) ; \n \n <ect>
\t1 <comment> \n \n \t1 if ( register != defaultRegister && <string_literal> . indexOf ( register ) == - 1 ) { \n \n \t1 registers . put ( defaultRegister , new Register ( defaultRegister , type , text ) ) ; \n \n <ect>
\t4 callChains . add ( methodCallChainsIt . next ( ) ) ; \n \n \t4 startingMethods . add ( classMethod ) ; <comment> \n \n \t2 if ( callChains . size ( ) == 0 ) \n \n \t2 { \n \n <ect>
\t7 ) ; \n \n \t7 load ( encoding , file , pattern ) ; \n \n \t7 loaded = true ; } } } \n \n \t4 if ( ! loaded ) \n \n <ect>
\t4 try { \n \n \t5 <comment> \n \n \t5 sendMessages ( true , <string_literal> , 1 , 0 ) ; \n \n \t4 } catch ( Exception expected ) { \n \n <ect>
\t4 originalImage . setProperty ( StructrApp . key ( Image . class , <string_literal> ) , exifGpsDataJson . toString ( ) ) ; \n \n \t4 exifDataJson . putOnce ( <string_literal> , exifGpsDataJson ) ; } \n \n \t3 return exifDataJson ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
<comment> \n \n public void savePartialPieces ( Peer peer , List < Request > partials ) \n \n { \n \n \t1 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 MediaType mediaType = MediaType . APPLICATION_JSON_TYPE . withCharset ( charset ) ; \n \n \t1 Entity < Cat > entity = Entity . entity ( \n \n \t3 new Cat ( <string_literal> , <string_literal> , <string_literal> , true , JsonBindingResource . CLIENT_TRANSIENT_VALUE ) , mediaType ) ; \n \n \t1 Cat json = target . request ( ) . post ( entity , Cat . class ) ; \n \n <ect>
\t1 protected void onBeforeProcess ( Exchange exchange , Processor processor , ProcessorDefinition < ? > definition , Breakpoint breakpoint ) { \n \n \t2 try { \n \n \t3 breakpoint . beforeProcess ( exchange , processor , definition ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t2 int command = serialMessage . getMessagePayloadByte ( offset ) ; \n \n \t2 switch ( command ) { \n \n \t3 case THERMOSTAT_MODE_GET : \n \n \t3 case THERMOSTAT_MODE_SUPPORTED_GET : \n \n <ect>
\t3 broker1 . stop ( ) ; \n \n \t2 } else { \n \n \t3 LOG . info ( <string_literal> ) ; } \n \n \t2 if ( broker2 != null && broker2 . isStarted ( ) ) { \n \n <ect>
\t2 case GreaterThanOrEqualToThreshold : \n \n \t2 exceedsThreshold = ( metricValue >= threshold ) ; \n \n \t2 break ; \n \n \t2 default : \n \n <ect>
\t1 { \n \n \t3 LOGGER . debug ( <string_literal> + this . sqlList . size ( ) ) ; \n \n \t3 for ( int i = 0 ; i < this . sqlList . size ( ) ; i ++ ) { \n \n <ect>
\t1 TimeUnit . MILLISECONDS . sleep ( DEFAULT_TIMEOUT ) ; } \n \n \t1 File actualOutput = sinkOutputDirChildren [ 0 ] ; \n \n \t1 if ( ! Files . toString ( actualOutput , Charsets . UTF_8 ) . equals ( expectedOutput ) ) { \n \n \t1 LOGGER . error ( <string_literal> ) ; \n \n <ect>
\t3 throw new FailedLoginException ( <string_literal> + transformedCredential . getId ( ) ) ; } \n \n \t2 if ( ! value . containsKey ( couchbaseProperties . getPasswordAttribute ( ) ) ) { \n \n \t3 throw new FailedLoginException ( <string_literal> + transformedCredential . getId ( ) ) ; } \n \n \t2 if ( ! value . get ( couchbaseProperties . getPasswordAttribute ( ) ) . equals ( transformedCredential . getPassword ( ) ) ) { \n \n <ect>
\t2 final Object value = args [ index ] ; \n \n \t2 if ( value instanceof Script ) { \n \n \t3 return ( Script ) value ; } \n \n \t2 if ( value == null ) { \n \n <ect>
\t1 if ( deleteValueSpillHeaderStmt != null ) { \n \n \t2 try { \n \n \t2 deleteValueSpillHeaderStmt . close ( ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n <ect>
\t2 Map < String , I_CmsPreference > prefs = OpenCms . getWorkplaceManager ( ) . getDefaultUserSettings ( ) . getPreferences ( ) ; \n \n \t2 if ( prefs . containsKey ( key ) ) { \n \n \t3 prefs . get ( key ) . setValue ( m_currentPreferences , value ) ; \n \n \t2 } else { \n \n <ect>
\t2 < p > Reload this page with open console , enter text and hit the log button . . . < / p > \n \n \t2 Message : \n \n \t2 < input type = <string_literal> ng - model = <string_literal> / > \n \n \t2 < button ng - click = <string_literal> > log < / button > \n \n <ect>
\t4 ntCache = ( NodeTableCache ) ntx ; } \n \n \t3 ntx = ntx . wrapped ( ) ; } \n \n \t2 ntBase = ntx ; \n \n \t2 if ( ntInline == null ) \n \n <ect>
\t1 @ Override \n \n \t1 public void setHosts ( Collection < Host > hosts , int port ) { \n \n \t2 try { \n \n \t3 if ( session != null ) { \n \n <ect>
\t5 @ Override \n \n \t5 public void run ( ) { \n \n \t6 runWithContext ( ) ; } \n \n \t4 } ) ; } \n \n <ect>
\t3 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t3 while ( rs . next ( ) ) { \n \n \t4 result . add ( toEntityBean ( rs , false ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 for ( TestElement testElement : testElements ) { \n \n \t7 if ( isAddableTestElement ( testElement ) ) { \n \n \t8 treeModel . addComponent ( testElement , newNode ) ; } } } \n \n \t4 } catch ( IllegalUserActionException e ) { \n \n <ect>
\t1 } ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n \t1 throw e ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 } finally { \n \n \t3 if ( ois != null ) { \n \n \t4 CloseUtil . closeQuietly ( ois ) ; } \n \n \t3 close ( ) ; \n \n <ect>
\t1 stack_version = params . version \n \n \t1 if params . retryAble : \n \n \t1 Logger . info ( <string_literal> ) \n \n \t1 else : \n \n <ect>
\t6 default : \n \n \t7 unreachableCode ( ) ; } \n \n \t4 } catch ( Exception e ) { \n \n \t5 <comment> \n \n <ect>
\t10 final Authentication authentication , \n \n \t10 final RegisteredService service , \n \n \t10 final Collection < CasEvent > events ) { \n \n \t2 final String agent = HttpRequestUtils . getHttpServletRequestUserAgent ( request ) ; \n \n <ect>
\t2 List < SplunkEvent > data = extractData ( job , false , callback ) ; \n \n \t2 this . lastSuccessfulReadTime = startTime ; \n \n \t2 return data ; } \n \n \t1 private List < SplunkEvent > nonBlockingSearch ( SplunkResultProcessor callback ) throws Exception { \n \n <ect>
\t4 } else { \n \n \t5 logger . error ( <string_literal> + responseMessage ) ; \n \n \t5 return false ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 try { \n \n \t1 FileContext . getLocalFSFileContext ( ) . delete ( \n \n \t2 new Path ( targetWorkDir . getAbsolutePath ( ) ) , true ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 return ; } \n \n \t4 try { \n \n \t5 callable . call ( ) ; } \n \n \t4 catch ( Exception ex ) { \n \n <ect>
\t4 return null ; } \n \n \t3 s_logger . debug ( <string_literal> + vmName + <string_literal> , e ) ; \n \n \t3 return e . getMessage ( ) ; \n \n \t2 } catch ( final InterruptedException ie ) { \n \n <ect>
\t4 if ( ips != null ) { \n \n \t5 for ( byte [ ] ip : ips ) { \n \n \t6 if ( ! isValid ( ip ) ) { \n \n \t7 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t6 + <string_literal> + ( System . currentTimeMillis ( ) - startTick ) ) ; } \n \n \t2 } catch ( HttpException e ) { \n \n \t3 s_logger . error ( <string_literal> + _serviceUrl + <string_literal> + method . getParameter ( <string_literal> ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 Rights rights = new Rights ( ) ; \n \n \t3 rights . setContent ( rightsString . toString ( ) ) ; \n \n \t3 rights . setType ( ContentType . TEXT ) ; \n \n \t3 entry . setRights ( rights ) ; \n \n <ect>
\t2 orchestration = stack_select . PACKAGE_SCOPE_PATCH \n \n \t1 stack_select_packages = stack_select . get_packages ( orchestration , service_name = <string_literal> , component_name = <string_literal> ) \n \n \t1 if stack_select_packages is None : \n \n \t1 raise Fail ( <string_literal> ) \n \n <ect>
\t3 else { \n \n \t4 if ( ! StringUtils . isBlank ( d . getInputCatalog ( ) ) ) \n \n \t5 log . warn ( <string_literal> ) ; \n \n \t4 if ( ! StringUtils . isBlank ( d . getOutputCatalog ( ) ) ) \n \n <ect>
<comment> \n \n <ect>
\t2 } catch ( FrameworkException fex ) { \n \n \t3 logger . warn ( <string_literal> , uuid , fex . getMessage ( ) ) ; } \n \n \t2 return null ; } \n \n \t1 public static AbstractFile getFirstFileByName ( final SecurityContext securityContext , final String name ) { \n \n <ect>
\t3 return Response . ok ( <string_literal> + jobId + <string_literal> + minionType ) . build ( ) ; \n \n \t2 } catch ( InsufficientPrivilegesException e ) { \n \n \t3 return Response . status ( Response . Status . UNAUTHORIZED ) . entity ( e . getMessage ( ) ) . build ( ) ; \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t1 public void syncDirs ( @ NotNull File from , @ NotNull File to , @ NotNull File snapshotsStorageFile ) { \n \n \t2 try { \n \n \t3 syncDirsImpl ( from , to , snapshotsStorageFile ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 return super . getLastModified ( req ) ; } \n \n \t2 return f . lastModified ( ) ; } \n \n \t1 @ Override \n \n \t1 protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { \n \n <ect>
\t3 logger . debug ( <string_literal> , message ) ; } \n \n \t2 try { \n \n \t3 todUse = getIntFromText ( TODAY_USE_REG_EXP , message ) ; \n \n \t2 } catch ( LightwaveRfMessageException le ) { \n \n <ect>
\t3 selector = <string_literal> ; } \n \n \t2 private void process ( ) throws JMSException { \n \n \t3 long end = System . currentTimeMillis ( ) + <number_literal> ; \n \n \t3 int transCount = 0 ; \n \n <ect>
\t3 result . success = o ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 long now = System . currentTimeMillis ( ) ; \n \n \t2 if ( now < this . lastReload + RELOAD_FREQUENCY_MS ) return ; \n \n \t2 if ( watchedFile . lastModified ( ) == this . lastModified ) return ; \n \n <ect>
\t1 } catch ( Exception e ) { \n \n \t2 if ( PersistenceExceptions . isStaleUpdate ( e ) ) { \n \n \t2 logger . debug ( <string_literal> + natGatewayId + <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t2 <comment> \n \n \t2 Thread . sleep ( <number_literal> ) ; \n \n \t2 mock . assertIsSatisfied ( ) ; \n \n \t2 <comment> \n \n <ect>
\t1 byte [ ] gcLockData ; \n \n \t1 do { \n \n \t1 gcLockData = ZooLock . getLockData ( zcache , path , null ) ; \n \n \t1 if ( null != gcLockData ) { \n \n <ect>
\t5 logger . debug ( <string_literal> + jndiName + <string_literal> ) ; } \n \n \t4 return tsr ; } \n \n \t3 catch ( NamingException ex ) { \n \n <ect>
\t2 <comment> \n \n \t2 this . mandatoryCuboidSet = ImmutableSet . < Long > builder ( ) . addAll ( cuboidsForMandatory ) . build ( ) ; \n \n \t2 this . selectionCuboidSet = ImmutableSet . < Long > builder ( ) . addAll ( cuboidsForSelection ) . build ( ) ; \n \n \t2 if ( selectionCuboidSet . isEmpty ( ) ) { \n \n <ect>
\t4 try { \n \n \t5 result = ( ( NodeWrapper ) getNode ( ) ) . evaluateCustomQuery ( customPermissionQuery , params ) ; \n \n \t4 } catch ( final Exception ex ) { \n \n \t5 logger . error ( <string_literal> , ex ) ; } \n \n <ect>
\t4 for ( UpdateThread ut : threads ) { \n \n \t5 if ( ut . failedMap . containsKey ( i ) ) { \n \n \t6 totalFailures += ut . failedMap . get ( i ) ; } } \n \n \t4 expectedVersion -= totalFailures ; \n \n <ect>
\t2 if ( result . equals ( <string_literal> ) ) { \n \n \t3 _context . waitForTaskProgressDone ( morTask ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
\t2 dnld . setTmpltPath ( finalResourcePath ) ; \n \n \t2 File originalTemplate = new File ( td . getDownloadLocalPath ( ) ) ; \n \n \t2 String checkSum = computeCheckSum ( originalTemplate ) ; \n \n \t2 if ( checkSum == null ) { \n \n <ect>
private void displayStatus ( ) { \n \n \t1 displayUtilityTitle ( <string_literal> ) ; \n \n \t1 final ClientMessageBusImpl bus = ( ClientMessageBusImpl ) ErraiBus . get ( ) ; \n \n \t1 final boolean federatedApp = BusToolsCli . isRemoteCommunicationEnabled ( ) ; \n \n <ect>
\t2 if ( ! bindingsExist ( ) ) { \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 long networkTimeInMillis = getTime ( hostname ) ; \n \n <ect>
\t2 fileSystem . close ( ) ; \n \n \t2 return null ; } \n \n \t1 } ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 done . set ( true ) ; \n \n \t1 end = System . nanoTime ( ) ; \n \n \t1 t . join ( ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
\t3 s_logger . trace ( <string_literal> + pfRule + <string_literal> ) ; \n \n \t3 pfRule . setState ( FirewallRule . State . Revoke ) ; } \n \n \t2 try { \n \n \t3 if ( ! _firewallMgr . applyRules ( pfRules , true , false ) ) { \n \n <ect>
\t2 def . setTaskClass ( LatchExecuteTask . class . getName ( ) ) ; \n \n \t2 synchronized ( TASK_TEST_METHOD_LOCK ) { \n \n \t3 Collection < TaskDefinition > tasks = service . getRegisteredTasks ( ) ; \n \n \t3 for ( TaskDefinition task : tasks ) { \n \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onUserDeletion ( long target , StreamListener [ ] listeners ) throws TwitterException { \n \n \t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onUserSuspension ( long target , StreamListener [ ] listeners ) throws TwitterException { \n \n <ect>
\t1 assert <string_literal> . equals ( cache1 . get ( <string_literal> ) ) ; \n \n \t1 tm ( 0 ) . resume ( t ) ; \n \n \t1 cache0 . put ( <string_literal> , <string_literal> ) ; \n \n \t1 try { \n \n <ect>
\t2 try { \n \n \t2 resultsQueue . put ( entries ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n \t2 if ( TabletServerBatchReaderIterator . this . queryThreadPool . isShutdown ( ) ) \n \n <ect>
\t4 GuiPackage . getInstance ( ) . getMainFrame ( ) . showStoppingMessage ( <string_literal> ) ; \n \n \t4 engine . stopTest ( ) ; } \n \n \t2 } else if ( e . getActionCommand ( ) . equals ( ActionNames . ACTION_SHUTDOWN ) ) { \n \n \t3 if ( engine != null ) { \n \n <ect>
\t2 request . setAttribute ( name , upload ) ; \n \n \t2 logger . debug ( <string_literal> , name , upload ) ; } \n \n \t1 protected ServletFileUpload createServletFileUpload ( MultipartConfig config ) { \n \n \t2 FileItemFactory factory = new DiskFileItemFactory ( DEFAULT_SIZE_THRESHOLD , config . getDirectory ( ) ) ; \n \n <ect>
\t6 } catch ( Exception e ) { \n \n \t7 logger . error ( <string_literal> + connection + <string_literal> + e . getMessage ( ) , e ) ; \n \n \t7 lb . markServerDown ( server ) ; } } } } } \n \n \t2 if ( connection == null ) { \n \n <ect>
\t3 String classFileName = ctxt . getClassFileName ( ) ; \n \n \t3 if ( classFileName != null ) { \n \n \t4 File classFile = new File ( classFileName ) ; \n \n <ect>
\t3 if ( ! isSameCidr ) { \n \n \t4 s_logger . warn ( <string_literal> + requestedIp + <string_literal> + network + <string_literal> ) ; \n \n \t4 return null ; \n \n \t3 } else if ( NetUtils . IsIpEqualToNetworkOrBroadCastIp ( requestedIp , cidr [ 0 ] , Integer . parseInt ( cidr [ 1 ] ) ) ) { \n \n <ect>
\t4 if ( br != null ) { \n \n \t5 try { \n \n \t6 br . close ( ) ; } \n \n \t5 catch ( Exception e ) { \n \n <ect>
\t2 if ( appender != null ) { \n \n \t3 appender . stop ( ) ; } } \n \n \t1 @ Override \n \n \t1 public void onWebSocketText ( String message ) { \n \n <ect>
\t4 tmpSnapshotScheduleVO . setAsyncJobId ( jobId ) ; \n \n \t4 _snapshotScheduleDao . update ( snapshotScheId , tmpSnapshotScheduleVO ) ; \n \n \t3 } catch ( final Exception e ) { \n \n \t4 <comment> \n \n <ect>
\t4 self . logger . debug ( <string_literal> % \n \n \t6 ( vm . name , public_ip . ipaddress . ipaddress ) ) \n \n \t2 except : \n \n \t3 if expectFail : \n \n <ect>
\t9 s_logger . warn ( <string_literal> + router . getInstanceName ( ) + <string_literal> + router . getHostId ( ) , e ) ; \n \n \t9 continue ; } \n \n \t8 if ( answer != null ) { \n \n \t9 if ( ! answer . getResult ( ) ) { \n \n <ect>
\t2 Partition p = null ; \n \n \t2 try { \n \n \t2 p = resolvePartition ( ci ) ; \n \n \t2 if ( p == null && ci . partName != null ) { \n \n <ect>
\t1 { \n \n \t2 super ( cfs , compacting , gcBefore ) ; \n \n \t2 this . ignoreOverlaps = ignoreOverlaps ; \n \n \t2 if ( ignoreOverlaps ) \n \n <ect>
\t1 private void createFoldersIfNeeded ( File parentFile ) { \n \n \t2 if ( parentFile == null ) { \n \n \t3 return ; } \n \n \t2 if ( ! parentFile . exists ( ) ) { \n \n <ect>
\t4 channel . dispose ( ) ; \n \n \t4 channel = existingNonBlockingChannel ; } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t6 nestedPrefix = ( prefix + nestedPrefix ) . trim ( ) ; \n \n \t6 populateParameterConfigurationMap ( parameterMap , fieldType , nestedPrefix ) ; \n \n \t5 } else { \n \n \t6 if ( parameterMap . containsKey ( propertyName ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 ret . put ( \n \n \t3 results . getString ( <string_literal> ) , \n \n \t3 results . getString ( <string_literal> ) ) ; } } \n \n <ect>
\t3 public void handleGraphObject ( SecurityContext securityContext , AbstractRelationship rel ) { \n \n \t4 rel . updateInIndex ( ) ; } \n \n \t3 @ Override \n \n \t3 public void handleThrowable ( SecurityContext securityContext , Throwable t , AbstractRelationship rel ) { \n \n <ect>
\t5 log . debug ( <string_literal> + socket . toString ( ) + <string_literal> + servers [ i ] ) ; } } } \n \n \t1 private void populateConsistentBuckets ( ) { \n \n <ect>
\t2 Promise . asPromise ( loadbalancer ) , persistedZones ) ; } \n \n \t1 @ Override \n \n \t1 protected void doCatch ( Throwable e ) throws Throwable { \n \n \t2 if ( e instanceof CancellationException ) { \n \n <ect>
\t2 } finally { \n \n \t3 <comment> \n \n \t3 results . sampleEnd ( ) ; } \n \n <ect>
\t2 } finally { \n \n \t3 IOUtils . closeQuietly ( is ) ; \n \n \t3 IOUtils . closeQuietly ( isr ) ; \n \n \t3 IOUtils . closeQuietly ( bufferedReader ) ; } \n \n <ect>
\t1 public void testAliases ( ) throws Exception { \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 createIndex ( <string_literal> ) ; \n \n \t2 ensureGreen ( ) ; \n \n <ect>
\t1 tran . setRollbackOnly ( ) ; \n \n \t1 return Entities . uniqueResult ( new SnapshotInfo ( snapshotId ) ) ; \n \n \t1 } catch ( TransactionException | NoSuchElementException dbe ) { \n \n \t1 <comment> \n \n <ect>
\t3 log . warn ( <string_literal> + \n \n \t5 <string_literal> + \n \n \t5 <string_literal> , ERXWOForm . formName ( context , <string_literal> ) ) ; \n \n \t5 log . warn ( <string_literal> , context . page ( ) ) ; \n \n <ect>
\t3 result . ouch2 = ( AccumuloSecurityException ) e ; \n \n \t3 result . setOuch2IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 if ( result != null ) { \n \n \t4 value . set ( result ) ; } \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n \t3 <comment> \n \n <ect>
\t3 FilePermissions permissions = FileUtil . getFilePermissions ( file ) ; \n \n \t3 if ( permissions . isBrowsable ( ) ) { \n \n \t4 return file ; \n \n \t3 } else { \n \n <ect>
\t4 if ( key . startsWith ( <string_literal> ) ) { \n \n \t5 String name = key . substring ( <string_literal> . length ( ) ) ; \n \n \t5 aliasMap . put ( name , ( String ) entry . getValue ( ) ) ; } } \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t2 mockBImOpSet . deliverMessage ( TEST_CONTACT_NAME_1 , messagesToSend [ 1 ] ) ; \n \n \t2 mockBImOpSet . deliverMessage ( TEST_CONTACT_NAME_2 , messagesToSend [ <number_literal> ] ) ; \n \n \t2 waitWrite ( <number_literal> ) ; \n \n \t2 TestMsgHistoryService . controlDate2 = new Date ( ) ; \n \n <ect>
\t3 if ( BindAxisEvent . class . isAssignableFrom ( registerBindClass ) ) { \n \n \t4 BindableButton positiveButton = getBindButton ( new SimpleUri ( info . positiveButton ( ) ) ) ; \n \n \t4 BindableButton negativeButton = getBindButton ( new SimpleUri ( info . negativeButton ( ) ) ) ; \n \n \t4 if ( positiveButton == null ) { \n \n <ect>
\t4 parts . add ( new StringPart ( MESSAGE_KEY_API_KEY , apiKey , UTF_8_ENCODING ) ) ; \n \n \t3 } else if ( ! StringUtils . isEmpty ( defaultApiKey ) ) { \n \n \t4 parts . add ( new StringPart ( MESSAGE_KEY_API_KEY , defaultApiKey , UTF_8_ENCODING ) ) ; \n \n \t3 } else { \n \n <ect>
\t1 protected void cleanup ( ) { \n \n \t2 try { \n \n \t3 selector . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 public static Path soapuiHomeDir ( ) { \n \n \t2 String homePath = System . getProperty ( <string_literal> ) ; \n \n \t2 if ( homePath == null ) { \n \n \t3 File homeFile = new File ( <string_literal> ) ; \n \n <ect>
\t2 try { \n \n \t3 if ( ! targetProject . isAccessible ( ) ) \n \n \t4 targetProject . open ( monitor ) ; } \n \n \t2 catch ( CoreException e ) { \n \n <ect>
\t3 commandListener . commandSucceeded ( new CommandSucceededEvent ( message . getId ( ) , connectionDescription , commandName , response , \n \n \t5 elapsedTimeNanos ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 assertThat ( policy . history ) . containsOnly ( \n \n \t7 entry ( INIT , TestUtils . findHost ( cluster , 1 ) ) , \n \n \t7 entry ( INIT , TestUtils . findHost ( cluster , <number_literal> ) ) \n \n \t5 ) ; \n \n <ect>
\t3 DataHelper . loadProps ( props , cfgFile ) ; \n \n \t3 return props ; \n \n \t2 } catch ( IOException ioe ) { \n \n \t3 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t1 else { \n \n \t2 addObjectToBothSidesOfRelationshipWithKey ( object , _Talent . ROLES_KEY ) ; } } \n \n public void removeFromRolesRelationship ( er . distribution . example . client . eo . MovieRole object ) { \n \n <ect>
\t8 if ( matcher . matches ( ) ) { \n \n \t9 try { \n \n \t10 currentAudioTrack . setYear ( Integer . parseInt ( matcher . group ( 1 ) ) ) ; \n \n \t9 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t1 structured_output [ <string_literal> ] = { <string_literal> : code , <string_literal> : <string_literal> . format ( str ( output ) ) } \n \n \t1 self . put_structured_out ( structured_output ) \n \n def get_clearcache_cmd ( self ) : \n \n \t1 if OSCheck . is_redhat_family ( ) : \n \n <ect>
\t2 public boolean apply ( VAppTemplate from ) { \n \n \t3 try { \n \n \t3 templateToEnvelope . apply ( from ) ; \n \n \t3 } catch ( IllegalArgumentException e ) { \n \n <ect>
<comment> \n \n \t1 protected void addTicketToRegistry ( final OAuthToken ticket , final TicketGrantingTicket ticketGrantingTicket ) { \n \n <ect>
\t1 if ( statement != null ) { \n \n \t2 try { \n \n \t2 statement . close ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t2 final Map < String , String > configs = _configDao . getConfiguration ( <string_literal> , params ) ; \n \n \t2 _proxy = configs . get ( Config . SecStorageProxy . key ( ) ) ; \n \n \t2 String cert = configs . get ( <string_literal> ) ; \n \n \t2 if ( ! <string_literal> . equalsIgnoreCase ( cert ) ) { \n \n <ect>
\t1 @ Test \n \n \t1 public void emptyFileStreamEncryptDecrypt ( ) throws IOException { \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; \n \n \t2 emptyFile . streamEncryptDecrypt ( ) ; \n \n <ect>
\t8 <string_literal> , \n \n \t8 morseCodes . length , frequencies . length ) ; \n \n \t6 return ; } \n \n \t4 } else { \n \n <ect>
\t1 if ( systemId . endsWith ( <string_literal> ) || PUBLIC_ID . equals ( publicId ) ) { \n \n \t1 Class clazz = getClass ( ) ; \n \n \t1 InputStream in = clazz . getResourceAsStream ( <string_literal> ) ; \n \n \t1 if ( in == null ) { \n \n <ect>
\t4 String path = vol . substring ( 0 , vol . lastIndexOf ( File . separator ) ) ; \n \n \t4 TemplateLocation loc = new TemplateLocation ( _storage , path ) ; \n \n \t4 try { \n \n \t5 if ( ! loc . load ( ) ) { \n \n <ect>
\t4 protocol , \n \n \t4 port , \n \n \t4 withDescription ( String . format ( <string_literal> , port , vApp . getName ( ) , \n \n \t6 vApp . getName ( ) ) ) ) ; } \n \n <ect>
\t2 return new org . apache . thrift . async . AsyncMethodCallback < Void > ( ) { \n \n \t2 public void onComplete ( Void o ) { } \n \n \t2 public void onError ( java . lang . Exception e ) { \n \n \t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t4 XWikiUser user = context . getWiki ( ) . checkAuth ( context ) ; \n \n \t4 if ( user != null ) { \n \n \t5 userReference = resolveUserName ( user . getUser ( ) , new WikiReference ( context . getWikiId ( ) ) ) ; } \n \n \t3 } catch ( XWikiException e ) { \n \n <ect>
\t2 try { \n \n \t3 while ( ( line = reader . readLine ( ) ) != null ) { \n \n \t4 logger . info ( <string_literal> , prefix , line ) ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 catch ( InterruptedException e ) { \n \n \t5 throw new GridException ( <string_literal> , e ) ; } } } \n \n \t3 for ( Map . Entry < String , Integer > entry : receivedParams . entrySet ( ) ) { \n \n <ect>
\t6 } catch ( UnsupportedEncodingException usex ) { \n \n \t7 s_logger . warn ( key + <string_literal> + value [ 0 ] ) ; \n \n \t7 throw new ServerApiException ( BaseCmd . PARAM_ERROR , key + <string_literal> + value [ 0 ] ) ; \n \n \t6 } catch ( IllegalArgumentException iae ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t4 @ Override \n \n \t4 public void handleTransactionFailure ( SecurityContext securityContext , Throwable t ) { \n \n \t5 logger . warn ( <string_literal> , t . getMessage ( ) ) ; } \n \n \t3 } ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( BundleContext bc ) throws Exception { \n \n <ect>
\t4 mapper . send ( ( Collection < GridComputeJob > ) null ) ; \n \n \t4 assert false ; } \n \n \t3 catch ( NullPointerException e ) { \n \n <ect>
\t2 log . info ( <string_literal> , key , timeoutMillis ) ; \n \n \t2 return result ; } \n \n \t1 @ Override \n \n \t1 public ReplyHandler putIfAbsent ( String key , ReplyHandler value , long timeoutMillis ) { \n \n <ect>
\t2 m_pathCache . replace ( structureId , rootPath ) ; \n \n \t2 if ( isSitemapConfiguration ( rootPath , type ) ) { \n \n \t3 m_updateSet . add ( structureId ) ; \n \n \t2 } else if ( isModuleConfiguration ( rootPath , type ) ) { \n \n <ect>
\t2 LOG . info ( <string_literal> , firstFollowerIndex ) ; \n \n \t2 qU . shutdown ( firstFollowerIndex ) ; \n \n \t2 LOG . info ( <string_literal> , secondFollowerIndex ) ; \n \n \t2 qU . shutdown ( secondFollowerIndex ) ; \n \n <ect>
\t3 String uuid \t2 = webSocketData . getId ( ) ; \n \n \t3 byte [ ] data \t2 = new byte [ 0 ] ; \n \n \t3 if ( rawData != null ) { \n \n \t4 if ( rawData instanceof String ) { \n \n <ect>
\t4 for ( int i = 0 ; i < cmds . length ; i ++ ) { \n \n \t5 startups [ i ] = ( StartupCommand ) cmds [ i ] ; } \n \n \t4 attache = handleConnectedAgent ( link , startups , request ) ; \n \n \t4 if ( attache == null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 if ( expectedEvents . contains ( event . getType ( ) ) ) { \n \n \t4 latch . countDown ( ) ; } } \n \n \t2 public boolean matches ( ) throws InterruptedException { \n \n \t3 if ( ! latch . await ( CONNECTION_TIMEOUT / <number_literal> , TimeUnit . MILLISECONDS ) ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t3 res . addHeader ( X_ATMOSPHERE_ERROR , <string_literal> ) ; \n \n \t3 res . flushBuffer ( ) ; \n \n \t3 return new Action ( ) ; } \n \n \t2 if ( config . handlers ( ) . isEmpty ( ) ) { \n \n <ect>
\t2 public final void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { \n \n \t3 if ( evt instanceof SslHandshakeCompletionEvent ) { \n \n \t4 SslHandshakeCompletionEvent handshakeEvt = ( SslHandshakeCompletionEvent ) evt ; \n \n \t4 if ( handshakeEvt . cause ( ) != null ) { \n \n <ect>
\t5 if ( crop ) { \n \n \t6 final int offsetX = reqOffsetX != null ? reqOffsetX : Math . abs ( maxWidth - destWidth ) / <number_literal> ; \n \n \t6 final int offsetY = reqOffsetY != null ? reqOffsetY : Math . abs ( maxHeight - destHeight ) / <number_literal> ; \n \n \t6 final Integer [ ] dims = finalImageDimensions ( offsetX , offsetY , maxWidth , maxHeight , sourceWidth , sourceHeight ) ; \n \n <ect>
\t1 public void receiveCommand ( Item item , Command command , ZWaveNode node , ZWaveDoorLockCommandClass commandClass , \n \n \t3 int endpointId , Map < String , String > arguments ) { \n \n \t2 ZWaveCommandConverter < ? , ? > converter = this . getCommandConverter ( command . getClass ( ) ) ; \n \n \t2 if ( converter == null ) { \n \n <ect>
\t3 responseData . put ( <string_literal> , Integer . toString ( response . getStatusLine ( ) . getStatusCode ( ) ) ) ; \n \n \t3 for ( final Header header : response . getAllHeaders ( ) ) { \n \n \t4 responseData . put ( header . getName ( ) , header . getValue ( ) ) ; } \n \n \t2 } catch ( final Throwable t ) { \n \n <ect>
\t3 DeleteOnHaltHook . runHooks ( ) ; } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n \t3 logger . warn ( <string_literal> , t ) ; } \n \n <ect>
\t8 _projectMgr . deleteProject ( CallContext . current ( ) . getCallingAccount ( ) , CallContext . current ( ) . getCallingUserId ( ) , project ) ; \n \n \t7 } else { \n \n \t8 s_logger . debug ( <string_literal> + project + <string_literal> + project . getId ( ) ) ; } \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t3 final List < IErlModule > includes ) { \n \n \t2 final List < String > moduleNames = Lists . newArrayList ( ) ; \n \n \t2 for ( final IErlModule module : includes ) { \n \n \t3 moduleNames . add ( module . getName ( ) ) ; } \n \n <ect>
\t1 log . info ( <string_literal> ) ; \n \n \t2 log . debug ( <string_literal> ) ; \n \n \t2 log . debug ( <string_literal> , System . getProperty ( <string_literal> ) ) ; \n \n <ect>
<comment> \n \n \t1 public void registerTaskManager ( final TaskExecutorConnection taskExecutorConnection , SlotReport initialSlotReport ) { \n \n \t2 checkInit ( ) ; \n \n <ect>
<comment> \n \n \t1 public synchronized CountBalancedTree < K , V > split ( ) { \n \n \t2 CountBalancedTree < K , V > at = new CountBalancedTree < > ( ) ; \n \n \t2 if ( root == null || root . left == null || root . right == null ) { \n \n <ect>
\t6 jpaService . execute ( new WorkflowActionUpdateJPAExecutor ( wfAction ) ) ; } \n \n \t5 catch ( JPAExecutorException je ) { \n \n \t6 throw new CommandException ( je ) ; } \n \n \t5 catch ( Exception ex ) { \n \n <ect>
\t4 ContentName cn = SegmentationProfile . segmentName ( \n \n \t6 ContentName . fromNative ( <string_literal> + new Integer ( tValue ) . toString ( ) ) , SegmentationProfile . baseSegment ( ) ) ; \n \n \t4 ContentObject result = reader . get ( Interest . last ( cn , 1 , null ) , <number_literal> ) ; \n \n \t4 checkResult ( result , highest ) ; } } \n \n <ect>
\t4 return saveNewDict ( newDictInfo ) ; } \n \n \t2 } else { \n \n \t3 String dupDict = checkDupByContent ( newDictInfo , newDict ) ; \n \n \t3 if ( dupDict != null ) { \n \n <ect>
\t3 p . setValue ( NOT_OTHER , Boolean . TRUE ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 log . warn ( <string_literal> , e ) ; \n \n \t3 throw new RuntimeException ( <string_literal> , e ) ; } \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
public static Compressor getCompressor ( CompressionCodec codec ) { \n \n \t1 Compressor compressor = borrow ( COMPRESSOR_POOL , codec . getCompressorType ( ) ) ; \n \n \t1 if ( compressor == null ) { \n \n \t1 compressor = codec . createCompressor ( ) ; \n \n <ect>
\t3 _instance = <string_literal> ; } \n \n \t2 Map < String , String > agentMgrConfigs = configDao . getConfiguration ( <string_literal> , params ) ; \n \n \t2 _mgmt_host = agentMgrConfigs . get ( <string_literal> ) ; \n \n \t2 if ( _mgmt_host == null ) { \n \n <ect>
\t2 } ) ; \n \n \t2 if ( nodeScopedCondition . get ( ) && ! indexingRule . isNodeFullTextIndexed ( ) ) { \n \n \t3 return false ; } \n \n \t2 if ( relativeParentsFound . get ( ) ) { \n \n <ect>
\t5 return new StopAnswer ( cmd , msg ) ; } \n \n \t4 State state = s_vms . getState ( _cluster , vmName ) ; \n \n \t4 synchronized ( _cluster . intern ( ) ) { \n \n \t5 s_vms . put ( _cluster , _name , vmName , State . Stopping ) ; } \n \n <ect>
\t4 handleAccessRequest ( req , resp , vmId ) ; \n \n \t3 } else { \n \n \t4 handleAuthRequest ( req , resp , vmId ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 catch ( JPAExecutorException e ) { \n \n \t5 throw new CommandException ( e ) ; } } \n \n \t3 LOG . debug ( <string_literal> + jobList . size ( ) + <string_literal> + actionDeleted ) ; } \n \n \t2 else { \n \n <ect>
\t1 public static void deleteHTable ( TableName tableName ) throws IOException { \n \n \t2 Admin admin = HBaseConnection . get ( KylinConfig . getInstanceFromEnv ( ) . getStorageUrl ( ) ) . getAdmin ( ) ; \n \n \t2 try { \n \n \t3 if ( admin . tableExists ( tableName ) ) { \n \n <ect>
\t1 IndexMetaData archiveBrokenIndexSettings ( IndexMetaData indexMetaData ) { \n \n \t2 final Settings settings = indexMetaData . getSettings ( ) ; \n \n \t2 final Settings upgrade = indexScopedSettings . archiveUnknownOrInvalidSettings ( \n \n \t3 settings , \n \n <ect>
\t1 advanceDumpDir ( ) ; \n \n \t1 run ( <string_literal> + dbName + <string_literal> + replDumpId , driver ) ; \n \n \t1 String incrementalDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 String incrementalDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t3 SmackConfiguration . setPacketReplyTimeout ( <number_literal> ) ; \n \n \t3 newParent . addContact ( contact ) ; } \n \n \t2 catch ( XMPPException ex ) \n \n \t2 { \n \n <ect>
\t4 if ( sleepBetweenSend > 0 ) { \n \n \t5 try { \n \n \t6 Thread . sleep ( sleepBetweenSend ) ; \n \n \t5 } catch ( InterruptedException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 try { \n \n \t2 upload = objectManager . initiateCreation ( upload ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 { \n \n \t5 <comment> \n \n \t5 activity . setOriginalActor ( null ) ; \n \n \t5 <comment> \n \n <ect>
\t4 if ( br != null ) { \n \n \t5 try { \n \n \t6 br . close ( ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t5 col += colSpan ; \n \n \t5 if ( col >= currentRowMaxColums ) { \n \n \t6 row ++ ; \n \n \t6 col = 0 ; \n \n <ect>
\t2 } else { \n \n \t3 logger . warn ( <string_literal> , \n \n \t5 command . toString ( ) , config . getItemName ( ) ) ; } } \n \n \t1 private void callMios ( String url ) { \n \n <ect>
\t4 configuration . port ) ) } } \n \n \t2 } else { \n \n \t2 logger . info ( <string_literal> ) } \n \n \t1 } catch ( final Exception e ) { \n \n <ect>
\t4 this . transactionManager . commit ( this . transactionStatus ) ; } } \n \n \t2 finally { \n \n \t3 this . transactionStatus = null ; } \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 { \n \n \t2 URI uri ; \n \n \t2 if ( ( uri = processExtStylesheet ( target , data ) ) != null ) \n \n \t2 { \n \n <ect>
\t10 oldVal , hasOldVal , CU . subjectId ( tx , cctx ) , null , \n \n \t10 inTx ( ) ? tx . resolveTaskName ( ) : null ) ; \n \n \t8 cctx . cache ( ) . metrics0 ( ) . onRead ( false ) ; } \n \n <ect>
\t3 sessions . put ( nick , sess ) ; \n \n \t2 } catch ( SessionsDB . ExistingIdException e ) { \n \n \t3 return <string_literal> + nick ; } \n \n \t2 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t4 config . setTargetType ( targetType ) ; \n \n \t4 propertyChangeSupport . firePropertyChange ( TARGET_TYPE_PROPERTY , oldName , targetType ) ; } } \n \n \t2 public void propertyRemoved ( String name ) { \n \n \t3 if ( name . equals ( sourceType ) ) { \n \n <ect>
\t3 return ; \n \n \t2 } catch ( CmsException ex ) { \n \n \t3 resp . setStatus ( CmsWebdavStatus . SC_INTERNAL_SERVER_ERROR ) ; \n \n \t3 if ( LOG . isErrorEnabled ( ) ) { \n \n <ect>
\t3 out . writeByte ( Message . classMap . inverse ( ) . get ( payload . getClass ( ) ) ) ; \n \n \t3 payload . write ( out ) ; \n \n \t3 return out . toByteArray ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 foUserAgent . setKeywords ( <string_literal> ) ; \n \n \t2 try { \n \n \t3 Fop fop = fopFactory . newFop ( MimeConstants . MIME_PDF , foUserAgent , os ) ; \n \n <ect>
\t6 } else { \n \n \t7 _log . logAlways ( Log . WARN , <string_literal> + key + \n \n <number_literal> <string_literal> + file + <string_literal> + b64 ) ; } } \n \n \t4 } catch ( IOException ioe ) { \n \n <ect>
\t5 log . warn ( <string_literal> ) ; \n \n \t5 authenticate ( ) ; \n \n \t5 deleteObject ( containerName , objectName ) ; \n \n \t4 } else { \n \n <ect>
\t2 throw new SemanticException ( e1 ) ; } \n \n \t1 ctx . resetOpContext ( ) ; \n \n \t1 ctx . resetStream ( ) ; \n \n \t1 TaskFactory . resetId ( ) ; \n \n <ect>
<comment> \n \n \t1 private boolean renderFileFromFilesystem ( String path , XWikiContext context ) throws XWikiException \n \n \t1 { \n \n <ect>
\t2 } else if ( resourceDataKey != null ) { \n \n \t3 LOGGER . debug ( <string_literal> + resourceDataKey ) ; \n \n \t3 response = responseForDataCachedWithKey ( resourceDataKey ) ; } \n \n \t2 if ( response == null ) { \n \n <ect>
\t2 { \n \n \t3 process ( String . format ( <string_literal> , Auth . AUTH_KS , PERMISSIONS_CF , escape ( droppedUser ) ) ) ; } \n \n \t2 catch ( RequestExecutionException e ) \n \n \t2 { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , attrs ) ; } \n \n \t2 if ( authenticator . getReturnAttributes ( ) != null ) { \n \n \t3 final List < String > authenticatorAttributes = CollectionUtils . wrapList ( authenticator . getReturnAttributes ( ) ) ; \n \n \t3 if ( ! authenticatorAttributes . isEmpty ( ) ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> , e ) ; \n \n \t3 throw new CloudRuntimeException ( e . toString ( ) ) ; } } \n \n \t1 @ Override \n \n \t1 public KVMStoragePool createStoragePool ( String name , String host , int port , String path , String userInfo , StoragePoolType type ) { \n \n <ect>
\t2 checkpointMBean . createCheckpoint ( <number_literal> ) ; \n \n \t2 Set < String > afterCheckpointBlobs = createBlobs ( <number_literal> , <number_literal> ) ; \n \n \t2 state . blobsPresent . addAll ( afterCheckpointBlobs ) ; \n \n \t2 log . info ( <string_literal> , state . blobsAdded . size ( ) , state . blobsAdded ) ; \n \n <ect>
\t2 final String entityId = pair . getValue ( ) . getEntityId ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , entityId ) ; \n \n \t2 final AuthnRequest authnRequest = authenticationContext . getKey ( ) ; \n \n \t2 this . responseBuilder . build ( authnRequest , request , response , casAssertion , pair . getKey ( ) , pair . getValue ( ) , binding ) ; \n \n <ect>
\t1 } finally { \n \n \t2 if ( runtime != null ) { \n \n \t2 runtime . dispose ( ) ; } } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 @ Test \n \n \t1 @ OperateOnDeployment ( APP_GRANT ) \n \n \t1 public void testJSMEnabled ( @ ArquillianResource URL webAppURL ) throws Exception { \n \n \t2 final URI checkJSMuri = new URI ( webAppURL . toExternalForm ( ) + JSMCheckServlet . SERVLET_PATH . substring ( 1 ) ) ; \n \n <ect>
\t1 public void receiveCommand ( Item item , Command command , ZWaveNode node , ZWaveIndicatorCommandClass commandClass , \n \n \t3 int endpointId , Map < String , String > arguments ) { \n \n \t2 ZWaveCommandConverter < ? , ? > converter = this . getCommandConverter ( command . getClass ( ) ) ; \n \n \t2 if ( converter == null ) { \n \n <ect>
\t1 public void restore ( Version [ ] versions , \n \n \t6 boolean removeExisting ) \n \n \t2 throws ItemExistsException , UnsupportedRepositoryOperationException , VersionException , LockException , \n \n \t2 InvalidItemStateException , RepositoryException { \n \n <ect>
\t3 VolumeApiResult result = future . get ( storagePoolMaxWaitSeconds , TimeUnit . SECONDS ) ; \n \n \t3 if ( volumeDetail != null ) { \n \n \t4 volumeDetailsDao . remove ( volumeDetail . getId ( ) ) ; } \n \n \t3 if ( result . isFailed ( ) ) { \n \n <ect>
\t3 { \n \n \t4 new EventTrace ( <string_literal> , tracer . get ( ) ) . commit ( ) ; \n \n \t4 if ( ! Boolean . getBoolean ( DebugUtils . PROPERTY_DONT_LOG_CONNECTION_ISSUES ) ) \n \n \t4 { \n \n <ect>
public boolean stop ( ) { \n \n \t1 if ( hsqlServer != null ) { \n \n \t1 try { \n \n \t2 logger . debug ( <string_literal> ) ; <comment> \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n \t2 context = bc ; \n \n <ect>
\t9 new ArrayList < String > ( ) , true ) ; \n \n \t6 } catch ( IOException e ) { \n \n \t7 log . warn ( <string_literal> , icsFile , e ) ; \n \n \t6 } catch ( ParserException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 startStopwatch ( ) ; \n \n \t2 <comment> \n \n <ect>
\t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t1 bucketWriter . append ( e ) ; } \n \n \t1 logger . info ( <string_literal> , hdfsWriter . getEventsWritten ( ) ) ; \n \n \t1 logger . info ( <string_literal> , hdfsWriter . getBytesWritten ( ) ) ; \n \n <ect>
\t2 try { \n \n \t3 Pair < Boolean , String > result = SshHelper . sshExecute ( cmd . getAccessDetail ( NetworkElementCommand . ROUTER_IP ) , DEFAULT_DOMR_SSHPORT , <string_literal> , \n \n \t5 new File ( <string_literal> ) , null , <string_literal> + args ) ; \n \n \t3 if ( ! result . first ( ) ) { \n \n <ect>
\t2 publishEvent ( new CasAuthenticationTransactionSuccessfulEvent ( this , credential ) ) ; \n \n \t2 Principal principal = result . getPrincipal ( ) ; \n \n \t2 final String resolverName = resolver != null ? resolver . getClass ( ) . getSimpleName ( ) : <string_literal> ; \n \n \t2 if ( resolver == null ) { \n \n <ect>
\t3 if ( ! HttpHeaders . isKeepAlive ( request ) ) { \n \n \t4 lastContentFuture . addListener ( ChannelFutureListener . CLOSE ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 raf . close ( ) ; \n \n <ect>
\t5 s_logger . warn ( <string_literal> + backupRouter . getInstanceName ( ) , e ) ; \n \n \t4 } catch ( ResourceUnavailableException e ) { \n \n \t5 s_logger . warn ( <string_literal> + backupRouter . getInstanceName ( ) , e ) ; \n \n \t4 } catch ( InsufficientCapacityException e ) { \n \n <ect>
\t3 result . ouch4 = ( TableExistsException ) e ; \n \n \t3 result . setOuch4IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> ) ; } \n \n \t2 for ( ManagementServerHostVO mshost : nodeList ) { \n \n <ect>
\t4 Properties opts = new Properties ( ) ; \n \n \t4 I2PSocketManager mgr = new I2PSocketManagerFull ( _context , _session , opts , <string_literal> ) ; \n \n \t4 _log . debug ( <string_literal> ) ; \n \n \t4 I2PServerSocket ssocket = mgr . getServerSocket ( ) ; \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t4 response . readEntity ( String . class ) ) ; \n \n \t2 List < ResteasyConstraintViolation > classViolations = resteasyViolationException . getClassViolations ( ) ; \n \n \t2 Assert . assertEquals ( 1 , classViolations . size ( ) ) ; \n \n \t2 Assert . assertEquals ( ValidationExceptionCrazyConstraint . DEFAULT_MESSAGE , classViolations . get ( 0 ) . getMessage ( ) ) ; \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 boolean removed = _timedJobs . remove ( job ) ; \n \n \t4 if ( removed && _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 if ( ! SSHCmdHelper . sshExecuteCmd ( sshConnection , cmd ) ) { \n \n \t4 throw new CloudRuntimeException ( <string_literal> + computingHostIp + <string_literal> + _host . getIp ( ) ) ; } \n \n \t3 return true ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t3 if ( ( ! blockEntity . exists ( ) || ! blockEntity . hasComponent ( NetworkComponent . class ) ) && isBlockRelevant ( blockPosition . x , blockPosition . y , blockPosition . z ) ) { \n \n \t4 Block block = getBlock ( blockPosition . x , blockPosition . y , blockPosition . z ) ; \n \n \t4 blockEntity = createBlockEntity ( blockPosition , block ) ; } \n \n \t3 return blockEntity ; } \n \n <ect>
\t2 times [ i % times . length ] = \n \n \t3 ( System . nanoTime ( ) - start ) / ( 1 . 0e6 * document . getNumNondefaultElements ( ) ) ; \n \n \t2 if ( i % <number_literal> == 0 ) { \n \n \t3 long time = System . nanoTime ( ) - startTime ; \n \n <ect>
\t2 return createServiceFilter ( configurationProperties . getServiceFilter ( ) ) ; } \n \n \t1 @ PostConstruct \n \n \t1 public void addServiceFilterConfigurations ( ) { \n \n \t2 if ( ! ( beanFactory instanceof ConfigurableBeanFactory ) ) { \n \n <ect>
\t4 logger . warn ( <string_literal> + remove + <string_literal> + body . getMethod ( ) + <string_literal> ) ; \n \n \t3 if ( ! remove . equals ( units . getFirst ( ) ) ) { \n \n \t4 Unit pred = ( Unit ) units . getPredOf ( remove ) ; \n \n \t4 if ( debug ) \n \n <ect>
public void setTalent ( webobjectsexamples . businesslogic . eo . Talent value ) { \n \n \t1 takeStoredValueForKey ( value , _MovieRole . TALENT_KEY ) ; } \n \n public void setTalentRelationship ( webobjectsexamples . businesslogic . eo . Talent value ) { \n \n <ect>
\t2 this . keyRangeNum = JStormUtils . getScaleOutNum ( ConfigExtension . getKeyRangeNum ( context . getStormConf ( ) ) , componentTaskNum ) ; \n \n \t2 Collection < Integer > keyRanges = keyRangesByTaskIndex ( keyRangeNum , componentTaskNum , context . getThisTaskIndex ( ) ) ; \n \n \t2 for ( Integer keyRange : keyRanges ) { \n \n \t3 initKeyRangeState ( keyRange ) ; } \n \n <ect>
\t3 Exception e = wrapWithOnErrorHook ( failureType , originalException ) ; \n \n \t3 return Observable . error ( new HystrixRuntimeException ( failureType , this . getClass ( ) , getLogMessagePrefix ( ) + <string_literal> + message + <string_literal> , e , null ) ) ; \n \n \t2 } else { \n \n \t3 if ( isRecoverableError ( originalException ) ) { \n \n <ect>
\t2 assertAcked ( prepareCreate ( <string_literal> , <number_literal> , Settings . builder ( ) . put ( <string_literal> , <string_literal> ) ) ) ; \n \n \t2 NumShards numShards = getNumShards ( <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForActiveShards ( numShards . numPrimaries * <number_literal> ) . execute ( ) . actionGet ( ) ; \n \n <ect>
\t1 private static final long serialVersionUID = 1239820102030303L ; \n \n \t1 private static final Logger log = LoggerFactory . getLogger ( ModuleServlet . class ) ; \n \n \t1 @ Override \n \n \t1 protected void service ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { \n \n <ect>
\t4 samples . forEach ( s - > fingerprints . put ( s , new Fingerprint ( s , source , null ) ) ) ; } \n \n \t3 try { \n \n \t4 getFingerprintFromVc ( fingerprints , ctx ) ; \n \n \t3 } catch ( final IllegalArgumentException e ) { \n \n <ect>
\t4 return false ; } \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return true ; } \n \n \t2 if ( ! authn . getSuccesses ( ) . isEmpty ( ) ) { \n \n <ect>
\t2 LOG . trace ( LogUtil . subheader ( LogUtil . dumpObject ( config ) ) ) ; \n \n \t2 emf . put ( persistenceContext , entityManagerFactory ) ; \n \n \t2 LOG . info ( <string_literal> + persistenceContext ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t2 if ( configFile == null ) { \n \n \t3 configFile = System . getProperty ( SYS_PROP_CONFIG_FILE ) ; } \n \n \t2 if ( configFile != null && configFile . length ( ) > 0 ) { \n \n <ect>
\t3 requestPath = finalPath . toString ( ) ; } \n \n \t2 Header [ ] requestHeaders = new Header [ headers . size ( ) ] ; \n \n \t2 int index = 0 ; \n \n \t2 for ( Map . Entry < String , String > header : headers . entrySet ( ) ) { \n \n <ect>
\t5 irc . addListener ( listener ) ; \n \n \t5 irc . rawMessage ( <string_literal> + state . getNickname ( ) ) ; } \n \n \t4 catch ( final RuntimeException e ) \n \n \t4 { \n \n <ect>
\t6 if ( byteCount != bytesRead ) { \n \n \t7 log . error ( <string_literal> , null ) ; \n \n \t7 ok = false ; } } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t1 private HotRodClient client = new HotRodClient ( <string_literal> , server ( ) . getPort ( ) , cacheName , <number_literal> , ( byte ) <number_literal> ) ; \n \n \t1 @ Override \n \n \t1 public Void call ( ) throws Exception { \n \n \t2 TestResourceTracker . testThreadStarted ( HotRodConcurrentTest . this ) ; \n \n <ect>
\t3 try { \n \n \t4 URL url = ConversionUtils . makeRelativeURL ( lastRes . getURL ( ) , location ) ; \n \n \t4 url = ConversionUtils . sanitizeUrl ( url ) . toURL ( ) ; \n \n <ect>
<comment> \n \n \t1 protected void executeMimeResult ( final String finalLocation ) throws PortletException , IOException { \n \n <ect>
\t1 if ( writer != null ) { \n \n \t2 try { \n \n \t2 writer . close ( ) ; \n \n \t2 } catch ( MutationsRejectedException e ) { \n \n <ect>
\t6 s_logger . warn ( <string_literal> + vm . getUuid ( ) + <string_literal> ) ; } } \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( ! _vmMgr . expunge ( vm , callerUserId , caller ) ) { \n \n <ect>
\t4 ) ) ; \n \n \t3 connection ( ) . exec ( sqlStr ( <string_literal> ) ) ; \n \n \t2 } catch ( SQLException ex ) \n \n \t2 { \n \n <ect>
\t2 writer . setIndent ( <string_literal> ) ; \n \n \t2 try { \n \n \t3 writeModel ( writer ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 log . debug ( <string_literal> , entry , url ) ; \n \n \t3 return entry ; } \n \n \t2 if ( headers == null ) { \n \n <ect>
\t3 Object value = response . getValue ( ) ; \n \n \t3 return JolokiaHelpers . convertJolokiaToJavaType ( method . getReturnType ( ) , value ) ; \n \n \t2 } catch ( J4pException e ) { \n \n \t3 List < Object > argsList = args == null ? null : Arrays . asList ( args ) ; \n \n <ect>
\t4 logger . error ( <string_literal> ) ; \n \n \t4 return ; } } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t6 nodes , \n \n \t6 true ) . get ( ) ; } \n \n \t4 catch ( GridTopologyException e ) { \n \n <ect>
\t3 return CollectionUtils . wrapSet ( event ) ; } } \n \n \t1 private RegisteredService determineRegisteredServiceForEvent ( final RequestContext context , final Service service ) { \n \n \t2 RegisteredService registeredService = null ; \n \n \t2 if ( service != null ) { \n \n <ect>
\t6 vm . setAffinity ( conn , vm . getResidentOn ( conn ) ) ; \n \n \t6 if ( citrixResourceBase . canBridgeFirewall ( ) ) { \n \n \t7 final String result = citrixResourceBase . callHostPlugin ( conn , <string_literal> , <string_literal> , <string_literal> , command . getVmName ( ) ) ; \n \n \t7 if ( result == null || result . isEmpty ( ) || ! Boolean . parseBoolean ( result ) ) { \n \n <ect>
\t2 List < StaticDatabasePropertyEntry > entities = Entities . query ( new StaticDatabasePropertyEntry ( ) ) ; \n \n \t2 for ( StaticDatabasePropertyEntry entry : entities ) { \n \n \t2 if ( entry . getPropName ( ) != null && changes . containsKey ( entry . getPropName ( ) ) ) { \n \n \t3 String [ ] newProperty = changes . get ( entry . getPropName ( ) ) ; \n \n <ect>
\t1 GetHeadRequestHandler ( StandbyHeadReader reader ) { \n \n \t2 this . reader = reader ; } \n \n \t1 @ Override \n \n \t1 protected void channelRead0 ( ChannelHandlerContext ctx , GetHeadRequest msg ) throws Exception { \n \n <ect>
\t3 Script command = new Script ( true , <string_literal> , _timeout , s_logger ) ; \n \n \t3 command . add ( mountPoint ) ; \n \n \t3 result = command . execute ( ) ; \n \n \t3 if ( result != null ) { \n \n <ect>
\t4 trMap . put ( taskName , new TaskRunner ( task ) ) ; \n \n \t4 <comment> \n \n \t4 perfList . add ( taskName ) ; \n \n \t3 } catch ( IOException ioE ) { \n \n <ect>
\t3 } else { \n \n \t4 jobWithJars = prog . getPlanWithJars ( ) ; } \n \n \t3 return run ( jobWithJars , parallelism , prog . getSavepointSettings ( ) ) ; } \n \n \t2 else if ( prog . isUsingInteractiveMode ( ) ) { \n \n <ect>
protected int getHostInMemoryAggregationPort ( ) { \n \n \t1 return hostInMemoryAggregationPort ; } \n \n @ Override \n \n public void prepare ( Map conf ) { \n \n <ect>
\t2 log . debug ( <string_literal> , <string_literal> ) ; \n \n \t2 return cl . getResourceAsStream ( name ) ; } \n \n \t1 @ Override \n \n \t1 protected synchronized Class loadClass ( String name , boolean resolve ) throws ClassNotFoundException { \n \n <ect>
\t2 } else { \n \n \t3 consumer = consumeSession . createConsumer ( consumerDestination ) ; } \n \n \t2 consumer . setMessageListener ( this ) ; \n \n \t2 assertMessagesAreReceived ( ) ; \n \n <ect>
\t1 } else { \n \n \t1 return true ; } } \n \n protected boolean verifyContextNotStarted ( ) { \n \n \t1 if ( muleContext != null && muleContext . getLifecycleManager ( ) . isPhaseComplete ( Startable . PHASE_NAME ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( D2WModel . defaultModel ( ) == this ) { \n \n <ect>
\t1 setupLogging ( ) ; \n \n \t1 String portOverride = System . getenv ( <string_literal> ) ; \n \n \t1 int port = portOverride != null ? Integer . parseInt ( portOverride ) : <number_literal> ; \n \n \t1 Provider provider = Providers . getByName ( args [ 0 ] ) ; \n \n <ect>
\t1 public void accept ( final Void aVoid ) { \n \n \t2 OrderedShutdown . registerPostShutdownHook ( new Runnable ( ) { \n \n \t2 @ Override \n \n \t2 public void run ( ) { \n \n <ect>
\t4 resourceResolver = new PathMatchingResourcePatternResolver ( moduleClassLoader ) ; \n \n \t4 propertiesFiles = resourceResolver . getResources ( pattern ) ; \n \n \t4 Collections . addAll ( resourceSet , propertiesFiles ) ; } } \n \n \t2 catch ( IOException e ) { \n \n <ect>
\t5 SignatureValidator validator = new SignatureValidator ( credential ) ; \n \n \t5 try { \n \n \t6 validator . validate ( sig ) ; \n \n \t5 } catch ( ValidationException e ) { \n \n <ect>
\t1 void flushAvailable ( DataReceiver target , boolean blocking ) throws IOException { \n \n \t2 WriteStatus ws = null ; \n \n \t2 long before = System . currentTimeMillis ( ) ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) && _valid > 0 ) \n \n <ect>
\t1 @ Override \n \n \t1 public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) { \n \n \t2 NetData . NetMessage message = ( NetData . NetMessage ) e . getMessage ( ) ; \n \n \t2 if ( message . hasServerInfo ( ) ) { \n \n <ect>
\t1 private void addTrafficType ( Connection conn , long physicalNetworkId , String trafficType , String xenPublicLabel , String kvmPublicLabel , String vmwarePublicLabel ) { \n \n \t2 <comment> \n \n \t2 PreparedStatement pstmtUpdate = null ; \n \n \t2 try { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t2 if ( ! requestedProvider . isPresent ( ) ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return Pair . of ( Boolean . FALSE , Optional . empty ( ) ) ; } \n \n \t2 if ( contexts . stream ( ) . filter ( ctx - > ctx . toString ( ) . equals ( requestedContext ) ) . count ( ) > 0 ) { \n \n <ect>
\t2 logger . debug ( <string_literal> + evt . getSourceMessage ( ) . getContent ( ) ) ; \n \n \t2 Message transformedMessage = \n \n \t3 createMessage ( evt . getSourceContact ( ) , evt . getSourceMessage ( ) , \n \n \t4 <string_literal> ) ; \n \n <ect>
\t3 + <string_literal> + udfs . get ( fn . getClassName ( ) ) ) ; } \n \n \t1 udfs . put ( fn . getClassName ( ) , fqfn ) ; \n \n \t1 List < ResourceUri > resources = fn . getResourceUris ( ) ; \n \n \t1 if ( resources == null || resources . isEmpty ( ) ) { \n \n <ect>
public FileStatus getHiveJarDirectory ( Configuration conf ) throws IOException , LoginException { \n \n \t1 FileStatus fstatus = null ; \n \n \t1 String hdfsDirPathStr = HiveConf . getVar ( conf , HiveConf . ConfVars . HIVE_JAR_DIRECTORY , ( String ) null ) ; \n \n \t1 if ( hdfsDirPathStr != null ) { \n \n <ect>
\t1 assertTrue ( <string_literal> , \n \n \t2 blockUntilCompactionRunning ( tableName ) ) ; \n \n \t1 <comment> \n \n \t1 connector . tableOperations ( ) . cancelCompaction ( tableName ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 if ( getLockPath ( ) != null ) \n \n \t1 zooKeeper . getZooKeeper ( ) . setData ( getLockPath ( ) , b , - 1 ) ; } \n \n @ Override \n \n public synchronized void process ( WatchedEvent event ) { \n \n <ect>
\t2 } else { \n \n \t3 method = null ; \n \n \t3 error = new UnsupportedOperationException ( <string_literal> ) ; } \n \n \t2 if ( error == null ) { \n \n <ect>
\t5 I2PThread flood = new I2PThread ( flooder , <string_literal> + con ) ; \n \n \t5 flood . start ( ) ; \n \n \t5 _log . debug ( <string_literal> + _peerDestFiles [ i ] + <string_literal> + con ) ; \n \n \t4 } catch ( IOException ioe ) { \n \n <ect>
\t3 uploader . shutdown ( ) ; \n \n \t3 uploader . awaitTermination ( <number_literal> , TimeUnit . MILLISECONDS ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t2 if ( buf == null ) { \n \n \t3 return ; } \n \n \t2 synchronized ( buf ) { \n \n \t3 if ( Buf . isBad ( buf ) ) { \n \n <ect>
\t2 } else if ( channel != null && ! channel . isOpen ( ) && isAutomaticRecoveryEnabled ( ) ) { \n \n \t3 <comment> \n \n \t3 throw new IOException ( <string_literal> ) ; \n \n \t2 } else if ( channel == null || ! isAutomaticRecoveryEnabled ( ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 if ( response . getStatusCode ( ) == HttpStatus . SC_CREATED || response . getStatusCode ( ) == HttpStatus . SC_ACCEPTED ) \n \n \t5 { \n \n \t6 returnValue = response . getCdnUrl ( ) ; } \n \n \t5 else if ( response . getStatusCode ( ) == HttpStatus . SC_UNAUTHORIZED ) { \n \n <ect>
\t5 try { \n \n \t6 producer . send ( message ) ; \n \n \t6 queueSession . commit ( ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t3 if ( authenticationFromTgt == null ) { \n \n \t4 LOGGER . debug ( <string_literal> , ticketGrantingTicket ) ; \n \n \t4 this . centralAuthenticationService . destroyTicketGrantingTicket ( ticketGrantingTicket ) ; \n \n \t3 } else if ( areAuthenticationsEssentiallyEqual ( authentication , authenticationFromTgt ) ) { \n \n <ect>
\t3 if ( exception != null ) { \n \n \t4 throw exception ; } \n \n \t3 if ( position == size ) { \n \n \t4 if ( ! file . delete ( ) ) { \n \n <ect>
\t4 if ( ! classes [ i ] . isInterface ( ) ) { \n \n \t5 throw new CloudRuntimeException ( classes [ i ] . getName ( ) + <string_literal> ) ; } \n \n \t4 if ( classes [ i ] . isAssignableFrom ( clazz ) ) { \n \n \t5 keys . add ( classes [ i ] . getName ( ) ) ; \n \n <ect>
\t3 Element rootElement = doc . getDocumentElement ( ) ; \n \n \t3 for ( int i = 0 ; i < tagNames . length ; i ++ ) { \n \n \t4 NodeList targetNodes = rootElement . getElementsByTagName ( tagNames [ i ] ) ; \n \n \t4 if ( targetNodes . getLength ( ) < = 0 ) { \n \n <ect>
\t3 return null ; } \n \n \t2 script . add ( mountStr , mntPoint ) ; \n \n \t2 String result = script . execute ( ) ; \n \n \t2 if ( result != null && ! result . contains ( <string_literal> ) ) { \n \n <ect>
\t3 s_logger . error ( <string_literal> , ex ) ; } \n \n \t2 return null ; } \n \n \t1 private static String sshWinTest ( String host ) { \n \n \t2 if ( host == null ) { \n \n <ect>
\t6 . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING . getKey ( ) , <number_literal> ) ) \n \n \t4 . execute ( ) . actionGet ( ) ; \n \n \t2 assertThat ( client . admin ( ) . cluster ( ) . prepareState ( ) . setRoutingTable ( false ) . setNodes ( false ) . execute ( ) . actionGet ( ) . getState ( ) \n \n \t4 . getMetaData ( ) . persistentSettings ( ) . getAsInt ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING . getKey ( ) , - 1 ) , equalTo ( <number_literal> ) ) ; \n \n <ect>
\t3 list . remove ( maxSize - 1 ) ; } \n \n \t2 list . add ( 0 , res1 ) ; \n \n \t2 update ( ) ; } \n \n \t1 public void remove ( DLNAResource res ) { \n \n <ect>
\t7 } catch ( InterruptedException e ) { \n \n \t8 if ( terminated . get ( ) ) { \n \n \t9 break ; } } \n \n \t6 } else { \n \n <ect>
\t2 } finally { \n \n \t3 if ( ! success ) { \n \n \t4 s_logger . warn ( <string_literal> + id ) ; \n \n \t4 return null ; } \n \n <ect>
\t5 try { \n \n \t6 EOFetchSpecification fs = entity . fetchSpecificationNamed ( <string_literal> ) ; \n \n \t6 dsec . bindObjectsWithFetchSpecification ( fs , <string_literal> ) ; \n \n \t5 } catch ( Exception e1 ) { \n \n <ect>
\t9 new DecimalType ( getIntValueFromElements ( element , <string_literal> ) ) ) ; \n \n \t7 logger . debug ( <string_literal> , itemName , \n \n \t9 getIntValueFromElements ( element , <string_literal> ) ) ; \n \n \t6 } else { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t2 return ScriptingUtils . executeGroovyScript ( this . groovyScript , <string_literal> , new Object [ ] { LOGGER } , Map . class ) ; } \n \n \t1 @ Override \n \n \t1 public void writeDevicesBackToResource ( final List < U2FDeviceRegistration > list ) { \n \n \t2 ScriptingUtils . executeGroovyScript ( this . groovyScript , <string_literal> , new Object [ ] { list , LOGGER } , Boolean . class ) ; \n \n <ect>
\t1 final int numKeys = <number_literal> ; \n \n \t1 log . infof ( <string_literal> , numKeys ) ; \n \n \t1 for ( int i = 0 ; i < numKeys ; i ++ ) { \n \n \t2 cache ( 0 ) . put ( i , <string_literal> + i ) ; } \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 Thread . currentThread ( ) . interrupt ( ) ; } \n \n \t3 Node node = selectPeer ( ) ; \n \n \t3 adminClient . setAdminClientCluster ( metadataStore . getCluster ( ) ) ; \n \n <ect>
\t2 TransactionManager tx = cache . getAdvancedCache ( ) . getTransactionManager ( ) ; \n \n \t2 try { \n \n \t3 tx . begin ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 for ( int i = 0 ; i < messageCount ; i ++ ) { \n \n \t3 final String text = <string_literal> + i ; \n \n \t3 template . send ( destination , new MessageCreator ( ) { \n \n \t4 public Message createMessage ( Session session ) throws JMSException { \n \n <ect>
\t4 . getKernelDownloadManifest ( \n \n \t5 Partitions . lookupByName ( vm . getPartition ( ) ) . getNodeCertificate ( ) \n \n \t6 . getPublicKey ( ) , vm . getReservationId ( ) ) ) ; \n \n \t3 } catch ( MetadataException ex ) { \n \n <ect>
\t1 logger . debug ( <string_literal> + cmd ) ; } \n \n \t1 CommandProcessor . getInstance ( ) . executeCommand ( project , new ReadAction ( cmd ) , name , groupId ) ; } \n \n public static void runWriteCommand ( @ Nullable Project project , @ NotNull Runnable cmd , @ Nullable String name , @ Nullable Object groupId ) { \n \n <ect>
\t1 @ RequestMapping ( value = <string_literal> , method = RequestMethod . GET ) \n \n \t1 public String show ( ModelMap model ) { \n \n \t2 UIUtils . readUiConfig ( ) ; \n \n \t2 long start = System . currentTimeMillis ( ) ; \n \n <ect>
\t1 logger . debug ( content . toString ( ) ) ; } \n \n \t1 try { \n \n \t1 document = XmlDom4JHelper . getDocFromString ( content . toString ( ) , new PentahoEntityResolver ( ) ) ; \n \n \t1 } catch ( XmlParseException e ) { \n \n <ect>
\t2 File dataDir = new File ( zkProps . getProperty ( <string_literal> ) ) ; \n \n \t2 if ( ! dataDir . isDirectory ( ) && ! dataDir . mkdirs ( ) ) { \n \n \t3 throw new IOException ( <string_literal> + dataDir + <string_literal> ) ; } \n \n \t2 dataDir . deleteOnExit ( ) ; \n \n <ect>
\t5 if ( cmd == null ) { \n \n \t6 log . warn ( <string_literal> ) ; \n \n \t6 result = false ; \n \n \t5 } else { \n \n <ect>
\t3 JobGraphPrinter jp = new JobGraphPrinter ( this ) ; \n \n \t3 try { \n \n \t4 jp . visit ( ) ; \n \n \t3 } catch ( FrontendException e ) { \n \n <ect>
\t4 Map . Entry < DBKey , V > entry = iterator . next ( ) ; \n \n \t4 map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } \n \n \t3 return map ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t2 if ( in != null ) { \n \n \t3 in . close ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 log . debug ( <string_literal> , tableModel . getColumnData ( getUserColName ( col ) ) ) ; \n \n \t4 log . debug ( <string_literal> , threadLists ) ; } } \n \n <ect>
\t2 kbuilder . buildAll ( projectClass ) ; \n \n \t2 <comment> \n \n \t2 List < Message > msgs = kbuilder . getResults ( ) . getMessages ( Message . Level . INFO ) ; \n \n \t2 if ( msgs . size ( ) > 0 ) { \n \n <ect>
\t3 to = InetAddress . getByAddress ( ip ) ; \n \n \t2 } catch ( UnknownHostException uhe ) { \n \n \t3 <comment> \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 private void stop ( ) { \n \n \t2 try { \n \n \t3 jmxExporter . getMBeanServer ( ) . unregisterMBean ( connectorObjectName ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 return super . delete ( record ) ; } \n \n \t1 @ Override \n \n \t1 public Record find ( Record record ) \n \n \t1 { \n \n <ect>
\t2 try { \n \n \t3 if ( _emailAlert != null ) { \n \n \t4 _emailAlert . clearAlert ( alertType , dataCenterId , podId ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( sqlTables . get ( itemName ) == null ) { \n \n <ect>
\t1 if ( topN == null || topN . isEmpty ( ) ) { \n \n \t1 return null ; } \n \n \t1 Integer topNValue = parseIntStr ( topN ) ; \n \n \t1 if ( topNValue == 0 ) { \n \n <ect>
\t5 } catch ( ChannelException x ) { \n \n \t6 if ( debug ) log . error ( <string_literal> + x . getMessage ( ) , x ) ; \n \n \t6 log . error ( <string_literal> + x . getMessage ( ) ) ; \n \n \t6 ChannelException . FaultyMember [ ] faulty = x . getFaultyMembers ( ) ; \n \n <ect>
\t2 counterCache . setCapacity ( capacity * <number_literal> * <number_literal> ) ; } \n \n \t1 public void saveCaches ( ) throws ExecutionException , InterruptedException \n \n \t1 { \n \n \t2 List < Future < ? > > futures = new ArrayList < > ( <number_literal> ) ; \n \n <ect>
\t1 long t1 = System . currentTimeMillis ( ) ; \n \n \t1 TreeMap < KeyExtent , TabletData > tabletInfo = tablet . split ( splitPoint ) ; \n \n \t1 if ( tabletInfo == null ) { \n \n \t1 return null ; } \n \n <ect>
\t2 result . attempted ( parent . toString ( ) ) ; \n \n \t2 List < String > paths = repository . resource ( parent ) . list ( ) ; \n \n \t2 if ( paths == null ) { \n \n \t3 return Collections . emptyList ( ) ; } \n \n <ect>
\t2 <comment> \n \n \t2 long lag = _context . jobQueue ( ) . getMaxLag ( ) ; \n \n \t2 if ( ( lag > JOB_LAG_LIMIT_NETWORK ) && ( _context . router ( ) . getUptime ( ) > <number_literal> * <number_literal> ) ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 { \n \n \t4 osPeople . add ( convertToOSPerson ( currentPerson ) ) ; } } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t3 . isDirectory ( ) ) { \n \n \t3 error ( <string_literal> , output ) ; } \n \n \t2 if ( output . isFile ( ) && ! output . canWrite ( ) ) { \n \n \t3 error ( <string_literal> , output ) ; } \n \n <ect>
\t4 s_logger . debug ( <string_literal> ) ; } \n \n \t3 if ( cmd . needSetup ( ) ) { \n \n \t4 result = callHostPlugin ( conn , <string_literal> , <string_literal> , <string_literal> , _host . uuid ) ; \n \n \t4 if ( ! result . contains ( <string_literal> ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 public void shutdown ( ) { \n \n <ect>
\t7 try { \n \n \t8 str1 = new String ( ca1 , DataReaderWriter . UTF8 ) ; \n \n \t8 str2 = new String ( ca2 , DataReaderWriter . UTF8 ) ; \n \n \t7 } catch ( UnsupportedEncodingException uee ) { \n \n <ect>
\t2 Configuration . setConfiguration ( krb5configuration ) ; \n \n \t2 <comment> \n \n \t2 final LoginContext lc = Utils . loginWithKerberos ( krb5configuration , GSSTestConstants . PRINCIPAL , \n \n \t4 GSSTestConstants . PASSWORD ) ; \n \n <ect>
\t3 attemptItemAdvanceFinal ( ROLE . STEP3 , false ) ; \n \n \t3 contextReload ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 e . printStackTrace ( ) ; \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t2 throw handlePoolException ( pool , e ) ; } } } } \n \n private static boolean isSubDir ( Path srcf , Path destf , FileSystem srcFs , FileSystem destFs , boolean isSrcLocal ) { \n \n \t1 if ( srcf == null ) { \n \n <ect>
\t3 long end = System . currentTimeMillis ( ) ; \n \n \t3 int r = receivedMessages . get ( ) ; \n \n \t3 int p = producedMessages . get ( ) ; \n \n \t3 LOG . info ( <string_literal> + p + <string_literal> + ( p * 1000f / ( end - start ) ) + <string_literal> + <string_literal> + r + <string_literal> + ( r * 1000f / ( end - start ) ) + <string_literal> ) ; } \n \n <ect>
\t2 FileOffer fo ; \n \n \t2 synchronized ( this ) { \n \n \t3 fo = ( myFileOffersByUID . get ( uid ) ) ; } \n \n \t2 if ( fo == null ) { \n \n <ect>
\t4 InetAddress source = entry . getKey ( ) ; \n \n \t4 InetAddress preferred = SystemKeyspace . getPreferredIP ( source ) ; \n \n \t4 Collection < Range < Token > > ranges = entry . getValue ( ) ; \n \n <ect>
\t5 dest . readBytes ( fin ) ; \n \n \t5 I2PThread flooder = new I2PThread ( new Flooder ( dest ) , <string_literal> + dest . calculateHash ( ) . toBase64 ( ) . substring ( 0 , <number_literal> ) ) ; \n \n \t5 flooder . start ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 public void addUniqueKey ( String keyName , ColumnDefinition column ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( column == null ) { \n \n <ect>
\t5 } catch ( Throwable t ) { \n \n \t6 if ( broadcaster . isDestroyed ( ) ) { \n \n \t7 logger . trace ( <string_literal> , t ) ; \n \n \t6 } else { \n \n <ect>
\t2 assertNotNull ( <string_literal> , exchange ) ; \n \n \t2 Message in = exchange . getIn ( ) ; \n \n \t2 assertNotNull ( <string_literal> , in ) ; \n \n \t2 Map < String , Object > headers = in . getHeaders ( ) ; \n \n <ect>
\t2 final int numIndices = randomIntBetween ( 1 , <number_literal> ) ; \n \n \t2 for ( int i = 0 ; i < numIndices ; i ++ ) { \n \n \t3 assertAcked ( prepareCreate ( <string_literal> + i ) . setSettings ( Settings . builder ( ) \n \n \t4 . put ( SETTING_NUMBER_OF_SHARDS , 1 ) . put ( SETTING_NUMBER_OF_REPLICAS , 0 ) ) ) ; } \n \n <ect>
\t1 @ Override \n \n \t1 public void beforeTestMethod ( final TestContext testContext ) throws Exception { \n \n \t2 if ( Boolean . TRUE . equals ( testContext . getAttribute ( REINJECT_DEPENDENCIES_ATTRIBUTE ) ) ) { \n \n <ect>
\t1 throws IOException , ExportException { \n \n \t1 context . setConnManager ( this ) ; \n \n \t1 LOG . warn ( <string_literal> ) ; \n \n \t1 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t2 <comment> \n \n \t2 KeyStore store = KeyStore . getInstance ( keystore_type != null ? keystore_type : KeyStore . getDefaultType ( ) ) ; \n \n \t2 if ( key_password == null && store_password != null ) { \n \n \t3 key_password = store_password ; \n \n <ect>
\t1 final HttpSession session = request . getSession ( false ) ; \n \n \t1 final String expectedToken = ( session != null ? ( String ) session . getAttribute ( CSRF_TOKEN_ATTRIBUTE_NAME ) : null ) ; \n \n \t1 final String observedToken = request . getHeader ( ERRAI_CSRF_TOKEN_HEADER ) ; \n \n \t1 if ( expectedToken == null && session != null ) \n \n <ect>
\t4 final Class < AuthenticationResponseHandler > clazz = ( Class < AuthenticationResponseHandler > ) \n \n \t6 Class . forName ( customPolicyClass ) ; \n \n \t4 handlers . add ( clazz . getDeclaredConstructor ( ) . newInstance ( ) ) ; \n \n \t3 } catch ( final Exception e ) { \n \n <ect>
\t4 throw new IllegalArgumentException ( <string_literal> + job . getUuid ( ) + <string_literal> ) ; } \n \n \t3 writeJobResource ( pathOfJob ( job ) , job ) ; \n \n \t3 return job ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 finalIncludeLinkedZones = false ; \n \n \t5 } else { \n \n \t6 finalIncludeLinkedZones = true ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t4 queryService = MetricQueryService . startMetricQueryService ( actorSystem , resourceID ) ; \n \n \t4 metricQueryServicePath = AkkaUtils . getAkkaURL ( actorSystem , queryService ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 public void run ( ) { \n \n \t2 try { \n \n \t2 zooKeeperServer . runFromConfig ( configuration ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( LogFilter ) { \n \n \t4 log . info ( <string_literal> + req . getRequestURI ( ) ) ; \n \n \t4 log . info ( <string_literal> + uri ) ; \n \n <ect>
\t1 { \n \n \t2 int partitionCount = parsePartitionCount ( partitionProperties , clusterName ) ; \n \n \t2 if ( partitionCount < 0 ) \n \n \t2 { \n \n <ect>
\t3 in . close ( ) ; \n \n \t3 if ( connection . getResponseCode ( ) == <number_literal> ) { \n \n \t4 log . info ( <string_literal> + url . toString ( ) + <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
\t1 private < T > Object createInstance ( Class < T > type , MethodInvocation < ? super T > handler , ProxyFactory factory ) { \n \n \t2 try { \n \n \t3 return factory . create ( null , null , new MethodInvocationAdapter < > ( handler ) ) ; \n \n \t2 } catch ( ReflectiveOperationException | IllegalArgumentException e ) { \n \n <ect>
\t4 public void reset ( ) throws IOException { \n \n \t5 wrapped . reset ( ) ; } \n \n \t4 @ Override \n \n \t4 public void close ( ) throws IOException { \n \n <ect>
\t3 if ( broadcastUri != null ) { \n \n \t4 String vlanId = BroadcastDomainType . getValue ( broadcastUri ) ; \n \n \t4 s_logger . debug ( <string_literal> + vlanId + <string_literal> + broadcastUri + <string_literal> ) ; \n \n \t4 return vlanId ; } } \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 value . readFields ( dis ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 initialize ( this . instrumentation , null ) ; \n \n \t6 if ( hasStarted ) { \n \n \t7 startMetrics ( ) ; } \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t4 producer . setDeliveryMode ( DeliveryMode . PERSISTENT ) ; \n \n \t4 String msg = <string_literal> ; \n \n \t4 for ( int i = 0 ; i < count ; i ++ ) { \n \n \t5 producer . send ( session . createTextMessage ( msg + dest . getQueueName ( ) + <string_literal> + i ) ) ; } \n \n <ect>
\t3 <comment> \n \n \t3 String line = sock . readLine ( ) ; \n \n \t3 if ( DELETED . equals ( line ) ) { \n \n <ect>
\t5 _lb2VmMapDao . remove ( loadBalancer . getId ( ) , vmInstanceIds , null ) ; \n \n \t5 s_logger . debug ( <string_literal> + loadBalancer . getId ( ) + <string_literal> + vmInstanceIds ) ; } \n \n \t4 loadBalancer . setState ( backupState ) ; \n \n \t4 _lbDao . persist ( loadBalancer ) ; } \n \n <ect>
\t4 . setHost ( <string_literal> ) \n \n \t4 . setPath ( <string_literal> ) \n \n \t4 . setParameters ( buildParameters ( yqlConfiguration ) ) \n \n \t4 . build ( ) ; \n \n <ect>
\t1 String username = authentication . getName ( ) ; \n \n \t1 Object credentials = authentication . getCredentials ( ) ; \n \n \t1 String password = ( credentials instanceof String ) ? ( String ) credentials : null ; \n \n \t1 if ( StringUtils . isEmpty ( username ) ) { \n \n <ect>
\t3 for ( int i = 0 ; i < split . length ; i ++ ) { \n \n \t4 String substring = split [ i ] ; \n \n \t4 if ( substring . startsWith ( <string_literal> ) ) { \n \n \t5 pattern = substring . substring ( <number_literal> , substring . length ( ) - 1 ) ; \n \n <ect>
\t3 public Message onPreMessageReceived ( Peer peer , Message m ) { \n \n \t4 if ( m instanceof HeadersMessage ) { \n \n \t5 if ( ! ( ( HeadersMessage ) m ) . getBlockHeaders ( ) . isEmpty ( ) ) { \n \n \t6 Block b = Iterables . getLast ( ( ( HeadersMessage ) m ) . getBlockHeaders ( ) ) ; \n \n <ect>
\t2 _poolDao . update ( pool . getId ( ) , pool ) ; } \n \n \t1 @ Override \n \n \t1 public void deletePool ( String poolName ) throws InvalidParameterValueException , ResourceInUseException { \n \n <ect>
\t4 <comment> \n \n \t4 if ( logger == null ) \n \n \t5 throw new IllegalArgumentException ( \n \n \t6 <string_literal> + input ) ; \n \n <ect>
\t2 MetaData metaData = metaDataBuilder . build ( ) ; \n \n \t2 for ( ObjectCursor < IndexMetaData > cursor : metaData . indices ( ) . values ( ) ) { \n \n \t3 routingTableBuilder . addAsNew ( cursor . value ) ; } \n \n \t2 RoutingTable initialRoutingTable = routingTableBuilder . build ( ) ; \n \n <ect>
\t1 private final AtomicLong clientHandleCounter = new AtomicLong ( 0 ) ; \n \n \t1 private final class SubscriptionListenerImpl implements SubscriptionListener { \n \n \t2 @ Override \n \n \t2 public void onSubscriptionTransferFailed ( final UaSubscription subscription , final StatusCode statusCode ) { \n \n <ect>
\t3 } finally { \n \n \t4 AdminServiceRequestHandler . storeLock . unlock ( ) ; } \n \n \t2 } catch ( VoldemortException e ) { \n \n \t3 response . setError ( ProtoUtils . encodeError ( errorCodeMapper , e ) ) ; \n \n <ect>
\t1 public TinkerForgeActionService ( ) { } \n \n \t1 public void activate ( ) { \n \n \t2 logger . debug ( <string_literal> ) ; } \n \n \t1 public void deactivate ( ) { \n \n <ect>
\t2 try { \n \n \t3 RegisteredServiceAccessStrategyUtils . ensureServiceAccessIsAllowed ( service , registeredService ) ; \n \n \t3 return true ; \n \n \t2 } catch ( final UnauthorizedServiceException e ) { \n \n <ect>
\t5 endResult = false ; \n \n \t4 } else { \n \n \t5 results [ i ++ ] = null ; } \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t3 result . sec = ( ThriftSecurityException ) e ; \n \n \t3 result . setSecIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 . build ( ) ; } \n \n \t1 public void testDifferentPorts ( ) throws Exception { \n \n \t2 if ( ! NetworkUtils . SUPPORTS_V6 ) { \n \n \t3 return ; } \n \n <ect>
\t1 <comment> \n \n \t1 for ( String logger : otherLogsCopy ) { \n \n \t1 log . debug ( <string_literal> , getExtent ( ) , logger . toString ( ) ) ; } \n \n \t1 for ( String logger : currentLogsCopy ) { \n \n <ect>
\t7 break ; \n \n \t6 case <number_literal> : \n \n \t7 <comment> \n \n \t7 if ( p_protocol_read . getProperty ( <string_literal> ) . equals ( <string_literal> ) ) { \n \n <ect>
\t3 pstmt . setLong ( <number_literal> , id ) ; \n \n \t3 pstmt . setLong ( <number_literal> , runId ) ; \n \n \t3 int count = pstmt . executeUpdate ( ) ; \n \n \t3 if ( count < 1 ) { \n \n <ect>
\t2 this . storeName = parseStoreName ( requestURI ) ; \n \n \t2 if ( storeName != null ) { \n \n \t3 result = true ; \n \n \t2 } else { \n \n <ect>
\t1 @ GET \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 @ Produces ( <string_literal> ) \n \n \t1 public String matrixParamTwoParamDecoded ( @ MatrixParam ( <string_literal> ) String param , @ MatrixParam ( <string_literal> ) String param2 ) { \n \n <ect>
\t4 serverCnxn . close ( ) ; \n \n \t4 try { \n \n \t5 serverCnxn . toString ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 public static void writeInternalServerError ( final HttpServletResponse response ) { \n \n \t2 try { \n \n \t3 response . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; \n \n \t2 } catch ( IOException ioex ) { \n \n <ect>
\t2 if ( comparator . compare ( value , entry ) > 0 ) { \n \n \t2 return BLOCK_MIGHT_MATCH ; } } \n \n \t1 return BLOCK_CANNOT_MATCH ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t1 boolean logged = false ; \n \n \t1 while ( ! authenticationTokenKeyManager . isInitialized ( ) ) { \n \n \t2 <comment> \n \n \t2 if ( ! logged ) { \n \n <ect>
\t2 profilingListener . collectQueryInfo ( objectGraphNode , loadedBeanCount , executionTimeMicros ) ; } \n \n \t1 queryPlan . executionTime ( loadedBeanCount , executionTimeMicros , objectGraphNode ) ; \n \n \t1 getTransaction ( ) . profileEvent ( this ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 assert _resource == null : <string_literal> ; \n \n \t3 synchronized ( this ) { \n \n \t4 if ( _resource != null ) { \n \n <ect>
<comment> \n \n <ect>
\t4 _log . debug ( <string_literal> + akismetData . getPermalink ( ) ) ; } \n \n \t3 return true ; } \n \n <ect>
\t3 lock . notifyAll ( ) ; } } \n \n \t1 @ Override \n \n \t1 public void revokeLeadership ( ) { \n \n \t2 synchronized ( lock ) { \n \n <ect>
\t2 for ( NetworkElement element : _networkElements ) { \n \n \t3 if ( providersToDestroy . contains ( element . getProvider ( ) ) ) { \n \n \t4 try { \n \n \t5 if ( ! isProviderEnabledInPhysicalNetwork ( getPhysicalNetworkId ( network ) , <string_literal> ) ) { \n \n <ect>
\t1 public boolean isWriteable ( Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType ) { \n \n \t2 logger . info ( <string_literal> + type . getName ( ) ) ; \n \n \t2 if ( ! List . class . isAssignableFrom ( type ) ) { \n \n \t3 return false ; } \n \n <ect>
\t5 <comment> \n \n \t5 is . reset ( ) ; } \n \n \t4 return new CBZip2InputStream ( is ) ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 final TypeHandler handler = typeHandlers . get ( packet . getClass ( ) . getName ( ) ) ; \n \n \t3 if ( handler != null ) { \n \n \t4 handler . handle ( this , packet ) ; \n \n \t3 } else { \n \n <ect>
\t7 log . debug ( <string_literal> + entry ) ; } \n \n \t5 catch ( GridDistributedLockCancelledException e ) { \n \n <ect>
\t5 log . trace ( <string_literal> ) ; \n \n \t5 connection = ( HttpURLConnection ) plainConnection ; } \n \n \t4 else \n \n \t4 { \n \n <ect>
\t3 _alertMgr . sendAlert ( AlertManager . AlertType . ALERT_TYPE_HOST , dcId , podId , <string_literal> + uri . getHost ( ) , <string_literal> + e . getMessage ( ) ) ; \n \n \t3 s_logger . warn ( <string_literal> + uri . getHost ( ) , e ) ; \n \n \t2 } catch ( UnknownHostException e ) { \n \n \t3 _alertMgr . sendAlert ( AlertManager . AlertType . ALERT_TYPE_HOST , dcId , podId , <string_literal> + uri . getHost ( ) , <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t3 case HttpStatus . OK_200 : \n \n \t4 <comment> \n \n \t4 LoginToken token = objectMapper . readValue ( responseContent , LoginToken . class ) ; \n \n \t4 <comment> \n \n <ect>
\t4 return - 1 ; } \n \n \t3 if ( off + len > b . length ) { \n \n \t4 throw new IndexOutOfBoundsException ( <string_literal> ) ; } \n \n <ect>
\t3 int task = message . task ( ) ; \n \n \t3 DisruptorQueue queue = deserializeQueues . get ( task ) ; \n \n \t3 if ( queue == null ) { \n \n \t4 LOG . warn ( <string_literal> , task ) ; \n \n <ect>
<comment> \n \n \t1 protected void processRollback ( Exchange exchange ) { \n \n \t2 Exception cause = exchange . getException ( ) ; \n \n \t2 if ( cause != null ) { \n \n <ect>
\t2 logPath = StringUtils . replace ( logPath , <string_literal> , <string_literal> ) ; \n \n \t2 if ( StringUtils . isNotEmpty ( logPath ) ) { \n \n \t3 ambariUpgradeConfigUpdatesFilePath = logPath + File . separator + writeToAmbariUpgradeConfigUpdatesFile ; } \n \n \t2 } else { \n \n <ect>
\t1 synchronized ( this ) { \n \n \t2 collectIdCaches . computeIfAbsent ( beanType . getName ( ) , s - > new ConcurrentSkipListSet < > ( ) ) . add ( key ) ; } } \n \n \t1 return cacheFactory . createCache ( type , key , tenantProvider , options ) ; } \n \n void clearAll ( ) { \n \n <ect>
\t3 urls . addAll ( HtmlParsingUtils . createURLFromForm ( rootList . item ( x ) , result . getURL ( ) ) ) ; } \n \n \t2 for ( HTTPSamplerBase newUrl : urls ) { \n \n \t3 newUrl . setMethod ( HTTPConstants . POST ) ; \n \n <ect>
\t2 LOG . info ( <string_literal> , batchXorTracker ) ; \n \n \t2 batchXorTracker . clear ( ) ; } \n \n \t1 @ Override \n \n \t1 public void ackCommit ( long batchId , long timeStamp ) { \n \n <ect>
\t3 try { \n \n \t4 if ( outStream != null ) { \n \n \t5 outStream . close ( ) ; } } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t8 log . trace ( <string_literal> , event . getShortName ( ) ) ; \n \n \t8 createJob ( eventContainerOld , event , eventContainerOld . getEventList ( ) . size ( ) - 1 ) ; \n \n \t8 <comment> \n \n \t7 } catch ( SchedulerException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 void compileCore ( String avrBasePath , String buildPath , String corePath , String variant , String variantPath , File systemFolder ) \n \n \t2 throws RunnerException \n \n \t2 { \n \n <ect>
\t3 ResultSetJDBC jdbcResultSet = request . getStore ( ) . getConnection ( ) . execQuery ( sqlStmtStr , fetchSize ) ; \n \n \t3 try { \n \n \t4 <comment> \n \n \t4 if ( opSQL . getBridge ( ) == null ) \n \n <ect>
\t4 crc += b ; } \n \n \t3 crc = ( ( ~crc ) + 1 ) & 0xFF ; \n \n \t3 setByte ( <string_literal> , ( byte ) ( crc & 0xFF ) ) ; \n \n \t2 } catch ( FieldException e ) { \n \n <ect>
@ GET \n \n @ Path ( <string_literal> ) \n \n @ Produces ( MediaType . APPLICATION_JSON ) \n \n public Response getScript ( @ PathParam ( <string_literal> ) String scriptId ) { \n \n <ect>
\t3 s_logger . error ( <string_literal> + username ) ; \n \n \t3 return - 1 ; \n \n \t2 } else { \n \n \t3 s_logger . info ( <string_literal> + s_secretKey . get ( ) ) ; \n \n <ect>
\t4 } , 1 , REPOSITORY_INFO_KEY ) ; \n \n \t4 if ( this . upgradingRepository ) { \n \n \t5 LOGGER . debug ( <string_literal> , name ) ; \n \n \t4 } else { \n \n <ect>
\t4 processSwitchBinaryReport ( serialMessage , offset , endpoint ) ; \n \n \t4 dynamicDone = true ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t3 client ( ) . prepareUpdate ( indexOrAlias ( ) , <string_literal> , <string_literal> ) . setDoc ( Requests . INDEX_CONTENT_TYPE , <string_literal> , <string_literal> ) . get ( ) ; \n \n \t3 fail ( ) ; \n \n \t2 } catch ( RoutingMissingException e ) { \n \n \t3 assertThat ( e . getMessage ( ) , equalTo ( <string_literal> ) ) ; } \n \n <ect>
\t3 osBuilder . version ( ComputeServiceUtils . parseVersionOrReturnEmptyString ( family , matcher . group ( <number_literal> ) , \n \n \t5 osVersionMap ) ) ; \n \n \t3 builder . version ( matcher . group ( <number_literal> ) . replace ( <string_literal> , <string_literal> ) ) ; } \n \n \t1 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t2 for ( final Pair < Integer , Listener > listener : _cmdMonitors ) { \n \n \t3 answer = listener . second ( ) . processControlCommand ( attache . getId ( ) , cmd ) ; \n \n \t3 if ( answer != null ) { \n \n \t4 return answer ; } } \n \n <ect>
\t1 public static SPARQLResult result ( String filenameOrURI , ResultsFormat format ) { \n \n \t2 if ( format == null ) \n \n \t3 format = ResultsFormat . guessSyntax ( filenameOrURI ) ; \n \n \t2 if ( format == null ) { \n \n <ect>
\t4 log . error ( <string_literal> , e ) ; \n \n \t4 error ( e . getMessage ( ) , Protos . Error . ErrorCode . BAD_TRANSACTION , CloseReason . REMOTE_SENT_INVALID_MESSAGE ) ; \n \n \t4 return ; \n \n \t3 } catch ( ValueOutOfRangeException e ) { \n \n <ect>
\t2 log . debug ( <string_literal> + requestedPeople . size ( ) + <string_literal> ) ; \n \n \t2 for ( Person currentPerson : requestedPeople ) \n \n \t2 { \n \n \t3 people . put ( currentPerson . getOpenSocialId ( ) , currentPerson ) ; \n \n <ect>
\t9 default : \n \n \t10 break ; } \n \n \t7 } ) ; } \n \n \t6 final float p = info . getCount ( ) / ( float ) info . getLength ( ) ; \n \n <ect>
\t3 sum = sum . add ( bigSize ) ; \n \n \t3 numberOfShards ++ ; \n \n \t3 if ( numberOfShards % <number_literal> == 0 ) { \n \n \t4 GenomeLoc boundingRegion = getBoundingRegion ( filePointer , genomeLocParser ) ; \n \n <ect>
\t5 results = response . getResults ( ) ; \n \n \t5 query . set ( CursorMarkParams . CURSOR_MARK_PARAM , response . getNextCursorMark ( ) ) ; } \n \n \t3 } catch ( Exception e ) { \n \n \t4 results = Collections . emptyList ( ) ; \n \n <ect>
\t5 s_logger . error ( <string_literal> + vm ) ; \n \n \t5 try { \n \n \t6 _agentMgr . send ( srcHostId , new Commands ( cleanup ( vm . getInstanceName ( ) ) ) , null ) ; \n \n \t5 } catch ( AgentUnavailableException e ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected void doStart ( ) throws Exception { \n \n \t2 super . doStart ( ) ; \n \n \t2 this . targetAddress = GenericAddress . parse ( this . endpoint . getAddress ( ) ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 @ Override \n \n \t4 public void onResponse ( MQTTProtocolConverter converter , Response response ) throws IOException { \n \n \t5 if ( response . isException ( ) ) { \n \n \t6 Throwable error = ( ( ExceptionResponse ) response ) . getException ( ) ; \n \n <ect>
\t5 . getAddressOfRecord ( ) . getURI ( ) . toString ( ) ) ; \n \n \t2 if ( wlist == null || \n \n \t3 ! wlist . getAttribute ( PACKAGE_ATTRIBUTE ) . equals ( PRESENCE_ELEMENT ) ) \n \n \t2 { \n \n <ect>
\t3 throw new CoordinatorJobException ( ErrorCode . E1002 , appPath , ex . getMessage ( ) , ex ) ; } \n \n \t2 catch ( HadoopAccessorException ex ) { \n \n \t3 throw new CoordinatorJobException ( ex ) ; } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> + rbdDestPath + <string_literal> + rbdInfo . size + <string_literal> ) ; \n \n \t4 rbd . close ( image ) ; \n \n \t4 r . ioCtxDestroy ( io ) ; \n \n \t3 } catch ( QemuImgException e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + faultXMLFile ) ; \n \n \t3 <comment> \n \n \t3 int faultId = parseIdFromFileName ( faultXMLFile . getName ( ) ) ; \n \n \t3 if ( suppressedFaults . contains ( faultId ) && faultXMLFile . length ( ) != 0 ) { \n \n <ect>
\t5 ) ) ; \n \n \t3 Assert . fail ( <string_literal> ) ; \n \n \t2 } catch ( KeeperException e ) { \n \n \t3 <comment> \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 private final Object finalizerGuardian = new Object ( ) { \n \n \t2 protected void finalize ( ) throws Throwable { \n \n \t3 if ( ! executor . isShutdown ( ) ) { \n \n <ect>
\t5 _workTracker . handleException ( agentId ) ; } } \n \n \t2 } else { \n \n \t4 if ( vm != null ) \n \n <ect>
\t3 final Class relClass = StructrApp . getConfiguration ( ) . getRelationClassForCombinedType ( sourceNode . getType ( ) , relType , targetNode . getType ( ) ) ; \n \n \t3 if ( relClass != null ) { \n \n \t4 return StructrApp . getInstance ( sourceNode . getSecurityContext ( ) ) . create ( sourceNode , targetNode , relClass ) ; \n \n \t3 } else { \n \n <ect>
\t7 <comment> \n \n \t7 resFut . onDone ( ) ; } } \n \n \t5 catch ( GridException e1 ) { \n \n <ect>
\t1 } else { \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 readModel = new TopicModel ( numTopics , numTerms , eta , alpha , RandomUtils . getRandom ( seed ) , null , \n \n \t2 numTrainThreads , modelWeight ) ; } \n \n <ect>
\t1 @ Override \n \n \t1 public AccessTokenRequestDataHolder extract ( final HttpServletRequest request , final HttpServletResponse response ) { \n \n \t2 final String grantType = request . getParameter ( OAuth20Constants . GRANT_TYPE ) ; \n \n \t2 final Set < String > scopes = OAuth20Utils . parseRequestScopes ( request ) ; \n \n <ect>
\t1 public SessionConfig getClientSessionConfig ( Destination dest ) { \n \n \t2 if ( _manager != null ) \n \n \t3 return _manager . getClientSessionConfig ( dest ) ; \n \n \t2 else { \n \n <ect>
\t3 throws TransportException { \n \n \t2 switch ( expected ) { \n \n \t3 case KEXINIT : \n \n \t4 ensureReceivedMatchesExpected ( msg , Message . KEXINIT ) ; \n \n <ect>
\t2 HttpSelfHostServer server ; \n \n \t2 private static ILog logger = LogManager . GetLogger ( typeof ( AgentService ) ) ; \n \n \t2 public AgentService ( ) \n \n \t2 { \n \n <ect>
\t3 } finally { \n \n \t4 origTag . senderTransferEnds ( ( NodeCHK ) key , this ) ; } \n \n \t2 } else { \n \n \t3 <comment> \n \n <ect>
\t2 Assert . assertEquals ( portClient1 , s1 . getClientPort ( ) ) ; \n \n \t2 LOG . info ( <string_literal> + portClient2 ) ; \n \n \t2 s2 = new QuorumPeer ( peers , s2dir , s2dir , portClient2 , <number_literal> , <number_literal> , tickTime , initLimit , syncLimit ) ; \n \n \t2 Assert . assertEquals ( portClient2 , s2 . getClientPort ( ) ) ; \n \n <ect>
\t4 uniqueConsumerCount += consumerEventHandlers . keySet ( ) . size ( ) ; \n \n \t4 for ( Collection < LifecycleAwareExchangeEventHandler > lifecycleAwareExchangeEventHandlers : consumerEventHandlers \n \n \t6 . values ( ) ) { \n \n \t5 eventHandlers . addAll ( lifecycleAwareExchangeEventHandlers ) ; } } } \n \n <ect>
\t4 FritzahaWebInterface deviceHost = host . getConnection ( ) ; \n \n \t4 boolean valueToSet = ( command == OnOffType . ON ) ; \n \n \t4 switchDevice . setSwitchState ( valueToSet , itemName , deviceHost ) ; } \n \n \t2 } else { \n \n <ect>
\t4 newVol . setPath ( destVolume . getPath ( ) + File . separator + destVolumeUUID + <string_literal> ) ; \n \n \t4 newVol . setSize ( srcVolume . getSize ( ) ) ; \n \n \t4 return new CopyCmdAnswer ( newVol ) ; \n \n \t3 } catch ( final Exception e ) { \n \n <ect>
\t1 } else if ( totalFalsePositives > totalAllowed ) { \n \n \t1 log . warning ( String . format ( <string_literal> , totalFalsePositives - totalAllowed ) ) ; } \n \n \t1 for ( int x = 0 ; x < testResults . size ( ) ; x ++ ) { \n \n \t1 TestResult testResult = testResults . get ( x ) ; \n \n <ect>
\t3 final Resource resource = ResourceUtils . getResourceFrom ( this . groovyScript ) ; \n \n \t3 return ScriptingUtils . executeGroovyScript ( resource , args , Map . class ) ; \n \n \t2 } catch ( final Exception e ) { \n \n \t3 LOGGER . error ( e . getMessage ( ) , e ) ; } \n \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \n \t2 Connection connection = source . getConnectionForWriting ( ) ; \n \n \t2 if ( connection == null ) { \n \n \t3 throw new IOException ( <string_literal> ) ; } \n \n <ect>
\t2 } catch ( IOException ioe ) { \n \n \t3 _log . error ( <string_literal> , ioe ) ; \n \n \t3 return null ; \n \n \t2 } catch ( I2PSessionException ise ) { \n \n <ect>
\t5 task . execReplicate ( replicate . getRebalanceSource ( ) , replicate . getRebalanceTarget ( ) , true , true , replicate . wasQueued ( ) ) ; \n \n \t4 } catch ( Exception e ) { \n \n \t5 log . warn ( <string_literal> + task . getJobKey ( ) + <string_literal> + e , e ) ; } \n \n \t3 } else { \n \n <ect>
public void setMovie ( er . distribution . example . client . eo . Movie value ) { \n \n \t1 takeStoredValueForKey ( value , _PlotSummary . MOVIE_KEY ) ; } \n \n public void setMovieRelationship ( er . distribution . example . client . eo . Movie value ) { \n \n <ect>
\t1 Document doc = target . getDocument ( ) ; \n \n \t1 Caret caret = target . getCaret ( ) ; \n \n \t1 int offset = SearchHelper . findNextWord ( target . getText ( ) , caret . getDot ( ) , target . getText ( ) . length ( ) , \n \n <number_literal> - 1 , false , false ) ; \n \n <ect>
\t1 @ Override \n \n \t1 @ GET \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 public Response testGenerics ( ) { \n \n <ect>
\t1 try { \n \n \t2 LOG . debug ( <string_literal> , bucketPath ) ; \n \n \t2 ( ( DistributedFileSystem ) fileSystem ) . recoverLease ( new Path ( bucketPath ) ) ; \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t3 { \n \n \t4 log . error ( <string_literal> , e ) ; \n \n \t3 } catch ( InstantiationException e ) \n \n \t3 { \n \n <ect>
\t2 this . metadataResolver . setId ( ChainingMetadataResolver . class . getCanonicalName ( ) ) ; \n \n \t2 this . metadataResolver . setResolvers ( resolvers ) ; \n \n \t2 LOGGER . info ( <string_literal> , resolvers . size ( ) ) ; \n \n \t2 this . metadataResolver . initialize ( ) ; \n \n <ect>
\t2 Object responseBody = template . requestBody ( <string_literal> , requestBody ) ; \n \n \t2 assertNull ( responseBody ) ; } \n \n \t1 @ Test \n \n \t1 public void testOneWayMethodInvocation ( ) throws Exception { \n \n <ect>
\t7 return ; } \n \n \t6 break ; <comment> \n \n \t5 catch ( GridCacheEntryRemovedException ignore ) { \n \n <ect>
\t3 authn . getAttributes ( ) . keySet ( ) . stream ( ) . forEach ( attrName - > { \n \n \t4 if ( authenticationAttributes . containsKey ( attrName ) ) { \n \n \t5 LOGGER . debug ( <string_literal> , attrName ) ; \n \n \t5 final Object oldValue = authenticationAttributes . remove ( attrName ) ; \n \n <ect>
\t2 val variantDataName = getVariantName ( variantData ) \n \n \t2 logger . kotlinDebug ( <string_literal> ) \n \n \t2 val javaTask = getJavaTask ( variantData ) \n \n \t2 if ( javaTask == null ) { \n \n <ect>
private void removeFloatingIpFromNodeifAny ( RegionAndId regionAndId ) { \n \n \t1 try { \n \n \t2 removeFloatingIpFromNodeAndDeallocate . apply ( regionAndId ) ; \n \n \t1 } catch ( RuntimeException e ) { \n \n <ect>
\t2 if ( formObject == null ) { \n \n \t3 formObject = initFormObject ( context ) ; \n \n \t2 } else { \n \n <ect>
\t4 if ( image != null ) { \n \n \t5 Rectangle r = new Rectangle ( resizeToWidth , resizeToHeight ) ; \n \n \t5 image = ImageHelper . getResizedImage ( image , r ) ; } } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 try { \n \n \t5 Document doc = docBuilder . parse ( instream ) ; \n \n \t5 status = processResponse ( doc , item , resultSb ) ; \n \n \t4 } catch ( SAXException saxE ) { \n \n <ect>
\t2 assertTrue ( <string_literal> , value instanceof List ) ; \n \n \t2 List list = ( List ) value ; \n \n \t2 LOG . debug ( <string_literal> + list ) ; \n \n \t2 assertEquals ( <string_literal> , <number_literal> , list . size ( ) ) ; \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( hostName . length ( ) > <number_literal> || hostName . length ( ) < 1 ) { \n \n <ect>
\t3 int code = HttpServletResponse . SC_BAD_REQUEST ; \n \n \t3 response . setStatus ( code ) ; \n \n \t3 response . getWriter ( ) . append ( RestMethodResult . jsonError ( code , <string_literal> + jpex . getMessage ( ) ) ) ; \n \n \t2 } catch ( UnsupportedOperationException uoe ) { \n \n <ect>
\t4 contextPath = contextPath . substring ( contextPath . lastIndexOf ( <string_literal> ) ) ; } \n \n \t3 catch ( Exception e ) { \n \n \t4 log . error ( <string_literal> , e ) ; } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t1 try { \n \n \t2 CredentialProviderFactoryShim . createEntry ( conf , entry . getKey ( ) , \n \n \t3 entry . getValue ( ) . toCharArray ( ) ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t3 log . error ( <string_literal> , cnfe ) ; } \n \n \t2 catch ( SecurityException se ) { \n \n \t3 log . info ( <string_literal> , se ) ; } \n \n \t2 catch ( IllegalAccessException iae ) { \n \n <ect>
\t3 try { \n \n \t4 if ( engines . containsKey ( address ) ) { \n \n \t5 engines . get ( address ) . runTest ( ) ; \n \n \t4 } else { \n \n <ect>
\t6 logger . debug ( <string_literal> + bindingConfig . getPinNumber ( ) + <string_literal> + onOffValueForPin ) ; \n \n \t6 updateItemStates ( bindingConfig , onOffValueForPin ) ; } \n \n \t5 bindingConfigsToInitialise . remove ( bindingConfig ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 { \n \n \t3 logger . warn ( <string_literal> , e ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
@ Override \n \n protected void serviceStop ( ) throws Exception { \n \n \t1 if ( deletionThread != null ) { \n \n \t1 deletionThread . interrupt ( ) ; \n \n <ect>
\t3 SoapUI . logError ( e ) ; \n \n \t3 throw new SchemaException ( e , errorList ) ; \n \n \t2 } finally { \n \n \t3 for ( int c = 0 ; c < errorList . size ( ) ; c ++ ) { \n \n <ect>
\t2 Destination destination = session . createQueue ( name . getMethodName ( ) ) ; \n \n \t2 MessageConsumer consumer = session . createConsumer ( destination ) ; \n \n \t2 ActiveMQObjectMessage msg = ( ActiveMQObjectMessage ) consumer . receive ( ) ; \n \n \t2 AMQ5921MessagePayload payload = ( AMQ5921MessagePayload ) msg . getObject ( ) ; \n \n <ect>
\t2 try { \n \n \t2 cluster . getService ( serviceName ) ; \n \n \t2 hasService = true ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 LOGGER . error ( <string_literal> + \n \n \t3 <string_literal> , e ) ; \n \n \t2 } catch ( Throwable t ) { \n \n \t2 <comment> \n \n <ect>
<comment> \n \n \t1 private fun setOptionsForDefaultJunitRunConfiguration ( project : Project ) { \n \n \t2 val workspaceFile = File ( projectDir , <string_literal> ) \n \n \t2 if ( ! workspaceFile . exists ( ) ) { \n \n <ect>
\t3 log . error ( <string_literal> ) \n \n \t3 return null } \n \n \t2 val strings = classHeader . strings \n \n \t2 if ( strings == null ) { \n \n <ect>
<comment> \n \n \t1 public void rebuildRouterInfo ( boolean blockingRebuild ) { \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t3 kmfPassword = this . parsePropertyValue ( this . getKeyPassword ( ) ) . toCharArray ( ) ; } \n \n \t2 KeyStore ks = this . getKeyStore ( ) == null ? null : this . getKeyStore ( ) . createKeyStore ( ) ; \n \n \t2 kmf . init ( ks , kmfPassword ) ; \n \n \t2 keyManagers = kmf . getKeyManagers ( ) ; \n \n <ect>
\t1 if ( e instanceof AmbariException ) { \n \n \t2 LOG . error ( <string_literal> , e ) ; \n \n \t2 throw ( AmbariException ) e ; \n \n \t1 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t6 if ( _service == null ) { \n \n \t7 _service = current2 . getService ( WAN_PPP_CONNECTION ) ; \n \n \t7 if ( _service == null ) { \n \n \t8 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t3 if ( subject . hasUsername ( username ) ) \n \n \t3 { \n \n \t4 throw new InvalidArgumentsException ( <string_literal> + username + <string_literal> ) ; } \n \n \t3 userManager . activateUser ( username , requirePasswordChange ) ; \n \n <ect>
\t3 daemonRegistry . markState ( connectorAddress , Idle ) ; \n \n \t2 } catch ( DaemonRegistry . EmptyRegistryException e ) { \n \n \t3 LOGGER . warn ( <string_literal> ) ; } } \n \n \t1 public void onCancel ( ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> ) ; \n \n \t4 return new CheckOnHostAnswer ( cmd , true , <string_literal> ) ; } \n \n \t3 return new CheckOnHostAnswer ( cmd , null , <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 try { \n \n \t6 if ( grid ( ) . cache ( null ) . dataStructures ( ) . removeQueue ( queueName , 0 ) ) { \n \n \t7 rmvNum . incrementAndGet ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 semanticModel . writeGraphviz ( contextParameters . getParameterValue ( ContextParameter . GRAPHVIZ_MODELS_DIR ) + \n \n \t5 semanticModel . getName ( ) + \n \n \t5 <string_literal> , false , false ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 LOG . info ( <string_literal> + res . getRootPath ( ) ) ; } \n \n \t3 } catch ( Exception e ) { \n \n \t4 LOG . error ( <string_literal> + res . getRootPath ( ) + <string_literal> + e . getLocalizedMessage ( ) , e ) ; } } \n \n \t2 long end = System . currentTimeMillis ( ) ; \n \n <ect>
\t2 Set < String > envSet = new HashSet < String > ( ) ; \n \n \t2 for ( Map . Entry < String , String > entry : envs . entrySet ( ) ) { \n \n \t3 if ( ! entry . getKey ( ) . equals ( <string_literal> ) ) { \n \n \t4 envSet . add ( entry . getKey ( ) + <string_literal> + entry . getValue ( ) ) ; } } \n \n <ect>
<comment> \n \n \t1 public static Authenticator newLdaptiveAuthenticator ( final AbstractLdapAuthenticationProperties l ) { \n \n \t2 switch ( l . getType ( ) ) { \n \n \t3 case AD : \n \n <ect>
\t5 break ; } \n \n \t4 val = ( ++ val ) % maxVncPorts ; \n \n \t3 } while ( val != startVal ) ; \n \n \t3 if ( vncPort == 0 ) { \n \n <ect>
\t2 ) . build ( ) ; \n \n \t2 clusterState = strategy . reroute ( clusterState , <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 logger . info ( <string_literal> , clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) ) ; \n \n <ect>
\t5 String mstr = moduleName . toString ( ) ; \n \n \t5 if ( ! mstr . equals ( storedName ) ) \n \n \t6 p . setPersistentProperty ( PROJECT_PROPERTY_MODULENAME , mstr . toString ( ) ) ; } } \n \n \t3 catch ( CoreException e1 ) { \n \n <ect>
\t3 pstmt . executeUpdate ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
<comment> \n \n public void shutdown ( ) { \n \n \t1 synchronized ( this ) { \n \n \t1 if ( service . isShutdown ( ) ) { \n \n <ect>
\t2 authenticationRedirectStrategy . redirect ( request , response , logoutUrl ) ; } \n \n \t1 private void handleInitialAuthenticationRequest ( final WSFederationRequest fedRequest , \n \n <number_literal> final HttpServletResponse response , final HttpServletRequest request ) { \n \n \t2 final WSFederationRegisteredService service = findAndValidateFederationRequestForRegisteredService ( response , request , fedRequest ) ; \n \n <ect>
\t5 sb . append ( String . format ( <string_literal> , portId . getName ( ) ) ) ; } \n \n \t4 logger . error ( <string_literal> , sb . toString ( ) . trim ( ) ) ; \n \n \t3 } else { \n \n \t4 logger . error ( <string_literal> ) ; } \n \n <ect>
\t5 { \n \n \t6 public void processResult ( CuratorFramework client , CuratorEvent event ) \n \n \t7 throws Exception \n \n \t6 { \n \n <ect>
\t3 GraphVizLabelType linkLabelType , \n \n \t3 boolean showNodeMetaData , \n \n \t3 boolean showLinkMetaData , \n \n \t3 String filename ) throws IOException { \n \n <ect>
\t5 { \n \n \t6 throw new IllegalStateException ( e ) ; } } } \n \n \t3 catch ( final RegistrationException e ) \n \n \t3 { \n \n <ect>
\t3 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t3 while ( rs . next ( ) ) { \n \n \t4 result . add ( toEntityBean ( rs , false ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 node . queueRandomReinsert ( block ) ; \n \n \t3 finish ( SUCCESS , next , true ) ; \n \n \t3 return true ; \n \n \t2 } catch ( SSKVerifyException e ) { \n \n <ect>
\t5 continue ; } \n \n \t3 } catch ( ConflictingInsertionException e ) { \n \n \t4 lastException = e ; \n \n \t4 if ( retries < MAX_RETRIES ) { \n \n <ect>
\t2 assertEquals ( <string_literal> , <string_literal> , container . getName ( ) ) ; \n \n \t2 assertEquals ( <string_literal> , <string_literal> , container . getImage ( ) ) ; \n \n \t2 LOG . info ( <string_literal> + container ) ; \n \n \t2 String json = toJson ( podList ) ; \n \n <ect>
\t2 BrokerService broker = brokers . get ( pid ) ; \n \n \t2 if ( broker == null ) { \n \n \t3 return ; } \n \n \t2 try { \n \n <ect>
\t3 return emptyOptional ( ) ; } \n \n \t2 try { \n \n \t3 return optional ( new GZIPInputStream ( new ByteArrayInputStream ( byteBuffer ) ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 } catch ( BinaryStoreException e ) { \n \n \t5 logger . error ( e , JcrI18n . errorMarkingBinaryValuesUsed , e . getMessage ( ) ) ; } } \n \n \t3 if ( ! unusedBinaries . isEmpty ( ) ) { \n \n <ect>
\t2 if ( ERXStringUtilities . stringIsNullOrEmpty ( message ) ) \n \n \t2 { \n \n \t3 String mailTemplate = ( String ) localizer ( ) . valueForKey ( <string_literal> ) ; \n \n <ect>
\t5 } catch ( Throwable e ) { \n \n \t6 NginxClojureRT . log . warn ( <string_literal> , clz , e ) ; } } \n \n \t4 appResources = clzList . toArray ( new Class [ clzList . size ( ) ] ) ; } \n \n \t3 if ( appResources == null || appResources . length == 0 ) { \n \n <ect>
\t4 updateTxns ( conn1 ) ; \n \n \t4 updateLocks ( conn1 ) ; \n \n \t4 Thread . sleep ( <number_literal> ) ; \n \n \t4 conn1 . commit ( ) ; \n \n <ect>
\t2 { \n \n \t3 objType = ( ( Long ) props [ PR_OBJECT_TYPE ] ) . longValue ( ) ; } \n \n \t2 else \n \n \t2 { \n \n <ect>
\t1 if ( tServer != null ) { \n \n \t1 tServer . stop ( ) ; } \n \n \t1 if ( hiveServer != null ) { \n \n \t1 hiveServer . stop ( ) ; } \n \n <ect>
\t2 { \n \n \t3 return getfd ( ( FileDescriptor ) FILE_CHANNEL_FD_FIELD . get ( channel ) ) ; } \n \n \t2 catch ( IllegalArgumentException | IllegalAccessException e ) \n \n \t2 { \n \n <ect>
\t2 try { \n \n \t3 final Addresses addresses = Addresses . getInstance ( ) ; \n \n \t3 addresses . release ( addresses . lookupActiveAddress ( networkResource . value ) , null ) \n \n \t2 } catch ( NoSuchElementException e ) { \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 onApplyError ( <string_literal> + kind + <string_literal> + sourceName + <string_literal> + e + <string_literal> + resource , e ) ; } } } \n \n \t2 } else { \n \n \t3 if ( ! isAllowCreate ( ) ) { \n \n <ect>
\t2 currLlapQueueState = 'STOPPED' \n \n \t2 if 'yarn . scheduler . capacity . root . ' + llap_queue_name + ' . state' in capacity_scheduler_properties . keys ( ) : \n \n \t2 currLlapQueueState = capacity_scheduler_properties . get ( 'yarn . scheduler . capacity . root . ' + llap_queue_name + ' . state' ) \n \n \t2 else : \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 URL resource = Thread . currentThread ( ) . getContextClassLoader ( ) . getResource ( <string_literal> ) ; \n \n \t3 Preconditions . checkNotNull ( resource ) ; \n \n <ect>
\t4 if ( l . size ( ) >= idx + 1 ) { \n \n \t5 v . add ( l . get ( idx ) ) ; \n \n \t5 index . put ( ii , idx ) ; \n \n <ect>
\t4 s_logger . info ( <string_literal> + setting + <string_literal> + networkType ) ; \n \n \t3 } else if ( ! isMyTrafficType ( offering . getTrafficType ( ) ) ) { \n \n \t4 s_logger . info ( <string_literal> + setting + <string_literal> ) ; \n \n \t3 } else if ( offering . getGuestType ( ) != Network . GuestType . Isolated ) { \n \n <ect>
\t3 result . setSuccessIsSet ( true ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t1 trySchedulingPendingTasks ( ) ; } \n \n private void reenableDisabledNode ( NodeInfo nodeInfo ) { \n \n \t1 writeLock . lock ( ) ; \n \n \t1 try { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
@ GET @ ApiIgnore <comment> \n \n @ Produces ( <string_literal> ) \n \n @ Path ( <string_literal> ) \n \n public String getKey ( @ PathParam ( <string_literal> ) String keyName ) { \n \n <ect>
\t3 harmonyClient . connect ( host , new LoginToken ( accountId , sessionId ) ) ; \n \n \t3 hubs . put ( qualifier , new HarmonyHubInstance ( harmonyClient ) ) ; \n \n \t3 logger . debug ( <string_literal> , qualifier , harmonyClient . getDeviceLabels ( ) . toString ( ) ) ; \n \n \t3 logger . debug ( <string_literal> , qualifier , harmonyClient . getConfig ( ) . getActivities ( ) ) ; \n \n <ect>
\t6 IdentityProxy id = idList . get ( i ) ; \n \n \t6 ex . addProxyObject ( id . getTableName ( ) , id . getValue ( ) , id . getidFieldName ( ) ) ; \n \n \t6 s_logger . warn ( <string_literal> + t . getMessage ( ) + <string_literal> + id . getValue ( ) ) ; } \n \n \t4 } else { \n \n <ect>
\t4 <string_literal> + e . getMessage ( ) + \n \n \t4 ( Platform . isWindows ( ) ? <string_literal> : <string_literal> ) \n \n \t3 ) ; \n \n \t2 } catch ( FileNotFoundException e ) { \n \n <ect>
\t4 logger . warn ( <string_literal> + invocation , ex ) ; } \n \n \t3 throw ex ; } \n \n \t2 catch ( InvocationTargetException ex ) { \n \n <ect>
\t3 <comment> \n \n \t3 pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t3 rs = pstmt . executeQuery ( ) ; \n \n \t3 if ( ! rs . next ( ) ) { \n \n <ect>
\t4 this . messageStoreNotFull . signal ( ) ; } \n \n \t3 finally { \n \n \t4 storeLock . unlock ( ) ; } } \n \n \t2 catch ( InterruptedException e ) { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t5 result = _bareMetalVmService . startVirtualMachine ( this ) ; \n \n \t4 } else { \n \n \t5 result = _userVmService . startVirtualMachine ( this ) ; } \n \n \t3 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t2 if ( type == 0 ) { \n \n \t3 tokenData = list . get ( 0 ) ; \n \n \t2 } else { \n \n \t3 if ( type > list . size ( ) ) { \n \n <ect>
\t6 pstmt . executeUpdate ( ) ; } } } \n \n \t3 pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t3 pstmt . executeUpdate ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t5 } else { \n \n \t6 status = cursor . getNext ( dk , dv , lockMode ) ; } \n \n \t5 if ( status == opSuccess ) { \n \n \t6 next = current ( ) ; \n \n <ect>
\t9 ( ( ValidationAware ) action ) . addActionMessage ( developerNotification ) ; } } } } } \n \n \t4 if ( clearableStack && ( stack . getContext ( ) != null ) && ( newStack . getContext ( ) != null ) ) \n \n \t5 stack . getContext ( ) . put ( ActionContext . CONVERSION_ERRORS , newStack . getContext ( ) . get ( ActionContext . CONVERSION_ERRORS ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 TestData testData = new TestData ( ) ; \n \n \t2 testData . prepare ( ) ; \n \n \t2 Session session = openSession ( ) ; \n \n \t2 session . enableFilter ( <string_literal> ) . setParameter ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t6 LOGGER . trace ( <string_literal> + resource . getSystemName ( ) ) ; \n \n \t6 try { \n \n \t7 FileWatcher . add ( new FileWatcher . Watch ( resource . getSystemName ( ) + File . separator + <string_literal> , LIBRARY_RESCANNER ) ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t2 ps . genSubstitutedFile ( pigIStream , pigOStream , arg , argFiles ) ; \n \n \t2 FileInputStream pigResultStream = new FileInputStream ( basedir + <string_literal> ) ; \n \n \t2 pigExResultStream = new FileInputStream ( basedir + <string_literal> ) ; \n \n \t2 compareResults ( pigExResultStream , pigResultStream ) ; \n \n <ect>
\t1 protected Set < Event > resolveMultifactorEventViaRestResult ( final String results , final Collection < MultifactorAuthenticationProvider > providers ) { \n \n \t2 LOGGER . debug ( <string_literal> , results ) ; \n \n \t2 final MultifactorAuthenticationProvider restProvider = providers . stream ( ) . filter ( p - > p . matches ( results ) ) . findFirst ( ) . orElse ( null ) ; \n \n \t2 if ( restProvider != null ) { \n \n <ect>
\t4 @ Override \n \n \t4 public void uncaughtException ( Thread t , Throwable e ) { \n \n \t5 if ( ! ( e . getCause ( ) instanceof SocketException && e . getStackTrace ( ) [ 0 ] . getClassName ( ) \n \n \t7 . equals ( <string_literal> ) ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 public boolean apply ( final String userAgent , final GeoLocationRequest location ) { \n \n \t2 final ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; \n \n \t2 if ( clientInfo == null || StringUtils . isBlank ( userAgent ) ) { \n \n <ect>
\t4 if ( tmpExtensions != null ) { \n \n \t5 for ( Extension ext : tmpExtensions ) { \n \n \t6 if ( ! extensions . contains ( ext ) ) { \n \n \t7 extensions . add ( ext ) ; } } } } } \n \n <ect>
\t5 keyspace . getSerializerPackage ( CF_USERS . getName ( ) , false ) ) \n \n \t5 . setRowsAsArray ( true ) \n \n \t5 . setFixedColumnNames ( <string_literal> , <string_literal> ) \n \n \t5 . setIgnoreUndefinedColumns ( true ) . write ( rows ) ; \n \n <ect>
\t2 final AtomicReference < ServerSocket > serverSocket = new AtomicReference < > ( ) ; \n \n \t2 this . executor . execute ( ( ) - > { \n \n \t3 try { \n \n \t4 ServerSocket server = ServerSocketFactory . getDefault ( ) . createServerSocket ( 0 ) ; \n \n <ect>
\t4 _lunDao . remove ( lun . getId ( ) ) ; \n \n \t4 txn . commit ( ) ; \n \n \t3 } else { \n \n \t4 txn . rollback ( ) ; \n \n <ect>
\t1 private DatagramSocket getSocket ( ) { \n \n \t2 DatagramSocket socket = null ; \n \n \t2 int port = _listenPort ; \n \n \t2 if ( port > 0 && ! TransportUtil . isValidPort ( port ) ) { \n \n <ect>
\t3 if ( m . outputType ( ) == oneOutputType || m . outputType ( ) == MaryDataType . AUDIO ) { \n \n \t4 currentData . setOutputParams ( outputParams ) ; } \n \n \t3 if ( logger . getEffectiveLevel ( ) . equals ( Level . DEBUG ) \n \n \t5 && ( currentData . getType ( ) . isTextType ( ) || currentData . getType ( ) . isXMLType ( ) ) ) { \n \n <ect>
\t1 String path = qualifyPath ( key ) ; \n \n \t1 if ( ! zk . exists ( path ) ) { \n \n \t1 log . warn ( <string_literal> , key . getKeyId ( ) ) ; \n \n \t1 return ; } \n \n <ect>
\t6 <comment> \n \n \t6 if ( ngVO . getId ( ) != securityGroup . getId ( ) ) { \n \n \t7 final SecurityGroupVO tmpGrp = _securityGroupDao . lockRow ( ngId , false ) ; \n \n \t7 if ( tmpGrp == null ) { \n \n <ect>
\t5 log . debug ( <string_literal> + w + ' ] ' ) ; \n \n \t3 if ( remaining . isEmpty ( ) ) { \n \n <ect>
\t1 { \n \n \t2 _reader . onDone ( ) ; } \n \n \t1 catch ( Throwable ex ) \n \n \t1 { \n \n <ect>
\t5 thread . setContextClassLoader ( threadClassLoader ) ; } \n \n \t4 thread . setUncaughtExceptionHandler ( new Thread . UncaughtExceptionHandler ( ) { \n \n \t5 @ Override \n \n \t5 public void uncaughtException ( final Thread t , final Throwable e ) { \n \n <ect>
\t5 LOGGER . debug ( <string_literal> , attributeName , filteredValues ) ; \n \n \t5 return filteredValues ; \n \n \t4 } ) . flatMap ( Collection : : stream ) . collect ( Collectors . toList ( ) ) ; \n \n \t4 if ( finalValues . isEmpty ( ) ) { \n \n <ect>
\t4 <string_literal> + ldapSaslPrincipal + <string_literal> + directoryServiceFactory + <string_literal> + ldifFile ) ; \n \n \t2 this . directoryService = createDirectoryService ( ) ; \n \n \t2 log . info ( <string_literal> + ldifFile ) ; \n \n \t2 importLdif ( ) ; \n \n <ect>
\t3 try { \n \n \t3 <comment> \n \n \t3 rootNode = reader . readValue ( json ) ; \n \n \t3 } catch ( JsonParseException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 @ Path ( <string_literal> ) \n \n \t1 @ GET \n \n \t1 @ Produces ( <string_literal> ) \n \n \t1 public Object getCustomer ( ) { \n \n <ect>
\t1 String [ ] argv = getArgv ( isDirect , tableName , extraArgs ) ; \n \n \t1 try { \n \n \t1 runImport ( argv ) ; \n \n \t1 } catch ( IOException ioe ) { \n \n <ect>
\t1 long eventElapsedTime = System . currentTimeMillis ( ) - startTime ; \n \n \t1 if ( metadata != null ) { \n \n \t2 logger . debug ( <string_literal> , metadata . partition ( ) , \n \n \t4 metadata . offset ( ) ) ; } \n \n <ect>
\t1 try { \n \n \t1 handler . handleRegistration ( reg ) ; \n \n \t1 fail ( <string_literal> ) ; \n \n \t1 } catch ( AmbariException e ) { \n \n <ect>
\t3 pstmt . executeUpdate ( ) ; \n \n \t3 s_logger . info ( <string_literal> ) ; \n \n \t2 } catch ( SQLException e ) { \n \n \t3 if ( e . getMessage ( ) . contains ( <string_literal> ) ) { \n \n <ect>
\t4 } finally { \n \n \t5 is . close ( ) ; } \n \n \t4 long endTime = System . currentTimeMillis ( ) ; \n \n \t4 if ( verbose ) { \n \n <ect>
\t2 if ( ! StringUtils . isBlank ( metricQueryClientClass ) ) { \n \n \t3 LOG . info ( <string_literal> , metricQueryClientClass ) ; \n \n \t3 this . metricQueryClient = ( MetricQueryClient ) Utils . newInstance ( metricQueryClientClass ) ; \n \n \t2 } else { \n \n <ect>
\t4 if ( values . isEmpty ( ) ) { \n \n \t5 LOGGER . debug ( <string_literal> , this . principalAttributeName , extractedPrincipalId ) ; \n \n \t4 } else { \n \n \t5 principalId [ 0 ] = values . get ( 0 ) . toString ( ) ; \n \n <ect>
\t3 for ( Object o : all ) { \n \n \t4 <comment> \n \n \t4 LOG . info ( o ) ; } \n \n \t2 } catch ( Exception ignored ) { \n \n <ect>
<comment> \n \n private String applyPreProcessors ( final Resource resource , final ProcessingCriteria criteria ) \n \n \t1 throws IOException { \n \n \t1 final Collection < ResourcePreProcessor > processors = processorsFactory . getPreProcessors ( ) ; \n \n <ect>
\t3 Class clazz = Class . forName ( obj . get_full_class_name ( ) ) ; \n \n \t3 Constructor cons = clazz . getConstructor ( paraTypes ) ; \n \n \t3 return ( CustomStreamGrouping ) cons . newInstance ( paraValues ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t8 log . warn ( <string_literal> + size ) ; \n \n \t8 lastEnd = pos ; \n \n \t8 return false ; \n \n \t7 } else if ( size > <number_literal> ) { \n \n <ect>
\t3 Element el = queryAsyncJobResult ( server , input ) ; \n \n \t3 Map < String , String > success = getSingleValueFromXML ( el , \n \n \t5 new String [ ] { <string_literal> } ) ; \n \n \t3 if ( success . get ( <string_literal> ) == null ) { \n \n <ect>
\t5 log . info ( <string_literal> , catalog ) ; } \n \n \t3 catch ( Exception e ) { \n \n \t4 throw new GeneratorException ( <string_literal> + catalog , e ) ; } } \n \n \t2 <comment> \n \n <ect>
\t2 for ( IndexEventListener listener : listeners ) { \n \n \t3 try { \n \n \t4 listener . indexShardStateChanged ( indexShard , previousState , indexShard . state ( ) , reason ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 } else { <comment> \n \n \t4 try { \n \n \t5 resp = getJmxResult ( conn , url ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>