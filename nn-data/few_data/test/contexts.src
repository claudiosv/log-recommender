\t1 <comment> \n \n \t1 try { \n \n \t2 hookRunner . runAfterExecutionHook ( queryStr , hookContext , executionError ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t8 accepted . remove ( source ) ; } } } \n \n \t4 } ; } } \n \n \t2 if ( ! availableSlot ) { \n \n \t3 <comment> \n \n <ect>
\t1 try { \n \n \t1 new LocalMapJoinProcFactory . LocalMapJoinProcessor ( ) . hasGroupBy ( mapJoinOp , \n \n \t2 context ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 List < SyncQueueItemVO > l = _queueMgr . dequeueFromAny ( getMsid ( ) , MAX_ONETIME_SCHEDULE_SIZE ) ; \n \n \t5 if ( l != null && l . size ( ) > 0 ) { \n \n \t6 for ( SyncQueueItemVO item : l ) { \n \n <ect>
\t7 <string_literal> , \n \n \t7 allowedDatetimeUpdateHour ) ; \n \n \t4 } else { \n \n \t5 allowedDatetimeUpdateHour = - 1 ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
public boolean isRegisterFor ( Class < ? > cls ) { \n \n \t1 return cls . isAssignableFrom ( MPrinter . class ) ; } \n \n @ Override \n \n public boolean preUpdate ( BeanPersistRequest < ? > request ) { \n \n <ect>
\t6 <comment> \n \n \t6 <comment> \n \n \t6 <comment> \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 if not definition_id in self . alerts_run_time : \n \n \t2 self . alerts_run_time [ definition_id ] = curr_time \n \n \t2 interval_seconds = definition [ 'interval' ] * <number_literal> \n \n \t2 if curr_time > self . alerts_run_time [ definition_id ] + ( interval_seconds * stale_interval_multiplier ) : \n \n <ect>
\t6 storeDef . getType ( ) + \n \n \t6 <string_literal> + \n \n \t6 ReadOnlyStorageConfiguration . TYPE_NAME ) ; \n \n \t4 continue ; } \n \n <ect>
\t6 while ( ! ( isStopping ( ) || isStopped ( ) ) && ( session == null || session . getSessionState ( ) . equals ( SessionState . CLOSED ) ) \n \n \t8 && attempt < configuration . getMaxReconnect ( ) ) { \n \n \t7 try { \n \n \t8 attempt ++ ; \n \n <ect>
\t2 LOG . info ( <string_literal> + result ) ; \n \n \t2 assertTrue ( <string_literal> + result , result . contains ( <string_literal> ) ) ; \n \n \t2 HashMap < String , String > propsAfter = new HashMap < String , String > ( ) ; \n \n \t2 IntrospectionSupport . getProperties ( runtimeConfigurationView , propsAfter , null ) ; \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 NSNotificationCenter . defaultCenter ( ) . postNotification ( \n \n \t6 ERMDDeleteButton . BUTTON_PERFORMED_DELETE_ACTION , obj , userInfo ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public Sampler next ( ) { \n \n \t2 if ( StringUtils . isEmpty ( getLockName ( ) ) ) { \n \n <ect>
\t4 Trace . addReceiver ( receiver ) ; \n \n \t4 logger . info ( <string_literal> , receiver ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t3 if ( isNotBlank ( mBID ) ) { \n \n \t4 LOGGER . debug ( <string_literal> { } \\ <string_literal> { } \\ <string_literal> , mBID , tagInfo ) ; \n \n \t4 TableMusicBrainzReleases . writeMBID ( mBID , tagInfo ) ; \n \n \t4 return mBID ; } \n \n <ect>
\t6 . startAt ( DateBuilder . futureDate ( <number_literal> + i , IntervalUnit . SECOND ) ) . withSchedule ( SimpleScheduleBuilder \n \n \t8 . repeatMinutelyForever ( eventRuntime . getConfig ( ) . getReloadMinutes ( ) ) ) \n \n \t6 . build ( ) ; \n \n \t4 this . scheduler . scheduleJob ( jobTrigger ) ; \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( leftCount != rightCount && CompactionManager . isCompactionManager . get ( ) ) \n \n \t3 { \n \n <ect>
\t4 if ( accessControlMaxAge != null ) { \n \n \t5 response . setAccessControlMaxAge ( accessControlMaxAge ) ; } \n \n \t3 } else { \n \n \t4 <comment> \n \n <ect>
\t3 catch ( SecurityException e ) { \n \n \t4 fallbackToTmp = true ; } \n \n \t3 finally { \n \n \t4 if ( fallbackToTmp ) \n \n <ect>
\t4 } else { \n \n \t5 <comment> \n \n \t5 encoders . add ( ChannelHandlerFactories . newObjectEncoder ( protocol ) ) ; \n \n \t5 decoders . add ( ChannelHandlerFactories . newObjectDecoder ( protocol ) ) ; \n \n <ect>
\t2 List < UserSessionModel > sessions1 = getSessions ( session1 ) ; \n \n \t2 List < UserSessionModel > sessions2 = getSessions ( session2 ) ; \n \n \t2 Assert . assertEquals ( <number_literal> , sessions1 . size ( ) ) ; \n \n \t2 Assert . assertEquals ( <number_literal> , sessions2 . size ( ) ) ; \n \n <ect>
\t3 s_logger . error ( msg , e ) ; \n \n \t3 return new GetVncPortAnswer ( cmd , msg ) ; } } \n \n \t1 protected Answer execute ( SetupCommand cmd ) { \n \n <ect>
\t2 if ( ! hasAPoolFs ( ) ) { \n \n \t3 return nullIsTrueCallWrapper ( <string_literal> , type , target , \n \n \t5 clustername , fsid , nfsbaseid , managerid , fsid ) ; \n \n \t2 } else if ( hasPoolFs ( fsid ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 public boolean add ( Setting setting ) { \n \n \t2 SimpleUri id = setting . getId ( ) ; \n \n \t2 if ( id == null ) { \n \n <ect>
\t2 return serviceToValidate . matches ( this . service ) ; } \n \n \t1 @ Override \n \n \t1 public ProxyGrantingTicket grantProxyGrantingTicket ( final String id , final Authentication authentication , final ExpirationPolicy expirationPolicy ) throws AbstractTicketException { \n \n \t2 if ( this . grantedTicketAlready ) { \n \n <ect>
\t4 remainingSpace -= spaceUsed ; } \n \n \t3 else if ( effectiveIndexInterval > maxIndexInterval ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t4 logger . info ( <string_literal> , addr , getLinkInfo ( dbes , addr ) ) ; \n \n \t4 dev . setHasModemDBEntry ( true ) ; } \n \n \t2 } else { \n \n \t3 if ( m_driver . isModemDBComplete ( ) && ! addr . isX10 ( ) ) { \n \n <ect>
\t6 for ( int i = 0 ; i < aks . length ; i ++ ) { \n \n \t7 forceDestinationWakeupOnCompletion ( context , transaction , aks [ i ] . getDestination ( ) , aks [ i ] ) ; } \n \n \t6 transaction . setState ( Transaction . PREPARED_STATE ) ; \n \n \t6 registerMBean ( transaction ) ; \n \n <ect>
public void populateResource ( Resource resource , InputStream inputStream ) throws SystemException { \n \n \t1 try { \n \n \t1 Map < String , Object > responseMap = GSON . fromJson ( IOUtils . toString ( inputStream , <string_literal> ) , MAP_TYPE ) ; \n \n \t1 if ( responseMap == null ) { \n \n <ect>
\t2 setHtml ( EntityUtils . toString ( entity ( ) ) ) ; \n \n \t2 } else { \n \n \t2 setHtml ( EntityUtils . toString ( entity ( ) , receiveEncoding ( ) ) ) ; } } } \n \n <ect>
\t7 task . setVmCreateImageTaskState ( CreateImageState . complete ) ; \n \n \t5 } else \n \n \t6 continue ; \n \n \t4 } catch ( final Exception ex ) { \n \n <ect>
\t4 LOG . debug ( <string_literal> ) ; } \n \n \t3 try ( final PreparedStatement updateStatement = conn . prepareStatement ( <string_literal> ) ) { \n \n \t4 updateStatement . executeUpdate ( ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t4 return null ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 LOG . warn ( <string_literal> + namespace + <string_literal> + kubernetes . getMasterUrl ( ) ) ; \n \n \t3 return null ; } \n \n <ect>
\t1 try { \n \n \t1 currentBinding . toOM ( eucaMsg , this . getNamespace ( ) ) ; \n \n \t1 } catch ( final RuntimeException e ) { \n \n \t1 LOG . error ( <string_literal> + operationName + <string_literal> + params ) ; \n \n <ect>
\t1 { \n \n \t2 switch ( type ) \n \n \t2 { \n \n \t2 case TOP_OF_MINUTE : \n \n <ect>
\t3 @ Override \n \n \t3 public void onTransaction ( Peer peer , Transaction tx ) { \n \n \t4 Result result = DefaultRiskAnalysis . FACTORY . create ( null , tx , NO_DEPS ) . analyze ( ) ; \n \n \t4 incrementCounter ( TOTAL_KEY ) ; \n \n <ect>
\t1 if ( null != w ) { \n \n \t2 try { \n \n \t2 w . close ( ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t6 privateNtwk = _ntwkSvc . createPrivateNetwork ( networkName , networkName , physicalNetworkIdFinal , broadcastUri , ipAddress , null , gateway , netmask , \n \n \t8 gatewayOwnerId , vpcId , isSourceNat , networkOfferingId ) ; \n \n \t5 } else { <comment> \n \n \t6 <comment> \n \n <ect>
\t1 { \n \n \t2 LOGGER . info ( <string_literal> ) ; \n \n \t2 checkedSleep ( timeout , unit ) ; \n \n \t2 store . put ( key , value ) ; \n \n <ect>
\t3 valBytes ) ; \n \n \t2 try { \n \n \t3 fileWriter . write ( null , kv ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 if ( ( new File ( userDataFilePath ) . exists ( ) ) ) { \n \n \t3 Script hardLink = new Script ( ! _inSystemVM , <string_literal> , _timeout , s_logger ) ; \n \n \t3 hardLink . add ( userDataFilePath ) ; \n \n \t3 hardLink . add ( tempDirName + openStackConfigDriveName + <string_literal> ) ; \n \n <ect>
\t2 executorService . shutdown ( ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 executorService . awaitTermination ( THREADPOOL_TERMINATION_TIMEOUT , TimeUnit . SECONDS ) ; \n \n \t2 pause ( ADDITIONAL_SLEEP_AFTER * <number_literal> ) ; \n \n <ect>
\t3 log . debug ( format ( <string_literal> , idx , convert ( idx ) ) ) ; \n \n \t2 idx = convert ( idx ) ; \n \n \t2 BPTreePage page = get ( idx , READ ) ; \n \n \t2 if ( logging ( ) ) \n \n <ect>
\t1 @ Override \n \n \t1 public void bindingChanged ( BindingProvider provider , String itemName ) { \n \n \t2 if ( context . getConfig ( ) . isValid ( ) ) { \n \n \t3 if ( provider instanceof AstroBindingProvider ) { \n \n <ect>
\t1 if ( is == null ) { \n \n \t2 <comment> \n \n \t2 if ( filesToRead . empty ( ) ) return false ; \n \n \t2 Path p = filesToRead . pop ( ) ; \n \n <ect>
\t3 return _default ; } \n \n \t2 try { \n \n \t3 return Integer . parseInt ( value ) ; \n \n \t2 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t3 bshInterpreter . set ( <string_literal> , jmctx . getPreviousResult ( ) ) ; <comment> \n \n \t3 bshInterpreter . set ( <string_literal> , JMeterUtils . getJMeterProperties ( ) ) ; \n \n \t3 bshInterpreter . set ( <string_literal> , vars ) ; <comment> \n \n \t2 } catch ( JMeterException e ) { \n \n <ect>
\t2 waitForBridgeFormation ( 1 ) ; \n \n \t2 HashSet < NetworkBridge > bridgesStart = new HashSet < NetworkBridge > ( ) ; \n \n \t2 for ( NetworkConnector networkConnector : networkConnectors ) { \n \n \t3 bridgesStart . addAll ( networkConnector . activeBridges ( ) ) ; } \n \n <ect>
\t2 if ( SystemProperties . getBoolean ( USE_NATIVE_CLOCK_SYSTEM_PROPERTY , true ) && Native . isGettimeofdayAvailable ( ) ) { \n \n \t3 LOGGER . info ( <string_literal> ) ; \n \n \t3 return new NativeClock ( ) ; \n \n \t2 } else { \n \n <ect>
\t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( InvocationTargetException e ) { \n \n <ect>
\t2 Function . ReadFunction readFunction = Function . ReadFunction . getFunction ( topNConfig . getTopNFunction ( ) ) ; \n \n \t2 Function function = new Function ( readFunction , null ) ; \n \n \t2 conditionBuilder . topNFunction ( function ) ; \n \n \t1 } else { \n \n <ect>
\t1 private void handleError ( String msg ) { \n \n \t2 _collector . reportError ( new Exception ( <string_literal> + msg ) ) ; } \n \n \t1 @ Override \n \n \t1 public void activate ( ) { \n \n <ect>
\t1 private final Cipher encryptCipher ; \n \n \t1 private final Cipher decryptCipher ; \n \n \t1 private volatile boolean stop ; \n \n \t1 public UDPBroadcaster ( String config ) { \n \n <ect>
\t3 int adjustedLimit = query . hasLimit ( ) ? query . getLimit ( ) : Integer . MAX_VALUE - 1 ; \n \n \t3 if ( adjustedLimit < Integer . MAX_VALUE - 1 - offset ) adjustedLimit += offset ; \n \n \t3 else adjustedLimit = Integer . MAX_VALUE - 1 ; \n \n \t3 TopDocs docs = searcher . search ( q , adjustedLimit ) ; \n \n <ect>
\t4 <comment> \n \n \t4 final long t1 = System . currentTimeMillis ( ) ; \n \n \t4 ns2 . runBackgroundOperations ( ) ; <comment> \n \n \t4 final long t2 = System . currentTimeMillis ( ) ; \n \n <ect>
\t1 ConfigFilterType srcType = ConfigFilterType . OTHER ; \n \n \t1 try { \n \n \t1 srcType = ConfigFilterType . valueOf ( type . toUpperCase ( Locale . ENGLISH ) ) ; \n \n \t1 } catch ( IllegalArgumentException ex ) { \n \n <ect>
\t3 DataHelper . storeProps ( config , conf ) ; \n \n \t3 if ( _log . shouldInfo ( ) ) \n \n \t4 _log . info ( <string_literal> + conf ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t2 al . add ( any ) ; \n \n \t2 new Exclude ( al ) ; } \n \n \t1 @ Test ( expected = IllegalArgumentException . class ) \n \n \t1 public void testExcludeArrayListOfElementFails3 ( ) { \n \n <ect>
\t6 else if ( Options . v ( ) . verbose ( ) ) \n \n \t7 logger . debug ( <string_literal> + String . format ( <string_literal> , \n \n \t9 className , container . getDexName ( ) , container . getFilePath ( ) . getCanonicalPath ( ) ) ) ; } } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \n \t4 try { \n \n \t5 c = new Connection ( host , port , key ) ; \n \n \t5 connected = true ; \n \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \n \t3 try { \n \n \t4 socket . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 throw new CloudRuntimeException ( <string_literal> + host . getName ( ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 s_logger . warn ( <string_literal> + host + <string_literal> + dataStore , e ) ; } } \n \n \t2 if ( poolHosts . isEmpty ( ) ) { \n \n <ect>
\t2 if ( url . equals ( <string_literal> ) && certFileName == null ) { \n \n \t3 s_logger . error ( <string_literal> ) ; \n \n \t3 System . exit ( 1 ) ; } \n \n \t2 if ( secretKey == null ) { \n \n <ect>
\t2 command . add ( <string_literal> ) ; \n \n \t2 command . add ( <string_literal> ) ; \n \n \t2 result = command . execute ( ) ; \n \n \t2 if ( result != null ) { \n \n <ect>
\t5 logger . trace ( <string_literal> ) ; \n \n \t4 imConversation . sendMessage ( new SimpleMessage ( sysMsg . toString ( ) ) ) ; } \n \n \t3 catch ( Exception ex ) \n \n \t3 { \n \n <ect>
\t3 return false ; } \n \n \t2 final String clientId = context . getRequestParameter ( OAuth20Constants . CLIENT_ID ) ; \n \n \t2 final OAuthRegisteredService registeredService = getRegisteredServiceByClientId ( clientId ) ; \n \n \t2 if ( ! validator . checkServiceValid ( registeredService ) ) { \n \n <ect>
\t3 VersionNumber vn = new VersionNumber ( versionedName ) ; \n \n \t3 Assert . assertTrue ( t . equals ( vn . getAsTime ( ) ) ) ; \n \n \t3 <comment> \n \n \t3 Thread . sleep ( 1 ) ; } \n \n <ect>
\t5 boolean assignToVpcNtwk = network . getVpcId ( ) != null && ipVO . getVpcId ( ) != null && ipVO . getVpcId ( ) . longValue ( ) == network . getVpcId ( ) ; \n \n \t5 if ( assignToVpcNtwk ) { \n \n \t6 <comment> \n \n \t6 _networkModel . checkIpForService ( ipVO , Service . Lb , networkId ) ; \n \n <ect>
\t2 final Conditions conditions = this . samlObjectBuilder . newConditions ( issuedAt , service . getId ( ) , this . issueLength ) ; \n \n \t2 assertion . setConditions ( conditions ) ; \n \n \t2 LOGGER . debug ( <string_literal> , this . issuer , service . getId ( ) ) ; \n \n \t2 final Subject subject = this . samlObjectBuilder . newSubject ( principal . getId ( ) ) ; \n \n <ect>
\t7 break ; } } \n \n \t5 LOG . info ( <string_literal> + original . getQueueName ( ) + <string_literal> + index + <string_literal> + blockSize + <string_literal> ) ; \n \n \t5 connection . close ( ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 private File getWorkingDirForUser ( final String username ) throws IOException { \n \n \t2 final File userDir = getOrCreateSvnUserDirectory ( username ) ; \n \n <ect>
\t2 if ( ! deployment . getRealm ( ) . equals ( account . getKeycloakSecurityContext ( ) . getRealm ( ) ) ) { \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( account . checkActive ( ) ) { \n \n <ect>
<comment> \n \n void beanCacheRemove ( Object id ) { \n \n \t1 if ( beanCache != null ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , cause ) ; } \n \n \t2 if ( notifier != null ) { \n \n \t3 notifier . onFailure ( context , cause ) ; } \n \n \t2 if ( cause instanceof InterruptedException || cause instanceof InterruptedIOException ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t2 if ( grid . getTileSize ( ) == null ) { \n \n \t3 logger . error ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 if ( grid . getGridDimensions ( ) == null ) { \n \n <ect>
<comment> \n \n \t1 public void setKeyObtentionIterations ( final String iter ) { \n \n \t2 if ( StringUtils . isNotBlank ( iter ) && NumberUtils . isCreatable ( iter ) ) { \n \n <ect>
\t2 String columnNoStr = parameter . substring ( pos1 + <number_literal> ) ; \n \n \t2 int columnNo = Integer . parseInt ( columnNoStr ) ; \n \n \t2 if ( PentahoSystem . debug ) { \n \n \t2 TemplateUtil . logger . debug ( <string_literal> + inputName ) ; <comment> \n \n <ect>
\t1 verifyImport ( <string_literal> + seqFileVal , checkCols ) ; } \n \n @ Test \n \n public void testClob1 ( ) { \n \n \t1 if ( ! supportsClob ( ) ) { \n \n <ect>
\t3 if ( this . jwksFile != null ) { \n \n \t4 LOGGER . debug ( <string_literal> , this . jwksFile ) ; \n \n \t4 final JsonWebKeySet jsonWebKeySet = buildJsonWebKeySet ( this . jwksFile ) ; \n \n \t4 if ( jsonWebKeySet == null || jsonWebKeySet . getJsonWebKeys ( ) . isEmpty ( ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected void doCatch ( Throwable e ) throws Throwable { \n \n \t2 <comment> \n \n \t2 state = BillingWorkflowState . WORKFLOW_FAILED ; \n \n <ect>
\t3 if ( transport != null ) { \n \n \t4 try { \n \n \t5 transport . close ( ) ; \n \n \t4 } catch ( MessagingException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 String cidrSubnet = NetUtils . getCidrSubNet ( cidrAddress , cidrSize ) ; \n \n \t2 String serverSubnet = NetUtils . getSubNet ( serverPrivateIP , serverPrivateNetmask ) ; \n \n \t2 if ( ! cidrSubnet . equals ( serverSubnet ) ) { \n \n <ect>
\t1 protected Log logger = LogFactory . getLog ( RejectAndDontRequeueRecoverer . class ) ; \n \n \t1 @ Override \n \n \t1 public void recover ( Message message , Throwable cause ) { \n \n <ect>
\t4 final String snapshotFile = snapshotDestPath + <string_literal> + snapshotName ; \n \n \t4 try { \n \n \t5 s_logger . debug ( <string_literal> + rbdSnapshot ) ; \n \n \t5 final File snapDir = new File ( snapshotDestPath ) ; \n \n <ect>
<comment> \n \n \t3 status = Curator . CURATE_SUCCESS ; \n \n \t3 String handle = item . getHandle ( ) ; \n \n <ect>
\t2 totalQueries += dbpojoHiveSavedQuery . size ( ) ; \n \n \t2 logger . info ( <string_literal> + username ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 for ( i = 0 ; i < dbpojoHiveSavedQuery . size ( ) ; i ++ ) { \n \n <ect>
\t3 log . warn ( <string_literal> , indexPath ) ; \n \n \t3 return false ; } \n \n \t2 IndexInfoProvider infoProvider = infoProviders . get ( type ) ; \n \n \t2 if ( infoProvider == null ) { \n \n <ect>
\t2 } catch ( SmbException exc ) { \n \n \t3 throw new RuntimeIOException ( format ( <string_literal> , smbFile . getUncPath ( ) , exc . toString ( ) ) , exc ) ; } } \n \n \t1 @ Override \n \n \t1 public InputStream getInputStream ( ) throws RuntimeIOException { \n \n <ect>
\t7 QName typeName = part . getTypeName ( ) ; \n \n \t7 SchemaType type = typeName == null ? null : wsdlContext . getSchemaTypeLoader ( ) . findType ( typeName ) ; \n \n \t7 messageParts . add ( new MessageXmlPart ( children [ 0 ] , type , part , bindingOperation , isRequest ) ) ; } \n \n \t5 } else if ( children . length != 1 ) { \n \n <ect>
\t1 if ( ! m . matches ( ) ) { \n \n \t1 unmatchedRowsCount ++ ; \n \n \t2 if ( ! alreadyLoggedNoMatch ) { \n \n \t2 <comment> \n \n <ect>
\t2 this . log = log ; } \n \n \t1 @ Override \n \n \t1 public void corruptedLogFile ( long version , Throwable t ) \n \n \t1 { \n \n <ect>
\t2 if ( remoteSolrServerConfiguration . getSolrZkHost ( ) != null && remoteSolrServerConfiguration . getSolrZkHost ( ) . length ( ) > 0 ) { \n \n \t3 try { \n \n \t4 solrServer = initializeWithCloudSolrServer ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 PaginatedResult < ObjectEntity > result ; \n \n \t1 try { \n \n \t1 result = ObjectMetadataManagers . getInstance ( ) . listPaginated ( bucket , maxKeys , request . getPrefix ( ) , request . getDelimiter ( ) , request . getMarker ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 stream = new FileOutputStream ( destFile ) ; \n \n \t4 stream . write ( fileData ) ; \n \n \t4 LOGGER . info ( <string_literal> + needCode ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 protected void pruneUntilMinimal ( OWLClassExpression unsatClass ) throws OWLException { \n \n \t2 LOGGER . info ( <string_literal> , Integer . valueOf ( debuggingAxioms . size ( ) ) ) ; \n \n \t2 resetSatisfiabilityTestCounter ( ) ; \n \n <ect>
\t5 throw new StoreOperationFailureException ( String . format ( <string_literal> , \n \n <number_literal> def . getName ( ) ) ) ; } } \n \n \t2 } catch ( VoldemortException e ) { \n \n \t3 response . setError ( ProtoUtils . encodeError ( errorCodeMapper , e ) ) ; \n \n <ect>
\t1 s . setRange ( MetadataSchema . ReplicationSection . getRange ( ) ) ; \n \n \t1 for ( Entry < Key , Value > entry : s ) { \n \n \t2 log . info ( <string_literal> , entry . getKey ( ) . toStringNoTruncate ( ) , \n \n \t3 ProtobufUtil . toString ( Status . parseFrom ( entry . getValue ( ) . get ( ) ) ) ) ; } \n \n <ect>
\t3 result = new FileInputStream ( execResult . getCommand ( ) . getOutFile ( ) ) ; \n \n \t2 } else { \n \n \t3 <comment> \n \n \t3 if ( execResult . getStdout ( ) == null && execResult . getCommand ( ) . isUseStderrOnEmptyStdout ( ) ) { \n \n <ect>
\t3 for ( File child : files ) { \n \n \t4 recursivelyDeleteDirectory ( child ) ; } } \n \n \t2 boolean success = file . delete ( ) ; \n \n \t2 if ( ! success ) { \n \n <ect>
\t5 <comment> \n \n \t5 off += fragments [ i ] . getValid ( ) ; } \n \n \t4 if ( off != state . getCompleteSize ( ) ) { \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 try { \n \n \t2 HiveQueryId parsedJob = parseAtsHiveJob ( ( JSONObject ) job ) ; \n \n \t2 parsedJobs . add ( parsedJob ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t1 OpAttr [ ] inputs = new OpAttr [ inputsList . size ( ) ] ; \n \n \t1 for ( int i = 0 ; i < inputs . length ; i ++ ) { \n \n \t1 inputs [ i ] = dispatch ( inputsList . get ( i ) ) ; } \n \n <ect>
\t3 pstmt . executeBatch ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t3 if ( ! wakeup . isAwake ( ) ) { \n \n \t4 logger . debug ( <string_literal> , wakeup . getNode ( ) . getNodeId ( ) ) ; \n \n \t4 return ; } \n \n \t3 <comment> \n \n <ect>
\t2 syncWork . toRestartInUse . add ( sessionToDestroy ) ; } } \n \n \t1 e . toDestroy . clear ( ) ; \n \n \t1 <comment> \n \n \t1 for ( WmTezSession sessionToReturn : e . toReturn ) { \n \n <ect>
\t1 protected AuthenticationHandlerExecutionResult doAuthentication ( final Credential credential ) throws GeneralSecurityException { \n \n \t2 final YubiKeyCredential yubiKeyCredential = ( YubiKeyCredential ) credential ; \n \n \t2 final String otp = yubiKeyCredential . getToken ( ) ; \n \n \t2 if ( ! YubicoClient . isValidOTPFormat ( otp ) ) { \n \n <ect>
public void close ( ) throws IOException { \n \n \t1 LlapIoImpl . LOG . trace ( <string_literal> , \n \n \t2 isClosed , isInterrupted , pendingError . get ( ) , queue . size ( ) ) ; } \n \n <ect>
\t2 for ( CacheEventListener listener : listeners ) { \n \n \t3 try { \n \n \t4 listener . onFlush ( event ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 . EXEC_TIMEOUT_NAME + <string_literal> ; \n \n \t1 LOG . warn ( <string_literal> + cmd + msg + <string_literal> + res ) ; \n \n \t1 res . stderr += <string_literal> + msg ; } \n \n \t1 if ( res . exitcode != 0 ) { \n \n <ect>
\t2 try { \n \n \t3 topologyConf . remove ( ConfigExtension . TOPOLOGY_UPGRADE_FLAG ) ; \n \n \t3 submitTopology ( name , topologyCodeLocation , JStormUtils . to_json ( topologyConf ) , topology ) ; \n \n \t2 } catch ( AlreadyAliveException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 public void sendCommand ( HttpClient client , Connection conn ) { \n \n \t2 if ( TestCaseEngine . _printUrl == true ) \n \n \t2 { \n \n <ect>
\t2 if ( position < 0 || position > maxColumn ) { \n \n \t3 logger . error ( <string_literal> , maxColumn ) ; \n \n \t3 return ; } \n \n \t2 if ( line < 0 || line > maxLine ) { \n \n <ect>
\t3 UserVmVO vm = _vmDao . findById ( vmId ) ; \n \n \t3 vmNames . add ( vm . getInstanceName ( ) ) ; } \n \n \t2 Answer answer = _agentMgr . easySend ( hostId , new GetVmStatsCommand ( vmNames , _hostDao . findById ( hostId ) . getGuid ( ) , hostName ) ) ; \n \n \t2 if ( answer == null || ! answer . getResult ( ) ) { \n \n <ect>
\t2 { \n \n \t3 reconnect ( publicAddress , InetAddress . getByName ( localAddressValue . value ) ) ; } \n \n \t2 catch ( UnknownHostException e ) \n \n \t2 { \n \n <ect>
\t4 if ( approval . getStatus ( ) == ApprovalStatus . APPROVED ) { \n \n \t5 validUserApprovedScopes . add ( approval . getScope ( ) ) ; \n \n \t5 approvedScopes . add ( approval . getScope ( ) ) ; } } } \n \n <ect>
\t1 public BindingReport ( ) { \n \n \t2 this ( <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void call ( Injector injector ) { \n \n <ect>
\t2 if ( null != entry . getKey ( ) ) { \n \n \t2 nullByte | = 1 < < ( b % <number_literal> ) ; \n \n \t2 } else if ( warnedOnceNullMapKey != null ) { \n \n \t2 if ( ! warnedOnceNullMapKey . value ) { \n \n <ect>
\t2 LOG . info ( <string_literal> + sanSnapshotId + <string_literal> ) ; \n \n \t2 storageResource = connectionManager . connectTarget ( iqn , lun ) ; \n \n \t2 storageResource . setId ( snapshotId ) ; \n \n \t2 } catch ( Exception connEx ) { \n \n <ect>
\t2 try { \n \n \t3 request . writeTo ( out ) ; \n \n \t3 server . send ( dest , out . buffer ( ) , 0 , out . position ( ) ) ; } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
<comment> \n \n \t1 protected String getRegisteredServiceJwtProperty ( final RegisteredService service , final RegisteredServiceProperty . RegisteredServiceProperties propName ) { \n \n \t2 if ( service == null || ! service . getAccessStrategy ( ) . isServiceAccessAllowed ( ) ) { \n \n <ect>
\t4 return new FenceAnswer ( cmd , false , <string_literal> ) ; \n \n \t3 } else { \n \n \t4 return new FenceAnswer ( cmd ) ; } \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t3 s_logger . info ( <string_literal> + responseCode ) ; \n \n \t3 if ( responseCode == <number_literal> ) { \n \n \t4 InputStream is = method . getResponseBodyAsStream ( ) ; \n \n \t4 Map < String , String > success = getSingleValueFromXML ( is , new String [ ] { <string_literal> } ) ; \n \n <ect>
static void speedTestHashLogger ( final int len ) { \n \n \t1 final HLogger logger = hashLoggerContext . getLogger ( loggerName ) ; \n \n \t1 long start = System . nanoTime ( ) ; \n \n \t1 for ( int i = 0 ; i < len ; i ++ ) { \n \n <ect>
\t2 File exportFile = File . createTempFile ( <string_literal> , <string_literal> ) ; \n \n \t2 Path exportPath = Paths . get ( URI . create ( <string_literal> + exportFile . getAbsolutePath ( ) ) ) ; \n \n \t2 client ( <string_literal> ) . index ( new IndexRequest ( ) . index ( <string_literal> ) . type ( <string_literal> ) . id ( <string_literal> ) . source ( <string_literal> , <string_literal> ) . refresh ( true ) ) . actionGet ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n <ect>
\t3 pstmt . executeUpdate ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t4 dbProp = new Properties ( ) ; } \n \n \t3 try { \n \n \t4 dbProp . load ( new FileInputStream ( propertiesFile ) ) ; \n \n \t3 } catch ( FileNotFoundException e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public Boolean call ( ) { \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 for ( String databaseName : Iterables . filter ( Databases . getBootstrapper ( ) . listDatabases ( ) , DatabaseFilters . OLDVERSION ) ) { \n \n <ect>
\t5 return new UsernamePasswordAuthenticationToken ( username , password , authorities ) ; } \n \n \t4 LOGGER . warn ( <string_literal> , \n \n \t6 username , authorizer . getElements ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t3 long time = watch . stop ( ) ; \n \n \t3 Logger log = LoggerFactory . getLogger ( testContext . getTestClass ( ) ) ; \n \n \t3 log . info ( <string_literal> ) ; \n \n \t3 log . info ( <string_literal> + testContext . getTestMethod ( ) . getName ( ) + <string_literal> + testContext . getTestClass ( ) . getName ( ) + <string_literal> ) ; \n \n <ect>
\t6 else if ( currentToken . equals ( endToken ) ) { \n \n \t7 return true ; } \n \n \t5 } catch ( Exception e ) { \n \n \t6 error . compareAndSet ( null , e ) ; \n \n <ect>
\t1 final boolean valid = Boolean . parseBoolean ( builder . evaluate ( packIt , <string_literal> ) . toString ( ) ) ; \n \n \t1 if ( ! valid ) { \n \n \t1 final String json = builder . addJSON ( ) . evaluate ( \n \n \t2 String . format ( <string_literal> , getLinterName ( ) ) , <string_literal> ) . toString ( ) ; \n \n <ect>
\t2 if ( ! initialized ) { \n \n \t3 ApplicationContext applicationContext = ( ApplicationContext ) ActionContext . getContext ( ) . getApplication ( ) . get ( \n \n \t5 WebApplicationContext . ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE ) ; \n \n \t3 if ( applicationContext == null ) { \n \n <ect>
public Double runningAverage ( ) { \n \n \t1 return ( Double ) storedValueForKey ( _Voting . RUNNING_AVERAGE_KEY ) ; } \n \n public void setRunningAverage ( Double value ) { \n \n <ect>
\t3 try { \n \n \t4 fi = new FileInputStream ( cfg ) ; \n \n \t4 props . load ( fi ) ; \n \n \t3 } catch ( FileNotFoundException fnfe ) { \n \n <ect>
\t3 return ( ( LabeledLink ) this ) . copy ( newId ) ; \n \n \t2 else if ( this instanceof CompactLink ) \n \n \t3 return ( ( CompactLink ) this ) . copy ( newId ) ; \n \n \t2 else { \n \n <ect>
\t6 getTimer ( taskDefinition ) . scheduleAtFixedRate ( schedulerTask , \n \n \t7 SchedulerConstants . SCHEDULER_DEFAULT_DELAY , repeatInterval ) ; \n \n \t5 } else { \n \n \t6 <comment> \n \n <ect>
\t3 success = false ; } \n \n \t2 <comment> \n \n \t2 final List < FirewallRuleVO > firewallIngressRulesToApply = _firewallDao . listByNetworkPurposeTrafficType ( networkId , Purpose . Firewall , FirewallRule . TrafficType . Ingress ) ; \n \n \t2 if ( ! _firewallMgr . applyFirewallRules ( firewallIngressRulesToApply , false , caller ) ) { \n \n <ect>
\t2 String blockedNode = blockNodeWithIndex ( <string_literal> , <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <string_literal> , <string_literal> ) \n \n \t3 . setWaitForCompletion ( false ) . setIncludeGlobalState ( false ) . setIndices ( <string_literal> ) . get ( ) ; \n \n <ect>
\t2 public Boolean call ( ) { \n \n \t3 try { \n \n \t3 new ClusterAllocator ( allocInfo , config ) . run ( ) ; \n \n \t3 } catch ( final Exception ex ) { \n \n <ect>
\t2 } catch ( I2PSessionException e ) { \n \n \t3 _log . error ( <string_literal> , e ) ; \n \n \t3 return writeString ( SESSION_ERROR , e . getMessage ( ) ) ; \n \n \t2 } catch ( SAMException e ) { \n \n <ect>
\t3 sProp = sProperty ; \n \n \t3 sProp . addCallback ( new Runnable ( ) { \n \n \t4 @ Override \n \n \t4 public void run ( ) { \n \n <ect>
\t5 if ( upnString != null ) { \n \n \t6 return upnString ; } } } \n \n \t2 } catch ( final CertificateParsingException e ) { \n \n \t3 LOGGER . error ( <string_literal> , e ) ; \n \n <ect>
\t3 throw new RuntimeException ( e ) ; } } \n \n \t1 public static void modifyDocElementAttribute ( Document doc , String tagName , String attributeName , String regex , String replacement ) { \n \n \t2 NodeList nodes = doc . getElementsByTagName ( tagName ) ; \n \n \t2 if ( nodes . getLength ( ) != 1 ) { \n \n <ect>
\t4 log . debug ( <string_literal> , source ) ; \n \n \t4 source . init ( ) ; \n \n \t4 sourceList . add ( source ) ; \n \n \t3 } else { \n \n <ect>
\t6 s_logger . debug ( <string_literal> + _gson . toJson ( deviceConfigSpecArray [ i ] ) ) ; \n \n \t5 i ++ ; \n \n \t4 } else { \n \n <ect>
\t3 return resumeFlow ( ) ; } \n \n \t2 if ( result . getValue ( ) . isPresent ( ) ) { \n \n \t3 return CollectionUtils . wrapSet ( validateEventIdForMatchingTransitionInContext ( id , context , \n \n \t4 buildEventAttributeMap ( authentication . getPrincipal ( ) , service , result . getValue ( ) . get ( ) ) ) ) ; } \n \n <ect>
\t2 if ( result . isEmpty ( ) ) { \n \n \t3 return Response . status ( Status . NOT_FOUND ) . build ( ) ; } \n \n \t2 return Response . ok ( result . get ( 0 ) ) . build ( ) ; } \n \n \t1 private void createProtectedResource ( Album album ) { \n \n <ect>
\t4 player . join ( ) ; \n \n \t3 } catch ( SynthesisException e ) { \n \n \t4 logger . error ( <string_literal> , e . getLocalizedMessage ( ) , e ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t1 * \n \n \t1 * } catch ( Exception e ) { s_logger . warn ( <string_literal> , e ) ; } \n \n \t1 * finally { try { if ( rs != null ) { rs . close ( ) ; } if ( pstmt != null ) { \n \n \t1 * pstmt . close ( ) ; } txn . commit ( ) ; } catch ( SQLException sqle ) { \n \n <ect>
\t1 public ItemsVO doCreateItemsTableIfNot ( ItemsVO vo ) { \n \n \t2 String sql = StringUtilsExt . replaceArrayMerge ( SQL_CREATE_ITEMS_TABLE_IF_NOT , \n \n \t4 new String [ ] { <string_literal> , <string_literal> , <string_literal> , <string_literal> } , \n \n \t4 new String [ ] { vo . getItemsManageTable ( ) , vo . getColname ( ) , vo . getColtype ( ) , vo . getItemsManageTable ( ) } ) ; \n \n <ect>
\t2 } catch ( ResourceUnavailableException ex ) { \n \n \t3 s_logger . warn ( <string_literal> , ex ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . RESOURCE_UNAVAILABLE_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( ConcurrentOperationException ex ) { \n \n <ect>
\t1 assertThat ( id ) . isEqualTo ( 1L ) ; \n \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t1 Object val = s . nextId ( null ) ; \n \n \t1 log . warn ( <string_literal> + val ) ; } \n \n <ect>
\t3 } else if ( isPosixJNAAffinityUsable ( ) ) { \n \n \t4 LOGGER . trace ( <string_literal> ) ; \n \n \t4 AFFINITY_IMPL = PosixJNAAffinity . INSTANCE ; \n \n \t3 } else { \n \n <ect>
\t3 } catch ( CmsException e ) { \n \n \t4 LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } \n \n \t2 <comment> \n \n \t2 String result = ancestors . get ( 0 ) ; \n \n <ect>
\t2 String s = <string_literal> + extLockId + <string_literal> + \n \n \t2 <string_literal> + LOCK_WAITING + <string_literal> ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 if ( PropertyUtils . isWriteable ( target , name ) && properties . containsKey ( key ) ) { \n \n \t4 try { \n \n \t5 String value = context . expand ( String . valueOf ( properties . get ( key ) ) ) ; \n \n \t5 BeanUtils . setProperty ( target , name , value ) ; \n \n <ect>
\t1 if ( ! vm . isUsePrivateAddressing ( ) && \n \n \t2 ( VmState . PENDING . equals ( vm . getState ( ) ) || VmState . RUNNING . equals ( vm . getState ( ) ) ) ) { \n \n \t2 assignSystemAddress ( vm ) ; } \n \n \t1 } catch ( final NotEnoughResourcesException e ) { \n \n <ect>
\t2 spanPage = bf . file . readUnsignedInt ( ) ; \n \n \t2 bottom = bsl . spanHash . get ( Integer . valueOf ( spanPage ) ) ; \n \n \t2 if ( bottom == null ) { \n \n \t3 <comment> \n \n <ect>
\t2 _geoIP = new GeoIP ( _context ) ; \n \n \t2 _manager = new TransportManager ( _context ) ; \n \n \t2 startGeoIP ( ) ; } \n \n \t1 public synchronized void startup ( ) { \n \n <ect>
\t4 while ( ( entry = in . getNextEntry ( ) ) != null ) { \n \n \t5 String oriName = entry . getName ( ) ; \n \n \t5 String filename = directory . getAbsolutePath ( ) + File . separator + oriName ; \n \n \t5 if ( entry . isDirectory ( ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 @ Override \n \n \t1 public void teardownTest ( BackendListenerContext context ) throws Exception { \n \n <ect>
\t2 if ( addVif ) { \n \n \t3 args += <string_literal> ; } \n \n \t2 final String command = String . format ( <string_literal> , <string_literal> , VRScripts . IPASSOC , args ) ; \n \n <ect>
\t8 <string_literal> + me . getRecall ( ) + \n \n \t8 <string_literal> + elapsedTimeSec + \n \n \t8 <string_literal> + correctModel . getAccuracy ( ) + \n \n \t8 <string_literal> + correctModel . getMrr ( ) ) ; \n \n <ect>
\t6 savedConn = null ; <comment> \n \n \t6 conn . disconnect ( ) ; } \n \n \t5 setUseKeepAlive ( false ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t4 if ( ! allAttrReceived ) \n \n \t5 U . sleep ( <number_literal> ) ; } \n \n \t4 for ( Map . Entry < String , Integer > entry : receivedParams . entrySet ( ) ) \n \n <ect>
private static final Logger LOG = LoggerFactory . getLogger ( RetryPolicy . class ) ; \n \n private RetryPolicy ( ) { } \n \n @ Override \n \n public void handle ( Event event , Throwable cause ) throws EventDeliveryException { \n \n <ect>
\t5 public boolean process ( final Exchange exchange , final AsyncCallback callback ) { \n \n \t6 LOGGER . info ( <string_literal> ) ; \n \n \t6 return super . process ( exchange , new AsyncCallback ( ) { \n \n \t7 public void done ( final boolean doneSync ) { \n \n <ect>
\t2 FunctionRegistry . getFunctionNames ( <string_literal> ) ) ; \n \n \t1 for ( Function function : getAllFunctions ( ) ) { \n \n \t1 String functionName = function . getFunctionName ( ) ; \n \n \t1 try { \n \n <ect>
public synchronized void stop ( ) { \n \n \t1 LOGGER . info ( <string_literal> , getName ( ) ) ; \n \n \t1 twitterStream . shutdown ( ) ; \n \n \t1 super . stop ( ) ; \n \n <ect>
\t3 String name = ( String ) entry . getKey ( ) ; \n \n \t3 if ( ! IGNORE_SYS_PROPS . contains ( name ) ) { \n \n \t4 if ( name . startsWith ( <string_literal> ) && ! name . startsWith ( IGNORE_TEST_SYS_PROPS ) ) { \n \n \t5 if ( configuration . get ( name ) == null ) { \n \n <ect>
\t6 if ( i < usages . size ( ) ) { \n \n \t7 usage = <string_literal> + usages . get ( i ) ; } } \n \n \t5 s_logger . info ( <string_literal> + desc + usage ) ; } } \n \n \t2 } else { \n \n <ect>
\t2 String outputFileName = resourceName . substring ( resourceName . lastIndexOf ( <string_literal> ) + 1 ) ; \n \n \t2 try { \n \n \t3 outputFileName = configuration . getTempFolder ( ) + <string_literal> + outputFileName ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 confDirPath = confDir . getCanonicalPath ( ) ; \n \n \t1 File logDir = new File ( baseDir , <string_literal> ) ; \n \n \t1 logDir . mkdirs ( ) ; \n \n \t1 logDirPath = logDir . getCanonicalPath ( ) ; \n \n <ect>
\t1 try { \n \n \t1 return getContext ( ) . evaluateString ( scope , script , sourceName , 1 , null ) ; \n \n \t1 } catch ( final RhinoException e ) { \n \n \t1 final String message = RhinoUtils . createExceptionMessage ( e ) ; \n \n <ect>
\t5 if ( ! ( returnType == void . class ) ) { \n \n \t6 request . setAttribute ( extractor . nameFor ( returnType ) , result ) ; } \n \n \t5 if ( ! response . isCommitted ( ) ) { \n \n \t6 String path = resolver . pathFor ( DefaultResourceMethod . instanceFor ( type , method ) ) ; \n \n <ect>
\t4 log . debug ( <string_literal> + template . getDefaultDestinationName ( ) ) ; } \n \n \t3 Connection conn = template . getConnectionFactory ( ) . createConnection ( ) ; \n \n \t3 JmsUtils . closeConnection ( conn ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void internalReceiveCommand ( String itemName , Command command ) { \n \n \t2 if ( itemName == null ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t2 metadataProvider . setId ( metadataProvider . getClass ( ) . getCanonicalName ( ) ) ; \n \n \t2 buildMetadataFilters ( service , metadataProvider , metadataFilterList ) ; \n \n \t2 LOGGER . debug ( <string_literal> , service . getMetadataLocation ( ) ) ; \n \n \t2 metadataProvider . initialize ( ) ; \n \n <ect>
\t3 return netInfo != null && netInfo . isConnected } \n \n \t1 override fun loadTasksFromFile ( path : String ) : RemoteContents { \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 return received . size ( ) == SPLIT_COUNT ? GridComputeJobResultPolicy . REDUCE : GridComputeJobResultPolicy . WAIT ; } \n \n \t2 <comment> \n \n \t2 @ Override public Integer reduce ( List < GridComputeJobResult > results ) throws GridException { \n \n <ect>
\t3 if ( optionalOfferings != null && ! optionalOfferings . isEmpty ( ) ) { \n \n \t4 if ( networks != null && ! networks . isEmpty ( ) ) { \n \n \t5 for ( CloudStackNetwork network : networks ) { \n \n \t6 for ( CloudStackNetworkOffering optionalOffering : optionalOfferings ) { \n \n <ect>
\t1 import params \n \n \t1 env . set_params ( params ) \n \n \t1 hive_interactive ( name = 'hiveserver2' ) \n \n \t1 def pre_upgrade_restart ( self , env , upgrade_type = None ) : \n \n <ect>
\t4 <comment> \n \n \t4 if ( ctx . type ( ) == ExecuteType . BATCH ) \n \n \t5 log . debug ( <string_literal> , newline + ctx . sql ( ) ) ; \n \n \t4 else \n \n <ect>
\t2 this . log = logProvider . getLog ( getClass ( ) ) ; \n \n \t2 bindingListener = me - > \n \n \t2 { \n \n \t3 serverClusterId = me ; \n \n <ect>
\t4 if ( fs . getType ( ) == FileSystem . TYPE_LOCAL_DISK ) { \n \n \t5 disks . add ( fs . getDevName ( ) ) ; } } \n \n \t3 logger . debug ( <string_literal> , Arrays . toString ( disks . toArray ( ) ) ) ; \n \n \t2 } catch ( SigarException e ) { \n \n <ect>
\t3 public void operationComplete ( ChannelFuture future ) throws Exception { \n \n \t4 long durationNanos = System . nanoTime ( ) - creationNanos ; \n \n \t4 long durationMillis = TimeUnit . MILLISECONDS . convert ( durationNanos , TimeUnit . NANOSECONDS ) ; \n \n \t4 if ( future . isSuccess ( ) ) { \n \n <ect>
<number_literal> voldemortConfig . getNioAcceptorBacklog ( ) , \n \n <number_literal> voldemortConfig . getNioSelectorMaxHeartBeatTimeMs ( ) ) ; \n \n \t4 onlineServices . add ( nioSocketService ) ; \n \n \t3 } else { \n \n <ect>
\t4 return ; \n \n \t3 } else { \n \n \t4 state . setIsSuccessful ( true ) ; \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 this . handler = handler ; \n \n \t2 try { \n \n \t3 graphDb = ( DatabaseService ) StructrApp . getInstance ( ) . command ( GraphDatabaseCommand . class ) . execute ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t4 producer . send ( message ) ; \n \n \t4 messagesSent . incrementAndGet ( ) ; \n \n \t4 if ( messagesSent . get ( ) % <number_literal> == 0 ) { \n \n \t5 LOG . info ( <string_literal> + messagesSent . get ( ) ) ; \n \n <ect>
<comment> \n \n \t1 private void flushNewPartitions ( ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t2 } catch ( Throwable e ) { \n \n \t3 log . warn ( <string_literal> , e ) ; } } \n \n \t1 protected void onIO ( NginxClojureAsynSocket s , long sc , boolean isRead ) { \n \n <ect>
\t2 final OverlapDetector < Interval > ribosomalSequenceOverlapDetector = new OverlapDetector < Interval > ( 0 , 0 ) ; \n \n \t2 if ( ribosomalIntervalsFile != null ) { \n \n \t3 final IntervalList ribosomalIntervals = IntervalList . fromFile ( ribosomalIntervalsFile ) ; \n \n \t3 if ( ribosomalIntervals . size ( ) == 0 ) { \n \n <ect>
\t1 <comment> \n \n \t1 outPrinter . join ( ) ; \n \n \t1 errPrinter . join ( ) ; \n \n \t1 if ( exitVal != 0 ) { \n \n <ect>
\t9 new Versioned < byte [ ] > ( ByteUtils . getBytes ( entry . getValue ( ) , \n \n <number_literal> <string_literal> ) ) , \n \n \t9 null ) ; \n \n \t5 } catch ( ObsoleteVersionException e ) { \n \n <ect>
\t3 mdata = new MonitorData ( page , action , url , cthread . getName ( ) ) ; \n \n \t3 this . activeTimerDataList . put ( cthread , mdata ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 this . logger . warn ( <string_literal> , config . getController ( ) , e ) ; } } \n \n \t2 if ( node != null ) { \n \n \t3 executeCommand ( config , node , command ) ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t3 calcTabletStats ( conn , opts . getTableName ( ) , opts . auths , scanOpts . scanBatchSize , ke , \n \n \t4 columns ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 { \n \n \t3 ok = messageFactory . createResponse ( Response . OK , byeRequest ) ; } \n \n \t2 catch ( ParseException ex ) \n \n \t2 { \n \n <ect>
\t4 . setFetchMode ( <string_literal> , FetchMode . JOIN ) \n \n \t4 . list ( ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , salespersons . size ( ) ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , ( ( Salesperson ) salespersons . get ( 0 ) ) . getOrders ( ) . size ( ) ) ; \n \n <ect>
\t4 @ Override public void apply ( GridFuture < Long > t ) { \n \n \t5 exchWorker . addFuture ( forcePreloadExchange ( exchFut . discoveryEvent ( ) , exchFut . exchangeId ( ) ) ) ; } \n \n \t3 } ) ; } \n \n <ect>
\t4 LOG . info ( <string_literal> , fileStore ) ; \n \n \t4 if ( fileStore . getParentFile ( ) . mkdirs ( ) ) { \n \n \t5 LOG . info ( <string_literal> , fileStore ) ; \n \n \t4 } else { \n \n <ect>
\t2 } catch ( IOException ex ) { \n \n \t3 ex . printStackTrace ( ) ; \n \n \t3 Assert . fail ( <string_literal> + name + <string_literal> + ex . getMessage ( ) ) ; } } \n \n \t1 public int handleNameEnumerator ( ContentName prefix , ArrayList < ContentName > returnedNames ) { \n \n <ect>
\t4 <comment> \n \n <ect>
\t6 String message = ( String ) info . objectForKey ( <string_literal> ) ; \n \n \t6 String keyPaths = ( String ) info . objectForKey ( <string_literal> ) ; \n \n \t6 property = keyPaths == null ? property : keyPaths ; \n \n <ect>
\t1 public void initialize ( Map < String , Param > params ) throws TikaConfigException { \n \n \t2 AnnotationUtils . assignFieldParams ( recogniser , params ) ; \n \n \t2 recogniser . initialize ( params ) ; \n \n \t2 LOG . info ( <string_literal> , recogniser . getClass ( ) . getName ( ) ) ; \n \n <ect>
\t7 defaultStatelessKieSession = kieSessionModel ; \n \n \t7 defaultStatelessKieSessionFromMain = isMainModule ; \n \n \t6 } else { \n \n \t7 defaultStatelessKieSession = null ; \n \n <ect>
\t2 getAllowedAttributes ( ) . entrySet ( ) . stream ( ) . filter ( entry - > WSFederationClaims . contains ( entry . getKey ( ) . toUpperCase ( ) ) ) . forEach ( entry - > { \n \n \t3 final String claimName = entry . getKey ( ) ; \n \n \t3 final String attributeName = entry . getValue ( ) ; \n \n \t3 final WSFederationClaims claim = WSFederationClaims . valueOf ( claimName . toUpperCase ( ) ) ; \n \n <ect>
\t4 if ( cis != null ) { \n \n \t5 try { \n \n \t6 cis . close ( ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t5 . acceptLanguage ( <string_literal> ) . get ( ) ; \n \n \t3 Assert . assertEquals ( <number_literal> , response . getStatus ( ) ) ; \n \n \t3 String vary = response . getHeaderString ( HttpHeaderNames . VARY ) ; \n \n \t3 Assert . assertNotNull ( vary ) ; \n \n <ect>
\t3 return no ( ) ; } \n \n \t2 final String principal = c . getPrincipal ( ) . getId ( ) ; \n \n \t2 final LocalDate onOrAfter = LocalDate . now ( ) . minus ( trustedProperties . getExpiration ( ) , \n \n \t4 DateTimeUtils . toChronoUnit ( trustedProperties . getTimeUnit ( ) ) ) ; \n \n <ect>
\t3 if ( lock ( coordAction . getJobId ( ) ) ) { \n \n \t4 call ( store ) ; } \n \n \t3 else { \n \n \t4 queueCallable ( new CoordActionCheckCommand ( actionId , actionCheckDelay ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n <ect>
\t8 new org . apache . http . HttpVersion ( \n \n \t10 Integer . parseInt ( parts [ 0 ] ) , Integer . parseInt ( parts [ 1 ] ) ) ) ; } } \n \n \t3 ) ; } \n \n \t1 private static void load ( String file , GenericHttpParams params ) { \n \n <ect>
\t2 catch ( ClosedSelectorException cse ) { \n \n \t3 if ( this . isActive ( ) ) { \n \n \t4 logger . error ( <string_literal> , cse ) ; } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t2 if ( bindingConfig != null ) { \n \n \t3 BticinoBindingConfig config = parseBindingConfig ( item , bindingConfig ) ; \n \n \t3 addBindingConfig ( item , config ) ; \n \n \t2 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 response = base . request ( ) . post ( Entity . entity ( book2 , Constants . MEDIA_TYPE_TEST_XML ) ) ; \n \n \t2 log . info ( <string_literal> + response . getStatus ( ) ) ; \n \n \t2 assertEquals ( HttpResponseCodes . SC_OK , response . getStatus ( ) ) ; \n \n \t2 int id2 = response . readEntity ( int . class ) ; \n \n <ect>
\t4 accountID . isJingleNodesAutoDiscoveryEnabled ( ) , \n \n \t4 searchNodesWithPrefix ) ; \n \n \t3 { \n \n <ect>
\t1 protected < T > void doAddOption ( Map < String , T > options , String name , T value ) { \n \n \t2 log . trace ( <string_literal> , name , value ) ; \n \n \t2 T val = options . put ( name , value ) ; \n \n \t2 if ( val != null ) { \n \n <ect>
\t3 try { \n \n \t4 port2Num = Integer . parseInt ( args [ <number_literal> ] ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n \t4 l . log ( <string_literal> ) ; \n \n <ect>
\t5 } else if ( end == - 1 || end > length - 1 ) { \n \n \t6 end = length - 1 ; } \n \n \t5 <comment> \n \n \t5 if ( start > end ) { \n \n <ect>
\t8 String reason = null ; \n \n \t8 if ( response == <number_literal> ) { \n \n \t9 success = true ; \n \n \t9 if ( internet ) { \n \n <ect>
\t2 Set < T > found = new LinkedHashSet < T > ( ) ; \n \n \t2 String [ ] versionDirs = getComponentVersionDirs ( windowsKitDir ) ; \n \n \t2 for ( String versionDir : versionDirs ) { \n \n \t3 VersionNumber version = VersionNumber . withPatchNumber ( ) . parse ( versionDir ) ; \n \n <ect>
\t4 if ( args [ i ] instanceof Wrapper ) { \n \n \t5 Class type = pt [ i ] ; \n \n \t5 MethodType mt = MethodType . methodType ( type , Wrapper . class ) ; \n \n \t5 handle = MethodHandles . filterArguments ( handle , i , UNWRAP_METHOD . asType ( mt ) ) ; \n \n <ect>
\t3 list = getListFromBytes ( cache . get ( inKey ) ) ; \n \n \t3 list . remove ( inValue ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t1 LOG . info ( <string_literal> + getPluginDescription ( ) ) ; } } \n \n @ Override \n \n public void registerSlimTables ( SlimTableFactory slimTableFactory ) throws PluginException { \n \n \t1 if ( register ( plugin , <string_literal> , SlimTableFactory . class , slimTableFactory ) ) { \n \n <ect>
\t5 . execute ( ) . actionGet ( ) ; \n \n \t3 assertHitCount ( searchResponse , docsTest1 + docsTest2 ) ; \n \n \t3 assertAllSuccessful ( searchResponse ) ; } \n \n \t2 IndicesStatsResponse indicesStats = client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . execute ( ) . actionGet ( ) ; \n \n <ect>
\t5 } else { \n \n \t6 sasl . done ( Sasl . SaslOutcome . PN_SASL_AUTH ) ; } \n \n \t5 LOG . debug ( <string_literal> , mechanism . getMechanismName ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t3 List < ? extends IpAddress > ipsToRelease = _ipAddressDao . listByAccount ( accountId ) ; \n \n \t3 for ( IpAddress ip : ipsToRelease ) { \n \n \t4 s_logger . debug ( <string_literal> + ip + <string_literal> + accountId + <string_literal> ) ; \n \n \t4 if ( ! _networkMgr . releasePublicIpAddress ( ip . getId ( ) , callerUserId , caller ) ) { \n \n <ect>
\t3 requestsAvg . report ( 1 . 0 ) ; \n \n \t3 if ( Arrays . equals ( results , data ) ) { \n \n \t4 fetchSuccesses ++ ; \n \n \t4 int percentSuccess = <number_literal> * fetchSuccesses / insertAttempts ; \n \n <ect>
\t3 int iterationToRestore = randomIntBetween ( 0 , iterationCount - 1 ) ; \n \n \t3 logger . info ( <string_literal> , iterationToRestore ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( indexName ) ) ; \n \n <ect>
\t4 s_logger . warn ( <string_literal> + item . getContentId ( ) , e ) ; \n \n \t4 try { \n \n \t5 _queueMgr . returnItem ( item . getId ( ) ) ; \n \n \t4 } catch ( Throwable thr ) { \n \n <ect>
\t3 _toTry . remove ( _key ) ; \n \n \t3 empty = _toTry . isEmpty ( ) ; } \n \n \t2 if ( empty ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 public boolean hasNext ( ) { \n \n \t2 if ( jobCount < nJobs ) { \n \n \t3 boolean hasNext = jobIter . hasNext ( ) ; \n \n <comment> \n \n <ect>
\t1 builder . transferGB ( templateOptions . getTransferGB ( ) ) ; \n \n \t1 ServerSpec spec = builder . build ( ) ; \n \n \t1 <comment> \n \n \t1 String password = templateOptions . hasRootPassword ( ) ? templateOptions . getRootPassword ( ) : getRandomPassword ( ) ; \n \n <ect>
\t4 try { \n \n \t5 resource . configure ( <string_literal> , params ) ; \n \n \t4 } catch ( ConfigurationException e ) { \n \n \t5 _alertMgr . sendAlert ( AlertManager . AlertType . ALERT_TYPE_HOST , dcId , podId , <string_literal> + url . getHost ( ) , <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t2 if ( holder . isEnterOracleImplicitCache ( ) ) { \n \n \t3 try { \n \n \t4 OracleUtils . exitImplicitCacheToClose ( holder . statement ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 Thread . sleep ( <number_literal> * <number_literal> ) ; <comment> \n \n \t1 <comment> \n \n \t1 } catch ( InterruptedException e ) { \n \n \t1 <comment> \n \n <ect>
\t2 } finally { \n \n \t3 try { \n \n \t4 listener . testEnded ( host ) ; \n \n \t3 } catch ( RemoteException e ) { \n \n <ect>
\t3 } else { \n \n \t4 logger . warn ( String . format ( <string_literal> , \n \n \t6 event . getNodeId ( ) , item . getName ( ) , bit ) ) ; } \n \n \t2 } else { \n \n <ect>
\t4 dao = ( Dao < ? , ? > ) constructor . newInstance ( arguments ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 throw SqlExceptionUtil . create ( <string_literal> + daoClass , e ) ; } } \n \n \t2 addDaoToTableMap ( tableKey , dao ) ; \n \n <ect>
\t2 int maxVersion = in . readInt ( ) ; \n \n \t2 from = CompactEndpointSerializationHelper . deserialize ( in ) ; \n \n \t2 <comment> \n \n \t2 MessagingService . instance ( ) . setVersion ( from , maxVersion ) ; \n \n <ect>
\t2 Integer xacceleration = acceleration != null ? acceleration : this . acceleration ; \n \n \t2 Integer xpwm = pwm != null ? pwm : this . pwmFrequency ; \n \n \t2 short xspeed = 0 ; \n \n \t2 if ( speed == null ) { \n \n <ect>
<number_literal> queue_scheduler = queue_scheduler_factory ( ) ) , \n \n \t8 topic_manager = TopicManager ( ) , \n \n \t8 authenticator = authenticator , \n \n \t8 protocol = STOMP11 ) \n \n <ect>
\t1 @ PostConstruct \n \n \t1 public void initTest ( ) { \n \n \t2 Assert . assertTrue ( true ) ; } \n \n \t1 public void MethodWithClassDbAnnotated ( ) { \n \n <ect>
\t2 <string_literal> , 1 , cf_defs ) ; \n \n \t1 cluster . addKeyspace ( ks_def ) ; \n \n \t1 log . info ( <string_literal> + keyspace ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 if ( ( _coordinatorState . hasCache ( curr ) || _coordinator . isReady ( ) ) && ! _activeTx . containsKey ( curr ) ) { \n \n \t6 TransactionAttempt attempt = new TransactionAttempt ( curr , _rand . nextLong ( ) ) ; \n \n \t6 Object state = _coordinatorState . getState ( curr , _initializer ) ; \n \n \t6 _activeTx . put ( curr , new TransactionStatus ( attempt ) ) ; \n \n <ect>
\t2 if ( NODE == null ) { \n \n \t3 startNode ( seed ) ; } } \n \n \t1 @ Override \n \n \t1 public void tearDown ( ) throws Exception { \n \n <ect>
\t2 <comment> \n \n \t2 String bucketIdStr = \n \n \t4 Utilities . getBucketFileNameFromPathSubString ( bucketName ) ; \n \n \t2 int bucketId = Utilities . getBucketIdFromFile ( bucketIdStr ) ; \n \n <ect>
\t5 logger . debug ( remoteFilePath + <string_literal> ) ; } } } \n \n \t2 else if ( FileExistsMode . REPLACE_IF_MODIFIED . equals ( fileExistsMode ) ) { \n \n <ect>
\t7 + e . getMessage ( ) + <string_literal> ) ; } \n \n \t4 catch ( Exception t2 ) { \n \n \t5 <comment> \n \n \t5 <comment> \n \n <ect>
\t5 <string_literal> + d2wContext . valueForKeyPath ( <string_literal> ) + <string_literal> + \n \n \t5 <string_literal> + d2wContext ( ) . valueForKey ( <string_literal> ) + <string_literal> + \n \n \t5 <string_literal> + d2wContext ( ) . valueForKey ( <string_literal> ) + <string_literal> , ex ) ; \n \n \t2 } else { \n \n <ect>
\t5 return new ContextEndpoint ( uri , this , endpoint ) ; \n \n \t5 <comment> \n \n \t2 throw new ResolveEndpointFailedException ( <string_literal> + uri + <string_literal> + getLocalCamelContext ( ) . getName ( ) ) ; } \n \n \t1 protected void logUsingEndpoint ( String uri , Endpoint endpoint ) { \n \n <ect>
\t5 Entity . entity ( <string_literal> , MediaType . TEXT_PLAIN_TYPE ) ) ; \n \n \t3 Assert . assertEquals ( HttpResponseCodes . SC_BAD_REQUEST , response . getStatus ( ) ) ; \n \n \t3 String entity = response . readEntity ( String . class ) ; \n \n \t3 ResteasyViolationException e = new ResteasyViolationException ( String . class . cast ( entity ) ) ; \n \n <ect>
\t5 + userResource . toRepresentation ( ) . getUsername ( ) + <string_literal> <string_literal> \\ <string_literal> <string_literal> \\ <string_literal> ) ; \n \n \t3 userResource . roles ( ) . clientLevel ( clientId ) . add ( roleRepresentations ) ; \n \n \t2 } else { \n \n <ect>
\t4 _log . warn ( <string_literal> , path , e ) ; } } \n \n \t3 <comment> \n \n \t3 if ( propertiesInStore == null || ! propertiesInStore . equals ( discoveryProperties ) ) \n \n \t3 { \n \n <ect>
\t3 @ Override \n \n \t3 protected boolean onUnknownException ( Exception e , long nextDelayMs ) { \n \n \t4 if ( isShutdown ) \n \n \t5 return false ; \n \n <ect>
\t1 Predicate < Iterable < HostAndPort > > findOrBreak = or ( updateRefOnSocketOpen ( result ) , throwISEIfNoLongerRunning ( node ) ) ; \n \n \t1 logger . debug ( <string_literal> , sockets , timeout , timeUnits ) ; \n \n \t1 boolean passed = retryPredicate ( findOrBreak , timeout , period , timeUnits ) . apply ( sockets ) ; \n \n \t1 if ( passed ) { \n \n <ect>
\t4 <comment> \n \n \t4 processBasicReport ( serialMessage , offset , endpoint ) ; \n \n \t4 break ; \n \n \t3 case BASIC_GET : \n \n <ect>
\t5 + <string_literal> ) ; } } \n \n \t1 private void doWarnForRelativePath ( File file ) { \n \n \t2 if ( file . isAbsolute ( ) ) return ; \n \n \t2 if ( file . getPath ( ) . substring ( 0 , <number_literal> ) . equals ( <string_literal> + File . separator ) ) return ; \n \n <ect>
\t4 UpdateOp combined = UpdateOp . combine ( id , ops ) ; \n \n \t4 LOG . debug ( <string_literal> , ops . size ( ) ) ; \n \n \t4 before = queue . getStore ( ) . findAndUpdate ( NODES , combined ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t2 brokerService . start ( ) ; } \n \n \t1 @ Override \n \n \t1 protected void after ( ) { \n \n \t2 try { \n \n <ect>
\t3 stmt . executeUpdate ( sql ) ; \n \n \t3 removedir ( node . getChildText ( <string_literal> ) . toString ( ) , view . getProperties ( ) . get ( <string_literal> ) ) ; \n \n \t3 logger . info ( node . getChildText ( <string_literal> ) . toString ( ) + <string_literal> ) ; } \n \n \t3 else { \n \n <ect>
\t3 <comment> \n \n \t3 if ( <string_literal> . equals ( address ) ) { \n \n \t4 processCurrentLocation ( exchange ) ; \n \n \t3 } else { \n \n <ect>
\t3 dropHBaseTable ( context ) ; \n \n \t3 dropHdfsPath ( context ) ; \n \n \t3 dropHiveTable ( context ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 @ Test \n \n \t1 public void testClientCleanup ( ) throws Throwable { \n \n \t2 OSMXBean osMbean = new OSMXBean ( ) ; \n \n \t2 if ( osMbean . getUnix ( ) == false ) { \n \n <ect>
\t3 LOG . error ( <string_literal> ) ; \n \n \t3 throw new IllegalArgumentException ( \n \n \t5 <string_literal> ) ; } \n \n \t2 if ( ObjectHelper . isEmpty ( namespaceName ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n @ Test \n \n public void duContextTest ( ) throws Exception { \n \n <ect>
\t2 for name , value in yaml . load ( file ) . iteritems ( ) : \n \n \t2 if name != None : \n \n \t3 configurations [ name ] = str ( value ) \n \n \t1 except : \n \n <ect>
\t3 people = ( ArrayList < Map < String , Object > > ) serviceActionController . execute ( new ServiceActionContext ( null , \n \n \t5 null ) , getAllPersonAdditionalPropertiesAction ) ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
{ \n \n \t1 if ( interest != interesting ) \n \n \t1 { \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 FavoriteItemService favoriteItemService = AppContextUtil . getSpringBean ( FavoriteItemService . class ) ; \n \n \t3 return favoriteItemService . isUserFavorite ( UserUIContext . getUsername ( ) , getType ( ) , \n \n \t5 PropertyUtils . getProperty ( beanItem , <string_literal> ) . toString ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 project . logger . warn ( deprecationMessage ) \n \n \t2 } else { \n \n \t3 throw GradleException ( deprecationMessage ) } \n \n \t2 if ( project . plugins . findPlugin ( ANDROID_APT_PLUGIN_ID ) != null ) { \n \n <ect>
\t3 nic = _nicsDao . findByNetworkIdInstanceIdAndBroadcastUri ( network . getId ( ) , vm . getId ( ) , broadcastUri . toString ( ) ) ; \n \n \t2 } else { \n \n \t3 nic = _networkModel . getNicInNetwork ( vm . getId ( ) , network . getId ( ) ) ; } \n \n \t2 if ( nic == null ) { \n \n <ect>
\t2 return tgt ; } \n \n \t1 private boolean shouldIssueTicketGrantingTicket ( final Authentication authentication , final String ticketGrantingTicket ) { \n \n \t2 boolean issueTicketGrantingTicket = true ; \n \n \t2 if ( StringUtils . isNotBlank ( ticketGrantingTicket ) ) { \n \n <ect>
\t7 log . debug ( <string_literal> ) ; \n \n \t7 log . debug ( <string_literal> , operation ) ; \n \n \t7 log . debug ( <string_literal> , key ) ; \n \n \t7 log . debug ( <string_literal> , data ) ; \n \n <ect>
\t5 if ( stt == null || stt . isExpired ( ) ) { \n \n \t6 LOGGER . warn ( <string_literal> , sts ) ; \n \n \t6 return null ; } \n \n \t5 if ( stt . getSecurityToken ( ) . isExpired ( ) ) { \n \n <ect>
\t10 final Map < String , String > vmmetadata = new HashMap < String , String > ( ) ; \n \n \t10 vmmetadata . put ( vm . getInstanceName ( ) , platform ) ; \n \n \t10 syncVMMetaData ( vmmetadata ) ; } } } \n \n \t7 if ( answer == null || ! answer . getResult ( ) ) { \n \n <ect>
\t3 return true ; } \n \n \t2 return false ; } \n \n \t1 public NSArray attributeListAtDepth ( ) { \n \n \t2 Number ky = Integer . valueOf ( depth ) ; \n \n <ect>
\t1 @ Bean \n \n \t1 public AuthenticationEventExecutionPlanConfigurer pac4jAuthenticationEventExecutionPlanConfigurer ( ) { \n \n \t2 return plan - > { \n \n \t3 if ( ! builtClients ( ) . findAllClients ( ) . isEmpty ( ) ) { \n \n <ect>
\t3 cipherProviderType ; \n \n \t2 logger . error ( errMessage ) ; \n \n \t2 throw new FlumeException ( errMessage ) ; } \n \n \t1 } catch ( ClassNotFoundException ex ) { \n \n <ect>
\t2 final DiscoveryNodes . Delta nodesDelta = clusterChangedEvent . nodesDelta ( ) ; \n \n \t3 String summary = nodesDelta . shortSummary ( ) ; \n \n \t3 if ( summary . length ( ) > 0 ) { \n \n <ect>
@ Test \n \n public void testPersistActions ( ) throws AmbariException { \n \n \t1 populateActionDB ( db , hostName , requestId , stageId , false ) ; \n \n \t1 for ( Stage stage : db . getAllStages ( requestId ) ) { \n \n <ect>
\t3 } else if ( StringUtils . isEmpty ( configInDB . getValue ( ) ) ) { \n \n \t4 s_logger . info ( <string_literal> ) ; \n \n \t4 _configDao . update ( Config . SSVMPSK . key ( ) , Config . SSVMPSK . getCategory ( ) , getPrivateKey ( ) ) ; } \n \n \t2 } catch ( NoSuchAlgorithmException ex ) { \n \n <ect>
\t3 Gson gson = gb . create ( ) ; \n \n \t3 byte [ ] details = proxy . getSessionDetails ( ) ; \n \n \t3 status = gson . fromJson ( details != null ? new String ( details , Charset . forName ( <string_literal> ) ) : null , ConsoleProxyStatus . class ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t5 if ( ! result . isSuccessful ( ) ) { \n \n \t6 <comment> <ect>
\t2 } catch ( OutOfMemoryError e ) { \n \n \t3 s_logger . error ( <string_literal> ) ; \n \n \t3 System . exit ( 1 ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t1 private static void tryUnlock ( CmsObject cms , CmsResource resource ) { \n \n \t2 try { \n \n \t3 cms . unlockResource ( resource ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t1 if ( con != null && cleanup ) { \n \n \t2 try { \n \n \t2 con . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 InputStream in = ! chunked ? new BufferedInputStream ( request . getResponseBodyAsStream ( ) ) \n \n \t9 : new ChunkedInputStream ( request . getResponseBodyAsStream ( ) ) ; \n \n \t3 RandomAccessFile out = new RandomAccessFile ( file , <string_literal> ) ; \n \n \t3 out . seek ( localFileSize ) ; \n \n <ect>
\t2 runnable = new RESTRunnable ( m_restCache , m_queuedUrls , m_ttlUrlCache , m_gson , \n \n \t3 streamProvider , url ) ; \n \n \t2 break ; \n \n \t1 default : \n \n <ect>
\t5 if ( equalCon == null ) continue ; \n \n \t5 Collection < Object > labels = equalCon . getValue ( ) ; \n \n \t5 assert labels . size ( ) >= 1 ; \n \n \t5 if ( labels . size ( ) > 1 ) { \n \n <ect>
\t2 try { \n \n \t3 Thread . sleep ( checkInterval ) ; \n \n \t3 return false ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 rows [ i ] = i + <string_literal> + <number_literal> . <number_literal> ; } \n \n \t1 HcatTestUtils . createTestDataFile ( INPUT_FILE_NAME , rows ) ; \n \n <ect>
\t3 } else { <comment> \n \n \t3 imagingServiceName = configuration . getHostName ( ) + <string_literal> + imaging ; } \n \n \t3 try { \n \n \t3 ServiceConfigurations . lookupByName ( Imaging . class , imagingServiceName ) ; \n \n <ect>
\t2 out . tab ( 1 ) . println ( <string_literal> ) ; } \n \n \t1 protected void printConvenienceMethodProcedure ( JavaWriter out , RoutineDefinition procedure , boolean instance ) { \n \n \t2 <comment> \n \n \t2 if ( procedure . getInParameters ( ) . size ( ) > <number_literal> ) { \n \n <ect>
\t1 runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n \t1 runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n \t1 runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n \t1 List < String > rs = runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n <ect>
\t3 if ( bitmap != null ) { \n \n \t4 bitfield = new BitField ( bitmap , bitmap . length * <number_literal> ) ; \n \n \t3 } else { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 ) ; \n \n \t2 } catch ( FileNotFoundException e ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 { \n \n \t4 notifyCommitted ( outcome . getCommitIndex ( ) ) ; } } \n \n \t2 catch ( Throwable e ) \n \n \t2 { \n \n <ect>
\t1 exec ( <string_literal> , true ) ; \n \n \t1 exec ( <string_literal> , true , <string_literal> ) ; } \n \n @ Test \n \n public void commentTest ( ) throws IOException { \n \n <ect>
\t2 for ( int i = 0 ; i < message . capacity ( ) ; i ++ ) { \n \n \t3 message . writeByte ( ( byte ) i ) ; } } \n \n \t1 @ Override \n \n \t1 public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { \n \n <ect>
\t1 public static boolean deletePlugin ( RouterContext ctx , String appName ) throws Exception { \n \n \t2 Log log = ctx . logManager ( ) . getLog ( PluginStarter . class ) ; \n \n \t2 File pluginDir = new File ( ctx . getConfigDir ( ) , PLUGIN_DIR + ' / ' + appName ) ; \n \n \t2 if ( ( ! pluginDir . exists ( ) ) || ( ! pluginDir . isDirectory ( ) ) ) { \n \n <ect>
\t4 modificationQueue . registerNodeCallback ( node , callbackId ) ; \n \n \t3 } else { \n \n \t4 logger . error ( <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t3 return ErrorResponse . exists ( <string_literal> ) ; \n \n \t2 } catch ( ForbiddenException fe ) { \n \n \t3 throw fe ; \n \n \t2 } catch ( Exception me ) { <comment> \n \n <ect>
\t2 } else { \n \n \t3 jettyWebXmlLoc = this . jettyWebXmlLocation ; } \n \n \t2 URL jettyWebXml = bundleContext . getBundle ( ) . getResource ( jettyWebXmlLoc ) ; \n \n \t2 if ( jettyWebXml != null ) { \n \n <ect>
\t2 ef = new Exclude ( array ) ; \n \n \t2 assertTrue ( ef . match ( b1 ) ) ; \n \n \t2 assertFalse ( ef . match ( b3 ) ) ; \n \n \t2 assertTrue ( ef . match ( b06 ) ) ; \n \n <ect>
\t3 Answer rebootAnswer = cmds . getAnswer ( RebootAnswer . class ) ; \n \n \t3 if ( rebootAnswer != null && rebootAnswer . getResult ( ) ) { \n \n \t4 rebootedVm = vm ; \n \n \t4 return rebootedVm ; } \n \n <ect>
\t3 logger . error ( <string_literal> , job , e ) ; \n \n \t3 return null ; } } \n \n \t1 public static JobInstance parseToJobInstance ( CubingJob job , Map < String , Output > outputs ) { \n \n \t2 if ( job == null ) { \n \n <ect>
\t1 { \n \n \t2 try { \n \n \t3 listener . onRequestSent ( ) ; } \n \n \t2 catch ( Throwable t ) { \n \n <ect>
\t3 try { \n \n \t4 scheduler . scheduleJob ( job , trigger ) ; \n \n \t4 triggersCreated = true ; \n \n \t3 } catch ( SchedulerException se ) { \n \n <ect>
\t2 <comment> \n \n \t2 while ( newGroupsEnum . hasMoreElements ( ) ) \n \n \t2 { \n \n \t3 String groupName = newGroupsEnum . nextElement ( ) ; \n \n <ect>
\t4 ArrayList < Msg > lrs = db . getValue ( ) . getLinkRecords ( ) ; \n \n \t4 for ( Msg m : lrs ) { \n \n \t5 int recordFlags = m . getByte ( <string_literal> ) & 0xff ; \n \n \t5 String ms = ( ( recordFlags & ( 0x1 < < <number_literal> ) ) != 0 ) ? <string_literal> : <string_literal> ; \n \n <ect>
\t3 } catch ( BinaryStoreException e ) { \n \n \t4 I18n msg = JcrI18n . problemsGettingBinaryKeysFromBinaryStore ; \n \n \t4 problems . addError ( msg , repositoryName ( ) , backupLocation ( ) , e . getMessage ( ) ) ; } } \n \n \t2 private void removeExistingDocuments ( ) { \n \n <ect>
\t2 try { \n \n \t3 final ControlClusterStatus clusterStatus = niciraNvpApi . getControlClusterStatus ( ) ; \n \n \t3 final String status = clusterStatus . getClusterStatus ( ) ; \n \n \t3 if ( clusterIsUnstable ( status ) ) { \n \n <ect>
\t6 String msg = ioex . getMessage ( ) ; \n \n \t6 boolean sockReset = msg != null && msg . contains ( <string_literal> ) ; \n \n \t6 if ( sockReset ) { \n \n \t7 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t4 <comment> \n \n \t4 try { \n \n \t5 this . registrar . setScheduler ( resolveSchedulerBean ( beanFactory , ScheduledExecutorService . class , false ) ) ; } \n \n \t4 catch ( NoUniqueBeanDefinitionException ex2 ) { \n \n <ect>
\t2 return new org . apache . thrift . async . AsyncMethodCallback < Void > ( ) { \n \n \t2 public void onComplete ( Void o ) { } \n \n \t2 public void onError ( java . lang . Exception e ) { \n \n \t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t4 Logger . error ( this , format ( <string_literal> , listener ) , t ) ; } } \n \n \t2 return false ; } \n \n \t1 public boolean tripPendingKey ( Key key , KeyBlock block , ClientContext context ) { \n \n \t2 if ( ( key instanceof NodeSSK ) != isSSKScheduler ) { \n \n <ect>
\t4 sched . deleteJobs ( new ArrayList < JobKey > ( jobKeys ) ) ; \n \n \t4 logger . debug ( <string_literal> , jobKeys . size ( ) , \n \n \t6 jobKeys ) ; } \n \n \t2 } catch ( SchedulerException e ) { \n \n <ect>
\t2 try { \n \n \t3 VmwareManager mgr = getServiceContext ( ) . getStockObject ( VmwareManager . CONTEXT_STOCK_NAME ) ; \n \n \t3 Pair < Boolean , String > result = SshHelper . sshExecute ( controlIp , DEFAULT_DOMR_SSHPORT , <string_literal> , mgr . getSystemVMKeyFile ( ) , null , <string_literal> + args ) ; \n \n \t3 if ( ! result . first ( ) ) { \n \n <ect>
\t4 String fixedMessageSelector = replyToSelectorName + <string_literal> + replyToSelectorValue + <string_literal> ; \n \n \t4 answer = new SharedQueueMessageListenerContainer ( endpoint , fixedMessageSelector ) ; \n \n \t4 <comment> \n \n \t4 answer . setCacheLevel ( DefaultMessageListenerContainer . CACHE_CONSUMER ) ; \n \n <ect>
\t4 _log . debug ( <string_literal> ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t6 } catch ( InterruptedException e ) { \n \n \t7 throw new IOException ( <string_literal> , e ) ; } } } \n \n \t4 log . info ( <string_literal> + duration + <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t1 logger . info ( <string_literal> , ex ) ; } \n \n \t1 executor . shutdownNow ( ) ; \n \n \t1 super . stop ( ) ; \n \n \t1 sourceCounter . stop ( ) ; \n \n <ect>